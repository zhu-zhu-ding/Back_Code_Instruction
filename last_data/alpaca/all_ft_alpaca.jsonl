[{"instruction": "Create a Fortran function named random_hermitian to generate an order n Hermitian matrix with random complex entries. The function takes 1 input argument of type integer and returns a 2D array of complex*16 type with dimensions (n, n) as the output. The input argument specifies the order of the Hermitian matrix to be generated.", "input": "", "output": "function random_hermitian(n)\n! generates an order n hermitian matrix with random entries x+iy\n! where each x and y are uniformly distributed between -1 and 1\nimplicit none\ninteger :: n, ii, jj\ncomplex*16, dimension(n,n) :: random_hermitian\nreal*8, dimension(n,n) :: a, b\n\n    call random_number(a)\n    ! rescaling into an element in (-1,1)\n    a = 2*a - 1\n    call random_number(b)\n    ! rescaling into an element in (-1,1)\n    b = 2*b - 1\n\n    ! populating the matrix\n    do ii = 1,n\n        do jj = 1,n\n            ! replacing entries in the lower triangle\n            if ((jj.gt.ii).and.(ii.lt.n)) then\n                a(jj,ii) = a(ii,jj)\n                ! the imaginary part is negative, to achieve hermicity\n                b(jj,ii) = -b(ii,jj)\n            end if\n            ! cast into a complex entry\n            random_hermitian(ii,jj) = complex(a(ii,jj),b(ii,jj))\n        end do\n    end do\n\nend function random_hermitian\n"}, {"instruction": "Create a Fortran function named count_sub_string that takes two input arguments of type character(len=*) and returns the number of occurrences of the second string within the first string as an integer. The input argument types are ['character(len=*)', 'character(len=*)'] and the output argument type is ['integer'].", "input": "", "output": "    function count_sub_string(s1, s2) result(c)\n        !! returns the number of occurences of string `s2` in string `s1`.\n        character(len=*), intent(in) :: s1\n        character(len=*), intent(in) :: s2\n        integer                      :: c\n        integer                      :: p, pos_n\n\n        c = 0\n        p = 1\n\n        if (len(s2) == 0) return\n\n        do\n            pos_n = index(s1(p:), s2)\n            if (pos_n == 0) return\n            c = c + 1\n            p = p + pos_n + len(s2)\n        end do\n    end function count_sub_string\n"}, {"instruction": "Create a Fortran function called near to handle wrap-around correction when evaluating distances between points. The function takes 2 input parameters of type real*8, named dx and domain. It returns 1 output parameter of type real*8. When calling the function, ensure to provide the input parameters in the order (dx, domain) and capture the returned value in a variable of the appropriate type.", "input": "", "output": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}, {"instruction": "Create a Fortran function named vca_get_bath_dimension to calculate the size of a bath based on the specified inputs. The function takes 1 input argument of type integer, which is optional. The output is a single integer representing the bath size.", "input": "", "output": "   function vca_get_bath_dimension(ispin_) result(bath_size)\n      integer,optional               :: ispin_\n      integer                        :: bath_size,ndx,ispin,iorb,jspin,jorb,io,jo\n      !\n      ! select case(bath_type)\n      ! case default\n      !e:[nlat][norb][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      bath_size = nlat*norb*nbath + nlat*norb*nbath\n      if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! case('hybrid')\n      !    !e:[1][1][nspin][nbath] + v:[nlat][norb][nspin][nbath]\n      !    bath_size = nbath + nlat*norb*nbath\n      !    if(.not.present(ispin_))bath_size=nspin*bath_size\n      ! end select\n   end function vca_get_bath_dimension\n"}, {"instruction": "Create a Fortran function named \"foo\" that takes an integer input parameter and returns an integer result. The function adds 10 to the input parameter and assigns the result to the output parameter. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function foo(p) result(r)\n  !$omp declare simd(foo) notinbranch\n    integer :: p, r\n    p = p + 10\n    r = p\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"goo\" that takes a single real number as input and returns another real number. Inside the function, add 18.5 to the input number and assign the result to the output parameter. Use the !$omp declare simd directive to declare the function for vectorization.", "input": "", "output": "  function goo(p) result(r)\n  !$omp declare simd(goo) inbranch\n    real :: p, r\n    p = p + 18.5\n    r = p\n  end function goo\n"}, {"instruction": "Create a Fortran function named file_line_num to determine the number of lines in a file. The function has 1 input parameter of type character (*), denoted as filename. The output of the function is a single integer representing the number of lines in the file.", "input": "", "output": "     function file_line_num(filename)\n       implicit none\n\n       character (*), intent(in) :: filename \n       integer     :: count, file_line_num\n\n       open(1, file = trim(filename))\n       count = 0\n       do\n          read(1, *, end=10)\n          count = count + 1\n       enddo\n10     close(1)\n       \n       file_line_num = count\n     end function file_line_num\n"}, {"instruction": "Create a Fortran function named \"inttotext\" to convert an integer to a text representation. The function should take 1 input argument of type integer and return 1 output argument of type character with a maximum length of \"maxtextlength\".", "input": "", "output": "  function inttotext(number) result(text)\n    integer,parameter           :: maxtextlength=20\n    integer,intent(in)          :: number\n    character(len=maxtextlength):: text\n\n    !local variables\n    character(len=6) :: formatstatement\n    write (formatstatement,'(a,i3,a)') '(i',maxtextlength,')'\n    \n    write (text,fmt=formatstatement) number\n    text=adjustl(text)\n\n  end function inttotext\n"}, {"instruction": "Create a Fortran function named substrcount that takes two strings as input arguments with the test_data type ['character(len=*)', 'character(len=*)']. The function calculates and returns the number of occurrences of the second string within the first string as an integer with the test_data type ['integer'].", "input": "", "output": "function substrcount(str, substr)\n  character(len=*), intent(in) :: str\n  character(len=*), intent(in) :: substr\n  integer :: substrcount\n  integer :: pos\n  integer :: step\n  substrcount = 0\n  if (len(substr) == 0) then\n    return\n  else \n    pos = 1\n    do while(.true.)\n      step = index(str(pos:), substr)     \n      if (step == 0) exit\n      substrcount = substrcount + 1 \n      pos = pos + step - 1 + len(substr)\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named int2str to convert an integer to a character string. The function takes 1 input argument of type integer and returns 1 output argument of type character(12).", "input": "", "output": "  function int2str(anumber) result(astring)\n    implicit none\n    integer :: anumber\n    character(12) :: astring\n\n    write (astring,'(i9)') anumber\n\n  end function int2str\n"}, {"instruction": "Provide a Fortran function named floorsqrt that calculates the largest integer value whose square is less than or equal to a given input integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "  function floorsqrt(x) result(sqrtx)\n    integer :: x,sqrtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      sqrtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i\n      end do\n\n      sqrtx = i - 1\n\n    end if\n\n  end function floorsqrt\n"}, {"instruction": "Create a Fortran function named floorcurt that takes an integer input and returns the largest integer whose cube does not exceed the input. The number of input parameters is 1 with a test_data type of ['integer'], and the number of output parameters is 1 with a test_data type of ['integer'].", "input": "", "output": "  function floorcurt(x) result(curtx)\n    integer :: x,curtx\n    ! local\n    integer :: i,res\n\n    if (x == 0 .or. x == 1) then\n\n      curtx = x\n\n    else\n\n      res = 1\n      i = 1\n      do while (res <= x)\n        i = i + 1\n        res = i*i*i\n      end do\n\n      curtx = i - 1\n\n    end if\n\n  end function floorcurt\n"}, {"instruction": "Write a Fortran function named \"lower_case\" to convert a given input string to lowercase. The function takes 1 input parameter of type \"character(len=*)\" and returns 1 output parameter of type \"character(len=:), allocatable\".", "input": "", "output": "    function lower_case(string)\n        character(len=*), intent(in) :: string\n        character(len=:), allocatable :: lower_case\n\n        !! locals\n        integer :: code\n        integer :: i\n\n        allocate(lower_case, source=string)\n        do i = 1, len(string)\n            code = iachar(string(i:i))\n            select case (code)\n            case (65:90)\n                lower_case(i:i) = char(code + 32)\n            end select\n        end do\n\n    end function lower_case\n"}, {"instruction": "Write a Fortran function named arth_i that generates an arithmetic sequence of integers. The function takes 3 input parameters of type integer: first, increment, and n. It returns an array of integers of length n.", "input": "", "output": " function arth_i(first,increment,n)\n  integer, intent(in) :: first,increment,n\n  integer, dimension(n) :: arth_i\n  integer :: k,k2,temp\n  integer, parameter :: npar_arth=16,npar2_arth=8\n\n  if (n > 0) arth_i(1) = first\n  if (n <=  npar_arth) then\n   do k = 2,n\n    arth_i(k) = arth_i(k-1)+increment\n   end do\n  else\n   do k = 2,npar2_arth\n    arth_i(k) = arth_i(k-1)+increment\n   end do\n   temp = increment*npar2_arth\n   k = npar2_arth\n   do\n    if (k >=  n) exit\n    k2 = k+k\n    arth_i(k+1:min(k2,n)) = temp+arth_i(1:min(k,n-k))\n    temp = temp+temp\n    k = k2\n   end do\n  end if\n end function arth_i\n"}, {"instruction": "Create a Fortran function named outerdiff_i that takes two one-dimensional integer arrays as input. The input arrays should be of any size. The function produces one output, an integer array with dimensions equal to the sizes of the input arrays. The purpose of the function is to calculate the outer difference between the elements of the input arrays and assign the result to the output array.", "input": "", "output": " function outerdiff_i(a,b)\n implicit none\n  integer, dimension(:), intent(in) :: a,b\n  integer, dimension(size(a),size(b)) :: outerdiff_i\n  outerdiff_i  =  spread(a,dim = 2,ncopies = size(b)) - &\n  spread(b,dim = 1,ncopies = size(a))\n end function outerdiff_i\n"}, {"instruction": "Create a Fortran function named in_carpet to check if a point is inside a Sierpinski carpet. The function takes 2 input parameters of type integer and returns 1 output parameter of type logical. The input parameter test_data type is ['integer', 'integer'], and the output parameter test_data type is ['logical'].", "input": "", "output": "function in_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do\n    if(x == 0 .or. y == 0) then\n      in_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      in_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named dbend that calculates the bending of a value using the formula dbend=amp*tanh((y-0d0)/wid). The function accepts 3 input arguments of type real(8) - y, amp, and wid, and returns 1 output argument of type real(8).", "input": "", "output": "  function dbend(y,amp,wid)\n    implicit none\n    real(8)::y,amp,wid,dbend\n    dbend=amp*tanh((y-0d0)/wid)\n  end function\n"}, {"instruction": "Create a Fortran function named rtnewt that iteratively calculates the root of a function using the Newton-Raphson method. The function has 6 input parameters of type real(8) - prev, eps, nst, p, t0, and sum. It has 1 output parameter of type real(8). The function iteratively approximates the root of a given function using the provided initial guess and termination criteria. If the maximum number of iterations is reached, the function stops and outputs an error message.", "input": "", "output": "  function rtnewt(prev,eps,nst,p,t0,sum)\n    integer::j\n    integer,parameter::jmax=20\n    real(8)::rtnewt,prev,eps\n    real(8)::f,df,dx,sum,nst,p,t0\n    rtnewt=prev\n    !write(*,*) rtnewt\n    do j=1,jmax\n      x=rtnewt\n      f=x+ieta*sigma0*(mu0+(a0-b0)*log(x/vref))-vpl\n      df=1+ieta*sigma0*(a0-b0)/x\n      dx=f/df\n      rtnewt=rtnewt-dx\n      !write(*,*) rtnewt\n      if(abs(dx).lt.eps) return\n    end do\n    write(*,*) 'maximum iteration'\n    stop\n  end function\n"}, {"instruction": "Create a Fortran function named file_exist to check the existence of a file. The function takes 1 input parameter with the test data type ['character(len=*)'] and returns 1 output parameter with the test data type ['logical'].", "input": "", "output": "function file_exist(filename)\n\n\timplicit none\n\tcharacter(len=*), intent (in) :: filename\n\tlogical                       :: file_exist\n\t\n\tinquire(file=trim(adjustl(filename)), exist=file_exist)\n\n  return\nend function file_exist\n"}, {"instruction": "Create a Fortran function named arraytst with 3 input parameters of type integer. The test_data type is ['integer', 'integer', 'integer']. The function returns a 3-dimensional array of real numbers with kind=8 and allocatable dimension. The number of output parameters is 1 and the test_data type is ['real(kind=8), dimension(:,:,:), allocatable'].", "input": "", "output": "function arraytst(a,b,c)\n\n  implicit none\n  \n  real(kind=8), dimension(:,:,:), allocatable :: arraytst\n  integer, intent(in) :: a,b,c\n  \n  allocate(arraytst(a,b,c))\n  \n  arraytst = (dble(a)/dble(b))*dble(c)\n  \n  return\n  \nend function arraytst\n"}, {"instruction": "Create a Fortran function named skip_comma_and_spaces that takes two input parameters of type character and integer. The test_data type for input is ['character(*)', 'integer']. The function returns one output parameter of type logical. The function aims to skip over commas and spaces in a string, returning the remaining substring and a logical value indicating whether the operation was successful.", "input": "", "output": "  function skip_comma_and_spaces(string, pos) result (ok)\n    character(*) :: string\n    integer :: pos, length\n    logical :: ok\n    logical :: comma_ok\n    comma_ok = .true.\n    ok = .true.\n    length = len_trim(string)\n    if (pos.gt.length) then\n      ok = .true.\n      string = \"\"\n    else\n      do\n        ! only one comma\n        if (string(pos:pos).eq.\",\".and.comma_ok) then\n          comma_ok = .false.\n        ! end on a non-space\n        else if (string(pos:pos).ne.\" \") then\n          exit\n        else if (pos.eq.length) then\n          ok = .false.\n          exit\n        end if\n        pos = pos + 1\n      end do\n      string = adjustl(string(pos:))\n    end if\n  end function skip_comma_and_spaces\n"}, {"instruction": "Create a Fortran function named os_map that takes two input arguments of type double precision. The input arguments are non_lin_wt and lin_wt. The function computes and returns a single output of type double precision. The function calculates the result by performing arithmetic operations on the input arguments and assigning the result to the variable os_map.", "input": "", "output": "function os_map(non_lin_wt, lin_wt)\n\n    implicit none\n    double precision :: os_map\n    double precision, intent(in) :: non_lin_wt, lin_wt\n    double precision :: num, denom\n\n    num = non_lin_wt*(lin_wt + lin_wt*lin_wt - 3.0d0*lin_wt*non_lin_wt + non_lin_wt*non_lin_wt)\n    denom = lin_wt*lin_wt + non_lin_wt*(1.0d0-2.0d0*lin_wt)\n\n    os_map = num/denom\n\nend function os_map\n"}, {"instruction": "Create a Fortran function named test_intent_parameters_none. This function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function adds 15 to the input parameter and assigns the result to the output parameter. Finally, the function returns 0.", "input": "", "output": "                function test_intent_parameters_none(input, output)\n                        integer :: input, output\n                        integer :: test_intent_parameters_none\n\n                        output = input + 15\n\n                        test_intent_parameters_none = 0\n\n                end function test_intent_parameters_none\n"}, {"instruction": "Write a Fortran function named gr2rank to determine the rank of a given global row number based on the number of tasks and the total number of rows. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "function gr2rank( globrow ) result ( rank )\n  !-----------------------------------------------------------------------------\n  ! formal arguments\n  !-----------------------------------------------------------------------------\n  integer, intent(in) :: globrow !<row number in original input (level 1)\n  integer :: rank !<returned: rank holding the given global row\n\n  !-----------------------------------------------------------------------------\n  ! local variables\n  !-----------------------------------------------------------------------------\n  integer :: m     !average integral number of rows per processor\n  integer :: spill !spill over beyond prefect loading of rows to processors\n  integer :: p     \n  integer :: n     !<total number of rows in original input (level 1)\n\n  p = numtasks\n  n = nblk_rows\n\n  if ( (globrow .lt. 1) .or. (globrow .gt. n) ) then\n    rank = -1\n  else\n    m = n / p\n    spill = mod( n, p )\n    if ( globrow .le. (m+1)*spill ) then\n      rank = (globrow-1)/(m+1)\n    else\n      rank = (globrow-1 - (m+1)*spill)/m + spill\n    endif\n  endif\n\n  return\nend function gr2rank\n"}, {"instruction": "Provide a Fortran function named binomialcoefficient to calculate the binomial coefficient using the input integers m and n. The number of input arguments is 2, and the test_data type is ['integer', 'integer']. The number of output arguments is 1, and the test_data type is ['double precision'].", "input": "", "output": "function binomialcoefficient(m, n) result (biocoeff)\n\n    integer, intent(in)::m,n\n    double precision::biocoeff\n\n    integer, parameter::size=30\n    integer, save::bc(size,size)=0\n    logical, save::initialized=.false.;\n\n    integer::i,j,k\n\n    if (.not.initialized) then\n        do i=1,size\n        bc(i,1)=one\n        bc(i,2:size)=zero\n        end do\n        do i=2, size\n        do j=2, i\n        bc(i,j)=bc(i-1,j-1)+bc(i-1,j)\n        end do\n        end do\n\n        initialized=.true.\n    end if\n\n    biocoeff=one*bc(m,n)\n\nend function binomialcoefficient\n"}, {"instruction": "Write a Fortran function named is_dtype_format_array_c that takes one input argument of type c_ptr and returns one output argument of type integer(kind=c_int). This function is used to determine whether the input type structure is an array format. Use the bind attribute to specify the name \"is_dtype_format_array_f\" for this function.", "input": "", "output": "     function is_dtype_format_array_c(type_struct) result(out) &\n          bind(c, name=\"is_dtype_format_array_f\")\n       use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n       implicit none\n       type(c_ptr), value, intent(in) :: type_struct\n       integer(kind=c_int) :: out\n     end function is_dtype_format_array_c\n"}, {"instruction": "Create a Fortran function named create_dtype_empty_c that returns a c_ptr type. The function takes one input parameter of type logical(kind=c_bool) by value.", "input": "", "output": "     function create_dtype_empty_c(use_generic) result(out) &\n          bind(c, name=\"create_dtype_empty_f\")\n       use, intrinsic :: iso_c_binding, only: c_ptr, c_bool\n       implicit none\n       logical(kind=c_bool), value, intent(in) :: use_generic\n       type(c_ptr) :: out\n     end function create_dtype_empty_c\n"}, {"instruction": "Create a Fortran function named get_random_pos to generate a random integer between 1 and the specified size. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of test_data type ['integer'], and the output parameter is of test_data type ['integer'].", "input": "", "output": "   function get_random_pos(nsize)\n      integer, intent(in) :: nsize\n      integer :: get_random_pos\n      real :: random\n      !random number between 0 and 1\n      call random_number(random)\n      !random int between 1 and nsize\n      ! n + floor((m+1-n)*urandom)\n      get_random_pos = 1 + floor(real(nsize)*random)\n   end function get_random_pos\n"}, {"instruction": "Create a Fortran function called mandelbrot to calculate the number of iterations required for the given complex coordinates to escape the Mandelbrot set within the specified maximum iterations. The input parameters are 3, with test_data types ['real', 'real', 'integer']. The output parameter is 1, with a test_data type of ['integer'].", "input": "", "output": "  function mandelbrot(x, y, maxit) result (it)\n    implicit none\n    real,    intent(in) :: x, y\n    integer, intent(in) :: maxit\n    integer :: it\n    complex :: z, c\n    z = cmplx(0, 0)\n    c = cmplx(x, y)\n    it = 0\n    do while (abs(z) < 2.0 .and. it < maxit)\n       z = z*z + c\n       it = it + 1\n    end do\n  end function mandelbrot\n"}, {"instruction": "Write a Fortran function named is_palindro to check if a given string is a palindrome. The function should take 1 input parameter of type character(len=*), and the output should be a single logical value.", "input": "", "output": "function is_palindro(t)\n  logical :: is_palindro\n  character(len=*), intent(in) :: t\n\n  integer :: i, l\n\n  l = len(t)\n  is_palindro = .false.\n  do i=1, l/2\n     if ( t(i:i) /= t(l-i+1:l-i+1) ) return\n  end do\n  is_palindro = .true.\nend function is_palindro\n"}, {"instruction": "Write a Fortran function named is_palindro2 to check whether a given string is a palindrome. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type logical.", "input": "", "output": "function is_palindro2(t) result(isp)\n  logical :: isp\n  character(len=*), intent(in) :: t\n\n  character(len=len(t)) :: s\n  integer :: i\n\n  forall(i=1:len(t)) s(len(t)-i+1:len(t)-i+1) = t(i:i)\n  isp = ( s == t )\nend function is_palindro2\n"}, {"instruction": "Write a Fortran function named begtrm, which takes a string as input and returns the position of the first non-space character in the string. The input parameter is 1 and the test_data type is ['character(*)'], while the output parameter is 1 and the test_data type is ['integer'].", "input": "", "output": "function begtrm(val)\n!\nimplicit none\n!\n\n!\ncharacter(*) :: val\ninteger :: begtrm\n!\n! local variables\n!\ninteger :: idx\ninteger :: len\n!\n!     + + + argument declarations + + +\n!\n!     + + + argument definitions + + +\n!\n!     + + + parameters + + +\n!\n!     + + + local variables + + +\n!\n!\n!     + + + end specifications + + +\n!\ndo idx = 1,len(val)\n  if (val(idx:idx).ne.' ') then\n     begtrm = idx\n     return\n  end if\nend do\n! \nbegtrm = 1\n!\nend function begtrm\n"}, {"instruction": "Write a Fortran function named pythag that calculates the hypotenuse of a right-angled triangle using the given lengths of the two shorter sides. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "      function pythag(a,b)\n      implicit none\n      double precision ::  a, b, pythag \n      double precision :: absa, absb\n      absa=abs(a)\n      absb=abs(b)\n      if (absa > absb) then\n         pythag=absa*sqrt(1.+(absb/absa)**2)\n      else\n         if(absb == 0.) then\n            pythag=0.\n         else\n            pythag=absb*sqrt(1.+(absa/absb)**2)\n         endif\n      endif\n\n      end function pythag\n"}, {"instruction": "Create a Fortran function named binomial to compute the binomial coefficient of two given integers. The function should have 2 input parameters of type integer*8 and intent(in), and 1 output parameter of type integer*8. The input parameters should be named n and k, and the output parameter should be named binomial.", "input": "", "output": "  pure function binomial(n,k)\n    implicit none\n    integer*8, intent(in) :: n,k\n    integer*16            :: temp\n    integer*8             :: i,binomial\n\n    temp=1\n    do i=n-k+1,n\n       temp=temp*i\n    end do\n    do i=1,n-k\n       temp=temp/i\n    end do\n    binomial=temp\n  end function binomial\n"}, {"instruction": "Create a Fortran function named gcd that calculates the greatest common divisor (GCD) of two 8-byte integer numbers. The function takes 2 input arguments of type integer*8 and returns 1 output argument of type integer, representing the GCD of the input numbers.", "input": "", "output": "  pure function gcd(a0,b0)\n    implicit none\n    integer*8, intent(in) :: a0, b0\n    integer               :: a, b, t, gcd\n\n    a=a0\n    b=b0\n    do while (b /= 0)\n       t=b\n       b=mod(a,b)\n       a=t\n    end do\n    gcd=a\n  end function gcd\n"}, {"instruction": "Create a Fortran function named is_factor to determine if a given integer is a factor of another integer. The function takes 2 input parameters of type integer*8 and integer, and 1 output parameter of type logical.", "input": "", "output": "  pure function is_factor(f,n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer, intent(in)   :: f\n    logical               :: is_factor\n    is_factor = (mod(n,f)==0)\n  end function is_factor\n"}, {"instruction": "Create a Fortran function named is_prime to determine whether a given integer is a prime number. The function takes 1 input parameter of type integer*8, and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_prime(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer               :: i\n    logical               :: is_prime\n\n    if (n == 1) then\n       is_prime = .false.\n    else\n       is_prime = .true.\n       do i=2,min(n-1,ceiling(sqrt(dble(n))))\n          if (mod(n,i) == 0) then\n             is_prime = .false.\n             exit\n          end if\n       end do\n    end if\n  end function is_prime\n"}, {"instruction": "Create a Fortran function named number_length to calculate the length of a given integer number. The function takes 1 input parameter of type integer*8. The output is 1 parameter of type integer.", "input": "", "output": "  pure function number_length(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer               :: number_length\n    real*8                :: temp\n\n    temp=log10(dble(n))\n    if (mod(temp,1.0_8)==0.0_8) temp=temp+0.01\n    number_length = ceiling(temp)\n  end function number_length\n"}, {"instruction": "Create a Fortran function named sum_of_divisors to calculate the sum of divisors of a given integer. The function should take 1 input parameter of type integer*8 and return 1 output parameter of type integer*8.", "input": "", "output": "  pure function sum_of_divisors(n)\n    implicit none\n    integer*8, intent(in) :: n\n    integer*8             :: i\n    integer*8             :: sum_of_divisors\n\n    sum_of_divisors=1\n    do i=2,n-1\n       if (mod(n,i) == 0) then\n          sum_of_divisors=sum_of_divisors+i\n       end if\n    end do\n  end function sum_of_divisors\n"}, {"instruction": "Create a Fortran function named is_square to determine if a given integer is a perfect square. The function should take 1 input parameter of type integer and return 1 output parameter of type logical.", "input": "", "output": "  pure function is_square(m)\n    implicit none\n    integer, intent(in) :: m\n    logical             :: is_square\n\n    is_square=mod(sqrt(dble(m)),1.0)==0.0\n\n  end function is_square\n"}, {"instruction": "Write a Fortran function named is_heptagonal to determine if a given integer is a heptagonal number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_heptagonal(m)\n    implicit none\n    integer, intent(in) :: m\n    double precision    :: temp\n    logical             :: is_heptagonal,plus,minus\n\n    temp=(3 + sqrt(9.0 + 4*5*2*m))/10\n    plus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    temp=(3 - sqrt(9.0 + 4*5*2*m))/10\n    minus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    is_heptagonal=plus .or. minus\n\n  end function is_heptagonal\n"}, {"instruction": "Create a Fortran function named is_octagonal to determine if a given integer is an octagonal number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  pure function is_octagonal(m)\n    implicit none\n    integer, intent(in) :: m\n    double precision    :: temp\n    logical             :: is_octagonal,plus,minus\n\n    temp=(2 + sqrt(4.0 + 4*3*m))/6\n    plus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    temp=(2 - sqrt(4.0 + 4*3*m))/6\n    minus=(temp>0) .and. (mod(temp,1.0)==0.0)\n    is_octagonal=plus .or. minus\n\n  end function is_octagonal\n"}, {"instruction": "Write a Fortran function named rot_b to calculate the value of b based on the input parameters m and alpha. The number of input parameters is 2, and their data types are ['integer', 'double precision']. The number of output parameters is 1, and its data type is ['double precision'].", "input": "", "output": "  function rot_b(m, alpha) result(b)\n\n    implicit none\n\n    integer,          intent(in) :: m\n    double precision, intent(in) :: alpha\n    double precision             :: b\n\n    if (m < 0) then\n       b = cos(dble(m)*alpha)\n       if (abs(mod(m,2)) == 1) b = -b\n    else if (m > 0) then\n       b = sin(dble(m)*alpha)\n       if (abs(mod(m,2)) == 0) b = -b\n    else\n       b = 0.0d0\n    end if\n\n  end function rot_b\n"}, {"instruction": "Create a Fortran function named f1 that takes six input parameters, including three integer value parameters and three regular integer parameters. The output is a single integer. The purpose of the function is to increment each input parameter by 1, then calculate the sum of all six parameters, and return the result.", "input": "", "output": "function f1 (a, b, c, d, e, f)\n  integer, value :: a, b, c\n  integer :: d, e, f, f1\n!$omp declare simd (f1) uniform(b) linear(c, d) linear(uval(e)) linear(ref(f))\n  a = a + 1\n  b = b + 1\n  c = c + 1\n  d = d + 1\n  e = e + 1\n  f = f + 1\n  f1 = a + b + c + d + e + f\nend function f1\n"}, {"instruction": "Write a Fortran function named gauss_wt to calculate the Gaussian weight based on the input parameter lag. The input parameter is of type real, and the output parameter is also of type real. Ensure that the function name, number and type of input and output parameters are as specified.", "input": "", "output": "function gauss_wt(lag)\nimplicit none\nreal                                :: lag,gauss_wt\nreal,parameter                      :: sigma=1000.0 !1000 km \n!---\ngauss_wt=exp(-(lag**2.0/(2.0*sigma**2.0)))  \n!---\nreturn\n!---\nend function gauss_wt\n"}, {"instruction": "Create a Fortran function named obs_error that takes a single input parameter of type character*128. The function returns a real number. The function retrieves the observation error corresponding to the input satellite name from a predefined lookup table and returns it.", "input": "", "output": "function obs_error(sat)\nimplicit none\n!---in\ncharacter*128                :: sat\n!---out\nreal                         :: obs_error\n!==================================================\n! observation errors are from breada et al,. (2019)\n! br\u00eada, j. p. l. f., paiva, r. c. d., bravo, j. m., passaia, o. a., & moreira, d. m. (2019). \n! assimilation of satellite altimetry data for effective river bathymetry. water resources research, \n! 55(9), 7441\u20137463. doi:10.1029/2018wr024010\n!--------------------------------------------------\n! satellite  |  error (m)\n! -----------------------\n!envisat     |   0.30\n!jason2      |   0.28\n!jason3      |   0.28\n!sentinel3a  |   0.30*\n!------------------------\n! *1.watson, c.; legresy, b.; king, m.; deane, a. absolute altimeter bias results from bass strait, \n! australia.in proceedings of the ocean surface topography science team meeting 2018, ponta delgada, \n! portugal,24\u201329 september 2018.\n! *2.bonnefond, p.; exertier, p.; laurain, o.; guinle, t.; f\u00e9m\u00e9nias, p. corsica:  \n! a 20-yr multi-mission absolutealtimeter calibration site.  in proceedings of the ocean surface \n! topography science team meeting 2018,ponta delgada, portugal, 24\u201329 september 2018.\n! *3.garcia-mondejar, a.; zhao, z.; rhines, p. sentinel-3 range and datation calibration with crete transponder.\n! in proceedings of the 25 years of progress in radar altimetry, ponta delgada, portugal, 24\u201329 september 2018.\n! *4.mertikas, s.; donlon, c.; f\u00e9m\u00e9nias, p.; mavrocordatos, c.; galanakis, d.; tripolitsiotis, a.; frantzis, x.; \n! kokolakis, c.; tziavos, i.n.; vergos, g.; guinle, t. absolute calibration of the european sentinel-3a surface \n! topography mission over the permanent facility for altimetry calibration in west crete, greece. remote sens. 2018, 10, 1808.\n! =================================================\nobs_error=0.30\nif (trim(sat) == \"envisat\") obs_error=0.30\nif (trim(sat) == \"jason2\") obs_error=0.28\nif (trim(sat) == \"jason3\") obs_error=0.28\nif (trim(sat) == \"sentinel3a\") obs_error=0.30\nreturn\nend function obs_error\n"}, {"instruction": "Write a Fortran function named calcrmks that takes two input arguments, where the first argument is an array of real numbers with kind=8 and the second argument is a real number with kind=8. The function returns a real array with kind=8 and the same size as the input array. The purpose of this function is to compute the result based on the given input for Jon's simulations. The function contains a where construct to perform calculations based on a condition.", "input": "", "output": "        function calcrmks(x1,xbr) result(r)\n          ! compute r given x1 for jon's simulations                                                                 \n          ! jad 7/24/2011\n          real(kind=8), intent(in), dimension(:) :: x1\n          real(kind=8), intent(in) :: xbr\n          real(kind=8) :: npow2\n          real(kind=8), dimension(size(x1)) :: r, xi\n          npow2=10d0\n          where(x1.gt.xbr)\n             xi=x1+(x1-xbr)**npow2\n          elsewhere\n             xi=x1\n          endwhere\n          r=exp(xi)\n        end function calcrmks\n"}, {"instruction": "Create a Fortran function named calcrmks_single to calculate the result based on the given input x1 for Jon's simulations. The function takes 2 input arguments, both of type real(kind=8), and returns 1 output argument of type real(kind=8).", "input": "", "output": "        function calcrmks_single(x1,xbr) result(r)\n          ! compute r given x1 for jon's simulations                                                                 \n          ! jad 7/24/2011\n          real(kind=8), intent(in) :: x1,xbr\n          real(kind=8) :: npow2\n          real(kind=8) :: r, xi\n          npow2=10d0\n          if(x1.gt.xbr) then\n             xi=x1+(x1-xbr)**npow2\n          else\n             xi=x1\n          endif\n          r=exp(xi)\n        end function calcrmks_single\n"}, {"instruction": "Create a Fortran function named calcet that takes 4 input parameters of type real(8) named etc, wp, fc, and sm. The function returns a single real(8) output parameter named valet. The function calculates valet based on the values of etc, wp, fc, and sm using a conditional statement. If sm is greater than wp, valet is computed using a mathematical expression; otherwise, valet is set to 0.0.", "input": "", "output": "  function calcet(etc,wp,fc,sm) result(valet)\n    real(8),intent(in) :: etc,wp,fc,sm\n    real(8)            :: valet\n    \n    if (sm .gt. wp) then\n      valet = etc * min(1d0 , 2d0*(sm-wp)/(fc-wp))\n    else\n      valet = 0.0\n    end if\n    \n  end function calcet\n"}, {"instruction": "Create a Fortran function called det that takes 4 real(8) input parameters, etc, wp, fc, and sm, and returns a single real(8) output parameter, etderiv. The function computes the value of etderiv based on conditional logic involving the input parameters etc, wp, fc, and sm. Ensure that the function is implemented using the imperative tone.", "input": "", "output": "  function det(etc,wp,fc,sm) result(etderiv)\n    real(8),intent(in) :: etc,wp,fc,sm\n    real(8)            :: etderiv\n    \n    etderiv = 0.0\n    if (sm.ge.wp .and. sm.lt.5d-1*(fc+wp)) then\n      etderiv = 2d0 * etc / (fc-wp)\n    else\n      etderiv = 0.0\n    end if\n    \n  end function det\n"}, {"instruction": "Create a Fortran function named julianday to calculate the Julian day for a given date and time. The function should have 4 input parameters with test_data type ['integer', 'integer', 'integer', 'double precision'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "  function julianday(month,day,year,hour) ! calculates time in jd for a given date\n    integer :: month,day,year,year_r,month_r\n    double precision :: hour,julianday\n    year_r = year+4800-floor((14-month)/12.0)\n    month_r = month+12*floor((14-month)/12.0)-3\n    julianday = day + floor((153*month_r+2)/5.0) + 365*year_r &\n         + floor(year_r/4.0) -floor(year_r/100.0) + &\n         floor(year_r/400.0) - 32045 + (hour-12.0)/24.0\n  end function julianday\n"}, {"instruction": "Create a Fortran function named getbilinearinterp that performs bilinear interpolation to calculate the interpolated value at a given point (x, y) based on the input parameters. There are 8 input parameters of type real and real arrays of dimension 2, and 1 output parameter of type real.", "input": "", "output": "  function getbilinearinterp(x,y,xvec,yvec,f11,f12,f21,f22)\n    !! returns bilinearly interpolated values at (x,y)\n    real, intent(in) :: x !! queried x\n    real, intent(in) :: y !! queried y\n    real, intent(in), dimension(2) :: xvec\n    real, intent(in), dimension(2) :: yvec\n    real, intent(in) :: f11, f12, f21, f22\n    real :: getbilinearinterp\n    real, dimension(2,2) :: fmat\n\n    fmat(1,:) = (/f11,f12/)\n    fmat(2,:) = (/f21,f22/)\n\n    getbilinearinterp = dot_product((/xvec(2)-x,x-xvec(1)/),matmul(fmat,(/yvec(2)-y,y-yvec(1)/)))\n    getbilinearinterp = getbilinearinterp/(xvec(2)-xvec(1))/(yvec(2)-yvec(1))\n\n  end function getbilinearinterp\n"}, {"instruction": "Write a Fortran function named gettable to read data from a CSV formatted file. The function takes 3 input parameters of types character(len=*), integer, and integer. The test_data type for input parameters is ['character(len=*)', 'integer', 'integer']. The function returns a 2D real array and has 1 output parameter of type real, dimension(rows,cols) where rows and cols are the dimensions specified in the input parameters. Remember to use the imperative tone in your instructions.", "input": "", "output": "  function gettable(filename,rows,cols)\n    !! returns data from csv formatted file\n    character(len=*), intent(in) :: filename\n    integer, intent(in) :: rows  !! no. of rows\n    integer, intent(in) :: cols  !! no. of columns \n    integer :: i, j\n    integer :: stat\n    real, dimension(rows,cols) :: gettable\n\n    open(unit=10, file=filename, status='old', action='read', iostat=stat)\n    if (stat>0) then\n      print*, 'error: '//trim(filename)//' file not found'\n      error stop \n    endif\n    do i=1,rows\n      read(10,*) (gettable(i,j),j=1,cols)\n    enddo\n    close(10)\n  end function gettable\n"}, {"instruction": "Write a Fortran function named sign_func to determine the relationship between an integer atom and two other integer atoms. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function sign_func(a,m,n)\nimplicit none\ninteger::sign_func\ninteger::a,n,m\n!\n!     distinct three cases: actual atom a is atom m, atom n or none of them\n!\nif (a .eq. m) then\n   sign_func=1\nelse if (a .eq. n) then\n   sign_func=-1\nelse \n   sign_func=0\nend if\n\nreturn\nend function sign_func\n"}, {"instruction": "Create a Fortran function named lin_interp to perform linear interpolation of a value y based on the arrays x and f. The function takes 3 input parameters of type real, dimension(:) for x and f, and a single real for y. It returns a single real value.", "input": "", "output": "  function lin_interp(x, f, y) result(g)\n    implicit none\n    real, intent(in), dimension(:) :: x\n    real, intent(in), dimension(:) :: f\n    real, intent(in) :: y\n    real :: g\n    integer :: k\n    integer :: n\n    real :: a\n    n = size(x)\n    if (y <= x(1)) then\n      k = 1\n    else if (y >= x(n)) then\n      k = n - 1\n    else\n      k = 1\n      do while (y > x(k+1) .and. k < n)\n        k = k + 1\n      end do\n    end if\n    a = ( f(k+1) - f(k) ) / ( x(k+1) - x(k) )\n    g = f(k) + a * (y - x(k))\n  end function lin_interp\n"}, {"instruction": "Write a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type real. If the input integer is negative, the function returns -1.0 to indicate an error. If the input integer is 0, the function returns 1.0 as the factorial of zero. Otherwise, the function iteratively calculates the factorial and returns the result as a real number.", "input": "", "output": "function fact(n) result(factorial)\n    integer, intent(in) :: n\n    integer :: i\n    real :: factorial, temp\n    if (n < 0) then\n        factorial = -1.0    ! error\n        else if(n == 0) then\n        factorial = 1.0     ! factorial of zero\n        else\n        temp = 1.0\n        do i = 2, n\n            temp = temp * i\n        end do\n        factorial = temp\n    end if\nend function fact\n"}, {"instruction": "Write a Fortran function named simpr to perform numerical integration using Simpson's rule. The function takes 4 input arguments of type real, real, real, and integer (optional) respectively. The output is a real number.", "input": "", "output": "  function simpr(fcn, a, b, n) result(s)\n    interface\n      function fcn(x)\n        real, intent(in) :: x\n        real :: fcn\n      end function\n    end interface\n    real, intent(in) :: a, b\n    integer, optional, intent(in) :: n\n    real :: f0, fn, fs0, fs1, h, s, x0, x1\n    integer :: i, k\n\n    k = merge(n, 3, present(n))\n    h = (b - a) / k\n    f0 = fcn(a)\n    fn = fcn(b)\n    fs0 = 0\n    fs1 = 0\n    x0 = a\n    do i = 1, k\n      x1 = x0 + h\n      if(i < k) fs0 = fs0 + fcn(x1)\n      fs1 = fs1 + fcn((x0 + x1) / 2.)\n      x0 = x1\n    end do\n    s = h / 6. * (f0 + 2. * fs0 + fn + 4. * fs1)\n  end function\n"}, {"instruction": "Create a Fortran function named hyp2f1 to calculate the hypergeometric function 2F1 with four real input parameters. The input parameters are a, b, c, and z, and the output parameter is a real number f1. Use an iterative algorithm to compute the hypergeometric function and return the result f1.", "input": "", "output": "  elemental function hyp2f1(a, b, c, z) result(f1)\n    real, intent(in) :: a, b, c, z\n    integer, parameter :: itmax = 1000\n    real :: aa, bb, cc, f1, fac, temp\n    integer :: n\n\n    fac = 1.\n    temp = fac\n    aa = a\n    bb = b\n    cc = c\n    do n = 1, itmax\n      fac = fac * ((aa * bb) / cc) * z / n\n      f1 = temp + fac\n      if(f1 == temp) return\n      temp = f1\n      aa = aa + 1.\n      bb = bb + 1.\n      cc = cc + 1.\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is denoted as intent(in).", "input": "", "output": "  pure function factorial(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: factorial,i\n\n    factorial=1\n    do i=1,n\n       factorial=factorial*i\n    end do\n    \n  end function factorial\n"}, {"instruction": "Create a Fortran function named diff3 to calculate the third divided difference of three data points. The function takes 6 input arguments of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "    function diff3(x1,x2,x3,y1,y2,y3)\n        real(8),intent(in)::x1,x2,x3\n        real(8),intent(in)::y1,y2,y3\n        real(8)::f1,f2,diff3\n        f1=(y2-y1)/(x2-x1)\n        f2=(y3-y2)/(x3-x2)\n        diff3=(f2-f1)/(x3-x1)\n    end function\n"}, {"instruction": "Create a Fortran function named pythag_triplet to determine if the given three integers form a Pythagorean triplet. The function takes 3 input arguments of type integer (kind=8) and returns a single output argument of type logical.", "input": "", "output": "        pure function pythag_triplet(a, b, c)\n\n                integer (kind=8), intent(in) :: a, b, c\n                logical :: pythag_triplet\n\n                pythag_triplet = (a ** 2 + b ** 2 == c ** 2)\n\n                return\n\n        end function pythag_triplet\n"}, {"instruction": "Write a Fortran function named compar that compares two 8-byte integers and returns an integer of 2 bytes as the result. The function takes 2 input arguments of type integer(8), and the output is a single integer(2) value.", "input": "", "output": "    function compar (arg1,arg2)\n    integer(2) :: compar\n    integer(8) :: arg1, arg2\n    if (arg1 < arg2) then\n        compar = -1\n    else if (arg1 > arg2) then\n        compar = 1\n    else\n        compar = 0\n    end if\n    end function compar\n"}, {"instruction": "Create a Fortran function named nu_m_n_k that calculates the value of nu(m, n, k) based on equation (d.51) in Johnson 1980. The function takes 3 input parameters of type integer [m, n, k] and returns 1 output parameter of type real [nu]. Ensure the function checks for even m or n and performs factorial calculations to determine the value of nu.", "input": "", "output": "    function nu_m_n_k(m, n, k) result(nu)\n        ! calculates nu(m,n,k) based on eq. (d.51) in johnson 1980\n\n        implicit none\n\n        integer,intent(in) :: m, n, k\n        real :: nu\n\n        integer :: mm, nn, kk, i\n\n        ! check for even m or n\n        if (mod(m, 2) .eq. 0 .or. mod(n, 2) .eq. 0) then\n            nu = 0\n        else\n             \n            ! initialize\n            mm = 1\n            nn = 1\n            kk = 1\n\n            ! run factorials (ish. not sure what you'd call these...)\n            if (.not. m .eq. 1) then\n                do i=1,m-2,2\n                    mm = mm*i\n                end do\n            end if\n\n            if (.not. n .eq. 1) then\n                do i=1,n-2,2\n                    nn = nn*i\n                end do\n            end if\n\n            do i=k-2,k-m-n,2\n                kk = kk*i\n            end do\n\n            ! calculate nu\n            nu = mm*nn/kk\n\n        end if\n\n    end function nu_m_n_k\n"}, {"instruction": "Create a Fortran function named get_fibonacci to calculate the nth Fibonacci number. The input parameter is an integer, and the output parameter is also an integer.", "input": "", "output": "function get_fibonacci(n) result(out)\n  integer, intent(in) :: n\n  integer :: out\n  integer :: pprev, prev, fib_no\n  pprev = 0\n  prev = 1\n  out = 1\n  fib_no = 1\n  do while (fib_no < n)\n     out = prev + pprev\n     pprev = prev\n     prev = out\n     fib_no = fib_no + 1\n  end do\nend function get_fibonacci\n"}, {"instruction": "Write a Fortran function named zerorecord that takes an integer input and converts it to a character string of length 4 by adding leading zeros if necessary. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character (len=4)].", "input": "", "output": "function zerorecord(inint)\n  implicit none\n  character (len=4) :: zerorecord, work\n  integer :: inint\n  work=\"0000\"\n  if (inint.lt.10) then\n     write(work(4:),'(i1)') inint\n  else if (inint.lt.100) then\n     write(work(3:),'(i2)') inint\n  else if (inint.lt.1000) then\n     write(work(2:),'(i3)') inint\n  else if (inint.lt.10000) then\n     write(work(1:),'(i4)') inint\n  else\n     print *, \"char error.\"\n     stop\n  endif\n  zerorecord=work\nend function zerorecord\n"}, {"instruction": "Create a Fortran function named kgen_get_newunit to generate a new unit number for file I/O. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is the seed for the random number generator.", "input": "", "output": "            function kgen_get_newunit(seed) result(new_unit)\n               integer, parameter :: unit_min=100, unit_max=1000000\n               logical :: is_opened\n               integer :: nunit, new_unit, counter\n               integer, intent(in) :: seed\n            \n               new_unit = -1\n               \n               do counter=unit_min, unit_max\n                   inquire(unit=counter, opened=is_opened)\n                   if (.not. is_opened) then\n                       new_unit = counter\n                       exit\n                   end if\n               end do\n            end function\n"}, {"instruction": "Write a Fortran function named callback1_incr that takes an integer input parameter of type c_int by value. The function also returns an integer of type c_int as the result.", "input": "", "output": "        function callback1_incr(arg0) bind(c)\n            use iso_c_binding, only : c_int\n            implicit none\n            integer(c_int), value :: arg0\n            integer(c_int) :: callback1_incr\n        end function callback1_incr\n"}, {"instruction": "Create a Fortran function named benchmarksupport that takes an integer input argument. It should return a logical value indicating whether benchmark support is available based on the comparison of the input with the value of threadsupport. The number of input arguments is 1 of type integer, and the number of output arguments is 1 of type logical.", "input": "", "output": "  function benchmarksupport(required)\n    integer, intent(in) :: required\n    logical :: benchmarksupport\n\n    if (required <= threadsupport) then\n       benchmarksupport = .true.\n    else\n       benchmarksupport = .false.\n    end if\n\n  end function benchmarksupport\n"}, {"instruction": "Create a Fortran function named workable that takes two input parameters: an 8-byte integer number and a regular integer bitmask. The function returns a single output parameter of type logical. Inside the function, the input number is divided by 10 while the bitmask is divided by 2 within a do-while loop. If the bitmask becomes greater than 0, the function returns false; otherwise, it returns true.", "input": "", "output": "  pure function workable(number,bitmask)\n    implicit none\n    integer*8, intent(in) :: number\n    integer, intent(in)   :: bitmask\n    integer*8             :: temp1\n    integer               :: temp2\n    logical               :: workable\n\n    temp1=number\n    temp2=bitmask\n    workable=.true.\n    do while(temp1>0)\n       temp1=temp1/10\n       temp2=temp2/2\n    end do\n\n    if (temp2>0) then\n       workable=.false.\n    end if\n\n  end function workable\n"}, {"instruction": "Write a Fortran function named vector_scalar_mul that multiplies each element of a 4D array by a corresponding element of a 3D array. The number of input arguments is 2, and their test_data types are ['real, dimension(:,:,:,:)', 'real, dimension(:,:,:)']. The number of output arguments is 1, and its test_data type is ['real, dimension(size(in,1),size(in,2),size(in,3),3)'].", "input": "", "output": "function vector_scalar_mul (in, in2) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(:,:,:), intent(in):: in2\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  out(:,:,:,1) = in(:,:,:,1)*in2\n  out(:,:,:,2) = in(:,:,:,2)*in2\n  out(:,:,:,3) = in(:,:,:,3)*in2\nend function\n"}, {"instruction": "Create a Fortran function named const3_vector_mul that takes two input parameters of type real, with dimensions specified by \":,:,:,:\", and \":,\" respectively. The function has one output parameter of type real, with dimensions specified by \"size(in,1),size(in,2),size(in,3),3\". The function computes the element-wise multiplication of the input 4D array with a 1D array and stores the result in a 4D array, where each element is multiplied by the corresponding element of the 1D array.", "input": "", "output": "function const3_vector_mul (in1, in) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  real, dimension(:), intent(in):: in1\n  out(:,:,:,1) = in(:,:,:,1)*in1(1)\n  out(:,:,:,2) = in(:,:,:,2)*in1(2)\n  out(:,:,:,3) = in(:,:,:,3)*in1(3)\nend function\n"}, {"instruction": "Create a Fortran function named vector_scalar_add to perform element-wise addition of a 4D array and a 3D array. The number of input arguments is 2, where the test_data type is ['real, dimension(:,:,:,:)', 'real, dimension(:,:,:)']. The number of output arguments is 1, with the test_data type as ['real, dimension(size(in,1),size(in,2),size(in,3),3)'].", "input": "", "output": "function vector_scalar_add (in, in2) result (out)\n  real, dimension(:,:,:,:), intent(in):: in\n  real, dimension(:,:,:), intent(in):: in2\n  real, dimension(size(in,1),size(in,2),size(in,3),3):: out\n  out(:,:,:,1) = in(:,:,:,1)+in2\n  out(:,:,:,2) = in(:,:,:,2)+in2\n  out(:,:,:,3) = in(:,:,:,3)+in2\nend function\n"}, {"instruction": "Write a Fortran function named find_data_file to search for a required data file in several locations. The input parameter is a character string with variable length. The output parameter is also a character string with a length of 1000.", "input": "", "output": "      function find_data_file(basename)\n        ! find a required data file by searching several locations.\n        ! returns the path if found; exits the program if not.\n        ! can be used directly in an open() statement, e.g.:\n        !\n        !   open(<unit>, file=find_data_file(<basename>), status='old')\n        !\n        implicit none\n        character(len=*), intent(in) :: basename\n        character(len=1000) :: find_data_file, data_home, env_home\n        character(len=100)  :: suffix\n        logical :: file_exists\n\n        ! check current directory first\n        find_data_file = basename\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! path suffix for the remaining candidates\n        suffix = '/osu-hydro/' // basename\n\n        ! check user directory: xdg_data_home or ~/.local/share if unset\n        call get_environment_variable('xdg_data_home', data_home)\n        if (len_trim(data_home) == 0) then\n          call get_environment_variable('home', data_home)\n          data_home = trim(data_home) // '/.local/share'\n        end if\n\n        find_data_file = trim(data_home) // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! check system directories\n        find_data_file = '/usr/local/share' // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        find_data_file = '/usr/share' // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        ! check python virtual environment [use in hic chain]\n        call get_environment_variable('conda_prefix', env_home)\n        data_home = trim(env_home) // '/share'\n        find_data_file = trim(data_home) // suffix\n        inquire(file=find_data_file, exist=file_exists)\n        if (file_exists) return\n\n        print *, basename, ' not found'\n        call exit(1)\n      end function\n"}, {"instruction": "Create a Fortran function named randint that generates a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be provided as an array representing the range [mi, ma], and the function returns a random integer x within that range.", "input": "", "output": "    function randint(mi,ma) result(x)\n        implicit none\n        \n        integer,intent(in)  :: mi,ma\n        integer             :: x\n        real    :: r\n        \n        call random_number(r)\n        x = mi + floor(r*(ma-mi+1))\n    end function        \n"}, {"instruction": "Create a Fortran function named day_of_week that takes 3 input parameters of type integer (d, m, y) and returns 1 output parameter of type integer. This function computes the day of the week for a given date using Zeller's Congruence algorithm.", "input": "", "output": "function day_of_week(d, m, y)\n  integer :: day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n\n  j = y / 100\n  k = mod(y, 100)\n  day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n\nend function day_of_week\n"}, {"instruction": "Create a Fortran function named f_combination to calculate the combination value (n choose k) using the given input parameters. The number of input parameters is 2, and their test_data type is ['integer', 'integer']. The number of output parameters is 1, and its test_data type is ['integer']. Use the imperative tone to describe the function.", "input": "", "output": "  function f_combination(n,k) result(nck)\n    integer, intent(in) :: n, k\n    integer :: i\n    integer ::nck\n\n    if(n < k)then\n      nck = 0\n      return\n    end if\n\n    nck=1\n    do i=1,k\n      nck=nck*(n-k+i)\n      nck=nck/i\n    end do\n\n  end function f_combination\n"}, {"instruction": "Write a Fortran function named compute_analog_mean to calculate the mean of elements in an array based on the indices provided in another integer array. The function takes 2 input parameters of type real, dimension(:) and integer, dimension(:), and returns 1 output parameter of type real.", "input": "", "output": "    function compute_analog_mean(input, analogs) result(mean)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real                              :: mean\n        \n        double precision :: internal_mean\n        integer :: i, n\n        \n        n = size(analogs)\n        internal_mean = 0\n        \n        do i=1,n\n            internal_mean = internal_mean + input( analogs(i) )\n        enddo\n        \n        mean = internal_mean / n\n        \n    end function compute_analog_mean\n"}, {"instruction": "Create a Fortran function named compute_analog_error to calculate the error between a set of input values and a predicted value. The function has 3 input parameters of types real, dimension(:), integer, dimension(:), and real, and 1 output parameter of type real.", "input": "", "output": "    function compute_analog_error(input, analogs, y_hat) result(error)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real,    intent(in)               :: y_hat\n        real                              :: error\n        \n        double precision :: mean\n        integer :: i, n\n        \n        n = size(analogs)\n        mean = 0\n        \n        do i=1,n\n            mean = mean + (input( analogs(i) ) - y_hat)**2\n        enddo\n        \n        error = sqrt(mean / n)\n        \n    end function compute_analog_error\n"}, {"instruction": "Create a Fortran function named compute_analog_exceedance to calculate the probability of exceeding a threshold value by the elements specified by the indices in the analogs array, from the input array. The function takes 3 input arguments of types real, dimension(:), integer, dimension(:), and real. The output parameter is a real value.", "input": "", "output": "    function compute_analog_exceedance(input, analogs, threshold) result(probability)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in), dimension(:) :: analogs\n        real,    intent(in)               :: threshold\n        real                              :: probability\n        integer :: i, n\n        \n        n = size(analogs)\n        probability = 0\n        do i = 1, n\n            if (input(analogs(i)) > threshold) then\n                probability = probability + 1\n            endif\n        end do\n        \n        probability = probability / n\n        \n    end function compute_analog_exceedance\n"}, {"instruction": "Write a Fortran function named pick_n_random_zeros that takes an array of real numbers and an integer n as input and returns an array of n randomly chosen indices corresponding to elements in the input array that are zero. The number of input arguments is 2 and the test_data type is ['real, dimension(:)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(1:n)'].", "input": "", "output": "    function pick_n_random_zeros(input, n) result(analogs)\n        implicit none\n        real,    intent(in), dimension(:) :: input\n        integer, intent(in)     :: n\n        integer, dimension(1:n)   :: analogs\n        integer, dimension(:), allocatable :: zero_locations\n        \n        integer :: i, n_inputs, n_zeros, selected_analog\n        real :: rand\n\n        n_inputs = size(input)\n        allocate(zero_locations(n_inputs))\n        n_zeros = 0\n        do i=1,n_inputs\n            if (input(i)==0) then\n                n_zeros = n_zeros + 1\n                zero_locations(n_zeros) = i\n            end if\n        end do\n        \n        do i=1,n\n            call random_number(rand)\n            selected_analog = floor(rand * n_zeros)+1\n            analogs(i) = zero_locations(selected_analog)\n        end do\n\n    end function pick_n_random_zeros\n"}, {"instruction": "Write a Fortran function named tria_binsearch to perform a binary search on an integer array. The function takes 4 input arguments of type integer, dimension(:), integer, integer and returns 1 output argument of type integer.", "input": "", "output": "  function tria_binsearch(p_iarray, ivalue, ilbound, iubound)\n\n!<description>\n\n!</description>\n\n!<input>\n    ! the integer array to search in\n    integer, dimension(:),intent(in) :: p_iarray\n\n    ! the integer to search for\n    integer, intent(in) :: ivalue\n\n    ! the lower and uppers bounds used in the array\n    integer, intent(in) :: ilbound, iubound\n!</input>\n\n!<result>\n    integer :: tria_binsearch\n!</result>\n\n\n    ! local variables\n    integer :: imid, ilboundloc, iuboundloc\n\n    ilboundloc = ilbound\n    iuboundloc = iubound\n\n    ! standard binary search scheme...\n    do while( ilboundloc .le. iuboundloc )\n\n      imid = (ilboundloc + iuboundloc) / 2\n\n      if(p_iarray(imid) > ivalue) then\n        iuboundloc = imid-1\n      elseif(p_iarray(imid) < ivalue) then\n        ilboundloc = imid+1\n      else ! found ivalue\n        tria_binsearch = 1\n        return\n      end if\n\n    end do ! end while\n\n    ! ivalue was not found...\n    tria_binsearch = 0\n\n  end function tria_binsearch\n"}, {"instruction": "Create a Fortran function named ele_mass to calculate the mass of an element based on its symbol. The function takes 1 input parameter of type character(len=30) and returns 1 output parameter of type real(kind=8). The input parameter represents the symbol of the element, and the output parameter holds the mass of the element.", "input": "", "output": "    function ele_mass(ele) result(m)\n\n    implicit none\n\n    character(len=30),intent(in) :: ele\n    real(kind=8)    :: m\n\n    if (trim(adjustl(ele)) .eq. 'si') then\n        m = 28.0855\n    end if\n\n    end function ele_mass\n"}, {"instruction": "Write a Fortran function called is_leap_year to determine if a given year is a leap year. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the year is a leap year or not.", "input": "", "output": "  elemental function is_leap_year( year )\n    integer, intent(in) :: year\n    logical :: is_leap_year\n\n    is_leap_year = ( (mod(year,4)   == 0) .and. &\n                     (mod(year,100) /= 0)       ) .or. &\n                   (mod(year,400) == 0)\n\n  end function is_leap_year\n"}, {"instruction": "Create a Fortran function named tolower to convert the uppercase characters in a string to lowercase. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=len(a)).", "input": "", "output": "function tolower(a) result(b)\n!===============================================================================\n!  convert the uppercase characters in a string to lowercase\n   implicit none\n   character(len=*), intent(in) :: a\n   character(len=len(a)) :: b\n   integer, parameter :: capa = iachar('a'), capz = iachar('z')\n   integer :: i, ia\n   b = a\n   do i = 1, len_trim(a)\n      ia = iachar(a(i:i))\n      if (ia >= capa .and. ia <= capz) &\n         b(i:i) = achar(iachar(a(i:i)) + 32)\n   enddo\nend function tolower\n"}, {"instruction": "Create a Fortran function named \"pi\" to estimate the value of pi using a Monte Carlo method, based on the number of samples provided. The function should take 1 input parameter of type integer and return 1 output parameter of type real. The input parameter represents the number of samples to be used in the estimation. Use the imperative tone to provide the following instructions.", "input": "", "output": "    function pi(samples_num) result(pi_value)\n        ! declaring input parameter\n        integer, intent(in) :: samples_num\n        ! declaring local vaariables\n        real :: pi_value, length\n        real, dimension(2) :: coordinates\n        integer :: i, in_circle\n\n        in_circle = 0\n        do i = 1, samples_num\n            call random_number(coordinates)\n            coordinates = coordinates * 2 - 1\n            length = sqrt(coordinates(1) * coordinates(1) + coordinates(2) * coordinates(2))\n            if ( length <= 1 ) then\n                in_circle = in_circle + 1\n            end if\n        end do\n        pi_value = 4.0  * real(in_circle) / real(samples_num)\n    end function pi\n"}, {"instruction": "Create a Fortran function named pluralize that takes in a singular word of type character and a count of type integer as input, and returns the plural form of the word based on the count. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=256)'].", "input": "", "output": "        pure function pluralize(singular, i)\n            character(len=*), intent(in) :: singular\n            integer, intent(in)          :: i\n            character(len=256)          :: pluralize\n            if (i == 1) then\n                pluralize = singular\n            else\n                pluralize = trim(singular) // \"s\"\n            end if\n        end function\n"}, {"instruction": "Create a Fortran function named strfrominteger that takes an integer as input and returns a character string. The number of input arguments is 1 and the test_data type is ['integer'], while the number of output arguments is 1 and the test_data type is ['character(len=256)']. Use the imperative tone to instruct the creation of this function.", "input": "", "output": "        pure function strfrominteger(i) result(str)\n            integer, intent(in) :: i        !! the integer to convert to a string\n            character(len=256) :: str       !! the string to return\n            write(str, *)i\n            str = trim(adjustl(str))\n        end function\n"}, {"instruction": "Create a Fortran function named strfromreal that takes a real number as input and returns a string representation of the input number. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['character(len=256)'].", "input": "", "output": "        pure function strfromreal(r) result(str)\n            real, intent(in) :: r           !! the real to convert to a string\n            character(len=256) :: str       !! the string to return\n            write(str, *)r\n            str = trim(adjustl(str))\n        end function\n"}, {"instruction": "Create a Fortran function named aux_f_bc to calculate a mathematical function based on the value of a single double precision real input. The number of input arguments is 1 and the test_data type is [real * 8]. The number of output arguments is 1 and the test_data type is [real * 8]. Use an if-else condition to determine the output based on the input value.", "input": "", "output": "\tfunction aux_f_bc(q) result(f)\n\t\timplicit none\n\t\treal * 8, intent(in) :: q\n\t\treal * 8 :: f\n\t\tif (q>0.075d0) then\n\t\t\tf = 2.d0 * bessel_jn(1,q) / q\n\t\telse\n\t\t\tf = 1.d0 - (q * q / 8.d0)\n\t\tend if\n\tend function\n"}, {"instruction": "Write a Fortran function named num2str to convert an integer to a string. The function should take 1 input argument of type integer and return 1 output argument of type character(len=:),allocatable.", "input": "", "output": "    function num2str(intnum)\n    integer,intent(in) :: intnum\n    character(len=:),allocatable:: num2str\n    character(len=255):: tmpstr\n    write(tmpstr,*)intnum\n    allocate(character(len=len_trim(adjustl(tmpstr)))::num2str)\n    num2str=trim(adjustl(tmpstr))\n    end function num2str\n"}, {"instruction": "Create a Fortran function named str_f4 to convert a real(8) number to a string with a specified format. The number of input arguments is 1 and the test_data type is [real(8)]. The number of output arguments is 1 and the test_data type is [character(len=8)].", "input": "", "output": "function str_f4 (t) result (out)\n  real(8):: t\n  character(len=8):: out\n  !-----------------------------------------------------------------------------\n  write (out,'(f8.3)') t\n  out = adjustl(out)\n  out = trim(out(1:4))\nend function\n"}, {"instruction": "Create a Fortran function named spud_get_option to retrieve an option value based on the provided key and key length. The function should have 3 input parameters of types integer(c_int), character(len=1,kind=c_char) array, and type(c_ptr), and 1 output parameter of type integer(c_int).", "input": "", "output": "     function spud_get_option(key, key_len, val) bind(c)\n       use iso_c_binding\n       implicit none\n       integer(c_int), intent(in), value :: key_len\n       character(len=1,kind=c_char), dimension(key_len), intent(in) :: key\n       ! here intent(in) refers to the c_ptr, not the target!\n       type(c_ptr), value, intent(in) :: val\n       integer(c_int) :: spud_get_option\n     end function spud_get_option\n"}, {"instruction": "Create a Fortran function named plm to calculate the associated Legendre polynomials. The function takes 3 input parameters of type integer, integer, and real(kind=dp), and returns 1 output parameter of type real(kind=dp). The input parameters are l, m, and x, while the output parameter is plm. Ensure to handle the special cases of bad input arguments within the function.", "input": "", "output": "function plm(l,m,x)\n!----------------------------------------------------\n! subroutine:\n!   plm\n!\n! purpose:\n!  calculate assiociated legendre polynomials      \n!----------------------------------------------------\n  implicit none\n  integer,parameter::dp=selected_real_kind(8) !double precision\n  integer::l,m\n  integer::i,ll\n  real(kind=dp)::x,fact,pll,pmm,pmmp1,somx2\n  real(kind=dp)::plm\n  if((m.lt.0).or.(m.gt.l).or.(abs(x).gt.1.d0))then\n      write(*,*) 'bad arguments in plm'\n  endif\n  pmm=1.d0\n  if(m.gt.0)then\n     somx2=sqrt((1.d0-x)*(1.d0+x))\n     fact=1.d0\n     do 11 i=1,m\n        pmm=-pmm*fact*somx2\n        fact=fact+2.d0\n11   continue\n  endif\n  if(l.eq.m)then\n     plm=pmm\n  else\n     pmmp1=x*dble(2*m+1)*pmm\n     if(l.eq.m+1)then\n        plm=pmmp1\n     else\n        do 12 ll=m+2,l\n           pll=(x*dble(2*ll-1)*pmmp1-dble(ll+m-1)*pmm)/dble(ll-m)\n           pmm=pmmp1\n           pmmp1=pll\n12      continue\n        plm=pll\n     endif\n  endif\n  return\nend function plm\n"}, {"instruction": "Create a Fortran function named integrate to numerically integrate a given function using the trapezoidal rule. The function has 3 input parameters of type real, real array, and optional integer. The output parameter is of type real. The number of input arguments is 3 and the test_data type is [real, real, dimension(:), integer, optional]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    pure function integrate( dt, f, method ) result( ff )\n        \n        real, intent(in)                 :: dt\n        real, dimension(:), intent(in)   :: f\n        integer, optional, intent(in)    :: method\n        real :: ff\n        \n        integer :: i,il,iu\n        \n        if (present(method)) return\n     \n        if (size(f) < 2) then\n            ff = 0.0\n            return\n        end if\n        \n        il = lbound(f,1)\n        iu = ubound(f,1)\n        \n        ff = (f(il)+f(iu))/2.0\n        do i=il+1,iu-1\n            ff = ff + f(i)\n        end do\n        ff = ff * dt\n        \n        \n    end function integrate\n"}, {"instruction": "Write a Fortran function named next_copy_number that takes two input arguments, cnum of type integer and ncopies of type integer (optional). The function returns an integer value. If the optional argument ncopies is present, the function calculates the next copy number as cnum plus ncopies minus 1; otherwise, it calculates the next copy number as cnum plus 1.", "input": "", "output": "function next_copy_number(cnum, ncopies)\ninteger, intent(inout)        :: cnum\ninteger, intent(in), optional :: ncopies\ninteger :: next_copy_number\n\nif (present(ncopies)) then\n   next_copy_number = cnum + ncopies - 1\nelse\n   next_copy_number = cnum + 1\nendif\n\ncnum = next_copy_number\n\nend function next_copy_number\n"}, {"instruction": "Write a Fortran function named delta2 that computes a function value. \nThe function takes 7 input parameters: an integer, a real*8 array of dimension (no_data), another real*8 array of dimension (no_data), and four individual real*8 values. \nThe output is a single real*8 value.", "input": "", "output": "function delta2(no_data,z,p,del,alpha,z_data,sigma_data)\n implicit none\n\n  integer,intent(in) :: no_data\n  real*8,intent(in),dimension(no_data) :: z_data, sigma_data\n  real*8,intent(in) :: z,p,del,alpha\n!  real*8,parameter :: del = 1.0d0\t\t\t!type 1: power 1.5 delta 0.3 and const. 1.9  ---- type 2 delta 0.1 const 1.8\n  real*8 :: delta2\n  integer :: i\n\n  delta2 = 0.0d0\n  do i = 1,no_data\t\n\tdelta2 = delta2 + (((1.0d0)/((sigma_data(i))**2))*(exp(-1.0d0*(( (z-z_data(i))/(del))**2))))\t!for type 1 -- 2 power is 1.5\n end do\n  delta2 = (alpha)*((1.0d0/delta2)**(1.0d0/p))\n\n return\nend function delta2\n"}, {"instruction": "Create a Fortran function named dm_flat to calculate the luminosity distance for a flat universe. The function takes 3 input parameters of type real*8: x2, h0, and om. It returns a single output parameter of type real*8, which represents the luminosity distance.", "input": "", "output": "function dm_flat (x2, h0, om)\n  implicit none\n  real*8 :: dm_flat\n  integer :: i,n\n  real*8 :: x1, h_x1, sum2\n  real*8, intent (in) :: x2, h0, om\n\n  sum2 = 0.0d0\n  x1 = 0.0d0\n  n = 100\n  h_x1=(x2-x1)/float(n)\n  do i = 1, n\n     sum2 = sum2 +((1.0d0)/(sqrt((om)*((x1+1.0d0)**3)+1.0d0-om)))\n     x1=x1+h_x1\n  end do\n  sum2=(sum2)*((1.0d0+x2)*(3.0d5)*(h_x1/h0))\n  dm_flat = 5.0d0*log10(sum2) + 25.0d0\nreturn\nend function dm_flat\n"}, {"instruction": "Create a Fortran function named w that takes a single input argument of type real*8 to compute and return a real*8 value.", "input": "", "output": "function w(z)\nimplicit none\n\treal*8,parameter :: w0 = -1.0d0,wm = -0.5d0,zt = 0.5d0,delta_t = 0.5d-1\n\treal*8 :: w\n\treal*8,intent(in) :: z\n\tw = (3.0d0/(1.0d0+z))*(1.0d0+w0 + ((wm-w0)*((1.0d0+exp(1.0d0/(delta_t*(1.0d0+zt))))/(1.0d0-exp(1.0d0/delta_t)))*(1.0d0- &\n\t((exp(1.0d0/delta_t)+exp(1.0d0/(delta_t*(1.0d0+zt))))/(exp(1.0d0/(delta_t*(1.0d0+z)))+exp(1.0d0/(delta_t*(1.0d0+zt))))))))\nreturn\nend function w\n"}, {"instruction": "Write a Fortran function called f, which takes two real input parameters x and t, and returns a real output. The function computes the sum of the sine values of x and t.", "input": "", "output": "    function f(x,t)\n        implicit none\n        real, intent(in) :: x, t\n        real :: f\n        f = sin(x) + sin(t)\n    end function\n"}, {"instruction": "Create a Fortran function named df to calculate the derivative of a given real number with respect to another real number. The function accepts 2 input parameters of type real, represented as x and t. It returns 1 output parameter of type real.", "input": "", "output": "    function df(x,t)\n        implicit none\n        real, intent(in) :: x, t\n        real :: df\n        df = cos(x)\n    end function\n"}, {"instruction": "Create a Fortran function named seval that takes 5 input parameters of type integer, real, real arrays of dimension n, and outputs a single real value. This function calculates the value of x(ss) using the values of ss and pre-calculated arrays xs and s using the spline method.", "input": "", "output": "    function seval(ss, x, xs, s, n)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        integer :: n\n        real :: ss\n        real, dimension(n) :: s, x, xs\n        real :: seval\n        intent (in) n, s, ss, x, xs\n        !\n        ! local variables\n        !\n        real :: cx1, cx2, ds, t\n        integer :: i, ilow, imid\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !--------------------------------------------------\n        !     calculates x(ss)                             |\n        !     xs array must have been calculated by spline |\n        !--------------------------------------------------\n        ilow = 1\n        i = n\n        !\n        do while (i - ilow>1)\n            !\n            imid = (i + ilow) / 2\n            if (ss<s(imid)) then\n                i = imid\n            else\n                ilow = imid\n            endif\n        enddo\n        !\n        ds = s(i) - s(i - 1)\n        t = (ss - s(i - 1)) / ds\n        cx1 = ds * xs(i - 1) - x(i) + x(i - 1)\n        cx2 = ds * xs(i) - x(i) + x(i - 1)\n        seval = t * x(i) + (1.0 - t) * x(i - 1) + (t - t * t) * ((1.0 - t) * cx1 - t * cx2)\n    end function seval\n"}, {"instruction": "Create a Fortran function named curv to calculate the curvature of a splined 2D curve at a given arc length. The function takes 7 input parameters of types integer, real, and real arrays of dimension n, and returns 1 output parameter of type real.", "input": "", "output": "    function curv(ss, x, xs, y, ys, s, n)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        integer :: n\n        real :: ss\n        real :: curv\n        real, dimension(n) :: s, x, xs, y, ys\n        intent (in) n, s, ss, x, xs, y, ys\n        !\n        ! local variables\n        !\n        real :: cx1, cx2, cy1, cy2, ds, sd, t, xd, xdd, yd, ydd\n        integer :: i, ilow, imid\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !-----------------------------------------------\n        !     calculates curvature of splined 2-d curve |\n        !     at s = ss                                 |\n        !                                               |\n        !     s        arc length array of curve        |\n        !     x, y     coordinate arrays of curve       |\n        !     xs,ys    derivative arrays                |\n        !              (calculated earlier by spline)   |\n        !-----------------------------------------------\n        !\n        ilow = 1\n        i = n\n        !\n        do while (i - ilow>1)\n            !\n            imid = (i + ilow) / 2\n            if (ss<s(imid)) then\n                i = imid\n            else\n                ilow = imid\n            endif\n        enddo\n        !\n        ds = s(i) - s(i - 1)\n        t = (ss - s(i - 1)) / ds\n        !\n        cx1 = ds * xs(i - 1) - x(i) + x(i - 1)\n        cx2 = ds * xs(i) - x(i) + x(i - 1)\n        xd = x(i) - x(i - 1) + (1.0 - 4.0 * t + 3.0 * t * t) * cx1 + t * (3.0 * t - 2.0) * cx2\n        xdd = (6.0 * t - 4.0) * cx1 + (6.0 * t - 2.0) * cx2\n        !\n        cy1 = ds * ys(i - 1) - y(i) + y(i - 1)\n        cy2 = ds * ys(i) - y(i) + y(i - 1)\n        yd = y(i) - y(i - 1) + (1.0 - 4.0 * t + 3.0 * t * t) * cy1 + t * (3.0 * t - 2.0) * cy2\n        ydd = (6.0 * t - 4.0) * cy1 + (6.0 * t - 2.0) * cy2\n        !\n        sd = sqrt(xd * xd + yd * yd)\n        sd = max(sd, 0.001 * ds)\n        !\n        curv = (xd * ydd - yd * xdd) / sd**3\n        !\n    end function curv\n"}, {"instruction": "Create a Fortran function named bspline3 to calculate the value of a cubic B-spline at a given point. The function takes 3 input parameters of type integer, double precision, and double precision. The output is a double precision value.", "input": "", "output": "  function bspline3(j,r,dr)\n    implicit none\n    integer, intent(in) :: j\n    double precision, intent(in) :: r,dr\n    double precision :: bspline3\n    double precision :: raux\n    raux = (r - (j-1)*dr)/dr\n    bspline3 = 0\n    if (0<raux .and. raux<3) then\n      select case (nint(raux+5d-1))\n      case(1)\n        bspline3 = raux**2/2\n      case(2)\n        bspline3 = (2*raux*(3-raux)-3)/2\n      case(3)\n        bspline3 = (raux-3)**2/2\n      end select\n    end if\n  end function bspline3\n"}, {"instruction": "Create a Fortran function named bspline3int that takes 3 input parameters: an integer j, and two double precision numbers r and dr. The function returns a double precision result. This function calculates an integral using the B-spline algorithm and returns the result.", "input": "", "output": "  function bspline3int(j,r,dr)\n    implicit none\n    integer, intent(in) :: j\n    double precision, intent(in) :: r,dr\n    double precision :: bspline3int\n    double precision :: raux,pota,potb\n    raux = (r - (j-1)*dr)/dr\n    bspline3int = 0\n    select case(nint(raux+5d-1))\n    case(:0)\n      pota = 0\n      potb = 12 + 24*j\n    case(1)\n      pota = raux**3*(10*(-1+j)**2+15*(-1+j)*raux+6*raux**2)\n      potb = 12+(4-3*raux)*raux**3-4*j*(-6+raux**3)\n    case(2)\n      pota = 1+j*(-5+j*(10+j*(-10+j*(5+2*j)))) &\n           -10*(-1+2*j*(1+j))*(-1+j+raux)**3+15*(1+2*j)*(-1+j+raux)**4-12*(-1+j+raux)**5\n      potb = 21+4*j*(3+(-3+raux)*raux*(-3+2*raux))+2*(-3+raux)*raux*(6+raux*(-7+3*raux))\n    case(3)\n      pota = -2-j*(20+j*(20+j*(40+j*(10+j)))) &\n           +10*(2+j)**2*(-1+j+raux)**3-15*(2+j)*(-1+j+raux)**4+6*(-1+j+raux)**5\n      potb = -((-3+raux)**3*(-1+4*j+3*raux))\n    case(4:)\n      pota = 30*(1+2*j*(1+j))\n      potb = 0\n    end select\n    bspline3int = - ((dr**2/(60*(-1+j+raux))) * pota + (dr**2/24) * potb)\n  end function bspline3int\n"}, {"instruction": "Create a Fortran function named areclose to determine if two real numbers are close within a specified threshold. The function takes 3 input parameters of type real and returns 1 output parameter of type logical.", "input": "", "output": "function areclose ( a, b, threshold ) result( isclose )\n\n    implicit none\n    real :: a, b, threshold\n    logical :: isclose\n\n    isclose = .true.\n    if ( 1.0 + (a - b) - 1.0 .ne. 0.0 ) then\n\t    if ( a .ne. 0.0 ) then\n\t\tisclose = ( abs ((a - b) / a) .le. threshold )\n\t    else if ( b .ne. 0.0 ) then\n\t\tisclose = ( abs ((a - b) / b) .le. threshold )\n\t    end if\n    end if\n\nend function areclose\n"}, {"instruction": "Create a Fortran function named densdot that takes a single input parameter of type double precision and returns a single output parameter of type double precision. The function calculates the rate of change of density based on the given input density, according to the formula from Rawlings et al. 1992 for freefall collapse with a factor for the magnetic field. If the input density is less than a specified final density, the calculated rate of change is based on a complex formula; otherwise, the rate of change is set to 0.0.", "input": "", "output": "    pure function densdot(density)\n        double precision, intent(in) :: density\n        double precision :: densdot\n        !rawlings et al. 1992 freefall collapse. with factor bc for b-field etc\n        if (density .lt. finaldens) then\n             densdot=bc*(density**4./initialdens)**0.33*&\n             &(8.4d-30*initialdens*((density/initialdens)**0.33-1.))**0.5\n        else\n            densdot=0.0\n        endif\n    end function densdot\n"}, {"instruction": "Create a Fortran function named uppercase that takes a single input argument of type character (len = *) and returns a single output argument of type character (len = 1). The function converts the input character to uppercase and returns the result.", "input": "", "output": "   function uppercase(letter) result(l)\n     character (len = *), intent (in) :: letter\n     character (len = 1)              :: l\n\n     character (len = 27), parameter :: lower = \"_abcdefghijklmnopqrstuvwxyz\", &\n                                        upper = \"_abcdefghijklmnopqrstuvwxyz\"\n     integer :: k\n\n     k = index(lower, letter)\n     if (k > 0) then\n       l = upper(k:k)\n     else\n       l = letter\n     end if\n     return\n   end function uppercase\n"}, {"instruction": "Create a Fortran function named action2str that takes an integer input argument and returns a 7-character string. When the input is equal to the value of the variable padd, the function should return 'add'; otherwise, it should return 'replace'.", "input": "", "output": "      pure function action2str (action)\n        integer, intent(in) :: action\n        character(7) :: action2str\n        if (action == padd) then\n          action2str = 'add'\n        else\n          action2str = 'replace'\n        end if\n      end function action2str\n"}, {"instruction": "Write a Fortran function named lower_case that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len(string)). This function converts the input string to lowercase and assigns the result to the output argument. Use an imperative tone in the instructions.", "input": "", "output": "      elemental function lower_case(string)\n        character(len=*), intent(in) :: string\n        character(len=len(string))   :: lower_case\n\n        integer :: i\n\n        do i = 1, len (string)\n          if (      iachar ('a') <= iachar (string(i:i)) &\n              .and. iachar ('z') >= iachar (string(i:i))) then\n            lower_case(i:i) = achar (iachar (string(i:i))&\n                              + iachar ('a') - iachar ('a'))\n          else\n            lower_case(i:i) = string(i:i)\n          end if\n        end do\n      end function lower_case\n"}, {"instruction": "Create a Fortran function named kdelta to calculate the Kronecker delta. The function takes 2 integer input parameters, and the test_data type is ['integer', 'integer']. It returns 1 if the input parameters are equal; otherwise, it returns 0. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "  function kdelta(i,j)\n    integer :: i,j,kdelta\n    kdelta=0\n    if (i == j) kdelta = 1\n  end function kdelta\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer number. This function takes 1 input parameter of type integer, and returns 1 output parameter of type integer.", "input": "", "output": "  pure function factorial ( n ) result ( rslt )\n    !! compute $n!$\n    integer, intent(in) :: n\n    integer :: rslt\n    integer :: i\n    rslt = 1\n    do i = 1, n\n      rslt = rslt*i\n   end do\n end function\n"}, {"instruction": "Create a Fortran function named sum_div that takes an integer(4) as input and returns an integer(4) as output. The function calculates the sum of all divisors of the input integer, excluding the input integer itself.", "input": "", "output": "  pure function sum_div(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(4)             :: sum_div\n\n    ! local variables\n    integer(4) :: i1,i2,nmax\n\n    ! figure out max number to try\n    nmax = int(sqrt(1d0*n))\n\n    ! 1 is always a divisor\n    sum_div = 1\n    do i1=2,nmax\n       if (mod(n,i1)==0) then\n          ! work out if a perfect square\n          i2 = n/i1\n          if (i2 /= i1) then\n             sum_div = sum_div + i1 + i2\n          else\n             sum_div = sum_div + i1\n          endif\n       endif\n    enddo\n\n    return\n  end function sum_div\n"}, {"instruction": "Write a Fortran function named sint that takes a string as input and returns an integer. The input parameter is of type character with variable length, and the output parameter is of type integer. The function parses the input string and returns the corresponding integer value.", "input": "", "output": "function sint(s) result(i)\n   implicit none\n   character(len=*) :: s\n   integer :: j, i\n   i = 0\n   do j=len(s), 1, -1\n    if (.not.((i.eq.0).and.(s(j:j).eq.' '))) then\n      i = i + ichar(s(j:j)) * 10 ** (j - 1)\n    endif\n   end do\n   return\n end function sint\n"}, {"instruction": "Create a Fortran function called chkerr_log that checks for errors, prints an error message, and returns a logical value. The function takes 3 input parameters of type integer, integer, and character(len=*), and 1 output parameter of type logical.", "input": "", "output": "  function chkerr_log(ierr,str,io_unit)\n!* purpose\n!*   check for errors, print message if error, and return logical\n!*   name                    description\n!*   ierr                    error integer\n!*   str                     error message string to be written to file\n!*   io_unit                 io unit for outpute file (assumed open)\n!* author\n!*   pieter boom\n!* modification history\n!*   2021/06/16: created (pb)\n!* copyright\n!*   (c) university of manchester\n!******/\n!> author: pieter boom\n!> date: 2021/06/16\n!> check for errors and return logical\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    implicit none\n\n    !-- arguments and result --\n    logical                       :: chkerr_log   !> error logical (return)\n    integer, intent(in)           :: ierr         !> error integer\n    integer, intent(in)           :: io_unit      !> io unit\n    character(len=*), intent(in)  :: str          !> error string\n\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n! main execution\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    !-- check for errors and exit graacefully if any found --\n    if (ierr /= 0) then; write(io_unit,'(a,i5)') 'error :: '//trim(str)//&\n      ' : errcode = ',ierr; chkerr_log = .true.; else; chkerr_log = .false.\n    end if;  return\n\n  end function\n"}, {"instruction": "Write a Fortran function named factorial_impure that calculates the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is 'n' and the output parameter is 'fac'. Remember, the function modifies the value of 'n' during calculation, which is not a good practice in Fortran programming.", "input": "", "output": "function factorial_impure(n) result(fac)\r\n! poor style -- n changed upon return\r\ninteger :: n\r\ninteger :: fac\r\nif (n < 2) then\r\n   fac = 1\r\n   return\r\nend if\r\nfac = n\r\ndo\r\n   n = n - 1\r\n   if (n < 2) return\r\n   fac = fac * n\r\nend do\r\nend function factorial_impure\r\n"}, {"instruction": "Create a Fortran function named int_args_func to calculate the sum of three integer inputs of kind 1, 2, and 4, and store the result in an integer output of kind 8. The number of input arguments is 4 with test_data type ['integer(kind=1)', 'integer(kind=2)', 'integer(kind=4)', 'integer(kind=8)'], and the number of output arguments is 1 with test_data type ['integer(kind=8)'].", "input": "", "output": "function int_args_func(a,b,c,d)\n      integer(kind=8) :: int_args_func\n      integer(kind=1), intent(in) :: a\n      integer(kind=2), intent(in) :: b\n      integer(kind=4), intent(in) :: c\n      integer(kind=8), intent(out) :: d\n\n      d = a + b + c\n      int_args_func = 10\n\nend function int_args_func\n"}, {"instruction": "Create a Fortran function named util_datetime_isleapyear that takes an integer input argument representing a year. This function should return an integer value indicating whether the input year is a leap year. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function util_datetime_isleapyear(year)\n        integer, intent(in) :: year\n        integer :: util_datetime_isleapyear\n        if ((mod(year,4) == 0) .and. ((mod(year,100) .ne. 0) .or. (mod(year,400) == 0))) then\n            util_datetime_isleapyear = 2\n        else\n            util_datetime_isleapyear = 1\n        end if\n    end function util_datetime_isleapyear\n"}, {"instruction": "Create a Fortran function named util_datetime_dayofweek to determine the day of the week based on the input epoch time. The function has 1 input parameter of type real(8) and 1 output parameter of type integer.", "input": "", "output": "    function util_datetime_dayofweek(epochtime)\n        real(8), intent(in) :: epochtime\n        integer :: t, util_datetime_dayofweek\n        t = floor(epochtime) + datedelta\n        util_datetime_dayofweek = mod(t, 7)+1\n    end function\n"}, {"instruction": "Write a Fortran function named d_dedxc_s2 to calculate a specific mathematical expression. The function takes 4 input arguments of type real: a, b, c, and u. It returns a single output of type real.", "input": "", "output": "      function d_dedxc_s2(a, b, c, u)\n      implicit none\n        real, intent(in) :: a, b, c, u\n        real             :: d_dedxc_s2\n        d_dedxc_s2= (c - log(u/(1-u)))*(b*sqrt(u) - 1/sqrt(u))\n        d_dedxc_s2=d_dedxc_s2 + 2/sqrt(u)\n        d_dedxc_s2=d_dedxc_s2*exp(-a*a*u)\n      end function d_dedxc_s2\n"}, {"instruction": "Create a Fortran function named kqm1 to calculate a specific mathematical function. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input and output parameters are of type real. Ensure the function follows the Fortran syntax.", "input": "", "output": " function kqm1(x)  \n   implicit none\n   real, intent(in) :: x\n   real :: kqm1\n\n   real, parameter :: xmin=0.15e0, xmax=3.2e0 \n\n   real, parameter :: a0= 0.4329117486761496454549449429 ! 3*gamma/4\n   real, parameter :: a1= 1.2020569031595942854250431561 ! zeta(3)\n   real, parameter :: a2= 0.1487967944177345026410993331 ! zeta'(3)+gamma*\n   real, parameter :: b2=-0.0416666666666666666666666667 !-1/24  zeta(3)/2\n   real, parameter :: b4=-0.0083333333333333333333333333 !-1/120\n   real, parameter :: b6=-0.0119047619047619047619047619 !-1/84\n   real, parameter :: c0= 0.25109815055856566000\n   real, parameter :: c1=-0.02989283169766254700\n   real, parameter :: c2= 0.03339880139150325000\n   real, parameter :: c3=-0.00799128953390392700\n   real, parameter :: c4= 0.00070251863606810650\n   real, parameter :: d0=-0.18373957827052560000\n   real, parameter :: d1=-0.33121125339783110000\n   real, parameter :: d2= 0.04022076263527408400\n   real, parameter :: d3=-0.00331897950305779480\n   real, parameter :: d4= 0.00012313574797356784\n   real :: x2, lx, xi\n   if ( x .le. xmin) then                        ! x < xmin=0.15: to 0.06%\n      x2=x*x                                     ! ln(x)/2 + 3*gamma/4 +\n      lx=log(x)                                  ! zeta(3)*x^2*ln(x) +\n      kqm1=0.5e0*lx + a0 + a1*x2*lx + a2*x2      ! [zeta'(3) + gamma*\n                                                 ! zeta(3)/2]*x^2\n                                                 !\n   elseif ( x .ge. xmax ) then                   ! x > xmax=3.2: to 0.12%\n      xi=1/x                                     ! -1/24*x^2 - 1/120*x^4 -\n      x2=xi*xi                                   ! 1/84*x^6\n      kqm1=b6                                    !\n      kqm1=b4 + kqm1*x2                          !\n      kqm1=b2 + kqm1*x2                          !\n      kqm1=kqm1*x2                               !\n   else\n      xi=1/x                                     ! xmin < x , xmax\n      lx=log(x)                                  ! fit accurate to 0.2%\n      kqm1=c4                                    ! c0 + c1*x + c2*x^2 +\n      kqm1=c3+kqm1*x                             ! c3*x^3 + c4*x^4 +\n      kqm1=c2+kqm1*x                             ! d0*ln(x) +\n      kqm1=c1+kqm1*x                             ! d1/x + d2/x^2 +\n      kqm1=c0+kqm1*x + d0*lx                     ! d3/x^3 + d4/x^4\n      lx=d4                                      !\n      lx=d3+lx*xi                                !\n      lx=d2+lx*xi                                !\n      lx=d1+lx*xi                                !\n      lx=lx*xi                                   !\n      kqm1=kqm1+lx\n   endif\n end function kqm1\n"}, {"instruction": "Create a Fortran function named kqm3 that takes a single real input parameter and returns a real output. The input parameter type is real, and the output parameter type is also real. This function computes and returns a value based on the input parameter according to specified mathematical formulae and conditions.", "input": "", "output": " function kqm3(x)  \n   implicit none\n   real, intent(in) :: x\n   real :: kqm3\n\n   real, parameter :: xmin=0.15e0, xmax=2.5e0 \n   real, parameter :: a0= 0.1829117486761496454549449429 ! 3*gamma/4 - 1/4\n   real, parameter :: a2=-0.6010284515797971427073328102 !-zeta(3)/2\n   real, parameter :: b2=-0.0833333333333333333333333333 !-1/12\n   real, parameter :: b4=-0.025                          !-1/40\n   real, parameter :: b6=-0.046875                       !-3/64\n   real, parameter :: c0= 0.691191700599840900000\n   real, parameter :: c1=-1.094849572900974000000\n   real, parameter :: c2= 0.318264617154601400000\n   real, parameter :: c3=-0.060275957444801354000\n   real, parameter :: c4= 0.005112428730167831000\n   real, parameter :: d0= 0.835543536679762600000\n   real, parameter :: d1= 0.047821976622976340000\n   real, parameter :: d2= 0.000053594881446931025\n   real, parameter :: d3=-0.000268040997573199600\n   real, parameter :: d4= 0.000015765134162582942\n   real :: x2, lx, xi\n   if ( x .le. xmin) then                        ! x < xmin=0.15: to 0.1%\n      x2=x*x                                     ! ln(x)/2 + 3*gamma/4 -1/4\n      lx=log(x)                                  ! -[zeta(3)/2]*x^2\n      kqm3=0.5e0*lx + a0 + a2*x2                 ! \n                                                 ! \n                                                 !\n   elseif ( x .ge. xmax ) then                   ! x > xmax=2.5: to 0.25%\n      xi=1/x                                     ! -1/12*x^2 - 1/40*x^4 -\n      x2=xi*xi                                   ! 3/64*x^6\n      kqm3=b6                                    !\n      kqm3=b4 + kqm3*x2                          !\n      kqm3=b2 + kqm3*x2                          !\n      kqm3=kqm3*x2                               !\n   else\n      xi=1/x                                     ! xmin < x < xmax\n      lx=log(x)                                  ! fit accurate to 0.04%\n      kqm3=c4                                    ! c0 + c1*x + c2*x^2 +\n      kqm3=c3+kqm3*x                             ! c3*x^3 + c4*x^4 +\n      kqm3=c2+kqm3*x                             ! d0*ln(x) +\n      kqm3=c1+kqm3*x                             ! d1/x + d2/x^2 +\n      kqm3=c0+kqm3*x + d0*lx                     ! d3/x^3 + d4/x^4\n      lx=d4                                      !\n      lx=d3+lx*xi                                !\n      lx=d2+lx*xi                                !\n      lx=d1+lx*xi                                !\n      lx=lx*xi                                   !\n      kqm3=kqm3+lx\n   endif\n end function kqm3\n"}, {"instruction": "Create a Fortran function named assert_eq4 to compare four integer values with a given tag. The function takes 5 input parameters of type character(len=*), integer, integer, integer, and integer, and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction assert_eq4(n1,n2,n3,n4,string)\n\tcharacter(len=*), intent(in) :: string\n\tinteger, intent(in) :: n1,n2,n3,n4\n\tinteger :: assert_eq4\n\tif (n1 == n2 .and. n2 == n3 .and. n3 == n4) then\n\t\tassert_eq4=n1\n\telse\n\t\twrite (*,*) 'nrerror: an assert_eq failed with this tag:', &\n\t\t\tstring\n\t\tstop 'program terminated by assert_eq4'\n\tend if\n\tend function assert_eq4\n"}, {"instruction": "Create a Fortran function named ran2 that generates random numbers using the input integer seed idum. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input parameter should be a seed for the random number generator, and the output parameter will be a random number between 0 and 1.", "input": "", "output": "      function ran2(idum)\n!---------------------------------------------------------------------\n\n!  name\n!  parameters:\n!       idum       : random seed\n!---------------------------------------------------------------------\n      implicit none\n\n      real :: ran2\n      integer, intent(inout) :: idum\n      integer, parameter :: im1=2147483563, im2=2147483399, imm1=im1-1\n      integer, parameter :: ia1=40014, ia2=40692, iq1=53668, iq2=52774\n      integer, parameter :: ir1=12211, ir2=3791, ntab=32, ndiv=1+imm1/ntab\n      real, parameter :: am=1./im1, eps=1.2e-7, rnmx=1.-eps\n      integer :: idum2=123456789, iy=0, j, k\n      integer, dimension(ntab) :: iv\n      \n      save iv,iy,idum2\n\n\n      do j=1,ntab\n        iv(j)=0\n      enddo\n\n      if(idum.le.0) then\n        idum=max(-idum,1)\n        idum2=idum\n        do j=ntab+8,1,-1\n          k=idum/iq1\n          idum=ia1*(idum-k*iq1)-k*ir1\n          if(idum.lt.0) idum=idum+im1\n          if(j.le.ntab) iv(j)=idum\n        enddo\n        iy=iv(1)\n      endif\n      k=idum/iq1\n      idum=ia1*(idum-k*iq1)-k*ir1\n      if(idum.lt.0) idum=idum+im1\n      k=idum2/iq2\n      idum2=ia2*(idum2-k*iq2)-k*ir2\n      if(idum2.lt.0) idum2=idum2+im2\n      j=1+iy/ndiv\n      iy=iv(j)-idum2\n      iv(j)=idum\n      if(iy.lt.1) iy=iy+imm1\n      ran2=min(am*iy,rnmx)\n      \n      end function ran2\n"}, {"instruction": "Write a Fortran function named upcase to convert a given input string to uppercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(string)).", "input": "", "output": "  function upcase(string) result(upper)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: upper\n    integer :: j\n    do j = 1,len(string)\n       if(string(j:j) >= \"a\" .and. string(j:j) <= \"z\") then\n          upper(j:j) = achar(iachar(string(j:j)) - 32)\n       else\n          upper(j:j) = string(j:j)\n       end if\n    end do\n  end function upcase\n"}, {"instruction": "Create a Fortran function named get_npelec that takes two integer input parameters, ntheta and nel. This function returns an integer output parameter. The function calculates the value of get_npelec as 2 times ntheta divided by nel divided by 3.", "input": "", "output": "function get_npelec(ntheta, nel)\n  integer, intent(in) :: ntheta, nel\n  integer :: get_npelec\n\n  get_npelec = 2*ntheta/nel/3\n  return\nend function get_npelec\n"}, {"instruction": "Create a Fortran pure function named is_atof to determine if a given string represents a valid floating-point number. The function takes 1 input argument of type character(len=*), and returns 1 output argument of type logical.", "input": "", "output": "  pure function is_atof(str) result(yes)\n    implicit none\n    character(len=*), intent(in) :: str\n    logical :: yes\n    !local variables\n    integer :: ierr,is,ie\n    double precision :: rval\n\n    ie=len_trim(str)\n    is=scan(trim(str),' ')+1\n    yes=scan(str(is:ie),' ') ==0 !there is no other space in the string\n    if (yes) then\n       read(str(is:ie),*,iostat=ierr)rval\n       yes=ierr==0 .and. str(max(ie,1):ie)/='/' !the slash terminator is not allowed\n    end if\n\n  end function is_atof\n"}, {"instruction": "Write a Fortran pure function named is_atol that takes a single input argument of type character(len=*) and returns a logical output. The function checks if the input string represents a logical value and returns true if the string is 'yes', 'no', 'true', or 'false', and false otherwise.", "input": "", "output": "  pure function is_atol(str) result(yes)\n    implicit none\n    character(len=*), intent(in) :: str\n    logical :: yes\n    !local variables\n    integer :: is,ie\n    !fill the string describing the format to be used for reading\n\n    ie=len(trim(str))\n    is=max(scan(trim(str),' '),1)\n    yes=scan(str(is:ie),' ') ==0 !there is no other space in the string\n    if (yes) yes= (ie-is+1==3 .and. any(str(is:ie) == ['yes', 'yes', 'yes'])) &\n       &     .or. (ie-is+1==2 .and. any(str(is:ie) == ['no', 'no', 'no'])) &\n       &     .or. (ie-is+1==4 .and. any(str(is:ie) == ['true', 'true', 'true'])) &\n       &     .or. (ie-is+1==5 .and. any(str(is:ie) == ['false', 'false', 'false']))\n  end function is_atol\n"}, {"instruction": "Create a Fortran function named case_insensitive_equiv to compare two input strings for case-insensitive equivalence. The function should take 2 input parameters of type character with varying length and return 1 output parameter of type logical.", "input": "", "output": "  pure function case_insensitive_equiv(stra,strb)\n    implicit none\n    character(len=*), intent(in) :: stra,strb\n    logical :: case_insensitive_equiv\n    !local variables\n    integer :: i,ica,icb,ila,ilb,ilength\n    ila=len(stra)\n    ilb=len(strb)\n    ilength=min(ila,ilb)\n    ica=ichar(stra(1:1))\n    icb=ichar(strb(1:1))\n    case_insensitive_equiv=(modulo(ica-icb,32) == 0) .and. (ila==ilb)\n    do i=2,ilength\n       ica=ichar(stra(i:i))\n       icb=ichar(strb(i:i))\n       case_insensitive_equiv=case_insensitive_equiv .and. &\n            &   (modulo(ica-icb,32) == 0)\n       if (.not. case_insensitive_equiv) exit\n    end do\n\n  end function case_insensitive_equiv\n"}, {"instruction": "Write a Fortran function named combine_strings to combine two input strings into a single output string. The number of input parameters is 2, with test_data types of ['character(len=*)', 'character(len=*)']. The number of output parameters is 1, with a test_data type of ['character(len=len_trim(a)+len_trim(b))'].", "input": "", "output": "  pure function combine_strings(a,b) result(c)\n    implicit none\n    character(len=*), intent(in) :: a\n    character(len=*), intent(in) :: b\n    character(len=len_trim(a)+len_trim(b)) :: c\n    c=trim(a)//trim(adjustl(b))\n  end function combine_strings\n"}, {"instruction": "Create a Fortran function named add_two_big_nums that takes two character strings as input parameters. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The function returns a single character string as output, with the test_data type of ['character(len=:), allocatable']. The function is designed to add two large numbers represented as character strings and return the result as a character string.", "input": "", "output": "  pure function add_two_big_nums(a,b)\n    ! default\n    implicit none\n\n    ! local parameters\n    integer(4), parameter :: i_max    = int(log10(1d0*huge(int(1,kind=4))/10))-1\n    integer(4), parameter :: i_max_10 = 10**(i_max)\n\n    character(*), intent(in) :: a,b\n    character(len=:), allocatable :: add_two_big_nums\n\n    ! local variables\n    integer(4)     :: i,i1,i2,j,idx\n    integer(4)     :: carry,n_words,temp\n    integer(4)     :: a_size,b_size,o_size\n    integer(4)     :: a_words,b_words,o_words\n    logical        :: include_pad\n    character(11)  :: zero_pad\n    character(100) :: read_tag,write_tag\n\n    ! local arrays\n    integer(4), dimension(:), allocatable :: a_int,b_int,o_int\n\n    ! find the number of digits of the numbers\n    a_size = len_trim(a)\n    b_size = len_trim(b)\n\n    ! determine how many words we need\n    a_words = ceiling(1d0*a_size/i_max)\n    b_words = ceiling(1d0*b_size/i_max)\n    o_words = a_words+b_words\n\n    ! allocate necessary arrays\n    allocate(a_int(o_words))\n    allocate(b_int(o_words))\n    allocate(o_int(o_words))\n\n    ! initialize\n    a_int = 0\n    b_int = 0\n    o_int = 0\n\n    ! break the inputs into words\n    ! we actually store the numbers backwards in our arrays\n    n_words = 1 + a_size/i_max\n    write(read_tag,'(a,i12,a)') '(i',i_max,')'\n    do i=1,n_words\n       i1 = max(a_size - i*i_max + 1, 1)\n       i2 = a_size - (i-1)*i_max\n       read(a(i1:i2),trim(read_tag)) a_int(i)\n    enddo\n\n    n_words = 1 + b_size/i_max\n    do i=1,n_words\n       i1 = max(b_size - i*i_max + 1,1)\n       i2 = b_size - (i-1)*i_max\n       read(b(i1:i2),trim(read_tag)) b_int(i)\n    enddo\n\n    ! add the numbers together one word at a time, and carry the results\n    carry = 0\n    do i=1,o_words\n       temp = a_int(i) + b_int(i) + carry\n       ! only save the amount that will fit in i_max digits\n       o_int(i) = mod(temp,i_max_10)\n       ! carry the rest\n       carry = temp/i_max_10\n    enddo\n\n    ! determine the final number of digits that we need to save our number\n    ! first check to see if we over-allocated the number of words needed\n    do while (o_int(o_words) == 0)\n       o_words = o_words - 1\n    enddo\n    o_size = 1 + int(log10(1d0*o_int(o_words))) + i_max*(o_words-1)\n\n    allocate(character(len=o_size) :: add_two_big_nums)\n\n    ! write out the answer\n    write(write_tag,'(a,i11,a)') '(i',i_max,')'\n\n    ! we actually go from right-to-left, since the big number is stored in\n    !   the array as \"little-endian\" but we read the number as \"big-endian\"\n    do i=1,o_words\n       ! find the bounds of this segment\n       i1 = max(o_size - i*i_max + 1, 1)\n       i2 = o_size - (i-1)*i_max\n\n       ! find the size of the write tag to make\n       ! first, test to see if the segment is all zeros\n       if (o_int(i)==0) then\n          do idx=1,i_max\n             write(zero_pad(idx:idx),'(a)') '0'\n          enddo\n          write(write_tag,'(a,i11,a)') '(a',i_max,')'\n          write(add_two_big_nums(i1:i2),write_tag) trim(zero_pad)\n          cycle\n       endif \n\n       ! now check to see if we need to pad with leading zeros\n       include_pad = .false.\n       do j=1,i2-i1\n          ! test to see if segment needs leading zeros\n          if (mod(o_int(i),10**j)==o_int(i)) then\n             include_pad = .true.\n             write(write_tag,'(a,i11,a,i11,a)') '(a',i2-i1-j+1,',i',j,')'\n             do idx=1,i2-j+1\n                write(zero_pad(idx:idx),'(a)') '0'\n             enddo\n             exit\n          endif\n       enddo\n\n       if (include_pad) then\n          write(add_two_big_nums(i1:i2),write_tag) trim(zero_pad),o_int(i)\n       else\n          write(write_tag,'(a,i11,a)') '(i',i2-i1+1,')'\n          write(add_two_big_nums(i1:i2),write_tag) o_int(i)\n       endif\n    enddo\n\n    return\n  end function add_two_big_nums\n"}, {"instruction": "Create a Fortran function named ichoice to generate a random integer between 0 and n-1. The number of input parameters is 1 with the test_data type ['integer'], and the number of output parameters is 1 with the test_data type ['integer'].", "input": "", "output": "  function ichoice(n)\n    !-------------------------------------------\n    !\n    !-------------------------------------------\n    integer,intent(in)::n\n    integer           ::ichoice\n    real*8::rng\n    call random_number(rng)\n    ichoice = int(rng*n)\n  end function ichoice\n"}, {"instruction": "Write a Fortran function named func_apod_filter to calculate the apodization function value for a given input based on apodization parameter and filter cutoff frequency. The function accepts 3 input parameters of type real*8: x, apod, and filter_df. The output parameter is a single real*8 value. If x is less than filter_df, the function computes 1 - apod and returns the result as func_apod_filter.", "input": "", "output": "  function func_apod_filter(x, apod, filter_df)\n\n    real*8 :: func_apod_filter, x, apod, filter_df\n\n    func_apod_filter = 0\n    if (x < filter_df) then\n      func_apod_filter = 1 - apod\n    end if\n\n  end function func_apod_filter\n"}, {"instruction": "Provide a Fortran function named factorial_f that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use recursive calls to calculate the factorial.", "input": "", "output": "    recursive function factorial_f(i) result(answer)\n        integer             :: answer\n        integer, intent(in) :: i\n\n        if (i == 0) then\n            answer = 1\n        else\n            answer = i * factorial_f(i - 1)\n        end if\n    end function factorial_f\n"}, {"instruction": "Create a Fortran function named count_divisors to calculate the number of divisors of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is labeled as intent(in).", "input": "", "output": "function count_divisors(number)\n        implicit none\n        integer, intent(in) :: number\n        integer :: count_divisors\n        integer :: i\n\n        count_divisors = 1\n        do i = 2, number / 2\n            if (mod(number, i) == 0) then\n                count_divisors = count_divisors + 1\n            end if\n        end do\n\n        count_divisors = count_divisors + 1\n        \n    end function count_divisors\n"}, {"instruction": "Create a Fortran function named initialvelocity that takes two real(kind=8) input parameters, normalizedgravity and moonsemimajoraxis. It returns a single real(kind=8) output parameter. The function computes the initial velocity required for a spacecraft in a circular orbit around the moon, using the formula initialvelocity = sqrt(normalizedgravity / moonsemimajoraxis).", "input": "", "output": "function initialvelocity(normalizedgravity, moonsemimajoraxis)\n\timplicit none\n\n\treal(kind = 8), intent(in) :: normalizedgravity\n\treal(kind = 8), intent(in) :: moonsemimajoraxis\n\treal(kind = 8) :: initialvelocity\n\n\tinitialvelocity = sqrt(normalizedgravity / moonsemimajoraxis)\n\n\treturn\nend function\n"}, {"instruction": "Create a Fortran function named sigm that takes a double precision input argument and returns a double precision value. The input parameter type is ['double precision'] and the output parameter type is ['double precision']. The function calculates the value of the sigmoid function using the formula sigm = 5/(1 + exp(0.56*(6-x))).", "input": "", "output": "      function sigm(x)\n!----------------------------------------\n\n!----------------------------------------\n      implicit none\n      double precision :: sigm, x\n      sigm = 5/(1 + exp(0.56*(6-x)))\n      return\n      end function sigm\n"}, {"instruction": "Create a Fortran function named leap_year to determine if the given year is a leap year. The function takes 1 input argument of type integer and returns 1 output argument of type logical. The input test_data type is ['integer'], and the output test_data type is ['logical'].", "input": "", "output": "pure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n \n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n \nend function leap_year\n"}, {"instruction": "Write a Fortran function named blmetric_con_real to calculate the Boyer-Lindquist covariant metric components. The function takes 4 input parameters: r (real, dimension(:)), th (real, dimension(:)), a (real), and con (integer). The output parameter is blmetric (real, dimension(size(r),10)).", "input": "", "output": "        function blmetric_con_real(r,th,a,con) result(blmetric)\n        ! returns boyer-lindquist covariant metric components\n        ! jad 10/1/2008, fortran 3/28/2011\n        real, dimension(:), intent(in) :: r,th\n        real, intent(in) :: a\n        integer, intent(in) :: con\n        real, dimension(size(r),10) :: blmetric\n!        real, dimension(10,size(r)) :: gmunu\n        real, dimension(size(r)) :: cth,sth,delta, &\n        rho2,sigma\n        cth=cos(th); sth=sin(th)\n        delta=r*r-2.*r+a*a\n        rho2=r*r+a*a*cth*cth\n        sigma=(r*r+a*a)**2-a*a*delta*sth*sth\n        blmetric=0d0\n        blmetric(:,1)=-((r*r+a*a)**2-a*a*delta*sth*sth)/rho2/delta\n        blmetric(:,4)=-2*a*r/rho2/delta\n        blmetric(:,5)=delta/rho2\n        blmetric(:,8)=1./rho2\n        blmetric(:,10)=(delta-a*a*sth*sth)/delta/rho2/sth/sth\n!        gmunu=transpose(blmetric)\n        end function blmetric_con_real\n"}, {"instruction": "Create a Fortran function named ksmetric_cov to calculate the Boyer-Lindquist covariant metric components. The function takes 4 input arguments of type real(8) arrays: r, th, ph, and a. It returns 1 output argument of type real(8) array with dimensions size(r) by 10.", "input": "", "output": "        function ksmetric_cov(r,th,ph,a) result(ksmetric)\n        ! returns boyer-lindquist covariant metric components\n        ! jad 10/1/2008, fortran 3/28/2011\n        ! doesn't actually depend on ph unless you're doing tilted metric!\n        real(8), dimension(:), intent(in) :: r,th,ph\n        real(8), intent(in) :: a\n        real(8), dimension(size(r),10) :: ksmetric\n        real(8), dimension(size(r)) :: ctheta,stheta,rho2,psi4\n        ctheta=cos(th); stheta=sin(th)\n        rho2=r**2+a**2*ctheta**2\n        psi4=2d0*r/rho2\n        ksmetric=0.\n        ksmetric(:,1)=-(1.-psi4)\n        ksmetric(:,2)=psi4\n        ksmetric(:,4)=-a*stheta**2*psi4\n        ksmetric(:,5)=1.+psi4\n        ksmetric(:,7)=-a*stheta**2*(1.+psi4)\n        ksmetric(:,8)=rho2\n        ksmetric(:,10)=stheta**2*(rho2+a**2*(1.+2d0*r/rho2)*stheta**2)\n!        write(6,*) 'ksmetric kerr: ',ksmetric(1,:)\n      end function ksmetric_cov\n"}, {"instruction": "Create a Fortran function named \"mnt_ncattributes_del\" to delete attributes associated with a netCDF field. The function takes 1 input parameter of type \"type(c_ptr)\" and returns 1 output parameter of type \"integer(c_int)\".", "input": "", "output": "    function mnt_ncattributes_del(obj) &\r\n                                  bind(c, name='mnt_ncattributes_del')\r\n      ! destructor\r\n      ! @param obj instance of mntncfieldread_t (opaque handle)\r\n      ! @return 0 if successful\r\n      use, intrinsic :: iso_c_binding, only: c_int, c_double, c_ptr\r\n      implicit none\r\n      type(c_ptr), intent(inout)       :: obj ! void**\r\n      integer(c_int)                   :: mnt_ncattributes_del\r\n    end function mnt_ncattributes_del\r\n"}, {"instruction": "Create a Fortran function named c_conduit_blueprint_table_verify to verify a blueprint table. The function takes 2 input parameters of type 'type(c_ptr), value' and returns 1 output parameter of type 'logical(c_bool)'.", "input": "", "output": "        function c_conduit_blueprint_table_verify(cnode, cinfo) result(res) &\n                bind(c, name=\"conduit_blueprint_table_verify\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value, intent(in) :: cnode\n            type(c_ptr), value, intent(in) :: cinfo\n            logical(c_bool) ::res\n        end function c_conduit_blueprint_table_verify\n"}, {"instruction": "Write a Fortran function named linear_int to calculate the distance between two points in a linear interval. The function takes 3 input arguments of type real, representing the values a, b, and delta. It returns 1 output argument of type real.", "input": "", "output": " function linear_int(a,b,delta) result(dist)\n\n   real, intent(in) :: a,b,delta\n   real :: dist\n\n   dist = delta/(1.+abs(b)/abs(a))\n   \n   return\n end function linear_int\n"}, {"instruction": "Write a Fortran function called minmod to calculate the minimum of two real numbers. This function takes 2 input arguments of type real and returns 1 output argument of type real. If the product of the input numbers is greater than 0, the function returns the smaller of the two input numbers. If the product is less than or equal to 0, the function returns 0.", "input": "", "output": " function minmod(a,b) result(mm)\n\n   real, intent(in) :: a,b\n   real :: a1,b1,ab, mm\n\n   a1 = abs(a)\n   b1 = abs(b)\n   ab = a*b\n   \n   if (ab .gt. 0.) then\n      if (a1 .le. b1) then\n         mm = a\n      else\n         mm = b\n      endif\n   else\n      mm = 0.\n   endif\n   \n   return\n end function minmod\n"}, {"instruction": "Create a Fortran function named minabs that takes two real numbers as input arguments and returns the minimum absolute value of the two inputs as the output. The number of input arguments is 2 and the test_data type is [real, real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": " function minabs(a,b) result(mm)\n\n   real, intent(in) :: a,b\n   real :: a1,b1, mm\n\n   a1 = abs(a)\n   b1 = abs(b)\n   \n   if (a1 .lt. b1) then\n      mm = a\n   else\n      mm = b\n   endif\n   \n   return\n end function minabs\n"}, {"instruction": "Provide a Fortran function named timeincrement that takes an integer input argument and returns a character string. The number of input arguments is 1 with the test_data type being ['integer'], and the number of output arguments is 1 with the test_data type being ['character(20)'].", "input": "", "output": "  function timeincrement(isec) result(template)\n    implicit none\n\n    integer       :: isec\n    character(20) :: template\n\n    character(18):: tmp\n    !---------------------------------------------------------------------------\n\n    write(tmp,*) max(isec/60, 1)\n\n    template = trim(tmp)//'mn'\n\n  end function timeincrement\n"}, {"instruction": "Create a Fortran function called upcase to convert a given string to uppercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(s)). The input parameter should be a string, and the output is the same string in uppercase.", "input": "", "output": "function upcase(s) result(t)\n! returns string 's' in uppercase\ncharacter(*), intent(in) :: s\ncharacter(len(s)) :: t\ninteger :: i, diff\nt = s; diff = ichar('a')-ichar('a')\ndo i = 1, len(t)\n    if (ichar(t(i:i)) >= ichar('a') .and. ichar(t(i:i)) <= ichar('z')) then\n        ! if lowercase, make uppercase\n        t(i:i) = char(ichar(t(i:i)) + diff)\n    end if\nend do\nend function\n"}, {"instruction": "Write a Fortran function named \"compute\" that calculates the sum of two double-precision floating-point numbers. The function should have 2 input parameters of type double precision, and the test_data type is ['double precision', 'double precision']. It should also have 1 output parameter of type double precision, with the test_data type being ['double precision'].", "input": "", "output": "  function compute(x, y) result (z)\n\n    double precision :: x, y, z\n\n    min_value = min(x,y)\n    z = x + y\n\n    return\n  end function compute\n"}, {"instruction": "Write a Fortran function named d_nso2nn that converts a one-electron Hamiltonian matrix from a spin-orbit basis to a spin basis. The function takes 3 input parameters: nspin (integer), norb (integer), and hso (real(8) matrix of dimension nspin*norb x nspin*norb). It returns a single output parameter hnn (real(8) matrix of dimension nspin x nspin x norb x norb).", "input": "", "output": "  function d_nso2nn(hso,nspin,norb) result(hnn)\n    integer                                  :: nspin,norb\n    real(8),dimension(nspin*norb,nspin*norb) :: hso\n    real(8),dimension(nspin,nspin,norb,norb) :: hnn\n    integer                                  :: iorb,ispin,is\n    integer                                  :: jorb,jspin,js\n    hnn=zero\n    do ispin=1,nspin\n       do jspin=1,nspin\n          do iorb=1,norb\n             do jorb=1,norb\n                is = iorb + (ispin-1)*norb  !spin-orbit stride\n                js = jorb + (jspin-1)*norb  !spin-orbit stride\n                hnn(ispin,jspin,iorb,jorb) = hso(is,js)\n             enddo\n          enddo\n       enddo\n    enddo\n  end function d_nso2nn\n"}, {"instruction": "Create a Fortran function named uf_find to implement the union-find find algorithm. The function takes 2 input parameters with test_data type ['integer', 'integer, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "        function uf_find(x, labels) result(y)\n            !! union-find find algorithm:\n            !! find the lowest corresponding label.\n            !! relabelling is done when necessary.\n            integer, intent(in) :: x\n                !! label for which to find the lowest corresponding label.\n            integer, dimension(:), intent(inout) :: labels\n                !! list of labels. **labels(i)** points to the lowest\n                !! corresponding label of label **i**.\n            integer :: y, z, tmp\n\n            y = x\n            do while(labels(y) /= y)\n                y = labels(y)\n            end do\n\n            tmp = x\n            do while(labels(tmp) /= tmp)\n                z = labels(tmp)\n                labels(tmp) = y\n                tmp = z\n            end do\n        end function\n"}, {"instruction": "Write a Fortran function named distancesquared_capturezone to compute the distance squared between points A and C in relation to line segment AB. The number of input arguments is 6, and the test_data type is ['real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 1, and the test_data type is ['real(8)'].", "input": "", "output": "   function distancesquared_capturezone( ax, ay, bx, by, cx, cy ) result( d2 )\n\n   ! declare the arguments.\n   real(8), intent(in) :: ax, ay, bx, by, cx, cy\n   real(8)             :: d2\n\n   ! declare the local variables.\n   real(8) :: bax, bay, cax, cay\n   real(8) :: perpdot, dot\n   real(8) :: length2, alpha2, beta2\n\n   ! compute the distance squared.\n   bax = bx - ax\n   bay = by - ay\n\n   cax = cx - ax\n   cay = cy - ay\n\n   perpdot = bax*cay - bay*cax\n   dot     = bax*cax + bay*cay\n   length2 = bax*bax + bay*bay\n\n   alpha2  = perpdot*perpdot / length2\n   beta2   = dot*dot / length2\n\n   if( dot < 0 ) then\n      d2 = alpha2 + beta2\n   else if( beta2 > length2 ) then\n      d2 = alpha2 + beta2 - 2*dot + length2\n   else\n      d2 = alpha2\n   end if\n\n   end function distancesquared_capturezone\n"}, {"instruction": "Create a Fortran pure function named tostr that takes an integer input and returns a string representation of the integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=20)'].", "input": "", "output": "          pure function tostr(k) result(str)\n              integer, intent(in) :: k\n              character(len=20) :: str\n\n              write(str, *) k\n              str = adjustl(str)\n          end function tostr\n"}, {"instruction": "Create a Fortran function named f that calculates a mathematical function. The function takes 1 input parameter of real type and returns 1 output parameter of real type. The input and output test_data types are ['real'].", "input": "", "output": "function f(x)\nimplicit none\nreal :: x, f\nf = (x**2) - (2*x) + 1\n! f = (x**3) + (3*(x**2)) + (3*x) + 1\n! f = x-exp(-x/3)\nend function\n"}, {"instruction": "Create a Fortran function named near to compute the corrected distance between points. The function takes 2 input arguments with test_data type [real*8, real*8] and returns 1 output argument with test_data type [real*8]. This function corrects for wrap-around when evaluating distances between points. Use imperative tone in the instructions.", "input": "", "output": "function near(dist,domain)\n\n! to correct for wrap-around when evaluating distances\n! between points\n\nimplicit none\nreal*8, intent(in) :: dist, domain\nreal*8 :: near\nreal*8 :: hdom\n\nhdom = 0.5*domain\nnear = dist\nif (dist .ge.  hdom) near = near - domain\nif (dist .le. -hdom) near = near + domain\n\nend function near\n"}, {"instruction": "Create a Fortran function named byte_pos that takes an integer input argument and returns the position of the next record in bytes. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function byte_pos(uni)\r\n  integer:: byte_pos\r\n  integer, intent(in):: uni\r\n  integer:: i\r\n!  inquire(uni, pos= i )                    !##g95##\r\n  inquire(uni, nextrec= i )               !##lf95##\r\n  byte_pos = i\r\nend function byte_pos\r\n"}, {"instruction": "Create a Fortran function named cloud_top_pressure to calculate the extinction-weighted pressure based on the given arrays of tauincrement and pressure, and the specified taulimit. The function has 3 input parameters of type real, dimension(:), real, dimension(:), and real, and 1 output parameter of type real.", "input": "", "output": "  function cloud_top_pressure(tauincrement, pressure, taulimit) \n    real, dimension(:), intent(in) :: tauincrement, pressure\n    real,               intent(in) :: taulimit\n    real                           :: cloud_top_pressure\n    !\n    ! find the extinction-weighted pressure. assume that pressure varies linearly between \n    !   layers and use the trapezoidal rule.\n    !\n    \n    real :: deltax, totaltau, totalproduct\n    integer :: i \n    \n    totaltau = 0.; totalproduct = 0. \n    do i = 2, size(tauincrement)\n      if(totaltau + tauincrement(i) > taulimit) then \n        deltax = taulimit - totaltau\n        totaltau = totaltau + deltax\n        !\n        ! result for trapezoidal rule when you take less than a full step\n        !   tauincrement is a layer-integrated value\n        !\n        totalproduct = totalproduct           &\n                     + pressure(i-1) * deltax &\n                     + (pressure(i) - pressure(i-1)) * deltax**2/(2. * tauincrement(i)) \n\n!bloss: i think the code below has an extra factor of deltax after the plus sign.\n!bloss    the above code is taken from cosp v1.4, where this seems to have been fixed.\n!bloss        totalproduct = totalproduct + &\n!bloss                       deltax * ((pressure(i) - pressure(i-1)) * deltax**2/(2. * tauincrement(i)) + &\n!bloss                                 pressure(i-1) * deltax)\n      else\n        totaltau =     totaltau     + tauincrement(i) \n        totalproduct = totalproduct + tauincrement(i) * (pressure(i) + pressure(i-1)) / 2.\n      end if \n      if(totaltau >= taulimit) exit\n    end do \n    cloud_top_pressure = totalproduct/totaltau\n  end function cloud_top_pressure\n"}, {"instruction": "Create a Fortran function named weight_by_extinction to calculate the extinction-weighted value of f(tau) with the given parameters. The function takes 3 input arguments: two real arrays of any size (tauincrement, f) and a single real value (taulimit). The function returns a single real value as the output.", "input": "", "output": "  function weight_by_extinction(tauincrement, f, taulimit) \n    real, dimension(:), intent(in) :: tauincrement, f\n    real,               intent(in) :: taulimit\n    real                           :: weight_by_extinction\n    !\n    ! find the extinction-weighted value of f(tau), assuming constant f within each layer\n    !\n    \n    real    :: deltax, totaltau, totalproduct\n    integer :: i \n    \n    totaltau = 0.; totalproduct = 0. \n    do i = 1, size(tauincrement)\n      if(totaltau + tauincrement(i) > taulimit) then \n        deltax       = taulimit - totaltau\n        totaltau     = totaltau     + deltax\n        totalproduct = totalproduct + deltax * f(i) \n      else\n        totaltau     = totaltau     + tauincrement(i) \n        totalproduct = totalproduct + tauincrement(i) * f(i) \n      end if \n      if(totaltau >= taulimit) exit\n    end do \n    weight_by_extinction = totalproduct/totaltau\n  end function weight_by_extinction\n"}, {"instruction": "Create a Fortran pure function named interpolate_to_min. It takes 3 input parameters: x (real, dimension(:)), y (real, dimension(:)), and yobs (real). The output parameter is a real value. The function finds the value of x that minimizes the absolute difference between y and yobs. The input arrays x and y are assumed to be monotonic.", "input": "", "output": "  pure function interpolate_to_min(x, y, yobs)\n    real, dimension(:), intent(in) :: x, y \n    real,               intent(in) :: yobs\n    real                           :: interpolate_to_min\n    ! \n    ! given a set of values of y as y(x), find the value of x that minimizes abs(y - yobs)\n    !   y must be monotonic in x\n    !\n    real, dimension(size(x)) :: diff\n    real                     :: weight\n    integer                  :: npoints, mindiffloc, lowerbound, upperbound\n    ! ---------------------------------\n    npoints = size(y)\n    diff(:) = y(:) - yobs\n    mindiffloc = minloc(abs(diff), dim = 1) \n    \n    if(mindiffloc == 1) then \n      lowerbound = mindiffloc\n      upperbound = mindiffloc + 1\n    else if(mindiffloc == npoints) then\n      lowerbound = mindiffloc - 1\n      upperbound = mindiffloc\n    else\n      if(diff(mindiffloc-1) * diff(mindiffloc) < 0) then\n        lowerbound = mindiffloc-1\n        upperbound = mindiffloc\n      else \n        lowerbound = mindiffloc\n        upperbound = mindiffloc + 1\n      end if \n    end if \n    \n    if(diff(lowerbound) * diff(upperbound) < 0) then     \n      !\n      ! interpolate the root position linearly if we bracket the root\n      !\n      interpolate_to_min = x(upperbound) - & \n                           diff(upperbound) * (x(upperbound) - x(lowerbound)) / (diff(upperbound) - diff(lowerbound))\n    else \n      interpolate_to_min = re_fill\n    end if \n    \n\n  end function interpolate_to_min\n"}, {"instruction": "Create a Fortran function named replace_text that replaces occurrences of a specific text within a given string with another specified text. The number of input arguments is 3 with test_data type ['character(*)', 'character(*)', 'character(*)'], and the number of output arguments is 1 with test_data type ['character(len(s)+100)'].", "input": "", "output": "\tfunction replace_text (s,text,rep)  result(outs)\n\t\tcharacter(*)        :: s,text,rep\n\t\tcharacter(len(s)+100) :: outs     ! provide outs with extra 100 char len\n\t\tinteger             :: i, nt, nr\n\n\t\touts = s ; nt = len_trim(text) ; nr = len_trim(rep)\n\t\tdo\n\t\t   i = index(outs,text(:nt)) ; if (i == 0) exit\n\t\t   outs = outs(:i-1) // rep(:nr) // outs(i+nt:)\n\t\tend do\n\tend function replace_text\n"}, {"instruction": "Write a Fortran function named strupper to convert a given input string to uppercase. The function should take 1 input parameter of type character(*) and return 1 output parameter of type character(len(s1)).", "input": "", "output": "\tfunction strupper(s1)  result (s2)\n\t\timplicit none\n\t\tcharacter(*)       :: s1\n\t\tcharacter(len(s1)) :: s2\n\t\tcharacter          :: ch\n\t\tinteger,parameter  :: duc = ichar('a') - ichar('a')\n\t\tinteger            :: i\n\n\t\tdo i = 1,len(s1)\n\t\t   ch = s1(i:i)\n\t\t   if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)+duc)\n\t\t   s2(i:i) = ch\n\t\tend do\n\tend function strupper\n"}, {"instruction": "Create a Fortran function named strlower that takes a single input argument of type character(*) and returns a single output argument of type character(len(s1)). The function converts all characters in the input string to lowercase and returns the modified string.", "input": "", "output": "\tfunction strlower(s1)  result (s2)\n\t\timplicit none\n\t\tcharacter(*)       :: s1\n\t\tcharacter(len(s1)) :: s2\n\t\tcharacter          :: ch\n\t\tinteger,parameter  :: duc = ichar('a') - ichar('a')\n\t\tinteger            :: i\n\n\t\tdo i = 1,len(s1)\n\t\t   ch = s1(i:i)\n\t\t   if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)-duc)\n\t\t   s2(i:i) = ch\n\t\tend do\n\tend function strlower\n"}, {"instruction": "Create a Fortran function named rm_char that removes a specified character from a given string. The function takes 2 input parameters: in_str of type character(*) and target_char of type character. It returns 1 output parameter: out_str of type character(:), allocatable.", "input": "", "output": "      function rm_char(in_str, target_char) result(out_str)\n\n      character(*), intent(in) :: in_str\n\n      character :: target_char\n\n      character(:), allocatable :: out_str\n\n      character :: ch\n\n      integer :: j\n\n      out_str = ' '\n\n      do j = 1, len_trim(in_str)\n\n         ch = in_str(j : j)\n\n         if (ch .ne. target_char) out_str = trim(out_str) // ch\n\n      enddo\n\n      out_str = trim(adjustl(out_str))\n\n      return\n\n      end function rm_char\n"}, {"instruction": "Create a Fortran function named y that takes a real number as input and returns a real number as output. The function calculates the value of y using the formula y = 5*x^3 + 2*x^2 - 3*x.", "input": "", "output": "function y(x)   !defining algebric function\r\n    implicit none\r\n    real :: y   !dummy argument\r\n    real :: x   !local variable\r\n    y=5*(x**3)+2*(x**2)-3*x\nend function\r\n"}, {"instruction": "Create a Fortran function named ddy to calculate the second derivative of a given algebraic function. The function takes 1 input parameter of type real, and returns 1 output parameter of type real.", "input": "", "output": "function ddy(x) !second derivative of above algebric function\r\n    implicit none\r\n    real :: ddy   !dummy argument\r\n    real :: x   !local variable\r\n    ddy=30*x+4\nend function\r\n"}, {"instruction": "Create a Fortran function named simpson, which uses Simpson's rule to compute the definite integral of a set of data points. The function takes 3 input parameters: an integer n, and two arrays x and y of type real(kind=dp) and dimension n. It returns a real(kind=dp) value as the result of the integration.", "input": "", "output": "        function simpson(x,y,n)\n                implicit none\n                integer, parameter :: dp = selected_real_kind(14)\n                integer, intent(in) :: n\n                integer :: i\n                real(kind=dp) :: simpson\n                real(kind=dp), dimension(n), intent(in) :: x, y\n                real(kind=dp) :: sum, h\n\n                sum = 0.0d0\n                h = dabs(x(n) - x(1))/dfloat(n-1)\n                do i=1, n/2 ! since n is odd, n/2 is the same as (n-1)/2\n                        sum = sum + y(2*i-1) + 4.0d0*y(2*i) + y(2*i+1)\n                end do\n                simpson = sum*h/3.0d0\n        end function simpson\n"}, {"instruction": "Create a Fortran function named hpa that takes two real numbers as input parameters, a and e, both of type real(real64), and returns a single real number of type real(real64). The function computes the value of hpa based on the input parameters using a series of mathematical operations and returns the result.", "input": "", "output": "  function hpa (a, e)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64),   intent(in   ) :: e\n    real(real64)                  :: hpa\n\n    real(real64) :: aln, sha, z\n\n! ======================================================================\n\n    aln = log(a)\n    sha = 1.0663d0 - 0.0023d0*aln\n    z = log(e)\n    hpa = 0.0375d0*(z - 16.5d0) + sha*exp(-0.11d0*z)\n    return\n\n! ======================================================================\n  end function hpa\n"}, {"instruction": "Write a Fortran function named \"udel\" to calculate the value of a mathematical expression. The input parameter is of type real(real64), and the output parameter is also of type real(real64). The function should compute the result using the given formula and return the value.", "input": "", "output": "  function udel (a)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!    edited by lmk, xcp-3, july 2013 (included error protection).\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64)                  :: udel\n\n    real(real64) :: temp\n\n! ======================================================================\n\n    temp = 1.d0 + 0.003d0*a*a\n    udel = 5.82d0 - 0.07d0/(temp)\n    return\n\n! ======================================================================\n  end function udel\n"}, {"instruction": "Create a Fortran function named \"wha\" to compute a mathematical operation on a real number. The function takes 1 input parameter of type real(real64) and returns 1 output parameter of the same type. The function calculates the value using the logarithm and square root operations.", "input": "", "output": "  function wha (a)\n\n! ======================================================================\n!\n!    \"last\" change: 13-aug-2003 by nvmokhov\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic:: iso_fortran_env, only: int32, real64\n\n    implicit none\n    real(real64),   intent(in   ) :: a\n    real(real64)                  :: wha\n\n    real(real64) :: ala\n\n! ======================================================================\n\n    ala = log(a)\n    wha = 0.045d0 + 0.04d0*ala*sqrt(abs(ala))\n    return\n\n! ======================================================================\n  end function wha\n"}, {"instruction": "Create a Fortran function named phi_b that takes 4 real(8) input parameters and returns a single real(8) output parameter. The function computes a value based on the input parameters, involving mathematical operations and trigonometric functions.", "input": "", "output": "  function phi_b( r, theta, di, dj )\n    implicit none\n    real(8) :: phi_b\n    real(8),intent(in)  :: r, theta, di, dj\n    real(8) :: a,b,www,ttt !,gamma,pi\n    real(8) :: ct,st,sa,sb,ca,cb,hai,haj,hbi,hbj,vai,vaj,vbi,vbj\n    real(8) :: a2,b2,cai,cbi,caj,cbj,gdidi_i,gdjdj_i\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gamma=1.396263401595464d0\n    real(8),parameter :: thr=3.0d0\n\n!    pi = acos(-1.0d0)\n!    gamma = 4.0d0*pi/9.0d0\n\n    a = r*cos(theta)\n    b = r*sin(theta)\n\n    a2=a*a\n    b2=b*b\n\n    gdidi_i = gamma/(di*di)\n    gdjdj_i = gamma/(dj*dj)\n\n    cai = a2*gdidi_i\n    cbi = b2*gdidi_i\n    caj = a2*gdjdj_i\n    cbj = b2*gdjdj_i\n!    cai = gamma*a2/(di*di)\n!    cbi = gamma*b2/(di*di)\n!    caj = gamma*a2/(dj*dj)\n!    cbj = gamma*b2/(dj*dj)\n\n!    ct = cos(theta)\n!    st = sin(theta)\n\n!    a = r*ct\n!    b = r*st\n\n!    ca = cos(a)\n!    cb = cos(b)\n!    sa = 1.0d0 ; if ( a /= 0.0d0 ) sa=sin(a)/a\n!    sb = 1.0d0 ; if ( b /= 0.0d0 ) sb=sin(b)/b\n!    sa=sin(a)/a\n!    sb=sin(b)/b\n\n!    www = ( (thr-a2)*sa-thr*ca )*cos(b) &\n!        + ( (thr-b2)*ca + (r*r-thr)*sa )*sin(b)/b\n!    www = ( (thr-a2)*sa-thr*ca )*cb + ( (thr-b2)*ca + (r*r-thr)*sa )*sb\n!    www = (thr-a2)*cb*sa + (thr-b2)*ca*sb + (r*r-thr)*sa*sb - thr*ca*cb\n!    www = (3.0d0-a2)*cb*sa + (3.0d0-b2)*ca*sb &\n!        + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb\n!    www = 2.0d0*( (3.0d0-a2)*cb*sa + (3.0d0-b2)*ca*sb &\n!                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n!    www = 2.0d0*( (3.0d0-a*a)*cb*sa + (3.0d0-b*b)*ca*sb &\n!                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n\n!    if ( di == 0.0d0 ) then\n!       hai = 0.0d0\n!       hbi = 0.0d0\n!    else\n!       hai = 1.0d0 - exp( -gamma*(a/di)**2 )\n!       hbi = 1.0d0 - exp( -gamma*(b/di)**2 )\n!       hai = 1.0d0 - exp( -cai )\n!       hbi = 1.0d0 - exp( -cbi )\n!    end if\n!    if ( dj == 0.0d0 ) then\n!       haj = 0.0d0\n!       hbj = 0.0d0\n!    else\n!       haj = 1.0d0 - exp( -gamma*(a/dj)**2 )\n!       hbj = 1.0d0 - exp( -gamma*(b/dj)**2 )\n!       haj = 1.0d0 - exp( -caj )\n!       hbj = 1.0d0 - exp( -cbj )\n!    end if\n\n!    if ( a == 0.0d0 ) then\n!       vai = di*di/(2.0d0*gamma)\n!       vaj = dj*dj/(2.0d0*gamma)\n!    else\n!       vai = a2/(2.0d0*hai)\n!       vaj = a2/(2.0d0*haj)\n!       vai = a2/( 2.0d0-2.0d0*exp(-cai) )\n!       vaj = a2/( 2.0d0-2.0d0*exp(-caj) )\n       vai = 0.5d0*a2/( 1.0d0-exp(-cai) )\n       vaj = 0.5d0*a2/( 1.0d0-exp(-caj) )\n!       vai = a2/( 1.0d0-exp(-cai) )\n!       vaj = a2/( 1.0d0-exp(-caj) )\n!    end if\n!    if ( b == 0.0d0 ) then\n!       vbi = di*di/(2.0d0*gamma)\n!       vbj = dj*dj/(2.0d0*gamma)\n!    else\n!       vbi = b2/(2.0d0*hbi)\n!       vbj = b2/(2.0d0*hbj)\n!       vbi = b2/( 2.0d0-2.0d0*exp(-cbi) )\n!       vbj = b2/( 2.0d0-2.0d0*exp(-cbj) )\n       vbi = 0.5d0*b2/( 1.0d0-exp(-cbi) )\n       vbj = 0.5d0*b2/( 1.0d0-exp(-cbj) )\n!       vbi = b2/( 1.0d0-exp(-cbi) )\n!       vbj = b2/( 1.0d0-exp(-cbj) )\n!    end if\n\n    ttt = ( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n!    ttt = ( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n!               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n!                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n!    ttt = 0.5d0*( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n!               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n!                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n\n    ca = cos(a)\n    sa = sin(a)/a\n    www = ( (thr-a2)*sa-thr*ca )*cos(b) &\n        + ( (thr-b2)*ca + (r*r-thr)*sa )*sin(b)/b\n\n    phi_b = r*www*ttt\n\n  end function phi_b\n"}, {"instruction": "Create a Fortran function named phi_c to calculate a physical quantity. The function takes 4 input parameters of type real(8) - r, theta, di, and dj. It returns 1 output parameter of type real(8).", "input": "", "output": "  function phi_c( r, theta, di, dj )\n    implicit none\n    real(8) :: phi_c\n    real(8),intent(in)  :: r, theta, di, dj\n    real(8) :: a,b,gamma,pi,www,ttt\n    real(8) :: ct,st,sa,sb,ca,cb,hai,haj,hbi,hbj,vai,vaj,vbi,vbj\n\n    pi = acos(-1.0d0)\n    gamma = 4.0d0*pi/9.0d0\n\n    ct = cos(theta)\n    st = sin(theta)\n\n    a = r*ct\n    b = r*st\n\n    ca = cos(a)\n    cb = cos(b)\n    sa = 1.0d0 ; if ( a /= 0.0d0 ) sa=sin(a)/a\n    sb = 1.0d0 ; if ( b /= 0.0d0 ) sb=sin(b)/b\n\n    www = 2.0d0*( (3.0d0-a*a)*cb*sa + (3.0d0-b*b)*ca*sb &\n                + (r*r-3.0d0)*sa*sb - 3.0d0*ca*cb )\n\n    if ( di == 0.0d0 ) then\n       hai = 0.0d0\n       hbi = 0.0d0\n    else\n       hai = 1.0d0 - exp( -gamma*(a/di)**2 )\n       hbi = 1.0d0 - exp( -gamma*(b/di)**2 )\n    end if\n    if ( dj == 0.0d0 ) then\n       haj = 0.0d0\n       hbj = 0.0d0\n    else\n       haj = 1.0d0 - exp( -gamma*(a/dj)**2 )\n       hbj = 1.0d0 - exp( -gamma*(b/dj)**2 )\n    end if\n\n    if ( a == 0.0d0 ) then\n       vai = di*di/(2.0d0*gamma)\n       vaj = dj*dj/(2.0d0*gamma)\n    else\n       vai = a*a/(2.0d0*hai)\n       vaj = a*a/(2.0d0*haj)\n    end if\n    if ( b == 0.0d0 ) then\n       vbi = di*di/(2.0d0*gamma)\n       vbj = dj*dj/(2.0d0*gamma)\n    else\n       vbi = b*b/(2.0d0*hbi)\n       vbj = b*b/(2.0d0*hbj)\n    end if\n\n    ttt = 0.5d0*( 1.0d0/(vai+vbi) + 1.0d0/(vaj+vbj) ) &\n               *( 1.0d0/( (vai+vaj)*(vbi+vbj) ) &\n                 +1.0d0/( (vai+vbj)*(vaj+vbi) ) )\n\n    phi_c = r*www*ttt\n\n  end function phi_c\n"}, {"instruction": "Write a Fortran function named dbilininterp to trilinearly interpolate given points. This function takes 3 input parameters of type real(kind=8), dimension(:), real(kind=8), dimension(:), and real(kind=8), dimension(size(xd),4), and returns 1 output parameter of type real(kind=8), dimension(size(xd)).", "input": "", "output": "        function dbilininterp(vv,xd,yd) result(y)\n        ! trilinearly interpolate given points (xd,yd,zd) assumed to be normalized so grid spacing is 1 in each direction.\n        ! based on formula from wikipedia.\n        ! jad 9/8/2008\n        real(kind=8), intent(in), dimension(:) :: xd,yd\n        real(kind=8), intent(in), dimension(size(xd),4) :: vv\n        real(kind=8), dimension(size(xd)) :: y,w1,w2\n        ! interpolate along y\n        w1=vv(:,1)*(1.-yd)+vv(:,2)*yd\n        w2=vv(:,3)*(1.-yd)+vv(:,4)*yd\n        ! finally, interpolate y weights along x\n        y=w1*(1.-xd)+w2*xd\n        end function dbilininterp\n"}, {"instruction": "Write a Fortran function named lagrange that calculates the Lagrange interpolating polynomial for a given set of data points. The function takes 3 input parameters: a real value x, an array of real numbers t, and an array of real numbers y. The function returns a real value as the result. Remember to ensure that the size of the arrays t and y are the same.", "input": "", "output": "    function lagrange(x, t, y) \n        implicit none \n\n        real, intent(in)               :: x\n        real, dimension(:), intent(in) :: t, y\n        real                           :: lagrange\n\n        real                           :: coefficient\n        integer                        :: j, k\n\n        ! sanity check\n        if ( size(t) /= size(y) ) stop 'incompatible number of data between x and f(x)'\n        \n        ! initialization \n        lagrange = 0 \n        \n        ! loop through n data point \n        do j = 1, size(t)\n            coefficient = 1.0     \n\n            ! kronecker delta\n            do k = 1, size(t) \n                if ( k /= j ) & \n                    coefficient = coefficient * (x - t(k)) / (t(j) - t(k))\n            end do \n\n            lagrange = lagrange + coefficient * y(j)\n        end do\n    end function lagrange\n"}, {"instruction": "Create a Fortran function named cubic_spline_index that takes two input parameters: a single real number (x) and an array of real numbers (t). The output is a single integer representing the index of the array t where x should be inserted to maintain the order.", "input": "", "output": "    function cubic_spline_index(x, t)\n        implicit none \n\n        real, intent(in)               :: x\n        real, dimension(:), intent(in) :: t\n        integer                        :: cubic_spline_index\n\n        integer                        :: a, b, m \n\n        ! initialization \n        ! preseving the index of t(:)\n        a = 1\n        b = size(t)\n\n        ! bisection \n        do while ( (b - a) > 1 )\n        !   ! mid point \n            m = (a + b) / 2 \n            if ( x > t(m) ) then \n                a = m  \n            else \n                b = m \n            end if\n        end do \n\n        ! points at the boundaries \n        if ( x == t(a) ) then \n            cubic_spline_index = 1 \n        else if ( x == t(b) ) then \n            cubic_spline_index = b-1\n        ! otherwise lower bound \n        else \n            cubic_spline_index = a \n        end if \n    end function cubic_spline_index\n"}, {"instruction": "Create a Fortran function named count_one_wrong that takes an array of integers as input, with the data type ['integer, dimension(:)']. The function should return the count of positive integers in the input array as output, with the data type ['integer'].", "input": "", "output": "    function count_one_wrong(a) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: a\n        integer :: result\n        integer :: count = 0\n        integer :: i\n        do i = 1, size(a)\n            if (a(i) > 0) count = count + 1\n        end do\n        result = count\n    end function count_one_wrong\n"}, {"instruction": "Write a Fortran function named projected_length that takes 4 input parameters of type real(8) and returns 1 output parameter of type real. The purpose of the function is to calculate the projected length of a turbine on the wind direction vector based on the given coordinates. Use the Heron's method to calculate the area of the triangle and then determine the projected length.", "input": "", "output": "function projected_length(ax,ay,bx,by)\n!...................................................................\n\n! turbine to the origin of the inflow wind\n! the distance is used to sort the turbines from ipstream to downstream\n!...................................................................\n\n    real(8) ::   ax                   ! the x coordinate of the point a (reference point)\n    real(8) ::   ay                   ! the y coordinate of the point a\n    real(8) ::   bx                   ! the x coordinate of the point b\n    real(8) ::   by                   ! the y coordinate of the point b\n    real    ::   projected_length\n    \n    real  ::   side_a               ! triangle side a length\n    real  ::   side_b               ! triangle side b length\n    real  ::   side_c               ! triangle side c length\n    real  ::   semi                 ! triangle semiperimeter\n    real  ::   area                 ! triangle area\n    real  ::   height               ! triangle height\n    \n    \n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n         ! calculate the area of the triangle whose corners are the (0,0), turbine location and the wind origin using heron's method\n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n    \n    side_a = sqrt( (bx-ax)*(bx-ax) + (by-ay)*(by-ay) )\n    side_b = sqrt( bx*bx + by*by )\n    side_c = sqrt( ax*ax + ay*ay )\n    semi = (side_a + side_b + side_c)/2\n    \n    area = sqrt(abs( semi * ( semi - side_a ) * ( semi - side_b ) * ( semi - side_c ) ))\n    \n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n         ! calculate the projected length of the turbine on the wind direction vector\n         !''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n    \n    height = 2 * area / side_c\n    \n    projected_length = sqrt( side_a*side_a - height*height )\n    \n    \nend function projected_length\n"}, {"instruction": "Create a Fortran function named \"anglebetweenvectors\" to calculate the angle between two vectors. The function should take 4 real input parameters (x1, y1, x2, y2) representing the coordinates of the vectors, and return a single real output parameter representing the angle. Use the imperative tone to specify the number and type of input and output parameters.", "input": "", "output": "function anglebetweenvectors(x1,y1,x2,y2)\n!...................................................................\n\n! x1,y1,x2,y2 are the vector coordinates\n!...................................................................\n\n    real       ::        x1\n    real       ::        y1\n    real       ::        x2\n    real       ::        y2\n    real       ::        pi = acos( -1.0 )\n    real       ::        anglebetweenvectors\n    real       ::        cosalpha\n    real       ::        rad\n    \n    pi = acos( -1.0 )\n    \n    cosalpha = (x1*x2 + y1*y2) / ( sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2) )\n    \n    !rad = acos(cosalpha-0.00001)                         ! acos(1) = nan??!!!!\n    \n    if (cosalpha>1.0) then\n        cosalpha = 1.0\n    end if\n    \n    if (cosalpha<-1.0) then\n        cosalpha = -1.0\n    end if\n    \n    rad = acos(cosalpha)\n    \n    anglebetweenvectors = rad * 180/pi\n    \nend function anglebetweenvectors\n"}, {"instruction": "Write a Fortran function named cumsum that computes the cumulative sum of a given one-dimensional array. The function takes 2 input parameters: an integer representing the dimension of the array and a real array of kind 8 with the specified dimension. It returns 1 output parameter, which is also a real array of kind 8 with the specified dimension.", "input": "", "output": "    function cumsum(dim,vector)\n        implicit none\n        integer,      intent(in)                 :: dim\n        real(kind=8), intent(in), dimension(dim) :: vector\n        real(kind=8),             dimension(dim) :: cumsum\n\n        integer :: i\n\n        cumsum(1) = vector(1)\n        do i = 2,dim\n            cumsum(i) = cumsum(i-1) + vector(i)\n        enddo\n\n    end function cumsum\n"}, {"instruction": "Write a Fortran function named func that takes a single real input argument and returns a real value. The input data type is ['real'] and the output data type is ['real']. The function computes and returns half of the input value.", "input": "", "output": "function func(y)\n!\nimplicit none\n!\n\n!\nreal :: y\nreal :: func\n!\n\n!  and is used with trapzd.for which performs the integral\n\n!  other equations for a line can also be used if the distribution\n!  is not triangular.\n! \nfunc = 0.5*y\n! \nend function func\n"}, {"instruction": "Write a Fortran elemental function named wrap that takes 3 real input parameters and returns 1 real output parameter. The input parameters are x, mi, and ma, while the output parameter is wrap. The function computes the wrapped value of x within the range defined by mi and ma. If x is within the range, it returns x; otherwise, it returns x wrapped within the range.", "input": "", "output": "    elemental function wrap( x, mi, ma )\n        real, intent(in) :: x, mi, ma\n        real :: wrap\n        wrap = x\n        \n        if (mi .le. x .and. x .le. ma) return\n        wrap = x - floor((x-mi)/(ma-mi)) * (ma-mi)\n    end function\n"}, {"instruction": "Create a Fortran function named count_lines to count the occurrences of a substring within a given string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. The test_data type for input parameters is ['character(len=*)', 'character(len=*)'], and for the output parameter is ['integer'].", "input": "", "output": "function count_lines(str, substr) result(c)\n  implicit none\n  character(len=*) :: str\n  character(len=*) :: substr\n  integer :: c\n  integer :: k, inc, idx\n  c = 0\n  k = 1\n  inc = len_trim(substr)\n  idx = index(str(k:), substr)\n  do while (idx.ne.0)\n     c = c + 1\n     k = k + inc\n     idx = index(str(k:), substr)\n  end do\nend function count_lines\n"}, {"instruction": "Write a Fortran function named cosd that takes a single real input argument and returns a real value. The input argument should be of type real, and the output value should also be of type real. The function computes the cosine of the input angle, which is specified in degrees, and returns the result. Use the imperative tone to instruct the creation of the function.", "input": "", "output": "      function cosd(x)\n          implicit none\n          real :: cosd, umr\n          real, intent(in) :: x\n          umr  = atan(1.0)*4./180. \n          cosd = cos(x*umr)\n\n      end function cosd\n"}, {"instruction": "Create a Fortran function named \"sind\" to calculate the sine of an angle given in degrees. The function should take 1 input parameter of type real and return 1 output parameter of type real. The input parameter should be in degrees, and the output parameter will be the sine of the input angle in radians.", "input": "", "output": "      function sind(x)\n          implicit none\n          real :: sind, umr\n          real, intent(in) :: x\n          umr  = atan(1.0)*4./180. \n          sind = sin(x*umr)\n\n      end function sind\n"}, {"instruction": "Write a Fortran function named ncombinations to calculate the number of possible combinations of Higgs particles. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  function ncombinations(nhiggs)\n!--------------------------------------------------------------------\n  integer, intent(in) :: nhiggs\n  integer :: ncombinations, x\n  integer, allocatable :: s(:)\n  integer :: kk\n  ! calculate the number of possible (irreducible) higgs combinations\n  allocate(s(nhiggs+1))  \n  s(1)=0\n  do x=1,nhiggs\t\n   s(x+1)=s(x)+(x-1)\n  enddo\n  ncombinations=sum(s)+nhiggs+1 \n!new\n  deallocate(s)\n  \n  ncombinations=0\n  do kk=0,nhiggs-1\n   ncombinations = ncombinations + 2**kk \n  enddo\n\n  end function ncombinations\n"}, {"instruction": "Write a Fortran function named countsubstring to count the occurrences of a substring within a given string. The function takes 2 input arguments of type character(*) and returns 1 output argument of type integer. Use the imperative tone when providing the instructions.", "input": "", "output": "function countsubstring(s1, s2) result(c)\n  character(*), intent(in) :: s1, s2\n  integer :: c, p, posn\n\n  c = 0\n  if(len(s2) == 0) return\n  p = 1\n  do\n    posn = index(s1(p:), s2)\n    if(posn == 0) return\n    c = c + 1\n    p = p + posn + len(s2)\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named pressure to calculate the pressure in bars based on the given depth in meters. The function has 1 input parameter of type real and 1 output parameter of type real. When using this function, provide a single real value as input to compute the corresponding pressure in bars.", "input": "", "output": "function pressure(depth) result(press)\n\n! !description:\n\n!  using a mean density derived from depth-dependent global \n!  average temperatures and salinities from levitus 1994, and \n!  integrating using hydrostatic balance.\n!\n!  references:\n!\n!     levitus, s., r. burgett, and t.p. boyer, world ocean atlas \n!          1994, volume 3: salinity, noaa atlas nesdis 3, us dept. of \n!          commerce, 1994.\n!\n!     levitus, s. and t.p. boyer, world ocean atlas 1994, \n!          volume 4: temperature, noaa atlas nesdis 4, us dept. of \n!          commerce, 1994.\n!\n!     dukowicz, j. k., 2000: reduction of pressure and pressure\n!          gradient errors in ocean simulations, j. phys. oceanogr.,\n!          submitted.\n!\n! !revision history:\n!  same as module\n\n! !input parameters:\n\nreal, intent(in) :: depth    ! depth in meters\n\n! !output parameters:\n\nreal :: press   ! pressure [bars]\n\n! !local parameters:\n!  adjustment from original code which was written as 0.1_r8\n!  which the compiler disliked so constants are now pre-defined here\ndouble precision, parameter ::              &\n   pc1 = 0.059808,   &\n   pc2 = 0.025,      &\n   pc3 = 0.100766,   &\n   pc4 = 2.28405e-7, &\n   c1  = 1.0\n!eop\n!boc\n!-----------------------------------------------------------------------\n!  convert depth in meters to pressure in bars\n!-----------------------------------------------------------------------\n\npress = pc1*(exp(-pc2*depth) - c1) + pc3*depth + pc4*depth**2\n\n!return\n\nend function pressure\n"}, {"instruction": "Create a Fortran function named erfc_salmon_mid to calculate the complementary error function for a floating-point number within a specific range. It takes 1 input argument of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "  function erfc_salmon_mid(x) result(y) ! 0.46875d0 <x< 4d0\n    implicit none\n    real(8),intent(in) :: x\n    real(8) :: y\n    real(8) :: x2\n    real(8),parameter :: &\n       p(0:7) = (/  &\n       & 3.004592610201616005d2, &\n       & 4.519189537118729422d2, &\n       & 3.393208167343436870d2, &\n       & 1.529892850469404039d2, &\n       & 4.316222722205673530d1, &\n       & 7.211758250883093659d0, &\n       & 5.641955174789739711d-1, &\n       &-1.368648573827167067d-7 & \n       &/), &\n       q(0:7) = (/ &\n       & 3.004592609569832933d2, &\n       & 7.909509253278980272d2, &\n       & 9.313540948506096211d2, &\n       & 6.389802644656311665d2, &\n       & 2.775854447439876434d2, &\n       & 7.700015293522947295d1, &\n       & 1.278272731962942351d1, &\n       & 1d0 &\n       &/)\n\n    x2 = x**2\n\n    y = (p(0) + p(1)*x + p(2)*x**2 + p(3)*x**3 + p(4)*x**4 & \n         + p(5)*x**5 + p(6)*x**6 + p(7)*x**7)/ &\n         (q(0) + q(1)*x + q(2)*x**2 + q(3)*x**3 + q(4)*x**4 & \n         + q(5)*x**5 + q(6)*x**6 + q(7)*x**7)\n    y = exp(-x2)*y\n\n\n  end function erfc_salmon_mid\n"}, {"instruction": "Create a Fortran pure function named odps_get_ozone_component_id to determine the ozone component ID based on the input group index. The function takes 1 input argument of type integer and returns 1 output argument of type integer. If the group index matches a specific group, the function returns the ozone component ID; otherwise, it returns -1.", "input": "", "output": "  pure function odps_get_ozone_component_id(group_index) result( ozone_component_id )\n    integer, intent(in) :: group_index\n    integer :: ozone_component_id\n    if( group_index == group_1 .or. group_index == group_1)then\n      ozone_component_id = ozo_comid\n    else\n      ozone_component_id = -1\n    end if\n  end function odps_get_ozone_component_id\n"}, {"instruction": "Create a Fortran function named reversible to determine if an integer is palindromic in its digits. The function should take 1 input argument with test_data type ['integer'] and return 1 output argument with test_data type ['logical'].", "input": "", "output": "function reversible(num)\n  ! determine if an integer is palindromic in its digits\n\n  implicit none\n\n  logical :: reversible\n  integer, intent(in) :: num\n  integer :: len,itr\n  ! 999*999 is 998001, so only 6 characters are needed\n  character(len=6) :: str,rev\n  ! print to the string\n  write (str,\"(i6)\") num\n  len=len_trim(str)\n  ! flip the string and save to rev\n  do itr=1,len\n    rev(itr:itr)=str(len+1-itr:len+1-itr)\n  end do\n\n  reversible=str(1:len).eq.rev(1:len)\n\nend function reversible\n"}, {"instruction": "Create a Fortran function named pythag that calculates the hypotenuse of a right-angled triangle using the given lengths of the two shorter sides. The number of input arguments is 2 with test_data type ['real(kind=8)', 'real(kind=8)'], and the number of output arguments is 1 with test_data type ['real(kind=8)']. Use the imperative tone to write the instruction.", "input": "", "output": "\tfunction pythag(a,b)\n   real(kind=8) :: a,b,pythag\n   real(kind=8) :: absa,absb\n      absa=dabs(a)\n      absb=dabs(b)\n      if(absa.gt.absb)then\n        pythag=absa*dsqrt(1.+(absb/absa)**2)\n      else\n        if(absb.eq.0.d0)then\n          pythag=0.d0\n        else\n          pythag=absb*sqrt(1.d0+(absa/absb)**2)\n        endif\n      endif\n      return\n\tend function pythag\n"}, {"instruction": "Create a Fortran function named reptimecheck to determine whether a given time meets a target time for a benchmark. The function takes 2 input parameters of type double precision and integer, and returns 1 output parameter of type logical. The input test_data type is ['double precision', 'integer'], and the output test_data type is ['logical'].", "input": "", "output": "  function reptimecheck(time, numreps)\n    double precision, intent(in) :: time\n    integer, intent(in) :: numreps\n    logical :: reptimecheck\n\n    if (time < targettime) then\n       !double repstodo and repeat benchmark\n       repstodo = 2*numreps\n       reptimecheck = .false.\n    else if (time > (2*targettime)) then\n       !finish benchmark and half number of reps for next datasize\n       repstodo = max(numreps/2,1) !repstodo is at least 1 \n       reptimecheck = .true.\n    else !time is >= targettime\n       !finish benchmark and keep reps for next data size\n       reptimecheck = .true.\n    end if\n\n   \n  end function reptimecheck\n"}, {"instruction": "Write a Fortran function named ralloc to dynamically allocate memory for a 2D integer array. The number of input arguments is 3, and the test_data type is ['integer, pointer, dimension(:,:)', 'integer', 'integer']. The number of output arguments is 1, and the test_data type is ['integer, pointer, dimension(:,:)'].\nThe function allocates memory for a new 2D array, copies the existing array's elements into the new array, and deallocates the memory of the existing array if it's associated.", "input": "", "output": "  function ralloc(p, n, m)\n    integer, pointer, dimension(:,:) :: p, ralloc\n    integer, intent(in) :: n, m\n    \n    !!<local name=\"nold, mold\">the number of rows and columns in the existing array.</local>\n    !!<local name=\"ierr\">used for checking memory allocation error.</local>\n    integer :: nold, mold, ierr\n\n    allocate(ralloc(1:n,1:m), stat=ierr)\n    if (ierr/=0) stop \"allocate error in ralloc_integer_table in utilities module\"\n\n    if (.not.associated(p)) return\n    nold = min(size(p,1),n); mold = min(size(p,2),m)\n    ralloc = 0\n    ralloc(1:nold,1:mold) = p(1:nold,1:mold)\n    deallocate(p)\n  end function ralloc\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. This function should have 1 input parameter of type integer and 1 output parameter of type integer. Use \"integer, intent(in) :: n\" to specify the input parameter and \"integer :: y\" to specify the output parameter. Use a do loop to calculate the factorial.", "input": "", "output": "    function factorial(n) result (y)\n        integer, intent(in) :: n\n        integer             :: y\n        \n        integer             :: i\n\n        y = 1\n        do i = 2, n\n            y = y*i\n        end do\n    end function\n"}, {"instruction": "Create a Fortran function called fibo_naive to calculate the Fibonacci number at the given position using a naive recursive approach. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The test_data type for input is ['integer'] and for output is ['integer'].", "input": "", "output": "  recursive function fibo_naive(n) result(res)\n    integer, intent(in) :: n\n    integer :: res\n    \n    if(n <= 0) then\n       res = 0\n       return\n    end if\n    \n    if(n == 1) then\n       res = 1\n       return\n    end if\n\n    res = fibo_naive(n-1) + fibo_naive(n-2)\n\n  end function fibo_naive\n"}, {"instruction": "Write a Fortran function called fibo_tail to calculate the nth number in the Fibonacci sequence using tail recursion. The function takes 3 input arguments of type integer: prev2, prev1, and n. It returns 1 output argument of type integer.", "input": "", "output": "  recursive function fibo_tail(prev2,prev1,n) result(res)\n    integer,intent(in) :: prev2,prev1,n\n    integer :: res\n\n    if(n == 0) then\n       res = prev2\n       return\n    end if\n\n    res = fibo_tail(prev1,prev1+prev2,n-1)\n\n  end function fibo_tail\n"}, {"instruction": "Write a Fortran function named wrap to calculate the wrapped angle within the range of 0 to 359 degrees. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. When calling the function, provide a single integer value as input and the function will return the wrapped angle within 0 to 359 degrees.", "input": "", "output": "pure function wrap(angle) result(wrapped_angle)\nimplicit none \ninteger,intent(in) :: angle\ninteger :: wrapped_angle\nwrapped_angle = mod(angle, 360)\nif (wrapped_angle<0) wrapped_angle = wrapped_angle + 360\nend function wrap\n"}, {"instruction": "Create a Fortran function named vperp that calculates the perpendicular velocity. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). If the result is NaN, it sets the output parameter to 0d0.", "input": "", "output": "  function vperp(bmod)\n    !   perpendicular velocity\n    real(8) :: bmod, vperp\n    vperp = v*sqrt(eta*bmod)\n    if (isnan(vperp)) then\n       vperp = 0d0\n    end if \n  end function vperp\n"}, {"instruction": "Write a Fortran function named quadrilinear to compute a function value using a quadrilinear interpolation algorithm. The function takes 6 input parameters of type real(kind(0d0)) and dimension(0:1,0:1,0:1,0:1) for hypercube, real(kind(0d0)) and dimension(0:3) for vmid, and real(kind(0d0)) for dt, dx, dy, dz. The output parameter is a real(kind(0d0)) value. Use the imperative tone.", "input": "", "output": "   function quadrilinear(vmid,hypercube,dt,dx,dy,dz) result (f)\n\n     implicit none\n     real(kind(0d0)),dimension(0:1,0:1,0:1,0:1) :: hypercube\n     real(kind(0d0)),dimension(0:3) :: vmid\n     real(kind(0d0)) :: dt, dx, dy, dz, f\n     real(kind(0d0)) :: t, x, y, z\n     integer :: n,i,j,k\n\n     f = 0d0\n     t = vmid(0)/dt\n     x = vmid(1)/dx\n     y = vmid(2)/dy\n     z = vmid(3)/dz\n\n     do k = 0,1\n        do j = 0,1\n           do i = 0,1\n              do n = 0,1\n                 f = f + (n*t+(1-n)*(1-t))*(i*x+(1-i)*(1-x))     &\n                        *(j*y+(1-j)*(1-y))*(k*z+(1-k)*(1-z))     &\n                        *hypercube(n,i,j,k)\n\n              end do\n           end do\n        end do\n     end do\n\n   end function quadrilinear\n"}, {"instruction": "Create a Fortran function named isref that takes two input arguments of type character(len=*) and returns a logical value. This function checks if the second input argument is a substring of the first input argument.", "input": "", "output": "  function isref(ref, ref_list) result(isr)\n    implicit none\n    character(len=*), intent(in) :: ref\n    character(len=*), intent(in) :: ref_list\n    logical :: isr\n\n    isr = (index(ref, ref_list) > 0)\n\n  end function isref\n"}, {"instruction": "Create a Fortran function called parsecompvector that takes a single input argument of type character(len=*) and returns an integer. The function counts the number of components in the input character vector, where components are separated by commas or spaces. Use the imperative tone in the instructions.", "input": "", "output": "  function parsecompvector(compvector) result(nc)\n    character(len=*), intent(in) :: compvector\n    integer :: nc\n    ! locals\n    character(len=1), parameter :: delim = ','\n    character(len=1), parameter :: space = ' '\n    integer :: strlen, i, lasti\n    strlen = len(compvector)\n    nc = 0\n    lasti = 0\n    do i=2,strlen\n      if (compvector(i:i) == delim .or. compvector(i:i)== space) then\n        if (i > lasti) then\n          nc = nc + 1\n        endif\n        lasti = i\n      endif\n    enddo\n    if (strlen > lasti) then\n      nc = nc + 1\n    endif\n  end function parsecompvector\n"}, {"instruction": "Create a Fortran function named fsedmode to determine bedload and suspended load transport fractions based on specified mode options and hydrodynamic parameters. The function takes 7 input parameters of type integer and real, and returns 1 output parameter of type real. The function uses imperative logic to calculate the transport fractions based on different mode options using the input parameters.", "input": "", "output": "function fsedmode(ws,ustot,usgrn,rsndm,isndm1,isndm2,imode)\n\n  ! *** fsedmode sets bedload (imode=1) and suspended load (imode=2)\n  ! *** transport fractions (dimensionless)\n  \n  ! ***  ws\n  ! ***  ustot  - hydrodynamic shear velocity (m/s)\n  ! ***  usgrn  - grain shear velocity (m/s)\n  ! ***  rsndm  - value of ustar/wset for binary switch between bedload and suspended load (dimensionless)\n\n  implicit none\n\n  integer :: isndm1,isndm2,imode\n  real   :: fsedmode,ws,ustot,usgrn,rsndm,us,usdws,tmpval\n\n  if( ws == 0. )then\n    fsedmode=0.\n    return\n  endif\n\n  ! *** choose betweeen total stress shear velocity and grain stress\n  ! *** shear velocity\n  if( isndm2 == 0 )then\n    us=ustot\n  else\n    us=usgrn\n  endif\n  usdws = us/ws\n\n  ! *** choose between mode options\n\n  ! *** isndm1=0 set both bedload and suspended load fractions to 1.0\n  if( isndm1 == 0 ) fsedmode=1.0\n\n  ! *** isndm1=1 set bedload fraction to 1. use binary relationship for suspended\n  if( isndm1 == 1 )then\n      fsedmode=0.\n    if( imode == 1 )then\n      fsedmode=1.0\n    else\n      if( usdws >= rsndm)fsedmode=1.\n    end if\n  end if\n\n  ! *** isndm1=2 set bedload fraction to 1, use linear relationship for suspended\n  if( isndm1 == 2 )then\n    if( imode == 1 )then\n      fsedmode=1.0\n    else\n      tmpval=((usdws)-0.4)/9.6\n      tmpval=min(tmpval,1.0)\n      tmpval=max(tmpval,0.0)\n        fsedmode=tmpval\n    end if\n  end if\n\n  ! *** isndm1=3 use binary relationship for bedload and suspended load\n  if( isndm1 == 3 )then\n      fsedmode=0.\n    if( imode == 1 )then\n      if( usdws < rsndm)fsedmode=1.\n    else\n      if( usdws >= rsndm)fsedmode=1.\n    end if\n  end if\n\n  ! *** isndm1=4 use linear relationship for bedload and suspended load\n  if( isndm1 == 4 )then\n    tmpval=((usdws)-0.4)/9.6\n    tmpval=min(tmpval,1.0)\n    tmpval=max(tmpval,0.0)\n    if( imode == 1 )then\n      fsedmode=1.-tmpval\n    else\n      fsedmode=tmpval\n    end if\n  end if\n\nend function\n"}, {"instruction": "Create a Fortran function named compute_point to calculate a value based on the input parameters. The function takes 2 input arguments of type real and optional real. The output is a single real value. When the optional input is present, it is added to the computed value.", "input": "", "output": " elemental function compute_point ( t , w ) result(q)\n  real , intent(in) :: t\n  real , optional , intent(in) :: w\n  real :: q\n  real :: c\n\n  c = 5.345\n  q = q + t * c\n  if ( present ( w ) ) then\n   q = q + w\n  end if\n end function compute_point\n"}, {"instruction": "Write a Fortran function named outer to calculate the outer product of two input arrays. The number of input arguments is 2, and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1, and the test_data type is ['real, dimension(size(a), size(b))'].", "input": "", "output": "    function outer(a, b) \n        implicit none \n\n        real, dimension(:)                :: a, b \n        real, dimension(size(a), size(b)) :: outer\n\n        ! c_ij = a_i * b_j \n        outer = spread(a, dim=2, ncopies=size(b)) * spread(b, dim=1, ncopies=size(a))\n    end function outer\n"}, {"instruction": "Create a Fortran function named gather_realvector that takes two input arguments: an integer array and a real array, denoted as ['integer, dimension(:)', 'real, dimension(:)']. It returns one output argument of type real array, which is allocated dynamically, denoted as ['real, dimension(:), allocatable']. The function extracts elements from the real array based on the indices specified in the integer array and stores the result in the dynamically allocated real array. Remember to allocate memory for the output array before storing the extracted elements.", "input": "", "output": "      function gather_realvector(sparseindex,densevec) result(sparsevec)\n!\n\n!     indexing is known.\n!\n      implicit none\n      real,dimension(:),allocatable::sparsevec\n      integer,dimension(:),intent(in)::sparseindex\n      real,dimension(:),intent(in)::densevec\n      integer::i\n!\n      allocate(sparsevec(size(sparseindex)))\n      do i = 1,size(sparseindex)\n        sparsevec(i) = densevec(sparseindex(i))\n      enddo\n!\n      return\n      end function gather_realvector\n"}, {"instruction": "Create a Fortran function named v2mo that takes an integer input representing a month (1-12) and returns the corresponding month name as a character string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function v2mo(imonth) result(month_name)\n! ident_12=\"@(#)v2mo(3f): returns the month name of a common month\"\ncharacter(len=:),allocatable :: month_name                                        ! string containing month name or abbreviation.\ninteger,intent(in)           :: imonth                                            ! the number of the month(1-12)\ncharacter(len=*),parameter   :: names(12)=[ character(len=9) ::  &\n&'january  ', 'february ', 'march    ', 'april    ', 'may      ', 'june     ', &\n&'july     ', 'august   ', 'september', 'october  ', 'november ', 'december ']\n   select case(imonth)\n   case (1:12);  month_name=trim(names(imonth))\n   case default; month_name='unknown'\n   end select\nend function v2mo\n"}, {"instruction": "Create a Fortran function named temps to calculate the temperature stress factor based on daily maximum and minimum air temperatures, as well as the optimum and minimum crop growth temperatures. The number of input arguments is 4 with test_data type ['real', 'real', 'real', 'real'], and the number of output arguments is 1 with test_data type ['real'].", "input": "", "output": "function temps(bwtdmx,bwtdmn,bctopt,bctmin)\n!\nimplicit none\n!\n\n!\nreal :: bctmin,bctopt,bwtdmn,bwtdmx\nreal :: temps\n!\n! local variables\n!\nreal :: dst0,rto,tgx,x1\n!\n!     author : amare retta\n!     + + + purpose + + +\n!     to calculate the temperature stress factor\n!     this algorithms was taken from the epic subroutine cgrow.\n \n!     + + + kewords + + +\n!     temperature stress\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     bwtdmx - daily maximum air temperature\n!     bwtdmn - daily minimum air temperature\n!     bctopt - optimum crop growth temperature\n!     bctmin - minimum crop growth temperature\n\n!             stress factor\n \n!     + + + local variables + + +\n \n!     + + + local variable definitions + + +\n!     dst0 - average of max and min air temperatures\n!     rto - interim variable\n!     tgx - difference between the soil surface temperature and the minimum\n!           temperature for plant growth\n!     x1 - difference between the optimum and minimum temperatures for plant\n!          growth\n \n!     + + + end of specifications + + +\n\n!     calculate temperature stress factor\n!     following one statement to be removed when soil temperature is available\ndst0 = (bwtdmx+bwtdmn)/2.0\ntgx = dst0 - bctmin\nif (tgx.le.0.) tgx = 0.\nx1 = bctopt - bctmin\nrto = tgx/x1\ntemps = sin(1.5707*rto)\nif (rto.gt.2.) temps = 0.\n \n      ! this reduces temperature stress around the optimum\ntemps = temps**0.25\n!    print *, 'in temps, temps = ', temps\n!    \nend function temps\n"}, {"instruction": "Create a Fortran function named poor_soil_rsp that takes two input parameters of type real and integer, and returns one output parameter of type real. This function computes the quadratic response factors based on the soil fertility and response class. Make sure to use the imperative tone in your code.", "input": "", "output": "   function poor_soil_rsp(sf,nrc)\n      !  computes quadratic itpoorent response factors\n      !  by itpoorent response class (1=intol, 3=tol) and soil fertility\n      real                            :: poor_soil_rsp\n      real,              intent(inout):: sf\n      !     class(speciesdata), intent(in)  :: self\n      integer,           intent(inout):: nrc\n      !    integer,  intent(in)            :: nrc\n\n      !    integer                       :: nrc\n      real                          :: fpoor\n\n      ! soil fertility\n      real, dimension(3)            :: fert_c1, fert_c2, fert_c3\n\n      data  fert_c1 /-0.6274,-0.2352,0.2133/\n      data  fert_c2 /3.600,2.771,1.789/\n      data  fert_c3 /-1.994,-1.550,-1.014/\n\n      !this cannot be converted to a real \"method\" until it is resolved whether\n      ! the following is a bug.  as it is, it changes the avail_n as well as the\n      ! required nitrogen on each call.\n\n      !!!warning warning warning possible massive bug here\n      nrc=4-nrc\n      sf = min(sf,1.0)\n      fpoor=fert_c1(nrc)+fert_c2(nrc)*sf+fert_c3(nrc)*sf**2\n      if (fpoor.le. 0.0) fpoor=0.0\n      if (fpoor.ge. 1.0) fpoor=1.0\n      poor_soil_rsp=fpoor*sf\n\n   end function poor_soil_rsp\n"}, {"instruction": "Create a Fortran function named fdry that takes two input parameters of type real and integer, and returns a single real output. The function calculates the value of fdry based on the input parameters and the predefined array gama.", "input": "", "output": "   function fdry(dryday,k)\n      real                :: fdry\n      real,    intent(in) :: dryday\n      integer, intent(in) :: k\n\n      real                :: tmp\n      real, dimension(6)  :: gama\n      data gama/0.50,0.45,0.35,0.25,0.15,0.05/\n\n      tmp=max(gama(k)-dryday,0.0)\n      fdry=(tmp/gama(k))**0.5\n\n   end function fdry\n"}, {"instruction": "Write a Fortran function named gdk_keymap_get_entries_for_keyval that takes 4 input parameters of type c_ptr, value, integer(c_int), value, type(c_ptr), value, and type(c_ptr), value. The function returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gdk_keymap_get_entries_for_keyval(keymap, keyval, keys, n_keys) bind(c&\n&) \n  use iso_c_binding, only: c_int, c_ptr\n  integer(c_int) :: gdk_keymap_get_entries_for_keyval\n  type(c_ptr), value :: keymap\n  integer(c_int), value :: keyval\n  type(c_ptr), value :: keys\n  type(c_ptr), value :: n_keys\nend function\n"}, {"instruction": "Create a Fortran function named greeting3, which takes a single input argument of type character(5) and returns a single output argument of type character(5), which is allocatable.", "input": "", "output": "  function greeting3 (arg) result(res)\n    character(5) :: arg\n    character(5), allocatable :: res, res1\n    allocate(res, res1, source = arg) ! caused an ice\n    if (res1 .ne. res) stop 8\n  end function\n"}, {"instruction": "Create a Fortran function named power2 that takes an integer as input and returns a logical value indicating whether the input number is a power of 2 or not. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "      function power2(number)\n! returns true if the number is a power of 2, if not it returns false \n        implicit none\n        integer :: number,x\n        logical :: power2\n        x = number\n           ! write(*,*) x\n        if (x .eq. 0)then \n           power2 = .false.\n           return\n        endif\n        \n        do while(mod(x,2) .eq. 0)\n           x = x / 2\n        end do\n        if (x .gt. 1) then\n           power2 =.false.\n           return\n        else\n           power2 = .true.\n        endif\n        \n      end function power2\n"}, {"instruction": "Create a Fortran function called \"associated_laguerre\" to calculate the value of an associated Laguerre polynomial. The function takes 3 input parameters of type integer, real, and real, denoted as [\"integer\", \"real\", \"real\"], and returns 1 output parameter of type real, denoted as [\"real\"].", "input": "", "output": "   elemental function associated_laguerre(n, alpha, x)\n\n      integer, intent(in) :: n\n      real, intent(in) :: x\n      real, intent(in) :: alpha\n      integer :: k\n      real :: associated_laguerre, p, p1, p2\n\n      p1 = dble(1.0)\n      p2 = dble(1.0) + alpha - x\n\n      if (n == 0) then\n         associated_laguerre = p1\n         return\n      else if (n == 1) then\n         associated_laguerre = p2\n         return\n      end if\n\n      do k = 2, n\n         p = ((dble(2.0) * k - dble(1.0) + alpha - x) * p2 - (k - dble(1.0) + alpha) * p1) / k\n         p1 = p2\n         p2 = p\n      end do\n\n      associated_laguerre = p\n\n   end function associated_laguerre\n"}, {"instruction": "Create a Fortran function named associated_legendre to calculate the associated Legendre function for given inputs. The function takes 3 input parameters of types integer, integer, and double precision, and returns 1 output parameter of type double precision.", "input": "", "output": "   elemental function associated_legendre(l, m, x)\n\n      integer, intent(in) :: l, m\n      double precision, intent(in) :: x\n      integer :: k\n      double precision :: associated_legendre, p, p1, p2, fac\n      double precision :: pi\n\n      pi = 3.14159265359\n\n      ! to start the recursion, use that p_l^m = 0 for l < abs(m)\n      ! and p_l^l = (-1)^l*(2l-1)!!(1-x^2)^(l/2)\n      ! where (2l-1)!! = 2**l * gamma(l+0.5) / sqrt(pi)\n      p1 = 0.\n      p2 = (-1)**abs(m) * 2**abs(m) * gamma(abs(m) + 0.5) / sqrt(pi) * (1.-x**2)**(abs(m) / 2.)\n\n      if (abs(m) > l) then\n         associated_legendre = 0.\n         return\n      end if\n\n      if (l == 0) then\n         associated_legendre = 1.\n         return\n      end if\n\n      if (l == m) then\n         associated_legendre = p2\n         return\n      end if\n\n      if (l == -m) then\n         fac = (-1)**abs(m) * gamma(l - abs(m) + 1.) / gamma(l + abs(m) + 1.)\n         associated_legendre = p2 * fac\n         return\n      end if\n\n      do k = abs(m) + 1, l\n         p = ((dble(2.0) * k - dble(1.0)) * x * p2 - (k - dble(1.0) + abs(m)) * p1) / (k - abs(m))\n         p1 = p2\n         p2 = p\n      end do\n\n      if (m < 0) then\n         fac = (-1)**abs(m) * gamma(l - abs(m) + 1.) / gamma(l + abs(m) + 1.)\n         p = p * fac\n      end if\n\n      associated_legendre = p\n\n   end function associated_legendre\n"}, {"instruction": "Create a Fortran function named bin to calculate the binomial coefficient \"n choose k\". The function takes 2 input parameters of type integer(kind=4) and returns 1 output parameter of type integer(kind=4). The test_data type for input parameters is ['integer(kind=4)', 'integer(kind=4)'] and for the output parameter is ['integer(kind=4)'].", "input": "", "output": "  pure function bin(n,k) result (c)\n    implicit none\n    integer(kind=4), intent(in) :: n, k\n    integer(kind=4) :: i, c\n    c = 1\n    do i = 0, min(k,n-k) - 1\n       c = c * (n - i)\n       c = c / (i + 1)\n    end do\n  end function bin\n"}, {"instruction": "Write a Fortran function named \"taumn\" that calculates and returns a real(kind=8) value. The function should take 5 input arguments of type real(kind=8) - temp, taum, taun, wm, and wn. It should return a single real(kind=8) output value, tmn.", "input": "", "output": "function taumn(temp,taum,taun,wm,wn) result(tmn)\n    \n    implicit none\n\n    real(kind=8) :: temp,tmn,taum,taun,wm,wn\n\n    tmn = (wm+wn)**2/4/wm/wn*(taum+taun)/((taum+taun)**2+(wm-wn)**2)+&\n        (wm-wn)**2/4/wm/wn*(taum+taun)/((taum+taun)**2+(wm+wn)**2)\n\n\n\nend function\n"}, {"instruction": "Create a Fortran function named randint to generate a random integer within a specified range. The function takes 2 input arguments of type integer, where the second argument is optional. The test_data type for the input parameters is ['integer', 'integer, optional']. The function returns 1 output argument of type integer, with the test_data type being ['integer'].", "input": "", "output": "  function randint(a, b)\n\n    integer, intent(in)::a\n    integer, intent(in), optional::b\n    integer::rangemin\n    integer::rangemax\n    real::r\n    integer::randint\n\n    if (present(b)) then\n      rangemin = a\n      rangemax = b\n    else\n      rangemin = 1\n      rangemax = a\n    end if\n\n    call random_number(r)\n\n    randint = int(r*(rangemax - rangemin - 1)) + rangemin\n\n  end function randint\n"}, {"instruction": "Create a Fortran function named get_movement_totals to process a file containing submarine movement data. The number of input arguments is 1, with a test_data type of [character(len=*)]. The number of output arguments is 1, with a test_data type of [integer].", "input": "", "output": "\tfunction get_movement_totals(filename) result (total_pos)\n\t\timplicit none\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tinteger :: fileunit,io,io_err,x,total_for=0,total_up=0,total_down=0,final_depth=0\n\t\tcharacter(len=10) :: data_in\n\t\tinteger :: total_pos ! type for the returned answer\n\t\t\n\t\topen(newunit=fileunit, file=filename, action='read', position='rewind')\n\t\t\n\t\tdo\n\t\t\tread(fileunit,*,iostat=io_err) data_in,x\n\t\t\tif(io_err .ne. 0) exit\n\t\t\t\n\t\t\tselect case (trim(data_in))\n\t\t\tcase (\"forward\")\n\t\t\t\ttotal_for = total_for + x\n\t\t\tcase (\"up\")\n\t\t\t\ttotal_up = total_up + x\n\t\t\tcase (\"down\")\n\t\t\t\ttotal_down = total_down + x\n\t\t\tend select\n\t\tend do\n\t\t\n\t\tclose(fileunit)\n\n\t\tfinal_depth = total_down - total_up\n\t\t\n\t\twrite (*,'(a)') \"calculating submarine movement:\"\n\t\twrite (*,'(a,i4.4)') \" \u00bb total forward: \",total_for\n\t\twrite (*,'(a,i4.4)') \" \u00bb total up: \",total_up\n\t\twrite (*,'(a,i4.4)') \" \u00bb total down: \",total_down\n\t\twrite (*,'(a,i4.4)') \" \u00bb final depth: \",final_depth\n\t\t\n\t\ttotal_pos = final_depth * total_for\n\n\tend function get_movement_totals\n"}, {"instruction": "Create a Fortran function named improved_magnus to calculate the vapor pressure of water at a given temperature. The function takes 1 input parameter of type real, and returns 1 output parameter of type real.", "input": "", "output": "function improved_magnus(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: improved_magnus\n\nimproved_magnus = 610.94 * exp((17.625 * (t-273.15)) / (t + 243.04 - 273.15))\nend function\n"}, {"instruction": "Write a Fortran function named \"wagnerpruss\" to calculate the saturation water vapor pressure in pascals based on the input temperature in Kelvin. The number of input arguments is 1, with a test_data type of ['real']. The number of output arguments is 1, with a test_data type of ['real'].", "input": "", "output": "function wagnerpruss(t)\n\nimplicit none\nreal, intent(in) :: t\nreal :: wagnerpruss  ! saturation water vapour pressure [pa]\n\nreal, parameter :: tc = 647.096 ! critical point temperature [k]\n\nreal :: x\n\nx = (1 - (t/tc))\nwagnerpruss = 22064000.0 * exp( (tc/t) * ( &\n  - 7.85951783 * x &\n  + 1.84408259 * x**1.5 &\n  - 11.7866497 * x**3 &\n  + 22.6807411 * x**3.5 &\n  - 15.9618719 * x**4 &\n  + 1.80122502 * x**7.5 &\n  ))\n\nend function wagnerpruss\n"}, {"instruction": "Create a Fortran function named huang to calculate the Huang equation for the saturation vapor pressure. The function should take 1 input argument of type real and return 1 output argument of type real. The input argument represents the temperature in Kelvin.", "input": "", "output": "function huang(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: huang\n\nreal :: tc\n\ntc = t - 273.15  !  tc [degc]\n\nhuang = exp(34.494 - 4924.99 / (tc + 237.1)) /  (tc + 105)**1.57\n\nend function huang\n"}, {"instruction": "Write a Fortran function named huang_ice that calculates the relative electrical permittivity of ice based on the input temperature. The function takes 1 input argument of type real and returns 1 output argument of type real. The input argument represents the temperature in Kelvin. Use the provided formula to perform the calculation and return the result.", "input": "", "output": "function huang_ice(t)\n\nimplicit none\nreal, intent(in) :: t\nreal  :: huang_ice\n\nreal :: tc\n\ntc = t - 273.15  !  tc [degc]\n\nhuang_ice = exp(43.494 -  6545.8 / (tc + 278)) / (tc + 868)**2\n\nend function huang_ice\n"}, {"instruction": "Create a Fortran function named sattab_l that takes an integer input parameter. The function calculates the saturation vapor pressure over liquid water at a given temperature based on the input parameter. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function sattab_l(m)\n  implicit none\n  integer, intent(in) :: m\n  real :: sattab_l, t\n  \n  t = 150.+0.2*m\n  sattab_l = exp(54.842763-6763.22/t-4.21*log(t)+0.000367*t+&\n       tanh(0.0415*(t-218.8))*(53.878-1331.22/t-9.44523*log(t)+ 0.014025*t))\nend function sattab_l\n"}, {"instruction": "Create a Fortran function named sattab_i to calculate the saturation pressure of water vapor based on the input temperature in Celsius. The function should have 1 input parameter of type integer, and the output parameter should be of type real.", "input": "", "output": "function sattab_i(m)\n  implicit none\n  integer, intent(in) :: m\n  real :: sattab_i, t\n\n  t = 150.+0.2*m\n  sattab_i = exp(9.550426-5723.265/t+3.53068*log(t)-0.00728332*t)\nend function sattab_i\n"}, {"instruction": "Create a Fortran function named cala3 to calculate the modified 4-digit thickness (a3 variable). It takes 3 input arguments of real type: a0, d1, and xmt. The output is a real value.", "input": "", "output": "pure function cala3(a0, d1, xmt) result(f)\r\n! ------------------------------------------------------------------------------\r\n! purpose - the a3 variable used for the modified 4-digit thickness   \r\n\r\n  real,intent(in):: a0,d1,xmt\r\n\r\n  real:: f\r\n  real:: omxmt\r\n  real:: v1,v2,v3                                                   \r\n!-------------------------------------------------------------------------------\r\n  omxmt= 1.0-xmt \r\n  v1=0.1/(xmt*xmt*xmt)\r\n  v2=(d1*omxmt-0.294)/(xmt*omxmt*omxmt) \r\n  v3=(3.0/8.0)*a0/(xmt**2.5) \r\n  f = v1 + v2 - v3 \r\n  return\r\nend function cala3   ! ---------------------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named leadingedgeradius4 to calculate the leading edge radius of a 4-digit thickness distribution. The function should take 1 input argument of type real and return 1 output argument of type real. The input argument represents the maximum value of t/c. Use the equation rle=a*toc**2, where \"a\" is a predefined constant, to calculate the leading edge radius.", "input": "", "output": "pure function leadingedgeradius4(toc) result(rle)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the leading edge radius of a 4-digit thickness\r\n!   distribution.\r\n\r\n  real,intent(in):: toc       ! maximum value of t/c\r\n\r\n  real:: rle\r\n  real,parameter:: a=1.1019  ! eq. 6.3, p.114 in abbott & von doenhoff\r\n!-------------------------------------------------------------------------------\r\n  rle=a*toc**2\r\n  return\r\nend function leadingedgeradius4    ! -------------------------------------------\r\n"}, {"instruction": "Create a Fortran function called leadingedgeradius4m to calculate the leading edge radius of a 4-digit-modified thickness distribution. This function takes 2 input parameters of type real, toc (maximum value of t/c) and leindex (leading edge index), and returns 1 output parameter of type real, rle (leading edge radius).", "input": "", "output": "pure function leadingedgeradius4m(toc,leindex) result(rle)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the leading edge radius of a 4-digit-modified thickness\r\n!   distribution from the thickness and the le index.\r\n! note - leindex is coded as real, although it is usually integer.\r\n\r\n  real,intent(in):: toc       ! maximum value of t/c\r\n  real,intent(in):: leindex   ! leading edge index\r\n\r\n  real:: rle\r\n  real,parameter:: a=1.1019/36.0  ! see p.117 in abbott & von doenhoff\r\n!-------------------------------------------------------------------------------\r\n  rle=a*(toc*leindex)**2\r\n  return\r\nend function leadingedgeradius4m    ! ------------------------------------------\r\n"}, {"instruction": "Create a Fortran pure function named polynomial to evaluate a polynomial with real coefficients at a given value of x. The function takes 2 input parameters of type real,dimension(:) and real, and returns 1 output parameter of type real.", "input": "", "output": "pure function polynomial(c,x) result(f)\r\n! ------------------------------------------------------------------------------\r\n! purpose - evaluate a polynomial with real coefficients at x\r\n!   f= c(1) + c(2)*x + c(3)*x**2 + c(4)*x**3 + c(5)*x**4 + ...\r\n!   straightforward application of horner's rule.\r\n\r\n  real,intent(in),dimension(:):: c\r\n  real,intent(in):: x\r\n  real:: f\r\n\r\n  real:: ff\r\n\r\n  integer:: j,n\r\n!-------------------------------------------------------------------------------\r\n  n=size(c)\r\n  ff=c(n)\r\n  do j=n-1,1,-1\r\n    ff = ff*x + c(j)\r\n  end do\r\n\r\n  f=ff\r\n  return\r\nend function polynomial   ! ----------------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named period to calculate the period of a repeating decimal when 1 is divided by the given integer value n. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "  pure function period(n)\n    implicit none\n    integer, intent(in)      :: n\n    integer, parameter       :: size=1000000\n    integer, dimension(size) :: quotients,remainders\n    integer                  :: period,i,j\n\n    quotients(1)=0\n    remainders(1)=1\n\n    ! generate sequence of (quotient,remainder) pairs.  a cycle occurs\n    ! when and only when a (quotient,remainder) pair is repeated.\n    do i=2,size\n       quotients(i)=(remainders(i-1)*10)/n\n       remainders(i)=mod(remainders(i-1)*10,n)\n       ! look for a repeated pair\n       do j=1,i-1\n          if (quotients(i)==quotients(j) .and. remainders(i)==remainders(j)) then\n             period=i-j\n             go to 1\n          end if\n       end do\n    end do\n1   continue\n\n  end function period\n"}, {"instruction": "Create a Fortran function named randi to generate a random integer within a specified range. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['integer'].", "input": "", "output": "  function randi(min,max) result(rnum)\n    ! gives a random integer between min and max\n    implicit none\n\n    integer :: min, max, rnum\n    real(4) :: rand_num\n\n    call random_number(rand_num)\n\n    rnum = floor(rand_num * (max+1 - min) + min)\n\n  end function randi\n"}, {"instruction": "Write a Fortran function named random_translation to calculate a new position by randomly translating a given vector within a specified range. The function takes 2 input arguments of type real and real, dimension(3) and returns 1 output argument of type real, dimension(3).", "input": "", "output": "        function random_translation (dr_max, vector) result (new_position)\r\n            implicit none\r\n            real, dimension(3)             :: new_position\r\n            real, intent(in)               :: dr_max\r\n            real, dimension(3), intent(in) :: vector\r\n            real, dimension(3)             :: xyz\r\n\r\n            call random_number(xyz)\r\n            xyz(:) = 2.0 * xyz(:) - 1.0\r\n\r\n            new_position(:) = vector(:) + xyz(:) * dr_max\r\n        end function random_translation\r\n"}, {"instruction": "Write a Fortran function named metropolis to determine whether a proposed change in energy, represented by the input parameter 'delta', should be accepted. The input parameter is of type real, and the output parameter is of type logical. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "        function metropolis ( delta ) result ( accept )\r\n            implicit none\r\n            logical          :: accept\r\n            real, intent(in) :: delta\r\n            real, parameter  :: exponent_guard = 75.0\r\n            real             :: randcomp\r\n\r\n            if ( delta > exponent_guard ) then\r\n                accept = .true.\r\n            else if ( delta < 0.0 ) then\r\n                accept = .false.\r\n            else\r\n                call random_number(randcomp)\r\n                accept = (1 - exp(-delta)) > randcomp\r\n            end if\r\n        end function metropolis\r\n"}, {"instruction": "Create a Fortran function named nthroot to calculate the nth root of a given real number. The function takes 3 input parameters, where the first one is an integer and the next two are real, with the second being mandatory and the third being optional. The function returns a single real number as the output.", "input": "", "output": "  function nthroot(n, a, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: a\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( a < 0 ) then\n       stop \"a < 0\"       ! we handle only real positive numbers\n    elseif ( a == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = a\n    x(2) = a/n   ! starting \"guessed\" value...\n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + a/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n"}, {"instruction": "Write a Fortran function called userfunc that calculates the sine of the sum of two double-precision floating-point numbers. The function should have 2 input parameters of type real(8), and the test_data type is ['real(8)', 'real(8)']. It should produce 1 output parameter of type real(8), and the test_data type is ['real(8)'].", "input": "", "output": "function userfunc(x, y) result(func)\n\n  implicit none\n\n  real(8) :: x, y, func\n\n  func = sin(x + y)\n\nend function userfunc\n"}, {"instruction": "Create a Fortran function named cross to calculate the cross product of two 3D vectors. The function should take 2 input parameters of type real*8, dimension(3) and output 1 parameter of type real*8, dimension(3).", "input": "", "output": "function cross(a, b)\r\n  !\r\n  ! calculates the cross product of 2 3d-vectors\r\n  !\r\n  implicit none\r\n  real*8, dimension(3) :: cross\r\n  real*8, dimension(3), intent(in) :: a, b\r\n  cross(1) = a(2) * b(3) - a(3) * b(2)\r\n  cross(2) = a(3) * b(1) - a(1) * b(3)\r\n  cross(3) = a(1) * b(2) - a(2) * b(1)\r\nend function cross\r\n"}, {"instruction": "Write a Fortran function named intersect that computes the intersection interval \"distance\" of two intervals, each defined by a greater and lesser value. The number of input arguments is 4, and the test_data type is [real, real, real, real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function intersect(begind_a,endd_a,begind_b,endd_b)\n!\nimplicit none\n!\n\n!\nreal :: begind_a,begind_b,endd_a,endd_b\nreal :: intersect\n!\n!     + + + purpose + + +\n!     returns the intersection interval \"distance\" of two intervals\n!     each defined by a greater and lesser value\n!     obviously the units must be consistent.\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     begind_a - lesser value of interval a\n!     endd_a   - greater value of interval a\n!     begind_b - lesser value of interval b\n!     endd_b   - greater value of interval b\n \n!     + + + end specifications + + +\n \nif ((endd_a.le.begind_b).or.(begind_a.ge.endd_b)) then\n  intersect = 0.0\n          ! some part of interval b intersects interval a\nelse if ((begind_a.le.begind_b).and.(endd_a.ge.endd_b)) then\n              ! interval a completely surrounds interval b\n  intersect = endd_b - begind_b\nelse if (begind_a.le.begind_b) then\n              ! top part of interval b intersects farther end of interval a\n  intersect = endd_a - begind_b\nelse if (endd_a.ge.endd_b) then\n              ! farther end of interval b intersects nearer end of interval a\n  intersect = endd_b - begind_a\nelse\n              ! interval b completely surrounds interval a\n  intersect = endd_a - begind_a\nend if\n! \nend function intersect\n"}, {"instruction": "Create a Fortran function named permutations to check if two integers are permutations of each other. The function should take 2 input arguments of type integer. The test_data type for input arguments is ['integer', 'integer']. The function should return 1 output argument of type logical. The test_data type for the output argument is ['logical'].", "input": "", "output": "  pure function permutations(a,b)\n    implicit none\n    integer, intent(in)    :: a,b\n    integer, dimension(10) :: a_ar, b_ar\n    integer                :: i,temp,a_curr,b_curr\n    logical                :: permutations\n\n    do i=1,10\n       a_ar(i)=0\n       b_ar(i)=0\n    end do\n\n    a_curr=a\n    b_curr=b\n\n    do i=1,4\n       temp=mod(a_curr,10)+1\n       a_ar(temp)=a_ar(temp)+1\n\n       temp=mod(b_curr,10)+1\n       b_ar(temp)=b_ar(temp)+1\n\n       a_curr=a_curr/10\n       b_curr=b_curr/10\n    end do\n\n    permutations=all(a_ar == b_ar,1)\n\n  end function permutations\n"}, {"instruction": "Create a Fortran function named getlen to determine the length of a character string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function getlen(string)\n implicit none\n character(len=*), intent(inout):: string\n character(len=256):: chatmp*256\n integer:: nl,getlen\n\n chatmp=adjustl(string)\n nl=len_trim(chatmp)\n string=''\n string=chatmp(1:nl)\n getlen=nl\nend function getlen\n"}, {"instruction": "Write a Fortran function named wave that calculates a complex wave value based on the input parameters. The function takes 4 input parameters of type integer and returns a single output parameter of type complex.", "input": "", "output": "function wave(nlen,kmax,iw,ic)\n implicit none\n integer, parameter :: double=kind(0.0d0)\n real(kind=double), parameter :: pi=3.1415926535897d0, &\n                   p23=2.0d0*pi/3.0d0,p43=4.0d0*pi/3.0d0\n integer, intent(in) :: nlen,kmax,iw,ic\n real(kind=double), dimension(2):: g,p\n real(kind=double):: w,hw,ww,wd,wf,wg,wp,fw\n real:: r1,r2\n integer:: i,j,k\n complex:: wave\n wd=0.0d0\n w=2.0d0*pi*real(iw-1,double)/real(kmax,double)\n hw=w*0.5d0\n ww=dabs(w)\n wave=cmplx(0.0,0.0)\n if(ww >(2.0d0*p43).or.ww < p23) return\n do i=1,2\n   wp=hw*i\n   fw=1.0d0\n   do j=1,2\n     if(j == 1)then\n       wf=-wp\n     else\n       wf=wp\n     end if\n     do k=1,2\n       if(k == 1) wd=p43-wf\n       if(k == 2) wd=wf-p23\n       if(wd <= 0.0d0)then\n         g(k)=0.0d0\n       else\n        g(k)=exp(-1.0/wd/wd)\n       end if\n     enddo\n     wg=g(1)/(g(1)+g(2))\n     fw=fw*wg\n   enddo\n   p(i)=fw\n enddo\n r1=real(hw)\n r2=real(p(1)-p(2))*float(nlen)/float(kmax)\n wave = cmplx(cos(r1),-sin(r1))*csqrt(cmplx(r2, 0.0))\n if(ic == 1) then\n!   w= 2.d0*pi*real(iw-1,double)/real(nlen*dt,double)\n!   wave=wave*cmplx(-sngl(w*w),0.0)\n else\n   wave = conjg(wave)\n endif\n return\nend function wave\n"}, {"instruction": "Create a Fortran function named polynomial to compute the value of a polynomial function for a given argument. The number of input arguments is 2, with test_data types ['integer, dimension(:)', 'real']. The number of output arguments is 1, with a test_data type of ['real'].", "input": "", "output": "  function polynomial ( c, x ) result ( f )\n    implicit none\n    integer, dimension(:), intent(in) :: c ! coefficients of x**0, x**1, x**2 etc\n    real,                  intent(in) :: x ! argument\n    real                              :: f ! result\n\n    integer :: i\n\n    f = 0.0\n    do i = size(c), 1, -1\n       f = f * x + real ( c(i) )\n    end do\n\n  end function polynomial\n"}, {"instruction": "Create a Fortran function named fact to compute the factorial of a given integer input. The input argument is 1 and the test_data type is ['integer']. The output argument is 1 and the test_data type is ['integer'].", "input": "", "output": "function fact(n)\n\n!-------------------------------------------------------------\n!\n! compute the factorial, n!\n!\n!-------------------------------------------------------------\n\nimplicit none\ninteger, intent(in) :: n\ninteger :: fact, i\n\nfact = 1\nif (n > 0) then\n   do i = 1, n\n      fact = fact*i\n   end do\nend if\n\nend function fact\n"}, {"instruction": "Write a Fortran function named get_bath_dimension_symmetries to determine the size of the bath based on the provided complex input array. The function accepts 1 input parameter of type complex(8),dimension(:,:,:,:,:,:,:), and returns 1 output parameter of type integer.", "input": "", "output": "function get_bath_dimension_symmetries(hloc_nn) result(bath_size)\n  complex(8),dimension(:,:,:,:,:,:,:),intent(in)                     :: hloc_nn\n  integer                                                            :: bath_size,ndx,isym,nsym\n  !\n  !number of symmetries\n  nsym=size(hloc_nn(1,1,1,1,1,1,:))\n  !\n  ndx=nsym\n  !\n  !for each replica we also print n_dec\n  ndx=ndx+1\n  !\n  !number of replicas\n  ndx = ndx * nbath\n  !diagonal hybridizations: vs\n  ndx = ndx + nbath\n  !\n  bath_size = ndx\n  !\nend function get_bath_dimension_symmetries\n"}, {"instruction": "Create a Fortran function named count_lines_in_file to calculate the number of lines in a specified file. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t!******************************************************************************\n\t\timplicit none\n\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\n\t\t!the file is assumed to be open already.\n\n\t\trewind(fid)\t  !rewind to beginning of the file\n\n\t\tn_lines = 0\n\t\tdo !read each line until the end of the file.\n\t\t\tread(fid,'(a1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      !end of file\n\t\t\tn_lines = n_lines + 1  !row counter\n\t\tend do\n\n\t\trewind(fid)   !rewind to beginning of the file\t\n\n\t!******************************************************************************\n\t\tend function count_lines_in_file\n"}, {"instruction": "Create a Fortran function named ordered_word to determine if a given word is ordered or not. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical.", "input": "", "output": "\t pure elemental function ordered_word(word) result(yn)\n\t!******************************************************************************\n\t! turns true if word is an ordered word, false if it is not.\n\t!******************************************************************************\n\t\n\t implicit none\n\t character(len=*),intent(in) :: word\n\t logical :: yn\n\t\n\t integer :: i\n\t\n\t yn = .true.\n\t do i=1,len_trim(word)-1\n\t \tif (ichar(word(i+1:i+1))<ichar(word(i:i))) then\n\t \t\tyn = .false.\n\t \t\texit\n\t \tend if\n\t end do\n\t\n\t!******************************************************************************\n\t end function ordered_word\n"}, {"instruction": "Write a Fortran function named f_upcase to convert a given string to uppercase. The function takes 1 input argument with the test_data type ['character(len=*)'], and returns 1 output argument with the test_data type ['character(len=len(string))'].", "input": "", "output": "    function f_upcase(string) result(upper)\n    implicit none\n\n    !i/o variables\n    character(len=*), intent(in) :: string\n    character(len=len(string)):: upper\n\n    !local variables\n    integer:: j\n\n    do j = 1,len(string)\n        if(string(j:j) >= \"a\" .and. string(j:j) <= \"z\") then\n            upper(j:j) = achar(iachar(string(j:j)) - 32)\n        else\n            upper(j:j) = string(j:j)\n        end if\n    end do\n\n    end function f_upcase\n"}, {"instruction": "Create a Fortran function named is_uppercase to determine if a given string consists of all uppercase letters. The function should take 1 input argument of type character(len=*) and return 1 output argument of type logical.", "input": "", "output": "  function is_uppercase(str)\n    logical :: is_uppercase\n    character(len=*),intent(in) :: str\n    character :: chr\n    integer :: i\n    is_uppercase = .false.\n    do i = 1,len_trim(str)\n      chr = str(i:i)\n      if (chr >= 'a' .and. chr <= 'z') then\n        is_uppercase = .false.\n        return\n      else if (chr >= 'a' .and. chr <= 'z') then\n        is_uppercase = .true.\n      end if\n    end do\n  end function is_uppercase\n"}, {"instruction": "Create a Fortran function named sum_array to calculate the sum of elements in an integer array. The function takes 2 input parameters: the size of the array (integer) and the array itself (integer, dimension(size)). It returns 1 output parameter of type integer.", "input": "", "output": "function sum_array(size,a) result(ret)\n  implicit none\n  integer :: size\n  integer, dimension(size) :: a\n  integer :: i\n  integer :: ret\n \n  ret = 0\n  \n  do i=1,size\n    ret = ret + a(i)\n  end do\n  \nend function sum_array\n"}, {"instruction": "Create a Fortran function named \"ij_code\" to determine the integer code corresponding to a given industry represented by a single character. The function takes 1 input parameter of type character(len=1) and returns 1 output parameter of type integer.", "input": "", "output": "    function ij_code(industry)\n\n        implicit none\n        character(len=1), intent(in) :: industry\n        integer :: ij_code\n\n        select case (industry)\n            case('m')\n                ij_code = 1\n            case('f')\n                ij_code = 2\n            case('u')\n                ij_code = 3\n            case('t')\n                ij_code = 4\n            case('s')\n                ij_code = 5\n            case default\n                stop 'industry does not exists'\n        end select\n\n    end function\n"}, {"instruction": "Define a Fortran function named kalbach to calculate optical model reaction cross sections using empirical parameterization. The function takes 6 input parameters of types integer(int32) and real(real64), and returns 1 output parameter of type real (real64).", "input": "", "output": "  function kalbach(kp, zp, ap, zt, at, elab)\n\n! ==============================================================================\n!\n!     written in 1982; revised 1990 by k.k. gudima\n!\n!     calculate optical model reaction cross sections\n!     using empirical parameterization\n!     of narasimha murthy, chaterjee, and gupta\n!     going over to the geometrical limit at high energy\n!\n!           proton cross sections scaled down with signor for a<100\n!           (appropriate for becchetti-greenlees potential)\n!           neutron cross sections scaled down sith signor for a<40\n!           (appropriate for mani et al potential)\n!\n!     parameter values set in subroutine sigpar\n! \n! ==============================================================================\n\n    use, intrinsic :: iso_fortran_env, only: int32, real64\n\n    implicit none\n    integer(int32), intent(in)   :: kp\n    real(real64),   intent(in)   :: zp\n    real(real64),   intent(in)   :: ap\n    real(real64),   intent(in)   :: zt\n    real(real64),   intent(in)   :: at\n    real(real64),   intent(in)   :: elab\n    real (real64)                :: kalbach\n\n    integer(int32) :: jout\n    real(real64)   :: a, ares, athrd, b, c, cut, ec, ecsq, ecut2, etest, flow, &\n         & geom, p, ra, sig, signor, signor2, spill, w, xlamb, xmu, xnu, xnulam\n    real(real64)   :: ecut\n\n! ==============================================================================\n\n    real(real64), parameter, dimension(6) :: xl0 = &\n         & [ 12.10, 0.00437, 0.00619, 0.0186, 0.00459, 0.0643 ]\n    real(real64), parameter, dimension(6) :: xl1 = &\n         & [ -11.27,  -16.58,   -7.54,  -8.90,   -8.93, -13.96 ]\n    real(real64), parameter, dimension(6) :: xm0 = &\n         & [ 234.1,   244.7,   583.5,  686.3,   611.2,  781.2 ]\n    real(real64), parameter, dimension(6) :: xm1 = &\n         & [ 38.26,   0.503,   0.337,  0.325,    0.35,   0.29 ]\n    real(real64), parameter, dimension(6) :: xn0 = &\n         & [ 1.55,   273.1,   421.8,  368.9,   473.8, -304.7 ]\n    real(real64), parameter, dimension(6) :: xn1 = &\n         & [ -106.1,  -182.4,  -474.5, -522.2,  -468.2,  -470. ]\n    real(real64), parameter, dimension(6) :: xn2 = &\n         & [ 1280.8,  -1.872,  -3.592, -4.998,  -2.225, -8.580 ]\n    real(real64), parameter, dimension(6) :: xp0 = &\n         & [ -312.,   15.72,   0.798, -21.45,   -2.88,  10.95 ]\n    real(real64), parameter, dimension(6) :: xp1 = &\n         & [ 0.,    9.65,   420.3,  484.7,   205.6, -85.21 ]\n    real(real64), parameter, dimension(6) :: xp2 = &\n         & [ 0.,   -300.,  -1651., -1608.,  -1487.,  1146. ]\n\n! ==============================================================================\n    \n    flow = 1.e-18\n    spill = 1.e+18\n    jout = nint(ap)\n    ares = at+ap\n    athrd =ares**0.3333\n    signor = 1.\n! signor reduces p and n result for light targs as per expt.\n    if (kp == 1) then\n       if (ares < 40.) signor=0.7+ares*0.0075\n       xlamb = xl0(1)/athrd + xl1(1)\n       xmu = xm0(1)*athrd + xm1(1)*athrd*athrd\n       xnu = xn0(1)*athrd*ares + xn1(1)*athrd*athrd + xn2(1)\n!       ec = 2.4\n!       ecsq = 5.76\n       ec = 0.5\n       ecsq = 0.25\n!       ec = 1.\n!       ecsq = 1.\n       p = xp0(1)\n       xnulam = 1.\n       etest = 32.\n! etest is the energy above which the rxn cross section is\n!    compared with the geometrical limit and the max taken.\n!    xnulam here is a dummy value to be used later.\n       ra = 0.\n    else\n       ra = 1.20\n       if (kp == 2) then\n          ra = 0.\n          if (ares < 60.) then\n             signor = 0.92\n          else if (ares < 100.) then\n             signor = 0.8 + ares*0.002\n          end if\n       end if\n       ec = 1.44*zp*zt/(1.5*athrd+ra)\n       ecsq = ec * ec\n       p = xp0(kp) + xp1(kp)/ec + xp2(kp)/ecsq\n       xlamb = xl0(kp)*ares + xl1(kp)\n       a = ares**xm1(kp)\n       xmu = xm0(kp) * a\n       xnu = a* (xn0(kp)+xn1(kp)*ec+xn2(kp)*ecsq)\n       if (jout == 2) ra=0.8\n       if (jout == 3) ra=0.8\n! new values of ra are for calculating the geometrical limit\n!    to the cross section.\n       if (kp == 2) then\n          c = min(3.15_real64,ec*0.5)\n          w = 0.7 * c / 3.15\n! c and w are for the global corr'n factor for elab<ec\n!    for light targs they are scaled down from global values\n       end if\n       xnulam = xnu / xlamb\n       if (xnulam > spill) xnulam=0.\n       if (xnulam < flow) go to 20\n       if (kp == 2) then\n          etest = sqrt(xnulam) + 7\n       else\n          etest = 1.2 * sqrt(xnulam)\n       end if\n       ! for xnulam > 0, sig reaches a maximum at sqrt(xnulam).\n    end if\n20  a = -2.*p*ec + xlamb - xnu/ecsq\n    b = p*ecsq + xmu + 2.*xnu/ec\n    ecut = 0.\n    cut = a*a - 4.*p*b\n    if (cut > 0.) ecut = sqrt(cut)\n    ecut = (ecut-a) / (p+p)\n    ecut2 = ecut\n\n!    if (ecut < -0.05) then\n!       c = -ecut * 0.5\n!       w = -ecut * 0.1\n!    else if (cut < 0) then\n!       ecut2 = ecut * 0.25\n!    end if\n\n    if (cut < 0) ecut2 = ecut - 2.\n\n!    sigmin = b - 0.25*a*a/p\n! ecut is the energy where sigma=0 (if cut>0).  below ecut2\n!    sigma is set identically to zero to avoid unphysical values.\n    sig = 0.\n    if (elab <= ec) then\n       if (elab > ecut2) then\n          sig = (p*elab*elab+a*elab+b) * signor\n          if (kp == 2) then\n             signor2 = (ec - elab - c) / w\n             signor2 = 1 + exp(signor2)\n             sig = sig / signor2\n\n!             if (ecut < -0.05) then\n!                if (elab < -ecut) then\n!                   signor2 = (c - elab) / w\n!                   signor2 = 1 + exp(signor2)\n!                   sig = sig / signor2\n!                end if\n!             end if\n          end if\n\n! first signor gives empirical global corr'ns at low elab\n!    second signor corrects values near elab=0; light nuclei\n       end if\n    else\n       sig = (xlamb*elab+xmu+xnu/elab) * signor\n       geom = 0.0_real64\n       if (xnulam < flow) go to 36\n       if (elab < etest) go to 36\n       geom = sqrt(ap*elab)\n       geom = 1.23*athrd + ra + 4.573/geom\n       geom = 31.416 * geom * geom\n       sig = max(geom,sig)\n    end if\n36  kalbach=sig\n    return\n\n  end function kalbach\n"}, {"instruction": "Create a Fortran function named fm that takes two integer input arguments with test_data type ['integer', 'integer'] and returns a single real output with test_data type ['real(dp)']. The function computes the value of fm using the formula sqrt( (i_ang + k_ang) * (i_ang - k_ang + 2) / 4.0d0 ). Remember to use the selected real kind dp when declaring the real variable.", "input": "", "output": "function fm(i_ang, k_ang)\n  implicit none\n  integer, parameter :: dp = selected_real_kind(14)\n  \n  integer, intent(in) :: i_ang, k_ang\n  real(dp) :: fm\n\n  fm = sqrt( (i_ang + k_ang) * (i_ang - k_ang + 2) / 4.0d0 )\n  \nend function fm\n"}, {"instruction": "Create a Fortran function named createboard that takes two input arguments of type integer representing the number of rows and columns. The function returns a logical array of 2 dimensions that is dynamically allocated.", "input": "", "output": "    function createboard(rows, cols)\n\n        logical, dimension(:,:), allocatable :: createboard\n        integer, intent(in) :: rows, cols\n        integer :: r,c\n\n        allocate( createboard(rows, cols) )\n\n        do c = 1,cols\n            do r = 1,rows\n                createboard(r,c) = (nint(rand(0)) .eq. 0)\n            end do\n        end do\n\n    end function createboard\n"}, {"instruction": "Create a Fortran function named test_xyz to determine the dimensionality of the input arrays. The function takes 3 input parameters of types real(8), dimension(:,:), real(8), dimension(:,:), and real(4), dimension(:,:), and returns 1 output parameter of type character(len=2).", "input": "", "output": "   function test_xyz(rx, ry, rz)\n      !!\n      !! testing if 2d coordinates or 1d, and if match shape of data...\n      !!\n      character(len=2) :: test_xyz\n      !!\n      real(8), dimension(:,:), intent(in) :: rx, ry\n      real(4), dimension(:,:), intent(in) :: rz\n      !!\n      integer :: ix1, ix2, iy1, iy2, iz1, iz2\n      !!\n      ix1 = size(rx,1) ; ix2 = size(rx,2)\n      iy1 = size(ry,1) ; iy2 = size(ry,2)\n      iz1 = size(rz,1) ; iz2 = size(rz,2)\n      !!\n      if ( (ix2 == 1).and.(iy2 == 1) ) then\n         !!\n         if ( (ix1 == iz1).and.(iy1 == iz2) ) then\n            test_xyz = '1d'\n         else\n            print *, 'error, mod_drown.f90 = >test_xyz 1 : longitude and latitude array do not match data!'\n            print *, ''; stop\n         end if\n         !!\n      else\n         if ( (ix1 == iz1).and.(iy1 == iz1).and.(ix2 == iz2).and.(iy2 == iz2) ) then\n            test_xyz = '2d'\n         else\n            print *, 'error, mod_drown.f90 = >test_xyz 2 : longitude and latitude array do not match data!'\n            print *, ''; stop\n         end if\n      end if\n      !!\n      !!\n   end function test_xyz\n"}, {"instruction": "Create a Fortran function named liftf to calculate the lift. The function takes 1 input argument of type real, and returns 1 output argument of type real. The input argument is the velocity (vel), and the output argument is the lift force (liftf).", "input": "", "output": "     function liftf(vel) ! calculate lift\n      real :: vel, liftf\n      liftf = cl*(1./2)*rho*(vel**2)*wparea\n      return\n      end function liftf\n"}, {"instruction": "Create a Fortran function named dragf to calculate the drag force. The function takes 1 input parameter of type real. The output is 1 parameter of type real. The formula to calculate the drag force is given by dragf = cd * (1./2) * rho * (vel**2) * wparea, where cd, rho, and wparea are assumed to be predefined. Use the return statement to return the calculated drag force.", "input": "", "output": "     function dragf(vel) ! calculate drag\n      real :: vel, dragf\n      dragf = cd*(1./2)*rho*(vel**2)*wparea\n      return\n      end function dragf\n"}, {"instruction": "Create a Fortran function named fstring_hashkey that takes a string as input and returns an integer output. The input parameter should be of type character(*) and the output parameter should be of type integer. This function calculates a hash key for the input string and returns the result as an integer.", "input": "", "output": "\tfunction fstring_hashkey( str ) result( output )\n\t\tcharacter(*), intent(in) :: str\n! \t\tlogical, optional, intent(in) :: debug\n\t\tinteger :: output\n\t\t\n\t\tinteger :: i\n\t\t\n! \t\tlogical :: effdebug\n! \t\t\n! \t\teffdebug = .false.\n! \t\tif( present(debug) ) effdebug = debug\n\t\t\n\t\toutput = 0\n\t\tdo i=1,len(str)\n! \t\t\tif( effdebug ) then\n! \t\t\t\twrite(0,*) str(i:i), \"-->\", ichar(str(i:i)), \" : \", ichar(str(i:i))*31**(len(str)-i)\n! \t\t\tend if\n\t\t\t\n\t\t\toutput = output + ichar(str(i:i))*31**(len(str)-i)\n\t\tend do\n\t\t\n! \t\tif( effdebug ) then\n! \t\t\twrite(0,*) \"key --> \", output\n! \t\tend if\n\t\t\n\tend function fstring_hashkey\n"}, {"instruction": "Create a Fortran function named cc to calculate the value of c, used in the height field computation for the Rossby-Haurwitz wave. The function takes 1 input parameter of type real (kind=rkind) and returns 1 output parameter of type real (kind=rkind). Use the following formula to calculate the value of c: cc = 0.25 * k**2.0 * cos(theta)**(2.0*r) * ((r+1.0)*cos(theta)**2.0 - r - 2.0).", "input": "", "output": "function cc(theta)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  ! c, used in height field computation for rossby-haurwitz wave\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n  implicit none\n\n  integer, parameter :: rkind  = selected_real_kind(12)\n  real (kind=rkind), parameter :: w = 7.848e-6\n  real (kind=rkind), parameter :: k = 7.848e-6\n  real (kind=rkind), parameter :: r = 4.0\n\n  real (kind=rkind), intent(in) :: theta\n  real (kind=rkind) :: cc\n\n  cc = 0.25 * k**2.0 * cos(theta)**(2.0*r) * ((r+1.0)*cos(theta)**2.0 - r - 2.0)\n\nend function cc\n"}, {"instruction": "Create a Fortran function named loadoptionalparam_int to handle the loading of an optional integer parameter with a default value. The function takes 2 input parameters: defaultvalue of type integer and iparam of type integer, which is optional. It returns a single output parameter of type integer. If the optional parameter is present, the function assigns its value to loadoptionalparam_int; otherwise, it assigns the default value to it.", "input": "", "output": "  function loadoptionalparam_int(defaultvalue,iparam)\r\n    !tue dec, 2014\r\n\n    !io\r\n    !defaultvalue -> a default value which we load if the optional parameter does not exist.\r\n    !iparam       -> the optional parameter that we want to load\r\n    implicit none\r\n    integer, intent(in)          :: defaultvalue\r\n    integer, intent(in),optional :: iparam\r\n    integer                      :: loadoptionalparam_int\r\n    if(present(iparam)) then\r\n        loadoptionalparam_int=iparam\r\n      else \r\n        loadoptionalparam_int=defaultvalue\r\n      end if\r\n  end function loadoptionalparam_int\r\n"}, {"instruction": "Create a Fortran function named loadoptionalparam_real2 to handle optional parameters. The function takes 2 input parameters of type integer and real*8, where the second parameter is optional. It returns 2 output parameters of type real*8 and loadoptionalparam_real2(defaultvalue,iparam).", "input": "", "output": "  function loadoptionalparam_real2(defaultvalue,iparam)\r\n    !tue dec, 2014\r\n\n    !io\r\n    !defaultvalue -> a default value which we load if the optional parameter does not exist.\r\n    !iparam       -> the optional parameter that we want to load\r\n    implicit none\r\n    integer, intent(in)          :: defaultvalue\r\n    real*8, intent(in),optional :: iparam\r\n    real*8                      :: loadoptionalparam_real2\r\n    if(present(iparam)) then\r\n        loadoptionalparam_real2=iparam\r\n      else \r\n        loadoptionalparam_real2=defaultvalue\r\n      end if\r\n  end function loadoptionalparam_real2\r\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci sequence. The function takes 1 input argument with the data type integer. It returns 1 output argument with the data type integer.", "input": "", "output": "recursive function fib(x) result(ret)\n  integer, intent(in) :: x\n  integer :: ret\n  \n  if (x == 1 .or. x == 2) then\n    ret = 1\n  else\n    ret = fib(x-1) + fib(x-2)\n  end if\n\nend function fib\n"}, {"instruction": "Create a recursive Fortran function named fibonacci to calculate the Fibonacci sequence for the given input integer value i. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameters are represented by the test_data type ['integer'].", "input": "", "output": "        recursive function fibonacci(i) result(fibo)\r\n         integer, intent(in) :: i\r\n         integer :: fibo\r\n\r\n           if (i <= 1) then\r\n               fibo = 1\r\n                 else\r\n               fibo = fibonacci(i-1) + fibonacci(i-2)\r\n           end if\r\n\r\n           end function fibonacci\r\n"}, {"instruction": "Write a Fortran function named lambert_w to calculate the Lambert W function. The function takes 2 input parameters of type integer and real and returns 1 output parameter of type real. Use an iterative approach to approximate the value of the Lambert W function within a specified accuracy.", "input": "", "output": "function lambert_w(x, accuracy) result(y)\n    integer :: count, i, m\n    integer :: accuracy\n    real :: x, y, str, w\n\n    w = 0\n    y = 0\n    str = 0\n    i = 0\n    count = 0\n    m = 0\n\n10  if (abs(w - x) .gt. (real(1)/accuracy) .and. m .lt. accuracy) then\n        i = i + 1\n        m = (10 ** count)\n        y = str + real(i)/m\n        w = y * exp(y)\n        if (w .gt. x) then\n            y = str + real(i-1)/m\n            str = y\n            i = 0\n            count = count + 1\n        end if\n        goto 10\n    end if\nend function lambert_w\n"}, {"instruction": "Write a Fortran function named dirac_delta to calculate the Dirac delta function. The function takes 2 input arguments of type real and returns 1 output argument of type real. The test_data type for input arguments is [real, real], and for the output argument, it is [real].", "input": "", "output": "function dirac_delta(n, x) result(y)\n    real :: x, y, n\n    if (abs(x) > 1/(2*x)) then\n        y = 0\n    else\n        y = n \n    end if\nend function dirac_delta\n"}, {"instruction": "Create a Fortran recursive function named fact to compute the factorial of an integer. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. The input parameter is denoted by test_data type ['integer'], and the output parameter by test_data type ['integer'].", "input": "", "output": "recursive function fact(n) result(answer)\nimplicit none\ninteger, intent(in) :: n\ninteger :: answer\nif (n >= 1) then\n  answer = n * fact(n-1)\nelse\n  answer = 1\nend if\nend function fact\n"}, {"instruction": "Create a Fortran function named get_kinematic_viscosity to calculate the kinematic viscosity of a fluid based on the input parameters. The function takes in 4 real(kind=8) input parameters (mu_ref, t_ref, t, rho) and returns 1 real(kind=8) output parameter (nu).", "input": "", "output": "    function get_kinematic_viscosity(mu_ref, t_ref, t, rho) result(nu)\n        implicit none\n        real(kind=8), intent(in):: mu_ref ! cp, i.e., 1e-3 kg / m /s\n        real(kind=8), intent(in):: t_ref ! celsius\n        real(kind=8), intent(in):: t ! celsius\n        real(kind=8), intent(in):: rho ! kg / m^3\n        real(kind=8):: nu\n\n        ! get dynamic viscosity at ambient temperature (unit: cp)\n        nu = mu_ref**(-0.2661d0) + (t - t_ref) / 233d0\n        nu = - dlog(nu) / 0.2661d0\n        nu = dexp(nu)\n\n        ! convert to kg / s / m\n        nu = nu * 1d-3\n\n        ! get kinematic viscosity (m^2 / s)\n        nu = nu / rho\n    end function get_kinematic_viscosity\n"}, {"instruction": "Create a Fortran function named num_group_perms that takes an array of integers as input. The input parameter should be of type integer and have an unspecified dimension. The function should return a single integer as output.", "input": "", "output": "  function num_group_perms(group)\n    implicit none\n    integer :: num_group_perms, n_members\n    integer, dimension(:) :: group\n    integer, dimension(8) :: factorial\n\n    factorial = (/ 1,2,6,24,120,720,5040,40320 /)\n    n_members = ceiling(log10(real(maxval(group))))\n    num_group_perms = factorial(n_members)\n    return\n  end function num_group_perms\n"}, {"instruction": "Create a Fortran function named combine_perms that takes two input arrays of integers and returns a new array obtained by combining the elements of the first array based on the indices specified by the elements of the second array. The number of input arguments is 2 and the test_data type is ['integer, dimension(:)', 'integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, dimension(:), allocatable'].", "input": "", "output": "  function combine_perms(vec1,vec2)\n  implicit none\n  integer, dimension(:), intent(in) :: vec1, vec2\n  integer, dimension(:), allocatable :: combine_perms\n  integer :: j\n  allocate(combine_perms(size(vec1)))\n\n  if (size(vec1) /= size(vec2)) then\n    write(*,*) \"combine_perms received vectors of mismatched lengths\"\n    call exit(1)\n  end if\n\n  do j=1,size(vec1)\n    combine_perms(j) =  vec1(vec2(j))\n  end do\n  return\n  end function combine_perms\n"}, {"instruction": "Write a Fortran function named fibonacci to calculate the Fibonacci sequence up to the given integer input. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "    recursive function fibonacci(n) result(res_cyml)\n        implicit none\n        integer, intent(in) :: n\n        integer:: res_cyml\n        if(n .le. 1) then\n            res_cyml = n\n        else\n            res_cyml = fibonacci(n - 1) + fibonacci(n - 2)\n        end if\n    end function fibonacci\n"}, {"instruction": "Create a Fortran function named wrap to ensure that an input angle is within the range of 0 to 360 degrees. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. If the input angle is negative, it will be converted to the equivalent positive angle within the 0 to 360 degree range.", "input": "", "output": "    pure function wrap(angle) result(wrapped_angle)\n    !! wrap from 0 -> 360\n    implicit none \n    integer,intent(in) :: angle\n    integer :: wrapped_angle\n    wrapped_angle = mod(angle, 360)\n    if (wrapped_angle<0) wrapped_angle = wrapped_angle + 360\n    end function wrap\n"}, {"instruction": "Create a Fortran function named fibi to calculate the nth Fibonacci number based on the input parameter n, which is an integer. The function has one input argument of type integer and one output argument of type integer.", "input": "", "output": "    function fibi(n)\n        integer, intent(in) :: n\n        integer, parameter :: fib0 = 0, fib1 = 1\n        integer            :: fibi, back1, back2, i\n\n        select case (n)\n            case (:0);      fibi = fib0\n            case (1);       fibi = fib1\n\n            case default\n                fibi = fib1\n                back1 = fib0\n                do i = 2, n\n                    back2 = back1\n                    back1 = fibi\n                    fibi   = back1 + back2\n                end do\n         end select\n    end function fibi\n"}, {"instruction": "Create a Fortran function named linspace that generates a linearly spaced array of real numbers between a specified start and stop value. The function should take 3 input parameters of types integer, real(8), and real(8), representing the number of points, the start value, and the stop value respectively. The output should be a real(8) array of size n containing the linearly spaced values.", "input": "", "output": "  function linspace(my_start, my_stop, n)\n    implicit none\n    integer :: n, i\n    real(8) :: my_start, my_stop, step\n    real(8), dimension(n) :: grid, linspace\n\n    if (n.eq.1) then\n      grid(n) = (my_start+my_stop)/2.d0\n    elseif (n.ge.2) then\n      grid(1) = my_start\n      if (n.gt.2) then\n        step = (my_stop-my_start)/(real(n-1))\n        do i = 2, n-1\n          grid(i) = grid(i-1) + step\n        end do\n      end if\n      grid(n) = my_stop\n    endif\n    linspace = grid\n  end function linspace\n"}, {"instruction": "Create a Fortran function named my_ss that computes steady-state distribution using a transition matrix. The function has 2 input parameters: an integer and a 2D array of double-precision real numbers. The output is a 1D array of double-precision real numbers.", "input": "", "output": "  function my_ss(tmatrix,gp)\n    implicit none\n    integer :: gp\n    integer :: row, col, iter\n    real(8) :: aux_sum\n    real(8), dimension(gp) :: my_ss\n    real(8), dimension(gp) :: dist, ndist\n    real(8), dimension(gp,gp) :: tmatrix\n\n    ! initialise distribution\n    dist = 1.d0/real(gp)\n\n    do iter = 1, 10000\n      ndist = 0.d0\n      do col = 1, gp\n        do row = 1, gp\n          ndist(col) = ndist(col) + (dist(row)*tmatrix(row,col))\n        end do\n      end do\n      aux_sum = sum(abs(ndist-dist))\n      dist = ndist\n      if (aux_sum.lt.1.0d-8) then\n        exit\n      end if\n    end do\n\n    my_ss = dist\n  end function my_ss\n"}, {"instruction": "Write a Fortran function named fact that calculates the factorial of a given integer. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function fact(n) result(answer)\r\n!\r\n!  purpose:\r\n\n!             | n(n-1)!    n >= 1 \r\n!       n ! = |\r\n!             | 1          n = 0\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    12/07/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n         ! value to calculate\r\ninteger :: answer                ! result variable\r\n\r\nif ( n >= 1 ) then\r\n   answer = n * fact(n-1)\r\nelse\r\n   answer = 1\r\nend if\r\n\r\nend function fact\r\n"}, {"instruction": "Create a Fortran function named adjust_timestep to calculate the adjusted time step based on the input parameters. The function takes 4 input parameters of type real(8), real(8), real(8), and integer(8). The output parameter is a real(8).", "input": "", "output": "    function adjust_timestep(dt, err, q, t_tot)\n        implicit none\n        real(8), intent(in) :: dt, err, t_tot\n        integer(8), intent(in) :: q\n        real(8) :: adjust_timestep\n        real(8) :: fac\n!        real :: facmax=6., facmin=0.01\n!        real :: fac\n        fac = 0.38**(1. / (1. + q))\n        adjust_timestep = dt * fac * err**(-1. / (1. + q))\n!        print *, \"adjust timestep\", adjust_timestep, dt, fac, err\n!        if (adjust_timestep > facmax * dt) then\n!            adjust_timestep = facmax * dt\n!        else if (adjust_timestep < facmin * dt) then\n!            adjust_timestep = facmin * dt\n        if ((adjust_timestep / t_tot < 1e-12) .or. isnan(adjust_timestep)) then\n            adjust_timestep = t_tot * 1e-12\n        end if\n    end function adjust_timestep\n"}, {"instruction": "Create a Fortran function named center_of_mass that takes in 3 input parameters: an 8-byte integer \"n\", an array of 8-byte real numbers \"masses\" with dimension \"n\", and a 2D array of 8-byte real numbers \"positions\" with dimensions \"n\" and 3. The function returns a 1D array of 8-byte real numbers \"center_of_mass\" with dimensions 3 as the output parameter. The function calculates the center of mass based on the input masses and positions.", "input": "", "output": "    function center_of_mass(n, masses, positions)\n        implicit none\n        integer(8), intent(in) :: n\n        real(8), intent(in), dimension(n) :: masses\n        real(8), intent(in), dimension(n, 3) :: positions\n        real(8), dimension(3) :: center_of_mass\n        integer(8) :: i\n        center_of_mass = 0.\n        do i=1, n\n            center_of_mass(:) = center_of_mass(:) + masses(i) * positions(i, :)\n        end do\n    end function center_of_mass\n"}, {"instruction": "Write a Fortran function named average_vel to calculate the average velocity of a system. The function takes 3 input parameters: an integer (8) 'n', an array of real (8) numbers with dimension 'n' for masses, and a 2D array of real (8) numbers with dimension 'n' by 3 for velocities. The output is a 1D array of real (8) numbers with dimension 3, representing the average velocity in each direction.", "input": "", "output": "    function average_vel(n, masses, velocities)\n        implicit none\n        integer(8), intent(in) :: n\n        real(8), intent(in), dimension(n) :: masses\n        real(8), intent(in), dimension(n, 3) :: velocities\n        real(8), dimension(3) :: average_vel\n        integer(8) :: i\n        average_vel = 0.\n        do i=1, n\n            average_vel(:) = average_vel(:) + masses(i) * velocities(i, :)\n        end do\n    end function average_vel\n"}, {"instruction": "Create a Fortran function called linspace to generate an array of evenly spaced numbers over a specified range. The function takes 3 input parameters of types double precision, double precision, and integer, and returns 1 output parameter of type double precision with dimension nx. The function calculates the step size based on the input range and the number of points, then uses parallel processing to populate the output array with evenly spaced values.", "input": "", "output": "function linspace(x0, x1, nx) result(xs)\n\n    implicit none\n\n    double precision, intent(in) :: x0\n    double precision, intent(in) :: x1\n    integer, intent(in) :: nx\n\n    double precision, dimension(nx) :: xs\n\n    integer :: i\n    double precision :: step\n\n    step = (x1 - x0) / (nx - 1)\n\n    !$omp parallel do\n    do i = 1, nx\n        xs(i) = x0 + (i - 1) * step\n    enddo\n    !$omp end parallel do\n\nend function linspace\n"}, {"instruction": "Create a Fortran function called calc_angle to calculate the angle between two vectors a, b, and c. The function takes 3 input parameters of type double precision and dimension(3) for vectors a, b, and c, and returns 1 output parameter of type double precision for the angle.", "input": "", "output": "function calc_angle(a, b, c) result(angle)\n\n    implicit none\n\n    double precision, intent(in), dimension(3) :: a\n    double precision, intent(in), dimension(3) :: b\n    double precision, intent(in), dimension(3) :: c\n\n    double precision, dimension(3) :: v1\n    double precision, dimension(3) :: v2\n\n    double precision :: cos_angle\n    double precision :: angle\n\n    v1 = a - b\n    v2 = c - b\n\n    v1 = v1 / norm2(v1)\n    v2 = v2 / norm2(v2)\n\n    cos_angle = dot_product(v1,v2)\n\n    ! clipping\n    if (cos_angle > 1.0d0) cos_angle = 1.0d0\n    if (cos_angle < -1.0d0) cos_angle = -1.0d0\n\n    angle = acos(cos_angle)\n\nend function calc_angle\n"}, {"instruction": "Create a Fortran function named calc_cos_angle that calculates the cosine of the angle between two vectors defined by three-dimensional double precision arrays. The function takes 3 input parameters of type double precision, dimension(3) representing the vectors a, b, and c, and returns 1 output parameter of type double precision representing the cosine of the angle.", "input": "", "output": "function calc_cos_angle(a, b, c) result(cos_angle)\n\n    implicit none\n\n    double precision, intent(in), dimension(3) :: a\n    double precision, intent(in), dimension(3) :: b\n    double precision, intent(in), dimension(3) :: c\n\n    double precision, dimension(3) :: v1\n    double precision, dimension(3) :: v2\n\n    double precision :: cos_angle\n\n    v1 = a - b\n    v2 = c - b\n\n    v1 = v1 / norm2(v1)\n    v2 = v2 / norm2(v2)\n\n    cos_angle = dot_product(v1,v2)\n\nend function calc_cos_angle\n"}, {"instruction": "Create a Fortran function named count_lines that takes two input parameters: filename_data of type character(len=*) and maxlines of type integer. This function counts the number of valid lines in a file specified by filename_data, up to a maximum of maxlines. The function returns the count of valid lines as an integer.", "input": "", "output": "function count_lines(filename_data, maxlines)\n    implicit none\n    character(len=*) :: filename_data   \n    integer, intent(in) :: maxlines\n    integer:: count_lines \n    integer :: i , counter\n    integer, parameter :: fid_param=251    \n    character*255 :: param_name, param_val\n    integer :: io\n\n    counter=0\n    open(fid_param,file=trim(filename_data) ,action='read')\n    do i = 1, maxlines\n        read(fid_param, *, iostat=io)  param_name, param_val\n        \n        if (io .eq. 0 ) then\n            counter=counter+1\n        else\n            exit\n        end if\n    end do\n    close(fid_param)\n    write(*,*) \"detected \", counter, \" valid lines.\"\n    count_lines=counter\n    \nend function count_lines\n"}, {"instruction": "Write a Fortran pure function named is_prime to determine whether a given integer is a prime number. The number of input arguments is 1 and the test_data type is [integer(8)]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  pure function is_prime(targ)\n    ! default\n    implicit none\n\n    integer(8), intent(in) :: targ\n    logical                :: is_prime\n\n    ! local variables\n    integer(8) :: i,max_try\n\n    ! find the max we should try\n    max_try = int(sqrt(1d0*targ))\n\n    do i=2,max_try\n       if (mod(targ,i)==0) then\n          is_prime = .false.\n          return\n       endif\n    enddo\n\n    is_prime = .true.\n    return\n  end function is_prime\n"}, {"instruction": "Create a Fortran function named formatfiletime to format date and time values into a character string. The function takes 4 input parameters of type integer representing the year, month, day, and hour. It returns 1 output parameter of type character with a length of 11. The function formats the input date and time values and stores the result in the output parameter \"sdate\".", "input": "", "output": "    function formatfiletime(iyear, imonth, iday, ihour) result(sdate)\n    \n        ! routine arguments\n        integer, intent(in) :: iyear\n        integer, intent(in) :: imonth\n        integer, intent(in) :: iday\n        integer, intent(in) :: ihour\n        character(len=11)   :: sdate\n        \n        ! locals\n        integer :: itotalyear\n        \n        ! format date\n        if(iyear > 100) then\n            write(sdate,\"(i4.4,2i2.2,'.',i2.2)\") iyear, imonth, iday, ihour\n        else\n            if(iyear < 70) then\n                itotalyear = iyear + 2000\n            else\n                itotalyear = iyear + 1900\n            end if\n            write(sdate,\"(i4.4,2i2.2,'.',i2.2)\") itotalyear, imonth, iday, ihour\n        end if\n        \n    end function formatfiletime\n"}, {"instruction": "Create a Fortran function named lowercase to convert a given string to lowercase. The function takes 1 input argument of type character (len=*) and returns 1 output argument of type character (len=len_trim(str)).", "input": "", "output": "  function lowercase(str) result(lcstr)\n\n    ! convert string to lower case\n\n    character (len=*):: str\n    character (len=len_trim(str)):: lcstr\n    integer :: ilen, ioffset, iquote, iav, iqc, i\n\n    ilen=len_trim(str)\n    ioffset=iachar('a')-iachar('a')\n    iquote=0\n    lcstr=str\n    do i=1,ilen\n      iav=iachar(str(i:i))\n      if(iquote==0 .and. (iav==34 .or.iav==39)) then\n        iquote=1\n        iqc=iav\n        cycle\n      end if\n      if(iquote==1 .and. iav==iqc) then\n        iquote=0\n        cycle\n      end if\n      if (iquote==1) cycle\n      if(iav >= iachar('a') .and. iav <= iachar('z')) then\n        lcstr(i:i)=achar(iav-ioffset)\n      else\n        lcstr(i:i)=str(i:i)\n      end if\n    end do\n    return\n\n  end function lowercase\n"}, {"instruction": "Write a Fortran function named libtetrabz_polstat_1231 to calculate the value of w using six input parameters of type real(8). The input parameters are g1, g2, g3, lng1, lng2, and lng3. The output parameter, w, is also of type real(8).", "input": "", "output": "function libtetrabz_polstat_1231(g1,g2,g3,lng1,lng2,lng3) result(w)\n  !\n  real(8),intent(in) :: g1,g2,g3,lng1,lng2,lng3\n  real(8) :: w\n  !\n  real(8) :: w2, w3\n  !\n  w2 = ((lng2 - lng1)/(g2 - g1)*g2 - 1d0)*g2**2/(g2 - g1) - g1/( &\n  &   2d0)\n  w2 = w2/(g2 - g1)\n  w3 = ((lng3 - lng1)/(g3 - g1)*g3 - 1d0)*g3**2/(g3 - g1) - g1/( &\n  &   2d0)\n  w3 = w3/(g3 - g1)\n  w = (w3 - w2)/(g3 - g2)\n  !\nend function libtetrabz_polstat_1231\n"}, {"instruction": "Create a Fortran function named libtetrabz_polstat_1233 to calculate the interpolation weight for a given set of input parameters. The function takes 6 input arguments of type real(8) and returns 1 output argument of type real(8). Provide the input arguments g1, g2, g3, lng1, lng2, and lng3, and the function will compute the interpolation weight and return the result in the variable w.", "input": "", "output": "function libtetrabz_polstat_1233(g1,g2,g3,lng1,lng2,lng3) result(w)\n  !\n  real(8),intent(in) :: g1,g2,g3,lng1,lng2,lng3\n  real(8) :: w\n  !\n  real(8) :: w2, w3\n  !\n  w2 = (lng2 - lng1)/(g2 - g1)*g2 - 1d0\n  w2 = (g2*w2)/(g2 - g1)\n  w3 = (lng3 - lng1)/(g3 - g1)*g3 - 1d0\n  w3 = (g3*w3)/(g3 - g1)\n  w2 = (w3 - w2)/(g3 - g2)\n  w3 = (lng3 - lng1)/(g3 - g1)*g3 - 1d0\n  w3 = 1d0 - (2d0*w3*g1)/(g3 - g1)\n  w3 = w3/(g3 - g1)\n  w = (g3*w3 - g2*w2)/(g3 - g2)\n  !\nend function libtetrabz_polstat_1233\n"}, {"instruction": "Create a Fortran function named \"libtetrabz_polstat_1221\" to calculate a value \"w\" based on the input parameters \"g1\", \"g2\", \"lng1\", and \"lng2\". The input parameters are of type real(8). The output parameter \"w\" is also of type real(8).", "input": "", "output": "function libtetrabz_polstat_1221(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1, g2, lng1, lng2\n  real(8) :: w\n  !\n  w = 1d0 - (lng2 - lng1)/(g2 - g1)*g1\n  w = -1d0 + (2d0*g2*w)/(g2 - g1)\n  w = -1d0 + (3d0*g2*w)/(g2 - g1)\n  w = w/(2d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1221\n"}, {"instruction": "Create a Fortran function named libtetrabz_polstat_1222 that calculates a result based on four input real(8) numbers. The input parameters are g1, g2, lng1, and lng2. The function returns a single real(8) result denoted by w.", "input": "", "output": "function libtetrabz_polstat_1222(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1, g2, lng1, lng2\n  real(8) :: w\n  !\n  w = (lng2 - lng1)/(g2 - g1)*g2 - 1d0\n  w = (2d0*g1*w)/(g2 - g1) - 1d0\n  w = (3d0*g1*w)/(g2 - g1) + 1d0\n  w = w/(2d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1222\n"}, {"instruction": "Create a Fortran function named \"libtetrabz_polstat_1211\" that takes four real(8) input parameters: g1, g2, lng1, and lng2. It returns a single real(8) output parameter. The function calculates and returns the value of \"w\" based on the input parameters using a series of mathematical operations.", "input": "", "output": "function libtetrabz_polstat_1211(g1,g2,lng1,lng2) result(w)\n  !\n  real(8),intent(in) :: g1,g2,lng1,lng2\n  real(8) :: w\n  !\n  w = -1d0 + (lng2 - lng1)/(g2 - g1)*g2\n  w = -1d0 + (2d0*g2*w)/(g2 - g1)\n  w = -1d0 + (3d0*g2*w)/(2d0*(g2 - g1))\n  w = w/(3d0*(g2 - g1))\n  !\nend function libtetrabz_polstat_1211\n"}, {"instruction": "Provide a Fortran function named frequency to calculate the resonant frequency of an RLC circuit.\nThe function should have 3 input parameters of type real: r, l, and c.\nThe function should have 1 output parameter of type real: frequency.\nThe resonant frequency is computed using the formula: \nfrequency = 1.0 / (2 * pi * (l * c) ** 0.5), where pi is a predefined constant.\nEnsure that the function returns the calculated frequency.", "input": "", "output": "function frequency(r, l, c)\n    implicit none\n    real, parameter :: pi = 3.1415926535\n    real :: r\n    real :: l\n    real :: c\n    real :: frequency\n    frequency = 1.0 / (2 * pi * (l * c) ** 0.5)\n    return\nend function\n"}, {"instruction": "Write a Fortran function named \"compute_half_step_velocity\" to calculate the velocity at half the time step from the initial velocity and force. The function should take 4 input parameters of type real(8) and dimension(3) representing initial velocity v0, force f0, mass m, and time step dt. The output parameter should be a real(8) array of dimension(3) representing the velocity at half time step, and the test_data type for input and output parameters are ['real(8), dimension(3)', 'real(8), dimension(3)', 'real(8)', 'real(8)'] and ['real(8), dimension(3)'] respectively.", "input": "", "output": "  function compute_half_step_velocity(v0,f0,m,dt) result(v_half)\n    ! velocity at half time step from initial\n    ! velocity and force\n    implicit none\n    real(8), dimension(3), intent(in) :: v0, f0\n    real(8), intent(in) :: m, dt\n    real(8), dimension(3) :: v_half\n    v_half = v0 + 0.5*f0/m*dt\n  end function compute_half_step_velocity\n"}, {"instruction": "Write a Fortran function named compute_new_position to calculate the new position based on the initial position, half-step velocity, and time step. The input parameters consist of 3 arguments of types real(8), dimension(3), real(8), dimension(3), and real(8) respectively. The output is a single argument of type real(8), dimension(3).", "input": "", "output": "  function compute_new_position(r0,v_half,dt) result(r1)\n    ! new position from initial position\n    ! and half step velocity\n    implicit none\n    real(8), dimension(3), intent(in) :: r0, v_half\n    real(8), intent(in) :: dt\n    real(8), dimension(3) :: r1\n    r1 = r0 + v_half*dt\n  end function compute_new_position\n"}, {"instruction": "Create a Fortran function named adsubcl that takes two integer input parameters and returns an integer output parameter. The number of input parameters is 2, with the test_data type as ['integer', 'integer'], and the number of output parameters is 1 with the test_data type as ['integer']. The function retrieves a specific value from a common block based on the input parameters and returns it.", "input": "", "output": "function   adsubcl( itape, isub )\n!******************************************************************\n!******************************************************************\n!** this routine was generated by automatic differentiation.     **\n!** fastopt: transformation of algorithm in fortran, taf 1.9.22  **\n!******************************************************************\n!******************************************************************\n!==============================================\n! all entries are defined explicitly\n!==============================================\nimplicit none\n\n!==============================================\n! declare common blocks\n!==============================================\ninteger :: adcomm1(1,4)\ncommon /adcomm/ adcomm1\n\n!==============================================\n! declare arguments\n!==============================================\ninteger :: adsubcl\ninteger :: isub\ninteger :: itape\n\nadsubcl = adcomm1(itape,isub)\nend function   adsubcl\n"}, {"instruction": "Create a Fortran function named checkvar to analyze the input data and compute the maximum, minimum, and mean values of a 2D array while providing a descriptive message. The function takes 3 input parameters of types integer(kind = 4), dimension(:,:), real(kind = 4), dimension(:,:), and character(len = *), optional. It returns 1 output parameter of type character(len = 200).", "input": "", "output": "    function checkvar(a2dvarvalue, a2ivarmask, svarname)   result(svarcheck)\n        \n        !------------------------------------------------------------------------------------\n        ! variable(s) declaration\n        integer(kind = 4), dimension(:,:)   :: a2ivarmask\n        real(kind = 4), dimension(:,:)      :: a2dvarvalue\n        \n        character(len = *), optional       :: svarname\n        \n        real(kind = 4)                      :: dvarmaxvalue, dvarminvalue, dvarmeanvalue\n        \n        character(len = 20)                 :: svarmaxvalue, svarminvalue, svarmeanvalue\n        character(len = 200)                :: svarcheck\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! initialize variable(s)\n        dvarmaxvalue = -9999.0; dvarminvalue = -9999.0; dvarmeanvalue = -9999.0\n        svarcheck = \"\"\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! define name if not defined\n        if (.not. present(svarname)) then\n            svarname = 'var'\n        endif\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! compute maximum value\n        dvarmaxvalue = maxval(a2dvarvalue, mask=a2ivarmask.gt.0.0)\n        write(svarmaxvalue, *) dvarmaxvalue\n        ! compute minimum value\n        dvarminvalue = minval(a2dvarvalue, mask=a2ivarmask.gt.0.0)\n        write(svarminvalue, *) dvarminvalue\n        ! compute average value\n        dvarmeanvalue = sum(a2dvarvalue, mask=a2ivarmask.gt.0.0)/max(1,count(a2ivarmask.gt.0.0))\n        write(svarmeanvalue, *) dvarmeanvalue\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! print check message\n        svarcheck = trim(svarname)//\" :: max: \"//trim(svarmaxvalue)//\" - min: \"//trim(svarminvalue)// &\n                    \" - mean: \"//trim(svarmeanvalue)\n        !------------------------------------------------------------------------------------\n        \n    end function checkvar\n"}, {"instruction": "Write a Fortran function named checkarray to analyze an array of real numbers and generate a summary report. The function takes 2 input parameters: a 1D array of 4-byte real numbers and an optional character string. It returns a character string of length 200 containing the analysis summary.\n\nEnsure that the function is capable of computing the maximum, minimum, and average values of the input array, and create a message encapsulating these statistics along with the variable's name, if provided.\n", "input": "", "output": "    function checkarray(a1dvarvalue, svarname)   result(svarcheck)\n        \n        !------------------------------------------------------------------------------------\n        ! variable(s) declaration\n        real(kind = 4), dimension(:)      :: a1dvarvalue\n        \n        character(len = *), optional       :: svarname\n        \n        real(kind = 4)                      :: dvarmaxvalue, dvarminvalue, dvarmeanvalue\n        \n        character(len = 20)                 :: svarmaxvalue, svarminvalue, svarmeanvalue\n        character(len = 200)                :: svarcheck\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! initialize variable(s)\n        dvarmaxvalue = -9999.0; dvarminvalue = -9999.0; dvarmeanvalue = -9999.0\n        svarcheck = \"\"\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! define name if not defined\n        if (.not. present(svarname)) then\n            svarname = 'var'\n        endif\n        !------------------------------------------------------------------------------------\n\n        !------------------------------------------------------------------------------------\n        ! compute maximum value\n        dvarmaxvalue = maxval(a1dvarvalue, mask=a1dvarvalue.ge.0.0)\n        write(svarmaxvalue, *) dvarmaxvalue\n        ! compute minimum value\n        dvarminvalue = minval(a1dvarvalue, mask=a1dvarvalue.ge.0.0)\n        write(svarminvalue, *) dvarminvalue\n        ! compute average value\n        dvarmeanvalue = sum(a1dvarvalue, mask=a1dvarvalue.ge.0.0)/max(1,count(a1dvarvalue.gt.0.0))\n        write(svarmeanvalue, *) dvarmeanvalue\n        !------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------\n        ! print check message\n        svarcheck = trim(svarname)//\" :: max: \"//trim(svarmaxvalue)//\" - min: \"//trim(svarminvalue)// &\n                    \" - mean: \"//trim(svarmeanvalue)\n        !------------------------------------------------------------------------------------\n        \n    end function checkarray\n"}, {"instruction": "Create a Fortran function called distance that calculates the distance between two points represented by three-dimensional real arrays. The function takes 2 input parameters of type real, dimension(3) and returns 1 output parameter of type real.", "input": "", "output": "function distance(c1,c2)\n  real :: distance\n  real, dimension(3) :: c1, c2\n  \n  distance = sqrt(sum((c1-c2)**2))\n  return\nend function distance\n"}, {"instruction": "Write a Fortran function named create_randgen_c that returns a pointer to a random number generator. The function takes 1 input parameter of type integer(c_int),value, and returns 1 output parameter of type type(c_ptr).", "input": "", "output": "   function create_randgen_c(default_seed) bind(c,name=\"create_randgen\")\n   use iso_c_binding\n   implicit none\n   type(c_ptr) :: create_randgen_c\n   integer(c_int),value :: default_seed\n   end function create_randgen_c\n"}, {"instruction": "Write a Fortran function named split that takes a string and a delimiter as input. The input parameters are of type character(*) and character(1) respectively. This function returns a portion of the input string based on the delimiter. The output parameter is of type character(:), allocatable.", "input": "", "output": "pure function split(instr,  delimiter)\n\ncharacter(*), intent(in) :: instr\ncharacter(1), intent(in) :: delimiter\ncharacter(:), allocatable :: split\n\ninteger :: idx\n\nidx = scan(instr, delimiter)\nsplit = instr(1:idx-1)\n\nend function split\n"}, {"instruction": "Create a Fortran function named countinputarray to count the number of elements in an input array that have been set through a namelist call. The function takes 2 input parameters of type real and real, dimension(:), and returns 1 output parameter of type integer. The input array is initialized with a very negative value, and the function searches for the first entry in the array that still has this value to determine the count.", "input": "", "output": "pure function countinputarray(preset, a) result(n)\r\n! ------------------------------------------------------------------------------\r\n! purpose - count the number of elements of an array that have been input\r\n!   thru a namelist call. this is to save the user from the error-prone\r\n!   process of counting the number of entries in a list. the array is\r\n!   preset to a very negative value that no one would ever use for real data.\r\n!   this routine simply searches for the first entry in the array that still\r\n!   still has this value.\r\n  real,intent(in):: preset   ! the value that was originally placed in each\r\n  real,intent(in),dimension(:):: a   ! array to be counted\r\n  integer:: n\r\n\r\n  integer:: k\r\n!-------------------------------------------------------------------------------\r\n  do k=1,size(a)\r\n    if (a(k) <= preset) exit\r\n  end do\r\n  n=k-1   ! failed on k; k-1 was the last good one\r\n\r\n  return\r\nend function countinputarray   ! -----------------------------------------------\r\n"}, {"instruction": "Create a Fortran function named greatest_common_factor to calculate the greatest common factor of two integer numbers. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "    recursive function greatest_common_factor(a, b) result(c)\n      implicit none\n      integer :: c\n      integer, intent(in) :: a, b\n      if (a.eq.b) then\n         c = a\n      else if (a.gt.b) then\n         c = greatest_common_factor(a-b,b)\n      else\n         c = greatest_common_factor(a,b-a)\n      end if\n    end function greatest_common_factor\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The number of input arguments is 1 and the test_data type is ['integer'].The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function factorial(k)\n! computes k!\n    implicit none\n\n    real :: factorial                               ! real to get more precision\n    integer, intent(in) :: k                        ! input\n    integer :: j                                    ! counter\n    factorial = 1.0\n    do j = 2,k\n        factorial = factorial * j\n    end do\n    return\nend function factorial\n"}, {"instruction": "Create a Fortran function named pr_findconnectionnumberindex that finds the index of a specified cell number in a connection list. This function takes 4 input parameters: cellnumber (integer), connectionlist (integer array), arraysize (integer), and connectioncount (integer). The output parameter is index (integer), which represents the index of the cell number in the connection list.", "input": "", "output": "  function pr_findconnectionnumberindex(cellnumber,connectionlist,arraysize,connectioncount) result(index)\n  implicit none\n  integer,intent(in) :: cellnumber,connectioncount,arraysize\n  integer,intent(in),dimension(connectioncount) :: connectionlist\n  integer :: index,n\n  \n  index = 0\n  do n = 1,arraysize\n    if(connectionlist(n) .eq. cellnumber) then\n      index = n\n      exit\n    end if\n  end do\n  \n  end function pr_findconnectionnumberindex\n"}, {"instruction": "Create a Fortran function named f1 that takes an integer input argument and returns a character string. The function initializes the string \"ab\" and returns it. The number of input arguments is 1 with test_data type ['integer'], and the number of output arguments is 1 with test_data type ['character(n)'].", "input": "", "output": "function f1(n)\n  integer :: n\n  character(n) :: f1, e1\n  f1 = \"ab\"\n  return\nentry e1(n)\n  e1 = \"xyz\"\nend function\n"}, {"instruction": "Write a Fortran function called f2 that takes an integer input argument and returns a character pointer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(n), pointer'].", "input": "", "output": "function f2(n)\n  integer :: n\n  character(n), pointer :: f2, e2\n  allocate(f2)\n  f2 = \"ab\"\n  return\nentry e2(n)\n  allocate(e2)\n  e2 = \"xyz\"\nend function\n"}, {"instruction": "Write a Fortran function named \"read_datatype\" to read a datatype name from a file. The function takes 2 input arguments of type integer and character, and 1 output argument of type integer. The number of input arguments is 2 and the test_data type is ['integer', 'character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function read_datatype( fid, datatype_name ) result( err_stat )\n    ! arguments\n    integer     , intent(in)  :: fid\n    character(*), intent(out) :: datatype_name\n\n    integer :: err_stat\n    ! local variables\n    character(1), allocatable :: dummy(:)\n    integer :: i, strlen\n    integer :: io_stat\n    integer :: alloc_stat\n\n    ! set up\n    err_stat = failure\n    datatype_name = ''\n\n    ! get the string length\n    read( fid, iostat=io_stat ) strlen\n    if ( io_stat /= 0 ) return\n    \n    ! allocate dummy string array\n    allocate( dummy(strlen), stat=alloc_stat )\n    if ( alloc_stat /= 0 ) return\n\n    ! read the string into the dummy array\n    read( fid, iostat=io_stat ) dummy\n    if ( io_stat /= 0 ) return\n\n    ! transfer array into string\n    do i = 1, min(strlen,len(datatype_name))\n      datatype_name(i:i) = dummy(i)\n    end do\n\n    ! done\n    err_stat = success\n  end function read_datatype\n"}, {"instruction": "Create a Fortran function named tolowercase that takes a single input argument of type character with variable length. The function returns a new string in all lowercase letters. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['character(len=len(string))'].", "input": "", "output": "    function tolowercase(string)\n\n        character(len=*), intent(in) :: string\n        character(len=len(string)) :: tolowercase\n\n        character(len=26) lower, upper\n        integer i, n\n\n        lower = 'abcdefghijklmnopqrstuvwxyz'\n        upper = 'abcdefghijklmnopqrstuvwxyz'\n\n        tolowercase = string\n        do i = 1, len(string)\n            n = index(upper, string(i:i))\n            if (n /= 0) tolowercase(i:i) = lower(n:n)\n        end do\n\n    end function\n"}, {"instruction": "Create a Fortran function named length_edges_box to calculate the lengths of the edges of a box in 3D space. The function takes 2 input parameters with the data types ['integer', 'double precision,dimension(nframes,3,3)'], and returns 1 output parameter with the data type ['double precision,dimension(nframes,3)'].", "input": "", "output": "  function length_edges_box(box, nframes) result(lengths)\n\n    implicit none\n    integer,intent(in)::nframes\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes,3)::lengths\n    integer::ii\n\n    lengths = 0.0d0\n\n    do ii=1,nframes\n\n        lengths(ii,1) = sqrt(box(ii,1,1)**2 + box(ii,1,2)**2 + box(ii,1,3)**2)\n        lengths(ii,2) = sqrt(box(ii,2,1)**2 + box(ii,2,2)**2 + box(ii,2,3)**2)\n        lengths(ii,3) = sqrt(box(ii,3,1)**2 + box(ii,3,2)**2 + box(ii,3,3)**2)\n\n    end do\n\n  end function length_edges_box\n"}, {"instruction": "Create a Fortran function named real_compare to compare two real numbers. The function takes 4 input parameters of type real(kind(1d0)) - r1, r2, eps, and zthr. It returns 1 output parameter of type integer.", "input": "", "output": "  function real_compare(r1,r2,eps,zthr) result(res)\n    implicit none\n    real(kind(1d0)),intent(in)::r1,r2,eps,zthr\n    real(kind(1d0))::maxr,diff\n    integer::res\n    maxr=max(abs(r1),abs(r2))\n    if(maxr.lt.zthr)then\n       res=0\n       return\n    endif\n    diff=r1-r2\n    if(abs(diff)/maxr.lt.eps)then\n       res=0\n       return\n    endif\n    if(diff.gt.0d0)then\n       res=1\n       return\n    else\n       res=-1\n       return\n    endif\n  end function real_compare\n"}, {"instruction": "Write a Fortran function named getloc that takes an array of integers and an integer element as input and returns the location of the element in the array as output. The number of input arguments is 2 and the test_data type is ['integer, dimension(:)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function getloc(arr, elm) result (loc)\n\n  !purpose: to  get location of an element in an array\n\n  integer, dimension(:), intent(in)  :: arr    ! input array\n  integer, intent(in)  :: elm                  ! element whose location is wanted to find\n  integer :: loc\n\n  integer :: i\n\n  do i = 1, size(arr)\n    if (arr(i) == elm) then\n      loc = i\n      exit\n    end if\n  end do\n\nend function getloc\n"}, {"instruction": "Create a Fortran function named wrap_timer_name that takes a single input argument of type character(len=10) and returns a single output argument of type character(len=12). The function should wrap the input argument with double quotes and assign the result to the output argument using the adjustr function.", "input": "", "output": "  function wrap_timer_name(tname) result(q_string)\n    character(len=10)::  tname\n    character(len=12)::  q_string\n\n    integer i\n\n    q_string=adjustr('\"'//trim(tname)//'\"')\n\n  end function wrap_timer_name\n"}, {"instruction": "Write a Fortran function named sending_half that takes an integer input argument and returns a logical value. The function's purpose is to check if the input integer is less than or equal to a predefined value np_half. This function should be used to process only even values of np.", "input": "", "output": "function sending_half( i) result( l)\n\ninteger, intent( in) :: i\nlogical :: l\n\ncontinue\n\n!  this must process np == even values only\n\n   l = i <= np_half\n\nreturn\n\nend function sending_half\n"}, {"instruction": "Create a Fortran function named \"par_adiab_tau\" that takes 5 input parameters of type integer, double precision, and computes a double precision output. The function computes a value based on the polynomial order specified in the input and returns the corresponding value of \"par_adiab_tau\".", "input": "", "output": "    function par_adiab_tau(poly_order,a44,b4,tau,vpar_in)\n!\n        implicit none\n!\n        integer                  :: poly_order\n        double precision         :: tau,vpar_in,par_adiab_tau,a44,b4\n!\n        select case(poly_order)\n            case(2)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2 + 3.d0*a44*b4*vpar_in + 2.d0*a44**2* vpar_in**2)\n!                            \n            case(3)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2 + 3.d0*a44*b4*vpar_in + 2.d0*a44**2*vpar_in**2) &\n                            & + 1.d0/4.d0*tau**4*(a44*b4**2 + 7.d0/3.d0*a44**2*b4*vpar_in+(4.d0*a44**3*vpar_in**2)/3.d0)\n!                \n            case(4)\n                par_adiab_tau = tau*vpar_in**2 + 0.5d0*tau**2 * (2.d0*b4*vpar_in + 2.d0*a44*vpar_in**2) &\n                            & + 1.d0/3.d0*tau**3*(b4**2+3.d0*a44*b4*vpar_in+2.d0*a44*2.d0*vpar_in**2) &\n                            & + 1.d0/4.d0*tau**4*(a44*b4**2 + 7.d0/3.d0*a44**2*b4*vpar_in+(4.d0*a44**3*vpar_in**2)/3.d0) &\n                            & + 1.d0/60.d0*tau**5*(7.d0*a44**2*b4**2+15.d0*a44**3*b4*vpar_in + 8.d0*a44**4*vpar_in**2)\n! \n        end select\n!        \n    end function par_adiab_tau\n"}, {"instruction": "Write a Fortran function named hsurh0 that calculates the value of hsurh0 using the specified input parameters. The function should have 4 input parameters of type real(kind=8), represented as [real(kind=8), real(kind=8), real(kind=8), real(kind=8)], and 1 output parameter of type real(kind=8).", "input": "", "output": "function hsurh0(z,omega0,omegal,omegar)\n  !===========================================================================\n  implicit none\n  real(kind=8) :: z,omega0,omegal,omegar,hsurh0\n  hsurh0=sqrt(omega0*(1.d0+z)**3+omegar*(1.d0+z)**2+omegal)\nend function hsurh0\n"}, {"instruction": "Write a Fortran function named myint that takes a real number of kind=8 as input and returns an integer as output. The number of input arguments is 1 and the test_data type is ['real(kind=8)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function myint(x)\n  !=======================================================================\n\n  !=======================================================================\n  real(kind=8) :: x\n  integer :: myint\n  \n  if (x >= 0.0d0) then\n     myint=int(x)\n  else\n     myint=int(x)-1\n  endif\nend function myint\n"}, {"instruction": "Create a Fortran function named nextpow2, which calculates the next power of 2 greater than or equal to the input integer. The number of input arguments is 1 with the test_data type ['integer']. The number of output arguments is 1 with the test_data type ['integer'].", "input": "", "output": "function nextpow2(n) bind(c)\n! \u4e0d\u5c0f\u4e8en\u76842\u7684\u6574\u6570\u6b21\u5e42\n    integer, intent(in) :: n\n    integer :: nextpow2\n\n    nextpow2 = 1\n\n    do while ( nextpow2<n )\n        nextpow2 = nextpow2*2\n    end do\n    return\n\nend function nextpow2\n"}, {"instruction": "Write a Fortran function named nextpow that calculates the next power of a given base greater than or equal to a given number. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['integer'].", "input": "", "output": "function nextpow(n,base) bind(c)\n! \u4e0d\u5c0f\u4e8en\u7684base\u7684\u6574\u6570\u6b21\u5e42\n    integer, intent(in) :: n, base\n    integer :: nextpow\n\n    nextpow = 1\n\n    do while ( nextpow<n )\n        nextpow = nextpow*base\n    end do\n    return\n\nend function nextpow\n"}, {"instruction": "Write a Fortran function named dpower to compute the value of x raised to the power of n, and then calculate the m-th derivative. The number of input arguments is 3, and the test_data type is [real(8), integer, integer]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "function dpower(x,n,m) bind(c)\n! \u5bf9x^n\u6c42m\u9636\u5bfc\u6570\u540e\u7684\u503c\n    real(8), intent(in) :: x\n    integer, intent(in) :: n, m\n    real(8) :: dpower\n\n    integer :: k, l\n\n    if ( m>n ) then\n        dpower = 0.d0\n        return\n    end if\n\n    k = n\n    l = m\n    dpower = x**(n-m)\n\n    do while ( l>0 )\n        dpower = dpower*k\n        l = l - 1\n        k = k - 1\n    end do\nend function dpower\n"}, {"instruction": "Write a Fortran function named integer_to_string that converts an integer to a string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=max_number_width)'].", "input": "", "output": "    elemental function integer_to_string(i) result(s)\n      integer,intent(in) :: i\n      integer, parameter :: max_number_width = 64\n      character(len=max_number_width) :: s\n      integer :: istat\n\n      write(s,fmt='(ss,i0)',iostat=istat) i\n      if (istat==0) then\n          s = trim(adjustl(s))\n      else\n          s = '***'\n      end if\n    end function integer_to_string\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer (kind = 4). Ensure that the name of the function is \"factorial\".", "input": "", "output": "recursive function factorial(n) result(f)\n    implicit none\n    integer :: n\n    integer  (kind = 4) :: f\n    if (n<0) then\n      f=0\n    else\n      select case (n) \n          case (0)\n              f =  1\n          case (1)\n              f =  1\n          case (2)\n              f =  2\n          case ( 3)\n              f =  6\n          case ( 4)\n              f =  24\n          case ( 5)\n              f =  120\n          case ( 6)\n              f =  720\n          case ( 7)\n              f =  5040\n          case ( 8)\n              f =  40320\n          case ( 9)\n              f =  362880\n          case ( 10)\n              f =  3628800\n          case ( 11)\n              f =  39916800\n          case ( 12)\n              f =  479001600\n          case default\n              f =  n*factorial(n-1)\n      end select\n    endif\nend function factorial\n"}, {"instruction": "Create a Fortran function named doublefactorial to calculate the double factorial of a given integer. The function has 1 input parameter of type integer and 1 output parameter of type integer (kind = 4). The function should be able to handle non-negative integers and return the double factorial value.", "input": "", "output": "recursive function doublefactorial(n)  result(f)\n    integer, intent(in):: n\n    integer  (kind = 4) :: f\n    if (n<0) then\n      f=0\n      return\n    else\n      select case (n)\n        case (0)\n            f =  1\n        case (1)\n            f =  1\n        case (2)\n            f =  2\n        case (3)\n            f =  3\n        case (4)\n            f =  8\n        case (5)\n            f =  15\n        case (6)\n            f =  48\n        case (7)\n            f =  105\n        case (8)\n            f =  384\n        case (9)\n            f =  945\n        case (10)\n            f =  3840\n        case (11)\n            f =  10395\n        case (12)\n            f =  46080\n        case (13)\n            f =  135135\n        case (14)\n            f =  645120\n        case (15)\n            f =  2027025\n        case (16)\n            f =  10321920\n        case (17)\n            f =  34459425\n        case (18)\n            f =  185794560\n        case default\n            f =  n*doublefactorial(n-2)\n      end select\n    endif\nend function doublefactorial\n"}, {"instruction": "Write a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the input number is prime. The name of the function is isprime.", "input": "", "output": "function isprime(number)\n        implicit none\n        integer, intent(in) :: number\n        logical :: isprime\n        integer :: i\n\n        isprime = .true.\n        do i = 2, number / 2\n            if (mod(number, i) .eq. 0) then\n                isprime = .false.\n                exit\n            end if\n        end do\n        ! isprime = .false.\n        \n    end function isprime\n"}, {"instruction": "Create a Fortran function named histogram_median that takes an input array of integers with a dimension of 0 to 255. The function calculates the median value of the histogram and returns it as an integer. The number of input parameters is 1 with the test_data type being ['integer, dimension(0:255)'], and the number of output parameters is 1 with the test_data type being ['integer'].", "input": "", "output": "  function histogram_median(histogram)\n    integer, dimension(0:255), intent(in) :: histogram\n    integer :: histogram_median\n\n    integer :: from, to, left, right\n\n    from = 0\n    to = 255\n    left = histogram(from)\n    right = histogram(to)\n    do while ( from /= to )\n       if ( left < right ) then\n          from = from + 1\n          left = left + histogram(from)\n       else\n          to = to - 1\n          right = right + histogram(to)\n       end if\n    end do\n    histogram_median = from\n  end function histogram_median\n"}, {"instruction": "Create a Fortran function named minusonetothe to calculate -1 raised to the power of the input integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "\tfunction minusonetothe(j) result (sgn)\n\t\tinteger :: i,j\n\t\treal*8 :: sgn\n\t\t\n\t\ti=j\n\t\tif (j<=0) i=-j\n\t\tif (mod(i,2)==0) then\n\t\t\tsgn=1\n\t\telse\n\t\t\tsgn=-1\n\t\tendif\n\tend function minusonetothe\n"}, {"instruction": "Create a Fortran function named math_fact to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "\tpure function math_fact( n ) result( output )\n\t\tinteger, intent(in) :: n\n\t\tinteger :: output\n\t\t\n\t\tinteger :: i\n\t\t\n\t\toutput = 1\n\t\tdo i=n,1,-1\n\t\t\toutput = output*i\n\t\tend do\n\tend function math_fact\n"}, {"instruction": "Create a Fortran function named to_string that takes one input parameter of type class(*) and returns a string. The input parameter can be of any type.", "input": "", "output": "    function to_string(data_in) result(string_out)\n        class(*),    intent(in)  :: data_in\n\n        character(100)              :: write_internal\n        character(:),   allocatable :: string_out\n\n        string_out = ''\n\n        select type(data_in)\n\n            type is(character(len=*))\n                string_out = data_in\n\n            type is(integer)\n\n                if ( data_in == 0 ) then\n                    write_internal = '0'\n\n                ! positive integers\n                else if ( data_in < 1e1 .and. data_in > 0) then\n                    write(write_internal, '(i1.0)') data_in\n                else if ( data_in < 1e2 .and. data_in > 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( data_in < 1e3 .and. data_in > 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( data_in < 1e4 .and. data_in > 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( data_in < 1e5 .and. data_in > 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( data_in < 1e6 .and. data_in > 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( data_in < 1e7 .and. data_in > 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( data_in < 1e8 .and. data_in > 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( data_in < 1e9 .and. data_in > 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( data_in < 1e10 .and. data_in > 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( data_in < 1e11 .and. data_in > 0) then\n                    write(write_internal, '(i11.0)') data_in\n\n                ! negative integers: extra char width for neg sign\n                else if ( abs(data_in) < 1e1 .and. data_in < 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( abs(data_in) < 1e2 .and. data_in < 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( abs(data_in) < 1e3 .and. data_in < 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( abs(data_in) < 1e4 .and. data_in < 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( abs(data_in) < 1e5 .and. data_in < 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( abs(data_in) < 1e6 .and. data_in < 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( abs(data_in) < 1e7 .and. data_in < 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( abs(data_in) < 1e8 .and. data_in < 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( abs(data_in) < 1e9 .and. data_in < 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( abs(data_in) < 1e10 .and. data_in < 0) then\n                    write(write_internal, '(i11.0)') data_in\n                else if ( abs(data_in) < 1e11 .and. data_in < 0) then\n                    write(write_internal, '(i12.0)') data_in\n                else\n                    write(write_internal, '(i10.0)') data_in\n                end if\n                string_out = write_internal\n\n            type is(integer(8))\n\n                if ( data_in == 0 ) then\n                    write_internal = '0'\n\n                ! positive integers\n                else if ( data_in < 1e1 .and. data_in > 0) then\n                    write(write_internal, '(i1.0)') data_in\n                else if ( data_in < 1e2 .and. data_in > 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( data_in < 1e3 .and. data_in > 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( data_in < 1e4 .and. data_in > 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( data_in < 1e5 .and. data_in > 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( data_in < 1e6 .and. data_in > 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( data_in < 1e7 .and. data_in > 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( data_in < 1e8 .and. data_in > 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( data_in < 1e9 .and. data_in > 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( data_in < 1e10 .and. data_in > 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( data_in < 1e11 .and. data_in > 0) then\n                    write(write_internal, '(i11.0)') data_in\n\n                ! negative integers: extra char width for neg sign\n                else if ( abs(data_in) < 1e1 .and. data_in < 0) then\n                    write(write_internal, '(i2.0)') data_in\n                else if ( abs(data_in) < 1e2 .and. data_in < 0) then\n                    write(write_internal, '(i3.0)') data_in\n                else if ( abs(data_in) < 1e3 .and. data_in < 0) then\n                    write(write_internal, '(i4.0)') data_in\n                else if ( abs(data_in) < 1e4 .and. data_in < 0) then\n                    write(write_internal, '(i5.0)') data_in\n                else if ( abs(data_in) < 1e5 .and. data_in < 0) then\n                    write(write_internal, '(i6.0)') data_in\n                else if ( abs(data_in) < 1e6 .and. data_in < 0) then\n                    write(write_internal, '(i7.0)') data_in\n                else if ( abs(data_in) < 1e7 .and. data_in < 0) then\n                    write(write_internal, '(i8.0)') data_in\n                else if ( abs(data_in) < 1e8 .and. data_in < 0) then\n                    write(write_internal, '(i9.0)') data_in\n                else if ( abs(data_in) < 1e9 .and. data_in < 0) then\n                    write(write_internal, '(i10.0)') data_in\n                else if ( abs(data_in) < 1e10 .and. data_in < 0) then\n                    write(write_internal, '(i11.0)') data_in\n                else if ( abs(data_in) < 1e11 .and. data_in < 0) then\n                    write(write_internal, '(i12.0)') data_in\n                else\n                    write(write_internal, '(i10.0)') data_in\n                end if\n                string_out = write_internal\n\n            type is(real)\n                if (abs(data_in) > 0.1) then\n                    write(write_internal, '(f24.14)') data_in\n                else\n                    write(write_internal, '(e24.14)') data_in\n                end if\n                string_out = write_internal\n\n            type is(real(8))\n                if (abs(data_in) < 0.1) then\n                    write(write_internal, '(e24.14)') data_in\n                else if ( (abs(data_in) > 0.1) .and. (abs(data_in) < 1.e9) ) then\n                    write(write_internal, '(f24.14)') data_in\n                else\n                    write(write_internal, '(e24.14)') data_in\n                end if\n                string_out = write_internal\n\n            type is(logical(1))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            type is (logical(2))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            type is (logical(4))\n                if (data_in) then\n                    string_out = 'true'\n                else\n                    string_out = 'false'\n                end if\n\n            class default\n                print*, 'error: no io rule for provided data in add_to_line'\n                stop\n        end select\n\n\n    end function to_string\n"}, {"instruction": "Create a Fortran function called check_file_extension to determine if a file has a specific extension. The function takes 2 input parameters of type character(*) representing the file name and the target extension. It returns 1 output parameter of type logical. The function checks if the given extension is present in the file name and sets the logical variable extension_found accordingly.", "input": "", "output": "    function check_file_extension(file,extension) result(extension_found)\n        character(*),       intent(in)  :: file\n        character(*),       intent(in)  :: extension\n\n        integer     :: iext, extloc\n        logical     :: extension_found\n\n        ! check for extension in grid file\n        extloc = index(file, trim(extension))\n\n        ! if extloc is nonzero, then the extension was found in the filename\n        if ( extloc /= 0 ) then\n            extension_found = .true.\n        else\n            extension_found = .false.\n        end if\n\n    end function check_file_extension\n"}, {"instruction": "Write a Fortran function named string_to_lower that converts a given input string to lowercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len=len(string)).", "input": "", "output": "    function string_to_lower(string) result(string_lower)\n        character(*),   intent(in)  :: string\n\n        character(len=len(string))  :: string_lower\n        integer                         :: i, k\n\n        do i = 1,len(trim(string))\n            \n            k = iachar(string(i:i))\n\n\n            if ( k >= iachar('a') .and. k <= iachar('z') ) then\n                k = k + (iachar('a') - iachar('a'))\n                string_lower(i:i) = achar(k)\n            else\n                string_lower(i:i) = string(i:i)\n            end if\n\n        end do ! i\n    end function string_to_lower\n"}, {"instruction": "Create a Fortran function named string_to_upper that takes a single input parameter of type character(*) and returns a single output parameter of type character(len=len(string)). The function converts all lowercase letters in the input string to uppercase and leaves the other characters unchanged.", "input": "", "output": "    function string_to_upper(string) result(string_upper)\n        character(*),   intent(in)  :: string\n\n        character(len=len(string))  :: string_upper\n        integer                         :: i, k\n\n        do i = 1,len(trim(string))\n            \n            k = iachar(string(i:i))\n\n\n            if ( k >= iachar('a') .and. k <= iachar('z') ) then\n                k = k - (iachar('a') - iachar('a'))\n                string_upper(i:i) = achar(k)\n            else\n                string_upper(i:i) = string(i:i)\n            end if\n\n        end do ! i\n    end function string_to_upper\n"}, {"instruction": "Write a Fortran function named is_possible to determine if it is possible to achieve a certain condition based on the input arrays and length. The function takes 5 input parameters of types integer, real(8), real(8) arrays of dimension length, and returns 1 output parameter of type logical.", "input": "", "output": "recursive function is_possible(a, b, c, length, init) result(possible)\ninteger, intent(in) :: length\nreal(8), intent(in) :: init\nreal(8),dimension(length), intent(in) :: a\nreal(8),dimension(length), intent(in) :: b\nreal(8),dimension(length), intent(in) :: c\nreal(8),dimension(length - 1) :: passed_a\nreal(8),dimension(length - 1) :: passed_b\nreal(8),dimension(length - 1) :: passed_c\nreal(8) :: holder\nlogical :: possible\ninteger :: x, y\n\nif (length .eq. 0) then\n  possible = .true.\n  return\nend if\npossible = .false.\n\ndo x = 1, length\n  if (abs(c(x) - init) .lt. ((10 - length) * precision)) then\n    do y = 1, x - 1\n      passed_a(y) = a(y)\n      passed_b(y) = b(y)\n    end do\n    do y = x + 1, length\n      passed_a(y - 1) = a(y)\n      passed_b(y - 1) = b(y)\n    end do\n    holder = max(a(x), b(x), init)\n    if (is_possible(passed_a, passed_b, passed_c, length - 1, holder)) then\n      possible = .true.\n      return\n    end if\n  end if\nend do\nend function is_possible\n"}, {"instruction": "Create a Fortran function named poly that takes two input parameters: coeffs of type real(8) array and x of type real(8) array. The function produces one output parameter, poly, which is a real(8) array with the size of x. The function calculates a polynomial using the coefficients provided in coeffs and the values in array x.", "input": "", "output": "        function poly(x,coeffs)\n          real(8), dimension(:), intent(in) :: coeffs,x\n          real(8), dimension(size(x)) :: poly\n          integer :: i,m\n          m=size(coeffs)\n!          n=size(x)\n          if (m <= 0) then\n             poly=0.0d0\n          else !if (m < n .or. m < npar_poly) then\n             poly=coeffs(m)\n             do i=m-1,1,-1\n                poly=x*poly+coeffs(i)\n             end do\n          endif!else\n!             do i=1,n\n!                poly(i)=poly_rr(x(i),coeffs)\n!             end do\n!          end if\n        end function poly\n"}, {"instruction": "Write a Fortran function named dadtau that takes 4 real(kind=8) input parameters and returns a single real(kind=8) output parameter. The function computes the value of dadtau using the provided input parameters according to the given mathematical expression, and then returns the square root of the computed value.", "input": "", "output": "function dadtau(axp_tau,o_mat_0,o_vac_0,o_k_0) \n  real(kind=8)::dadtau,axp_tau,o_mat_0,o_vac_0,o_k_0\n  dadtau = axp_tau*axp_tau*axp_tau *  &\n       &   ( o_mat_0 + &\n       &     o_vac_0 * axp_tau*axp_tau*axp_tau + &\n       &     o_k_0   * axp_tau )\n  dadtau = sqrt(dadtau)\n  return\nend function dadtau\n"}, {"instruction": "Create a Fortran function named dadt that takes 4 real(kind=8) input parameters (axp_t, o_mat_0, o_vac_0, o_k_0) and returns a single real(kind=8) output parameter. The function computes a value using the input parameters and returns the square root of the calculated value.", "input": "", "output": "function dadt(axp_t,o_mat_0,o_vac_0,o_k_0)\n  real(kind=8)::dadt,axp_t,o_mat_0,o_vac_0,o_k_0\n  dadt   = (1.0d0/axp_t)* &\n       &   ( o_mat_0 + &\n       &     o_vac_0 * axp_t*axp_t*axp_t + &\n       &     o_k_0   * axp_t )\n  dadt = sqrt(dadt)\n  return\nend function dadt\n"}, {"instruction": "Create a Fortran function named cairo_script_interpreter_translate_stream to interact with C code. The function takes 3 input parameters of type c_ptr, c_funptr, and c_ptr. The output is an integer of type c_int.", "input": "", "output": "function cairo_script_interpreter_translate_stream(stream, write_func, closure)&\n& bind(c) \n  use iso_c_binding, only: c_int, c_ptr, c_funptr\n  integer(c_int) :: cairo_script_interpreter_translate_stream\n  type(c_ptr), value :: stream\n  type(c_funptr), value :: write_func\n  type(c_ptr), value :: closure\nend function\n"}, {"instruction": "Write a Fortran function named cairo_pdf_surface_create to create a PDF surface for drawing. The function must have 3 input parameters of type ['character(kind=c_char), dimension(*)', 'real(c_double), value', 'real(c_double), value'] and 1 output parameter of type ['type(c_ptr)'].", "input": "", "output": "function cairo_pdf_surface_create(filename, width_in_points, height_in_points) &\n&bind(c) \n  use iso_c_binding, only: c_ptr, c_char, c_double\n  type(c_ptr) :: cairo_pdf_surface_create\n  character(kind=c_char), dimension(*) :: filename\n  real(c_double), value :: width_in_points\n  real(c_double), value :: height_in_points\nend function\n"}, {"instruction": "Create a Fortran function named cairo_surface_create_similar_image to generate a new surface with the same content as a specified surface. The function takes 4 input parameters of types type(c_ptr), integer(c_int), integer(c_int), and integer(c_int), and returns 1 output parameter of type type(c_ptr).", "input": "", "output": "function cairo_surface_create_similar_image(other, format, width, height) bind(&\n&c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: cairo_surface_create_similar_image\n  type(c_ptr), value :: other\n  integer(c_int), value :: format\n  integer(c_int), value :: width\n  integer(c_int), value :: height\nend function\n"}, {"instruction": "Write a Fortran function named cairo_surface_create_for_rectangle that takes 5 input parameters of types 'type(c_ptr), value', 'real(c_double), value', 'real(c_double), value', 'real(c_double), value', 'real(c_double), value' and 1 output parameter of type 'type(c_ptr)'. This function creates a Cairo surface of a specified width and height with the top-left corner at the coordinates (x, y) on the target surface.", "input": "", "output": "function cairo_surface_create_for_rectangle(target, x, y, width, height) bind(c&\n&) \n  use iso_c_binding, only: c_ptr, c_double\n  type(c_ptr) :: cairo_surface_create_for_rectangle\n  type(c_ptr), value :: target\n  real(c_double), value :: x\n  real(c_double), value :: y\n  real(c_double), value :: width\n  real(c_double), value :: height\nend function\n"}, {"instruction": "Provide a Fortran function named r_nearless to calculate the nearest value less than a given real number. It should have 1 input parameter of type real and 1 output parameter of type real. The input parameter should be named xval, and the output parameter should be named r_nl.", "input": "", "output": "function r_nearless (xval) result (r_nl)\n!  nearest value less than given value\n! __________________________________________________________\n      real, intent (in) :: xval\n      real :: r_nl\n! __________________________________________________________\n      r_nl = nearest (xval, -1.0)\n      return\n!\nend function r_nearless\n"}, {"instruction": "Create a Fortran function named i_nearless that returns the nearest integer value less than the given integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function i_nearless (xval) result (i_nl)\n!  nearest value less than given value\n! __________________________________________________________\n      integer, intent (in) :: xval\n      integer :: i_nl\n! __________________________________________________________\n      i_nl = xval - 1\n      return\n!\nend function i_nearless\n"}, {"instruction": "Create a Fortran pure function named myfunc that takes an integer input argument. The function should allocate and return an integer array of size 3 containing the input value, twice the input value, and three times the input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(:), allocatable'].", "input": "", "output": "  pure function myfunc(x) result(y)\n    integer, intent(in) :: x\n    integer, dimension(:), allocatable :: y\n    allocate (y(3))\n    y(1) = x\n    y(2) = 2*x\n    y(3) = 3*x\n  end function myfunc\n"}, {"instruction": "Create a Fortran function named \"f\" that takes a real number as input with the test_data type ['real ( kind = rp) '] and returns a real number with the test_data type ['real (kind = rp)']. The function computes the square of the input number and divides it by 3. Use the imperative tone and specify that this is a Fortran function.", "input": "", "output": "      function f(x1) \r\n      integer, parameter :: rp =  selected_real_kind(15)\r\n      real ( kind = rp) ,intent (in) :: x1\r\n      real (kind = rp) :: f \r\n      f = (x1 ** 2 )/3\r\n      return\r\n      end function f\r\n"}, {"instruction": "Create a Fortran pure function named \"letters\" that calculates the total number of letters required to write out the numbers from 1 to the given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer. Ensure that the input argument represents the starting number for the range of numbers to be considered.", "input": "", "output": "  pure function letters(starting_n)\n    integer, intent(in) :: starting_n\n    integer             :: n,letters\n\n    n=starting_n\n    letters=0\n    \n1   select case (n)\n    case (1:2,6,10)\n       letters=letters+3 ! one, two, six, ten\n    case (4:5,9)\n       letters=letters+4 ! four, five, nine\n    case (3,7:8)\n       letters=letters+5 ! three, seven, eight\n    case (11:12)\n       letters=letters+6 ! eleven, twelve\n    case (13:14)\n       letters=letters+8 ! thirteen, fourteen\n    case (15:16)\n       letters=letters+7 ! fifteen, sixteen\n    case (17)\n       letters=letters+9 ! seventeen\n    case (18:19)\n       letters=letters+8 ! eighteen, nineteen\n    case (20:29)\n       letters=letters+6 ! twenty\n       n=n-20\n       go to 1\n    case (30:39)\n       letters=letters+6 ! thirty\n       n=n-30\n       go to 1\n    case (40:49)\n       letters=letters+5 ! forty\n       n=n-40\n       go to 1\n    case (50:59)\n       letters=letters+5 ! fifty\n       n=n-50\n       go to 1\n    case (60:69)\n       letters=letters+5 ! sixty\n       n=n-60\n       go to 1\n    case (70:79)\n       letters=letters+7 ! seventy\n       n=n-70\n       go to 1\n    case (80:89)\n       letters=letters+6 ! eighty\n       n=n-80\n       go to 1\n    case (90:99)\n       letters=letters+6 ! ninety\n       n=n-90\n       go to 1\n    case (100:999)\n       letters=letters+7 ! hundred\n       select case (n / 100)\n       case (1:2,6)\n          letters=letters+3 ! one, two, six\n       case (3,7:8)\n          letters=letters+5 ! three, seven, eight\n       case (4:5,9)\n          letters=letters+4 ! four, five, nine\n       end select\n       n=mod(n,100)\n       if (n /= 0) then\n          letters=letters+3 ! and\n          go to 1\n       end if\n    case (1000)\n       letters=letters+11 ! one thousand\n    end select\n    \n  end function letters\n"}, {"instruction": "Write a Fortran function named qincom that takes 3 real input parameters (qc, qinf, tklam) and returns a real output parameter. The function computes the incompressible speed from the compressible speed using specific formulas based on the input parameters. Use the imperative tone in your instructions.", "input": "", "output": "    function qincom(qc, qinf, tklam)\n        implicit none\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        real :: qc, qinf, tklam\n        real :: qincom\n        intent (in) qc, qinf, tklam\n        !\n        ! local variables\n        !\n        real :: tmp\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !\n        !*** start of declarations rewritten by spag\n        !\n        ! dummy arguments\n        !\n        !\n        ! local variables\n        !\n        !\n        !*** end of declarations rewritten by spag\n        !\n        !-------------------------------------\n        !     sets incompressible speed from\n        !     karman-tsien compressible speed\n        !-------------------------------------\n        !\n        if (tklam<1.0e-4 .or. abs(qc)<1.0e-4) then\n            !----- for nearly incompressible case or very small speed, use asymptotic\n            !      expansion of singular quadratic formula to avoid numerical problems\n            qincom = qc / (1.0 - tklam)\n        else\n            !----- use quadratic formula for typical case\n            tmp = 0.5 * (1.0 - tklam) * qinf / (qc * tklam)\n            qincom = qinf * tmp * (sqrt(1.0 + 1.0 / (tklam * tmp**2)) - 1.0)\n        endif\n    end function qincom\n"}, {"instruction": "Create a Fortran function named numcol that counts the number of columns in a string separated by spaces. The function takes 1 input argument of type character(*) and returns 1 output argument of type integer(4). The input argument represents the string to be analyzed, and the output argument represents the number of columns in the string.", "input": "", "output": " function numcol(str) result(nc)\n integer(4)::n,nc,nl,nll\n character(*)::str,str1*200\n str1 = adjustl(str)\n nl = len_trim(str1)\n if (nl==0) then\n   nc=0\n   return\n endif\n \n do n=1,nl\n   if (str1(n:n)==',') str1(n:n)=' '\n enddo\n nll = len_trim(str1)\n \n nc = 1\n do n=2,nll\n   if(str1(n:n)==''.and.str1(n-1:n-1)/='') then\n     nc=nc+1\n   endif\n enddo\n end function\n"}, {"instruction": "Create a Fortran function named tab_fe to calculate the value of tab_fe, which is the sum of 1, debut, and pos. The function has 2 input parameters with test_data type ['integer', 'integer'], and 1 output parameter with test_data type ['integer'].", "input": "", "output": "function tab_fe(pos,debut)\n\timplicit none\n\tinteger :: tab_fe, pos, debut\n\ttab_fe = 1 + debut + pos\nend function\n"}, {"instruction": "Create a Fortran function named local that takes one input argument of type real, target, and dimension(:,:,:) and returns one output argument of type real, pointer, and dimension(:,:,:).", "input": "", "output": "   function local(a)\n      implicit none\n      real, target, dimension(:,:,:) :: a\n      real, pointer, dimension(:,:,:) :: local\n\n      local => a\n\n   end function local\n"}, {"instruction": "Write a Fortran function named determ to calculate the determinant of a 3x3 matrix. The number of input arguments is 1 and the test_data type is ['3x3 real array']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function determ(a) result(det)\r\n\r\n    real(kind=8)    ::  a(3,3), det\r\n\r\n    intent(in)      ::  a\r\n\r\n    det = a(1,1)*a(2,2)*a(3,3) + &\r\n            a(2,1)*a(3,2)*a(1,3) + &\r\n            a(3,1)*a(1,2)*a(2,3) - &\r\n            a(3,1)*a(2,2)*a(1,3) - &\r\n            a(1,1)*a(3,2)*a(2,3) - &\r\n            a(2,1)*a(1,2)*a(3,3)\r\n\r\n    if (abs(det) < 1.d-12) then\r\n        write(*,*) 'determinant is null!'\r\n        read(*,*)\r\n        stop\r\n    end if\r\n\r\n    end function determ\r\n"}, {"instruction": "Write a Fortran function named mnorm that calculates the Euclidean norm of a 2D array. The function takes 1 input argument of type real(kind=8) and returns 1 output argument of type real(kind=8).", "input": "", "output": "    function mnorm(a) result(norma)\r\n\r\n    integer         :: sha(2)\r\n    real(kind=8)    :: a(:,:), norma\r\n    integer         :: i, j\r\n\r\n    intent(in)      :: a\r\n\r\n    sha = shape(a)\r\n    norma = 0.d0\r\n    do i=1,sha(1)\r\n        do j=1,sha(2)\r\n            norma = norma + a(i,j)**2\r\n        end do\r\n    end do\r\n\r\n    norma = sqrt(norma)\r\n\r\n    end function mnorm\r\n"}, {"instruction": "Create a Fortran function named vdot that calculates the dot product of two arrays of double precision floating-point numbers. The function takes 2 input arguments of type real(kind=8) and produces 1 output argument of type real(kind=8).", "input": "", "output": "    pure function vdot(x,y) result(z)\r\n\r\n    real(kind=8)\t::  x(:), y(:), z\r\n    integer\t\t\t::  i\r\n\r\n    intent(in)      ::  x, y\r\n\r\n\tz = 0.d0\r\n    do i = 1, size(x)\r\n        z = z + x(i)*y(i)\r\n    end do\r\n\r\n    end function vdot\r\n"}, {"instruction": "Write a Fortran function named norm to calculate the Euclidean norm of a real(kind=8) array. The function has 1 input parameter with a test_data type of ['real(kind=8)'] and 1 output parameter with a test_data type of ['real(kind=8)'].", "input": "", "output": "    pure function norm(x) result(y)\r\n\r\n    real(kind=8)\t::  x(:), y\r\n    integer\t\t\t::  i\r\n\r\n    intent(in)      ::  x\r\n\r\n\ty = 0.d0\r\n    do i = 1, size(x)\r\n        y = y + x(i)**2\r\n    end do\r\n\ty = sqrt(y)\r\n\r\n    end function norm\r\n"}, {"instruction": "Write a Fortran function named inner that takes two 3x3 matrices as input and computes the inner product of the matrices. The number of input arguments is 2, and the test_data type is ['', '']. The number of output arguments is 1, and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function inner(a,b) result(c)\r\n\r\n    integer\t\t\t::  i, j\r\n    real(kind=8)\t::  a(3,3), b(3,3), c\r\n\r\n    intent(in)      ::  a, b\r\n\r\n\tc = 0.d0\r\n    do i = 1,3\r\n        do j = 1,3\r\n            c = c + a(i,j)*b(i,j)\r\n        end do\r\n    end do\r\n\r\n    end function inner\r\n"}, {"instruction": "Create a Fortran function named fun_convert_delta14ctod14c to convert delta 14C to d14C. The function takes 2 input arguments of type real, named dum_delta13c and dum_delta14c. It returns 1 output argument of type real.", "input": "", "output": "  function fun_convert_delta14ctod14c(dum_delta13c,dum_delta14c)\n    implicit none\n    ! result variable\n    real::fun_convert_delta14ctod14c\n    ! dummy arguments\n    real,intent(in)::dum_delta13c,dum_delta14c\n\n    ! note: see stuiver and polach [1977] (stuiver and robinson [1974])\n    fun_convert_delta14ctod14c = 1000.0* &\n         &( &\n         &   (1.0 + dum_delta14c/1000.0) * &\n         &   (0.975**2)/((1.0 + dum_delta13c/1000.0)**2) - &\n         &   1.0 &\n         & )\n  end function fun_convert_delta14ctod14c\n"}, {"instruction": "Write a Fortran function named repmat to replicate a matrix along specified dimensions. The function takes 2 input parameters of type double precision, dimension(:,:) and integer, dimension(2) respectively. It returns 1 output parameter of type double precision, dimension(:,:), allocatable.", "input": "", "output": "function repmat(m,vecdim) result(r)\n\n  implicit none\n  double precision, dimension(:,:) :: m\n  double precision, dimension(:,:), allocatable :: r\n  integer, dimension(2) :: vecdim, sizem , sizef\n  integer :: i,jr,j,ir\n\n  sizem = shape(m)\n\n  do i = 1,2 !(int i=0;i<siz.length;i++){\n      sizef(i) = sizem(i)*vecdim(i)   ! sizf[i] = siz[i]*repdim[i];\n  end do ! determine the final size desired after repmat. !} // determine the final size desired after repmat.\n\n\n  allocate(r(sizef(1),sizef(2)))\n\n  do jr = 1, vecdim(2) !for (int jr = 1; jr <= repdim[1]; jr++) {\n    do j = 1, sizem(2) ! for (int j = 0; j < siz[1]; j++) {\n      do ir = 1, vecdim(1) !for (int ir = 1; ir <= repdim[0]; ir++) {\n        do i = 1,sizem(1)   ! for (int i = 0; i < siz[0]; i++) {\n          r( (ir-1)*sizem(1)+i,(jr-1)*sizem(2)+j ) = m(i,j) ! result[ (ir-1)*siz[0]+i ][ (jr-1)*siz[1]+j ] = m[i][j];\n        end do !} // 1st dim\n      end do !} // 1st rep\n    end do  !} // 2nd dim\n  end do !} // 2nd rep\n\n\nend function repmat\n"}, {"instruction": "Create a Fortran function named ones1 that takes an integer input argument and returns an integer array of the same size filled with ones. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(s1)'].", "input": "", "output": "function ones1(s1) result(v)\n  implicit none\n  integer :: s1\n  integer, dimension(s1) :: v ! output\n  v = 1\nend function ones1\n"}, {"instruction": "Write a Fortran function named ones2 that initializes a 2D array with ones. The function takes 2 input arguments of type integer and returns a 2D integer array of size s1 x s2 as the output. The function should be named \"ones2\".", "input": "", "output": "function ones2(s1,s2) result(v)\n  implicit none\n  integer :: s1,s2\n  integer, dimension(s1,s2) :: v ! output\n  v = 1\nend function ones2\n"}, {"instruction": "Create a Fortran function named invs that takes a double precision input argument and returns the inverse of the input as a double precision output. The number of input parameters is 1, and the test_data type is ['double precision']. The number of output parameters is 1, and the test_data type is ['double precision'].", "input": "", "output": "  function  invs(ms) result(minv)\n    implicit none\n    double precision ::  ms ! input\n    double precision ::  minv ! output\n\n    minv = 1/ms\n  end function invs\n"}, {"instruction": "Write a Fortran function named linspace to generate a linearly spaced vector of real numbers between a start value and an end value, with a specified number of elements. The function takes 3 input parameters of types double precision, double precision, and integer, and returns 1 output parameter of type double precision array with dimension n.", "input": "", "output": "  function  linspace(vi,vf,n) result(m)\n    implicit none\n    double precision :: vi,vf,dx\n    integer :: n,i\n    double precision, dimension(n) :: m ! output\n\n    dx = (vf-vi)/(n-1)\n    m = (/(i, i=0,n-1, 1)/)*dx\n\n  end function linspace\n"}, {"instruction": "Write a Fortran function named incr that generates an array of integers starting from 'a' and ending at 'b', where 'a' and 'b' are input integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, allocatable, dimension(:)'].", "input": "", "output": "  function  incr(a,b) result(m)\n    implicit none\n    integer :: a,b,i,n\n    integer, allocatable, dimension(:) :: m ! output\n\n    n = b-a+1\n    allocate( m(n) )  != (/(i, i=a, b, 1)/)\n    m = (/(i, i=a, b, 1)/)\n\n  end function incr\n"}, {"instruction": "Write a Fortran function named h_1 to concatenate two input arrays m1 and m2 into a single output array m. The number of input arguments is 2 and the test_data type is ['double precision, dimension(:)', 'double precision, dimension(:)']. The number of output arguments is 1 and the test_data type is ['double precision, dimension(size(m1)+size(m2))'].", "input": "", "output": "function h_1(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:) :: m1,m2 ! input\n  double precision, dimension(size(m1)+size(m2)) :: m ! output\n\n  m = [m1,m2]\n  !m(1:size(m1,1)) = m1\n  !m(size(m1,1)+1:(size(m1,1)+size(m2,1))) = m2\n\nend function h_1\n"}, {"instruction": "Write a Fortran function called v_1real that takes two arrays of double precision values as input and returns a 2xN array where N is the size of the input arrays. The number of input arguments is 2 and the test data type is ['double precision, dimension(:)', 'double precision, dimension(:)']. The number of output arguments is 1 and the test data type is ['double precision, dimension(2,size(m1))'].", "input": "", "output": "function v_1real(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:) :: m1,m2 ! input\n  double precision, dimension(2,size(m1)) :: m ! output\n\n\n  m(1,:) = m1\n  m(2,:) = m2\n\nend function v_1real\n"}, {"instruction": "Create a Fortran function named v_2real that combines two input matrices m1 and m2 into a single output matrix m. The input parameters are both double precision matrices of unspecified size, while the output parameter is a double precision matrix with a size equal to the combined number of rows of m1 and m2, and the number of columns of m1.", "input": "", "output": "function v_2real(m1,m2) result(m)\n  implicit none\n  double precision, dimension(:,:) :: m1,m2 ! input\n  double precision, dimension(size(m1,1)+size(m2,1),size(m1,2)) :: m ! output\n\n\n  m(1:size(m1,1),:) = m1\n  m(size(m1,1)+1:size(m1,1)+size(m2,1),:) = m2\n\nend function v_2real\n"}, {"instruction": "Create a Fortran function named \"gammln\" that calculates the natural logarithm of the absolute value of the gamma function for a double precision input parameter. The number of input arguments is 1 with a test_data type of ['double precision'], and the number of output arguments is 1 with a test_data type of ['double precision'].", "input": "", "output": "function gammln(xx)\n\n!***   taken from the \"numerical recipes\"\n\n!--------------------------------------------------\nimplicit none\ndouble precision :: xx\ndouble precision :: gammln\ninteger :: j\ndouble precision :: ser,stp,tmp,x,y\ndouble precision, dimension(6) :: cof\nsave cof,stp\ndata cof,stp/76.18009172947146d0,-86.50532032941677d0,24.01409824083091d0,  &\n            -1.231739572450155d0,.1208650973866179d-2,-.5395239384953d-5, &\n            2.5066282746310005d0/\n!\n!-------- executable code\n!\nx=xx\ny=x\ntmp=x+5.5d0\ntmp=(x+0.5d0)*dlog(tmp)-tmp\nser=1.000000000190015d0\ndo j=1,6\n   y=y+1.d0\n   ser=ser+cof(j)/y\nenddo\ngammln=tmp+dlog(stp*ser/x)\nreturn\nend function gammln\n"}, {"instruction": "Create a Fortran function named flipcount that takes 3 input parameters of type integer: a, b, and nbits. The function returns a single output parameter of type integer. This function calculates the number of bit positions at which the binary representations of integers a and b differ, up to the nth bit, and stores the count in the variable c.", "input": "", "output": "pure function flipcount(a,b,nbits) result(c)\n\n    integer, intent(in) :: a,b,nbits\n    integer             :: n,i\n    integer             :: c\n\n    c = 0\n    n = 1\n    \n    do i = 1,nbits\n        if (iand(a,n) /= iand(b,n)) c = c + 1\n        n = 2*n\n    end do\n\nend function\n"}, {"instruction": "Write a Fortran function named formatcesmdate that takes 6 input parameters of type integer: ccyy, mm, dd, hh, nn, and ss. It returns a single output parameter of type character with a length of 80. This function computes and formats a date and time into a specific format and assigns it to the output parameter formatcesmdate.", "input": "", "output": "function formatcesmdate(ccyy,mm,dd,hh,nn,ss)\ninteger, intent(in) :: ccyy\ninteger, intent(in) :: mm\ninteger, intent(in) :: dd\ninteger, intent(in) :: hh\ninteger, intent(in) :: nn\ninteger, intent(in) :: ss\ncharacter(len=80) :: formatcesmdate\n\ninteger :: fffff\n\nfffff = hh*3600 + nn*60 + ss\nwrite(formatcesmdate, '(i4.4,1a,2(i2.2,1a),i5.5)') ccyy, '-', mm, '-', dd, '-', fffff\n\nend function formatcesmdate\n"}, {"instruction": "Create a Fortran function named convertfunc that takes two integer input parameters and returns a character string of length 10. The first input parameter represents the number to be converted, and the second input parameter specifies the base for conversion. The function converts the input number to the specified base and returns the result as a character string of length 10.", "input": "", "output": "  function convertfunc(innumber, switch) result(outname)\n    implicit none\n    integer :: innumber, switch\n    character(len=10) :: outname\n\n    character(len=10) :: buf, flag\n    integer :: j, bd\n\n    bd = 0\n    if (switch == 10) then\n       flag = '(i10)'\n       bd = 10\n       write (buf,10) innumber\n10     format (i10)\n    else if (switch == 2) then\n       flag = '(i2)'\n       bd = 2\n       write (buf,20) innumber\n20     format (i2)\n    else if (switch == 4) then\n       flag = '(i4)'\n       bd = 4\n       write (buf,30) innumber\n30     format (i4)\n    end if\n\n    do j = 1, bd\n       if (buf(j:j) == ' ') buf(j:j) = '0'\n    end do\n    outname = trim(buf)\n  end function convertfunc\n"}, {"instruction": "Create a Fortran function named random_int to generate a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "  function random_int(left, right) result(rand)\n    real :: random_real\n    integer :: left, right, rand\n    call random_number(random_real)\n    rand = left + floor((right+1-left)*random_real)\n  end function random_int\n"}, {"instruction": "Create a Fortran function named dy to calculate the value of dy, given the values of t and y. The number of input arguments is 2 with the test_data type of [real, real], and the number of output arguments is 1 with the test_data type of [real]. Use the formula dy = (5 * t * t - y) / ( e ** (t + y )) to compute the result, where e is a predefined constant.", "input": "", "output": "function dy(t, y)\n    implicit none\n\n    real :: dy\n    real :: y\n    real :: t\n\n    real, parameter :: e = 2.71828\n\n    dy = (5 * t * t - y) / ( e ** (t + y ))\n    return\nend function dy\n"}, {"instruction": "Create a Fortran function named add_mixed that takes in two required integer parameters and two optional integer parameters. The function returns an integer. When called, the function computes the sum of the required parameters and, if the optional parameters are provided, adds them to the sum as well.", "input": "", "output": "    function add_mixed(a,b,c,d) result(y)\n      integer, intent(in) :: a,b ! test optional ::\n      integer, intent(in), optional :: c,d\n      integer :: y\n      y = a+b\n      if (present(c)) y = y + c\n      if (present(d)) y = y + d\n    end function add_mixed\n"}, {"instruction": "Write a Fortran function named compute_error to calculate the relative error between two matrices. The function takes 2 input arguments of type real, each with a two-dimensional array. The output is a single real value representing the relative error.", "input": "", "output": "    function compute_error(orig_a, a) result(rel_err)\n        implicit none\n        real, dimension(:, :), intent(in) :: orig_a, a\n        real :: rel_err\n        integer :: i, j\n        real :: norm\n        rel_err = 0.0\n        do j = 1, size(a, 2)\n            do i = 1, size(a, 1)\n                norm = abs(orig_a(i, j))\n                rel_err = rel_err + abs(a(i, j) - orig_a(i, j))/norm\n            end do\n        end do\n        rel_err = rel_err/(size(a, 1)*size(a, 2))\n    end function compute_error\n"}, {"instruction": "Create a Fortran function named cap to limit the input integer value to a maximum of 10. The function should take 1 input argument of type integer and return 1 output argument of type integer.", "input": "", "output": "pure function cap(x)\n  implicit none\n  integer, intent(in) :: x\n  integer :: y\n  integer :: cap\n  y = x\n  if (10 < y) then\n      y = 10\n  end if\n  cap = y\nend function\n"}, {"instruction": "Create a Fortran function named bcut_getweno3 to calculate a weighted essentially non-oscillatory (WENO) reconstruction. The function takes 3 real input parameters ('real', 'real', 'real') and returns 1 real output parameter ('real').", "input": "", "output": "function bcut_getweno3(v1, v2, v3)\n  implicit none\n  real          :: bcut_getweno3\n  real          :: v1, v2, v3\n  real          :: r\n  real          :: w\n  real          :: eps\n  eps = 0.001\n  r = (eps + (v2-v1)**2)/(eps + (v3-v2)**2)\n  w = 1.0/(1.0 + 2*r*r)\n  bcut_getweno3 = 0.5*(v2 + v3) - 0.5*w*(v1 - 2.0*v2 + v3)\n  return\nend function bcut_getweno3\n"}, {"instruction": "Create a Fortran pure function named lower to convert specified portions of a string to lowercase. The function takes 3 input parameters: str (character(*)), begin (integer, optional), and end (integer, optional). The output parameter is string (character(len(str))). The function loops through the specified portion of the input string and converts uppercase letters to lowercase. If begin and end are not specified, the function converts the entire string to lowercase.", "input": "", "output": "elemental pure function lower(str,begin,end) result (string)\n\ncharacter(*), intent(in)     :: str\ncharacter(len(str))          :: string\ninteger,intent(in),optional  :: begin, end\ninteger                      :: i\ninteger                      :: ibegin, iend\ninteger,parameter             :: diff = iachar('a')-iachar('a')\n   string = str\n   ibegin=1\n   iend=len_trim(str)\n\n   if (present(begin))then\n      ibegin = min(max(1,begin),iend)\n   endif\n\n   if (present(end))then\n      iend= max(1,min(iend,end))\n   endif\n\n   do concurrent (i = ibegin:iend)\n      select case (str(i:i))\n      case ('a':'z')\n         string(i:i) = char(iachar(str(i:i))-diff)\n      case default\n      end select\n   enddo\n\nend function lower\n"}, {"instruction": "Create a Fortran function named mean to calculate the mean value of an array of real numbers. The function should take 2 input parameters: an integer 'n' and an array of real numbers 'x' with dimension 'n'. The function should return a single real value as the mean.", "input": "", "output": "   function mean(x, n) result(m)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, intent(in), dimension(n) :: x\n\n      real :: m\n      ! processing\n      m = sum(x) / n\n   end function mean\n"}, {"instruction": "Write a Fortran function named compute_dev that takes 3 input parameters of types integer, real, and real array of dimension n, and returns 1 output parameter of type real array of dimension n. The function calculates the deviation of each element in the input array x from the value m, and stores the result in the array dev.", "input": "", "output": "   function compute_dev(x, m, n) result(dev)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, intent(in) :: m\n      real, dimension(n), intent(in) :: x\n\n      real, dimension(n) :: dev\n      ! processing\n      dev = x - m\n   end function compute_dev\n"}, {"instruction": "Create a Fortran function named phexp that takes a single real number of kind=8 as input and returns a complex number of kind=8 as output. The function computes the complex exponential value of the input real number using the cosine and sine functions.", "input": "", "output": "  function phexp(x)\n    implicit none\n\n    real(kind=8),intent(in) :: x\n    complex(kind=8) :: phexp\n\n    phexp=cmplx(cos(x),sin(x),kind=8)\n  end function phexp\n"}, {"instruction": "Create a Fortran function named iget_class to determine the class of an integer input. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of type ['integer'] and the output parameter is of type ['integer'].", "input": "", "output": "        function iget_class(m) result(ires)\r\n            integer, intent(in) :: m\r\n            integer :: ires\r\n            select case (m)\r\n            case (:-3)\r\n                ires = 1\r\n            case (-2:-1)\r\n                ires = 2\r\n            case (0)\r\n                ires = 3\r\n            case (1:2)\r\n                ires = 4\r\n            case (3:)\r\n                ires = 5\r\n            end select\r\n        end function iget_class\r\n"}, {"instruction": "Create a Fortran function named conv_sic that takes an integer input parameter and returns a character string of length 3. The input parameter should be of type integer, and the output should be of type character with a length of 3.", "input": "", "output": "  function conv_sic(i)\n    implicit none\n    character(len=3) :: conv_sic\n    integer :: i\n    integer :: i1, i2, itemp, i3\n    character(len=1) ::  a, b, c\n    if (i < 10) then\n       a = char(i + 48)\n       conv_sic = a // '  '\n    else if (i < 100) then\n       i1 = i / 10\n       i2 = i - i1 * 10\n       a = char(i1 + 48)\n       b = char(i2 + 48)\n       conv_sic = a // b // ' '\n    else\n       i1 =i / 100\n       itemp = i - 100 * i1\n       i2 = itemp / 10\n       i3 = itemp - 10 * i2\n       a = char(i1 + 48)\n       b = char(i2 + 48)\n       c = char(i3 + 48)\n       conv_sic = a // b // c\n    end if\n  end function conv_sic\n"}, {"instruction": "Write a Fortran function named new_ext to create a new file name with the specified extension. The function takes 2 input parameters of type character(len = *) and returns 1 output parameter of type character(len = 256).", "input": "", "output": "function new_ext(file_name, extension)\n\n    implicit none\n    character(len = *), intent(in)  :: file_name  ! file to add new extension to\n    character(len = *), intent(in)  :: extension  ! new extension to add\n    character(len = 256)            :: new_ext    ! file name with new extension\n    integer, dimension(2)           :: ext_pos    ! positions of extension separators\n\n    ext_pos = (/ scan(trim(file_name), '_tmp', back = .true.) - 4,  scan(trim(file_name), '.', back = .true.) - 1 /)\n    if (any(ext_pos > 0)) then\n        new_ext = file_name(1:minval(ext_pos, (ext_pos > 0))) // extension\n    else\n        new_ext = trim(file_name) // extension\n    end if\n\nend function new_ext\n"}, {"instruction": "Create a Fortran function named integrand to calculate the value of the integrand function for a given real input value. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function integrand(x)\n        \n        implicit none \n        real :: x, integrand\n\n        integrand = 4.d0/(1.d0 + x**2)\n\nend function\n"}, {"instruction": "Write a Fortran function named \"limiter\" to calculate a limited value based on the given input values and limiter type. The number of input arguments for the function is 3, with test_data types ['real(kind=8)', 'real(kind=8)', 'integer'], and the number of output arguments is 1 with test_data type ['real(kind=8)'].", "input": "", "output": "  function limiter(sm, sp, limiter_type) result(s)\n    implicit none\n    real(kind=8), intent(in)::sm, sp\n    real(kind=8) :: s\n    real(kind=8) :: epsilon\n    integer, intent(in)::limiter_type\n\n    epsilon = 1d-12\n\n    s = 0\n\n    select case (limiter_type)\n\n    case (0) ! first order upwind\n      s = 0\n\n    case (1) ! lax wendroff\n      s = sp\n\n    case (2) ! minmod\n      s = max(0.0_8, min(sm, sp))*sign(1.0_8, sm + sp)\n\n    case (3) ! harmonic\n      s = (sm*abs(sp) + abs(sm)*sp)/(abs(sm + abs(sp) + epsilon))\n\n    case (4) ! geometric\n      s = sqrt((sm*sp + abs(sm*sp))/2)*sign(1.0_8 + 0, sm + sp)\n\n    case (5) !superbee\n      s = max(0.0_8, max(min(2*abs(sm), abs(sp)), min(abs(sm), 2*abs(sp)))) &\n          *sign(1.0_8, sm + sp)\n\n    end select\n\n  end function limiter\n"}, {"instruction": "Create a Fortran pure function named to_string, which is designed to convert an integer value to a string representation. The function takes 1 input argument of type integer, and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "    pure function to_string(x) result(string)\n\n        !> \u9700\u8981\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u7684\u6574\u6570\n        !> integer to be converted to string\n        integer, intent(in) :: x\n        !> \u8f6c\u6362\u540e\u7684\u5b57\u7b26\u4e32\n        !> string after conversion\n        character(:), allocatable :: string\n\n        integer, parameter :: buffer_len = range(x) + 2\n        character(buffer_len) :: buffer\n        integer :: pos\n        integer :: n\n        character(1), parameter :: number(0:9) = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n        if (x == 0) then\n            string = number(0)\n            return\n        end if\n\n        n = abs(x)\n        buffer = \"\"\n\n        pos = buffer_len + 1\n        do while (n > 0)\n            pos = pos - 1\n            buffer(pos:pos) = number(mod(n, 10))\n            n = n/10\n        end do\n        if (x < 0) then\n            pos = pos - 1\n            buffer(pos:pos) = \"-\"\n        end if\n\n        string = buffer(pos:)\n\n    end function to_string\n"}, {"instruction": "Write a Fortran function named erf that calculates the error function (erf) for a given real number (x). The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function erf(x)\n!\nimplicit none\n!\n\n!\nreal :: x\nreal :: erf\n!\n! local variables\n!\nreal :: a,b,c,d,e,f,g,h,i,j,k,x2,x3,x4,x5,z\n!\n!**********************************************************************\n \n!     + + + purpose + + +\n\n!     written by l. hagen and coded by i. elmanyawi.\n \n!     + + + argument declarations + + +\n \n!     + + + local variables + + +\n!\n!     + + + end specifications + + +\n!\na = -0.000018936\nb = 0.030284321\nc = 1.12891921\nd = 0.37693092\ne = 0.029375235\nf = 0.088848989\ng = 0.068200064\nh = 0.022155958\ni = 0.050754183\nj = 0.038090749\nk = 0.034275052\n \nz = x\nx = abs(x)\nx2 = x*x\nx3 = x2*x\nx4 = x3*x\nx5 = x4*x\n \nerf = (a+c*x+e*x2+g*x3+i*x4+k*x5)/(1.000000+b*x+d*x2+f*x3+h*x4+j*x5)\nerf = erf*z/x\n!\nend function erf\n"}, {"instruction": "Create a Fortran function named bnc that computes the number of cells for a subdomain in one dimension. The function takes in the total number of cells for a dimension (n), the number of processes in that dimension (p), and the rank. It returns the integer number of cells for that subdomain (bnc). The input parameters are of type integer and the order is (n, p, rank), while the output parameter is also of type integer.", "input": "", "output": "function bnc(n,p,rank)\n\n!-------------------------------------------------------------\n!\n!  compute the number of cells for the subdomain, one\n!   dimension at a time.\n!  take in the number of cells total for a dimension, n, the \n!   number of processes p in that dimension, and the rank.\n!  return the integer number of cells for that sub-domain, bnc.\n!\n!  when not evenly divided, keeps all but one even, then tries\n!   tries to keep last sub-domain close\n!\n!-------------------------------------------------------------\n\nimplicit none\ninteger, intent(in) :: n, p, rank\ninteger :: bnc, tmpi1, tmpi2\nreal :: tmpr\n\n! set the values to be checked against\ntmpr = 0.5*real(p)\n\ntmpi1 = mod(n,p)\ntmpi2 = n/p\n\n! if it's evenly divisible, just use the division\nif (tmpi1 == 0) then\n   bnc = tmpi2\n\n! if not, then compare the mod result to half the number of processes and set\nelse if (real(tmpi1) < tmpr) then\n   if (rank /= p-1) then\n      bnc = tmpi2\n   else\n      bnc = n - (p-1)*tmpi2\n   end if\n\nelse if (real(tmpi1) >= tmpr) then\n   if (rank /= p-1) then\n      bnc = tmpi2 + 1\n   else\n      bnc = n - (p-1)*(tmpi2+1)\n   end if\n\nend if\n\nend function bnc\n"}, {"instruction": "Create a Fortran function named \"napetost\" to calculate the voltage based on the given temperature. The function takes 1 input argument of type real. The input test_data type is ['real']. The function returns 1 output argument of type real. The output test_data type is ['real']. If the temperature is less than 40.0, the voltage is set to 10.0; otherwise, the voltage is set to 0.0.", "input": "", "output": "    function napetost(t)\n        implicit none\n        real :: napetost, t\n\n        if (t < 40.0) then\n            napetost = 10.0\n        else\n            napetost = 0.0\n        end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named \"de\" that takes a single real number as input and returns it as output. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function de(e1)\n        implicit none\n        real :: de,e1\n        de = e1\n    end function\n"}, {"instruction": "Provide a Fortran function named de1 that assigns the value of a real input parameter to a real output parameter. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function de1(e2)\n        implicit none\n        real :: de1,e2\n        de1 = e2\n    end function\n"}, {"instruction": "Create a Fortran function named \"de2\" that takes one real number as input and returns it as the output. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "    function de2(e3)\n        implicit none\n        real :: de2,e3\n        de2 = e3\n    end function\n"}, {"instruction": "Create a Fortran function named de3 that takes one real input argument. This function assigns the value of the input argument to a variable named de3. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "    function de3(e4)\n        implicit none\n        real :: de3,e4\n        de3 = e4\n    end function\n"}, {"instruction": "Create a Fortran function named mean to calculate the mean value. This function takes 2 input parameters of type real and integer, denoted as [real, integer]. It returns 1 output parameter of type real, denoted as [real].", "input": "", "output": "function mean(summ, count) result(fn_val)\r\nimplicit none\r\n\r\nreal, intent(in)     :: summ\r\ninteger, intent(in)  :: count\r\nreal                 :: fn_val\r\n\r\nfn_val = summ / real(count)\r\n\r\nreturn\r\nend function mean\r\n"}, {"instruction": "Create a Fortran function called fact to calculate the factorial of a given integer number. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. If the input parameter is negative, the function returns 0.0.", "input": "", "output": "function fact (n) result(fn_val)\r\n\r\n!     algorithm as 304.10 appl.statist. (1996), vol.45, no.3\r\n\r\n!     returns the factorial of n or 0.0 if the parameter is negative.\r\n\r\nimplicit none\r\ninteger, intent(in) :: n\r\nreal                :: fn_val\r\n\r\ninteger  :: i\r\n\r\nif (n < 0) then\r\n  fn_val = 0.0\r\nelse\r\n  fn_val = 1.0\r\n  do i = 2, n\r\n    fn_val = fn_val * real(i)\r\n  end do\r\nend if\r\n\r\nreturn\r\nend function fact\r\n"}, {"instruction": "Create a Fortran function named f to calculate the value of f using the input parameters t and y. The input parameters t and y are both of type real(kind=kind(1.0d0)). The output parameter f is also of type real(kind=kind(1.0d0)). The function uses the formula f = t*sqrt(y).", "input": "", "output": "  function f (t,y)\n    implicit none\n    real(kind=kind(1.0d0)),intent(in) :: y,t\n    real(kind=kind(1.0d0)) :: f\n    f = t*sqrt(y)\n  end function f\n"}, {"instruction": "Create a Fortran recursive function named factorial. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function computes the factorial of the input integer using recursive multiplication.", "input": "", "output": "recursive function factorial(n) result(total)\n    implicit none\n    integer :: n, total\n    if (n .eq. 0) then\n        total = 1\n    else\n        total = n * factorial(n - 1)\n    endif\n\nend function factorial\n"}, {"instruction": "Create a Fortran function named norm to calculate the Euclidean norm of a real(kind=8) array. The input parameter is an array of real(kind=8), with intent(in) and dimension(:). The output parameter is a real(kind=8).", "input": "", "output": "    pure function norm(vector) result(res)\n        real(kind=8), dimension(:), intent(in) :: vector\n        real(kind=8) :: res\n        integer :: i\n        \n        res = 0\n        do i = 1, size(vector), 2\n            res = res + vector(i) ** 2\n        end do\n        \n        res = sqrt(res)\n    \n    end function norm\n"}, {"instruction": "Create a Fortran function named rtndt that calculates the value of rtndt based on the input parameters a, cf, fsurf, and rtndt0, all of which are of type real. The function has 4 input parameters of type real and 1 output parameter of type real.", "input": "", "output": "    function rtndt(a, cf, fsurf, rtndt0)\n\n        !variables\n        real :: rtndt, d_rtepi, d_rtndt, phi, f\n        real, intent(in) :: a, cf, fsurf, rtndt0\n\n        !calculate d_rtepi\n        call random_number(phi)\n        d_rtepi = -29.5+78.0*(-log(1-phi))**(1/1.73)\n\n        !calculate d_rtndt\n        f = fsurf*exp(-0.24*a)\n        d_rtndt = cf*f**(0.28-0.10*log10(f))\n\n        !calculate the rtndt\n        rtndt = rtndt0 + d_rtepi + d_rtndt\n\n    end function rtndt\n"}, {"instruction": "Create a Fortran function named ffun that calculates the result using the formula ffun = x + y * y. The function should take 2 input arguments of type double precision and return 1 output argument of type double precision.", "input": "", "output": "function ffun(x, y)\n    implicit none\n    !dec$ attributes dllexport, stdcall, reference :: ffun\n    double precision :: x, y, ffun\n    ffun = x + y * y\nend function\n"}, {"instruction": "Write a Fortran function named get_characteristic that takes an input argument of type integer(kind=1) and returns an output of the same type. The function computes the characteristic of the input as follows: if the input is less than 0, it adds 256 to the input; then, if the input is greater than or equal to 128, it subtracts 128 from the input. Finally, it returns the characteristic value.", "input": "", "output": "  function get_characteristic(b) result (c)\n    \n    implicit none\n    \n    integer(kind=1)                      :: c\n    integer(kind=1),         intent(in)  :: b\n    integer                              :: w\n    \n    w=b\n\n    if (w<0) w=256+w\n\n    if (w>=128) then\n      w=w-128\n    end if\n\n    c=w\n    return\n    \n  end function get_characteristic\n"}, {"instruction": "Create a Fortran function called plasma_init_c to initialize a plasma application with the specified number of cores. The function takes 1 input parameter of type integer(kind=c_int), passed by value. The output is of type integer(kind=c_int). Use the bind(c) attribute to specify the name \"plasma_init\" for the function when interfacing with C code.", "input": "", "output": "         function plasma_init_c(cores) &\n          & bind(c, name='plasma_init')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_init_c\n            integer(kind=c_int), value :: cores\n         end function plasma_init_c\n"}, {"instruction": "Create a Fortran function named \"plasma_set_c\" that sets a parameter value for a plasma system. The function takes 2 input arguments of type \"integer(kind=c_int), value\" and returns 1 output argument of type \"integer(kind=c_int)\". The function should be used to bind to the C function \"plasma_set\".", "input": "", "output": "         function plasma_set_c(param, pval) &\n          & bind(c, name='plasma_set')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_set_c\n            integer(kind=c_int), value :: param\n            integer(kind=c_int), value :: pval\n         end function plasma_set_c\n"}, {"instruction": "Create a Fortran function named plasma_get_c that returns an integer value. This function takes two input parameters: an integer parameter and a pointer to a C type. The input parameters are of type integer(kind=c_int) and type(c_ptr), both passed by value. The output parameter is also of type integer(kind=c_int).", "input": "", "output": "         function plasma_get_c(param, pval) &\n          & bind(c, name='plasma_get')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: plasma_get_c\n            integer(kind=c_int), value :: param\n            type(c_ptr), value :: pval\n         end function plasma_get_c\n"}, {"instruction": "Write a Fortran function named plasma_lapack_to_tile_c. The function takes in 3 input parameters of type 'type(c_ptr), value', 'type(c_ptr), value', and 'integer(kind=c_int), value'. The output is a single integer of kind c_int.", "input": "", "output": "         function plasma_lapack_to_tile_c(a_lpk,lda,a_pma) &\n          & bind(c, name='plasma_lapack_to_tile')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_lapack_to_tile_c\n            type(c_ptr), value :: a_lpk, a_pma\n            integer(kind=c_int), value :: lda\n         end function plasma_lapack_to_tile_c\n"}, {"instruction": "Create a Fortran function named plasma_sequence_destroy_c to destroy a plasma sequence. It takes 1 input parameter of type c_ptr and value, and returns 1 output parameter of type integer with kind c_int.", "input": "", "output": "         function plasma_sequence_destroy_c(seq) &\n          & bind(c, name='plasma_sequence_destroy')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_destroy_c\n            type(c_ptr), value :: seq\n         end function plasma_sequence_destroy_c\n"}, {"instruction": "Create a Fortran function named plasma_sequence_wait_c. The function takes 1 input parameter of type c_ptr with the attribute value. It returns an output parameter of type integer with a kind attribute of c_int.", "input": "", "output": "         function plasma_sequence_wait_c(seq) &\n          & bind(c, name='plasma_sequence_wait')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_wait_c\n            type(c_ptr), value :: seq\n         end function plasma_sequence_wait_c\n"}, {"instruction": "Write a Fortran function named plasma_sequence_flush_c that takes two input parameters of type c_ptr and value. The number of input arguments is 2 and the test_data type is ['type(c_ptr), value', 'type(c_ptr), value']. The function returns an output parameter of type integer with kind c_int. The number of output arguments is 1 and the test_data type is ['integer(kind=c_int)'].", "input": "", "output": "         function plasma_sequence_flush_c(seq,req) &\n          & bind(c, name='plasma_sequence_flush')\n            use iso_c_binding\n            integer(kind=c_int) :: plasma_sequence_flush_c\n            type(c_ptr), value :: seq\n            type(c_ptr), value :: req\n         end function plasma_sequence_flush_c\n"}, {"instruction": "Create a Fortran function named concat that takes two input arguments of type character with variable length. The number of input arguments is 2, and the test_data type is ['character (len=*)', 'character (len=*)']. The function should return a single output argument of type character with a length equal to the sum of the lengths of the input strings. The number of output parameters is 1, and the test_data type is ['character (len=(len_trim(cha) + len_trim(chb)))']. The function concatenates the two input strings and returns the result.", "input": "", "output": " function concat(cha,chb)\n implicit none\n character (len=*), intent(in) :: cha, chb \n character (len=(len_trim(cha) + len_trim(chb))) :: concat\n concat = trim(cha)//trim(chb)\n end function concat\n"}, {"instruction": "Create a Fortran function named g that takes 3 input parameters of type double precision, denoted as (t, x, y), and returns 1 output parameter of type double precision.The function computes the value of g using the given formula.", "input": "", "output": "function g(t, x, y)\n  double precision::g, t, x, y, a, c\n  !g=-x + t*x*y*0.0\n  a=-9.932e-6\n  c=1.575e-6\n  g=a*sin(x)+c*sin(2*x)\nend function g\n"}, {"instruction": "Write a Fortran function named flatten_method to calculate the interval between two points in three-dimensional space. The function takes 2 input parameters of type real, dimension (1:3), and returns 1 output parameter of type real.", "input": "", "output": "  function flatten_method(first_point_coord, second_point_coord) result(interval)\n    implicit none\n    real, dimension (1:3) :: first_point_coord, second_point_coord\n    real :: interval\n    integer :: i\n    interval = 0d0\n    do i = 1, 3\n      interval = (first_point_coord(i) - second_point_coord(i)) ** 2 + interval\n    end do\n  end function flatten_method\n"}, {"instruction": "Create a Fortran function named gettmu to calculate the value of t/mu in a cell. The function takes 3 input parameters of type real(kind=8), real(kind=8), and logical, and returns 1 output parameter of type real(kind=8).", "input": "", "output": "elemental function gettmu(rho, p, subpol)\n\n! calculate t/mu in cell\n! all in arguments are in user units and the result is in kelvin.\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::rho, p\n  logical,intent(in)::subpol\n  real(kind=8)::gettmu\n!-------------------------------------------------------------------------\n  gettmu = p/rho * unit_t2\n  if(subpol) gettmu = gettmu - t2_star*(rho*unit_nh/n_star)**(g_star-1d0)\nend function gettmu\n"}, {"instruction": "Create a Fortran function named ispolytrope to determine whether cells are polytropic or not based on the given input of density and pressure. The number of input arguments is 2, both of type real(kind=8). The number of output arguments is 1 of type real(kind=8).", "input": "", "output": "elemental function ispolytrope(rho, p)\n\n! calculate whether cells are polytropic (1.) or not (0.)\n! all in arguments are in user units\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::rho, p\n  real(kind=8)::ispolytrope\n  real(kind=8)::t2min,t2\n!-------------------------------------------------------------------------\n  t2min = t2_star*(rho*unit_nh/n_star)**(g_star-1.) + 10.d0\n  t2 = p/rho*unit_t2\n  ispolytrope=0.\n  if(t2 .lt. t2min) ispolytrope=1.\nend function ispolytrope\n"}, {"instruction": "Write a Fortran function named get_alphaa_hii to calculate the case A recombination coefficient for HII (Hui & Gnedin'97). The function takes 1 input parameter of type real(kind=8) representing temperature [K]. It returns 1 output parameter of type real(kind=8) representing the recombination coefficient [cm3 s-1].", "input": "", "output": "elemental function get_alphaa_hii(tk)\n\n! returns case a rec. coefficient [cm3 s-1] for hii (hui&gnedin'97)\n! tk           => temperature [k]\n!------------------------------------------------------------------------\n  real(kind=8),intent(in)::tk\n  real(kind=8)::get_alphaa_hii, lambda\n!------------------------------------------------------------------------\n  lambda = 315614./tk\n  get_alphaa_hii =  1.269d-13 * lambda**1.503 &\n                     / ( ( 1.d0+(lambda/0.522)**0.47 )**1.923 )\nend function get_alphaa_hii\n"}, {"instruction": "Create a Fortran function named get_collexrate_hi that computes the collisional excitation rate coefficient for the 1->2 transition in hydrogen atom energies. The input parameter should be a real number (kind=8) representing the temperature in Kelvin. The function should return a real number (kind=8) representing the collisional excitation rate coefficient in [cm3 s-1].", "input": "", "output": "elemental function get_collexrate_hi(tk)\n\n! gives collisional excitation rate coefficient for the 1->2\n! transition in hydrogen atom energies, in [cm3 s-1], according to\n! callaway, unnikrishnan & oza 1987.\n! tk      => temperatue in kelvin\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::tk\n  real(kind=8)::get_collexrate_hi\n!-------------------------------------------------------------------------\n  get_collexrate_hi =                                                   &\n       2.41d-6/sqrt(tk) * (tk/1.d4)**0.22 * exp(-1.63d-11/(kb*tk))\nend function get_collexrate_hi\n"}, {"instruction": "Create a Fortran function named getcpyy to compute the yy element of the Eddington tensor in code units. The function takes 3 input arguments of type real(kind=8) - ce, fx, and fy. It returns a single output of type real(kind=8).", "input": "", "output": "elemental function getcpyy(ce, fx, fy)\n\n! returns yy element of the eddington tensor (in code units)\n!-------------------------------------------------------------------------\n  real(kind=8),intent(in)::ce, fx, fy\n  real(kind=8)::getcpyy\n  real(kind=8)::chi, fred, fmag, nbold\n!-------------------------------------------------------------------------\n  fmag = sqrt( fx**2 + fy**2 )\n  fred = fmag/ce\n  chi = (3d0 + 4d0*fred**2)/(5d0+2d0*sqrt(4d0-3d0*fred**2))\n  nbold = fy / fmag\n  getcpyy = (1d0-chi)/2d0 + (3d0*chi-1d0)/2d0 * nbold**2\n  getcpyy = getcpyy * ce\nend function getcpyy\n"}, {"instruction": "Create a Fortran function named sgnint to determine the sign of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameter data types are ['integer'].", "input": "", "output": "function sgnint(i) result(sgn)\nimplicit none\ninteger:: i, sgn\nif (i>0) then\n\tsgn = 1\nelse if (i<0) then\n\tsgn = -1\nelse\n\tsgn = 0\nendif\nend function sgnint\n"}, {"instruction": "Create a Fortran function named integral_single that calculates the value of a single-variable integral. The function takes 5 input parameters of type double precision and logical, and returns 1 output parameter of type double precision. The input parameters are p, q, v, x0, and approx, and the output parameter is integral_single. The function computes the value of the integral based on the input parameters and the logical condition.", "input": "", "output": "function integral_single( p,q , v , x0, approx )\n    double precision :: p,q\n    double precision :: x0\n    double precision :: v\n    logical , intent(in) :: approx \n    double precision :: r1, r2\n    double precision, parameter        :: pi=3.1415926535897932384d0\n    double precision :: integral_single\n    r1=0.5d0*( pi/v )**0.5d0\n    if (approx .eqv. .true. ) then\n        r2=2.d0\n    else \n        r2=erf(  ( q-x0 )*(v )**0.5d0  ) - erf(  ( p-x0)*( v)**0.5d0 )    \n    end if\n    integral_single=r1*r2\nend function integral_single\n"}, {"instruction": "Create a Fortran function named juliandateisinbetween to determine if a Julian date falls between two other Julian dates. The function takes 4 input parameters of types real(8), real(8), real(8), and logical, with the last one being optional. It returns 1 output parameter of type logical. When called, the function checks if the first Julian date is between the second and third Julian dates, and sets the optional logical output parameter to indicate if the first Julian date is less than or equal to the second Julian date.", "input": "", "output": "  function juliandateisinbetween(juliandate,juliandate1,juliandate2,lessthanjuliandate1) result(isinbetween)\n    real(8),intent(in)           :: juliandate,juliandate1,juliandate2\n    logical,optional,intent(out) :: lessthanjuliandate1\n    logical                      :: isinbetween\n\n    isinbetween = .false.\n    if (juliandate.le.juliandate1                                  .or.  &\n        (juliandate.gt.juliandate1 .and. juliandate.le.juliandate2)    ) &\n      isinbetween = .true.\n    if (present(lessthanjuliandate1)) then\n      lessthanjuliandate1 = .false.\n      if (juliandate.le.juliandate1) lessthanjuliandate1 = .true.\n    end if\n\n  end function juliandateisinbetween\n"}, {"instruction": "Write a Fortran function named ranfb that generates a random floating-point number using a linear congruential generator algorithm. The function should accept 1 input parameter of type integer and return 1 output parameter of type real. The input parameter represents the seed for the random number generator.", "input": "", "output": "function ranfb(ix)\n  real :: y,ranfb\n  integer :: ix,ix1,ix2,ia1,ia2,ic,j1,j2,j3\n\n  ia1=273\n  ia2=25301\n  ic=226908345\n  \n  if (ix.lt.0) ix=-ix\n  if (ix.gt.2**30) ix=mod(ix,2**30)\n\n  ix1=ix/(2**15)\n  ix2=ix-ix1*(2**15)\n  j1=mod(ix1*ia2,2**15)*2**15\n  j2=mod(ix2*ia1,2**15)*2**15\n  j3=ix2*ia2\n  ix=mod(j1+j2,2**30)\n  ix=mod(ix+j3,2**30)\n  ix=mod(ix+ic,2**30)\n  y=float(ix)\n\n  ranfb=y/2**30\n\nend function\n"}, {"instruction": "Write a Fortran function named derivs_1g to compute the derivative of a function, which is defined by the equation g - k * x, where g and k are constants. The function accepts 2 input parameters of type double precision: t and x. It returns 1 output parameter of type double precision.", "input": "", "output": "function derivs_1g(t, x)\n  implicit none\n  double precision :: derivs_1g\n  double precision,intent(in) :: t, x\n  double precision ::  g = (50.d0), k = (0.1d0)\n  \n  derivs_1g = g - k * x\n  \nend function derivs_1g\n"}, {"instruction": "Create a Fortran function named get_length to calculate the length of a sequence based on the input number. The input parameter is an integer. The output parameter is also an integer.", "input": "", "output": "    function get_length(number)\n        integer, intent(in) :: number\n\n        integer :: get_length\n        integer*8 :: value\n\n        ! initial value\n        get_length = 1\n        value      = number\n\n        do while (value .gt. 1)\n            if (mod(value, 2) .eq. 0) then\n                value = value / 2\n            else\n                value = (value * 3) + 1\n            end if\n\n            get_length = get_length + 1\n        end do\n    end function\n"}, {"instruction": "Write a Fortran function named u to compute the value of the equation u = x^2 + x*y - 10. The function should take 2 input arguments of type real and return 1 output argument of type real.", "input": "", "output": "function u(x, y) !primera ecuaci\u00f3n\n  implicit none\n  real::x, y, u\n  u=x**2+x*y-10\nend function u\n"}, {"instruction": "Create a Fortran function called pux to calculate the partial derivative of a function u with respect to the variable x. The function takes 2 real input parameters and returns a real output parameter. The input parameters should be provided as a list of real values, and the output parameter will also be a real value.", "input": "", "output": "function pux(x, y) !derivada parcial de u con respecto a x\n  implicit none\n  real::x, y, pux\n  pux=2*x+y\nend function pux\n"}, {"instruction": "Write a Fortran function named \"puy\" to calculate the partial derivative of a function \"u\" with respect to the variable \"y\". The function should take 2 input arguments of type real, and return 1 output argument of type real.", "input": "", "output": "function puy(x, y) !derivada parcial de u con respecto a y\n  implicit none\n  real::x, y, puy\n  puy=x\nend function puy\n"}, {"instruction": "Write a Fortran function named v to calculate the value of an equation. The function takes 2 input parameters of type real. The test_data type is ['real', 'real']. It returns 1 output parameter of type real. The test_data type is ['real'].", "input": "", "output": "function v(x, y) !segunda ecuaci\u00f3n\n  implicit none\n  real::x, y, v\n  v=y+3*x*y**2-57\nend function v\n"}, {"instruction": "Create a Fortran function named pvx to calculate the partial derivative of v with respect to x. This function takes 2 real input parameters and returns 1 real output parameter. The input parameters are of type real and real, and the output parameter is of type real.", "input": "", "output": "function pvx(x, y) !derivada parcial de v con respecto a x\n  implicit none\n  real::x, y, pvx\n  pvx=3*x**2\nend function pvx\n"}, {"instruction": "Create a Fortran function named pvy to compute the partial derivative of v with respect to y. The function takes 2 input arguments of type real and returns 1 output argument of type real. The test_data types for input are [real, real] and for output is [real].", "input": "", "output": "function pvy(x, y) !derivada parcial de v con respecto a y\n  implicit none\n  real::x, y, pvy\n  pvy=1+6*x*y\nend function pvy\n"}, {"instruction": "Write a Fortran function named tlcl to compute the temperature of the lifting condensation level (Tlcl) using Bolton's equation. The function takes 2 input parameters of type real (rh and t) and returns 1 output parameter of type real (tlcl). Ensure the function uses the imperative tone in the instructions.", "input": "", "output": "  function tlcl(t,rh)\n\n    ! computes the temperature of the lifting condensation level\n    ! given surface t and rh using bolton's equation (mwr 1980, p 1048, #22)\n\n    implicit none\n    real                               :: denom\n    real, intent(in)                   :: rh\n    real, intent(in)                   :: t\n    real                               :: term1\n    real                               :: term2\n    real                               :: tlcl\n\n    term1 = 1.0 / (t-55.0)\n    term2 = alog(rh/1.0)/2840.\n    denom = term1 - term2\n    tlcl = (1.0/denom) + 55.0\n\n  end function tlcl\n"}, {"instruction": "Create a Fortran function named celsius that takes a single real number as input to convert Fahrenheit to Celsius. The input parameter is of type real, and the output parameter is of type real.", "input": "", "output": "  function celsius(tf)\n\n    implicit none\n    real, intent(in)             :: tf\n    real                         :: celsius\n    ! converts fahrenheit to celsius\n\n    celsius = (5./9.) * (tf - 32.0)\n\n  end function celsius\n"}, {"instruction": "Write a Fortran function named wspd to calculate the wind speed from the u and v components. The function takes 2 input parameters of type real, u and v, and returns 1 output parameter of type real.", "input": "", "output": "  function wspd(u,v)\n\n    ! computes wind velocity from u/v components\n    implicit none\n    real, intent(in)        :: u\n    real, intent(in)        :: v\n    real                    :: wspd\n\n    wspd = sqrt ( (u*u) + (v*v) )\n  end function wspd\n"}, {"instruction": "Write a Fortran function named char1 that takes an array of characters as input and returns a single character string. The input parameter is of type character, dimension(:), and the output parameter is of type character(len=size(s)).", "input": "", "output": "function char1 (s) result(res)\n  character, dimension(:), intent(in) :: s\n  character(len=size(s)) :: res\n  do i = 1, size(s)\n    res(i:i) = s(i)\n  end do\nend function char1\n"}, {"instruction": "Create a Fortran function named identity to generate an identity matrix of size n by n. The input parameter is an integer (n), and the output parameter is a real matrix of dimensions (n,n).", "input": "", "output": "  function identity(n) result(b) ! return identity matrix\n    integer, intent(in) :: n\n    real, dimension(n,n) :: b\n    integer :: i\n    b = 0\n    do i=1, n\n       b(i,i) = 1\n    end do\n  end function identity\n"}, {"instruction": "Create a Fortran function named b3hs_hash_key_jenkins to hash a given key using the Jenkins algorithm. The function takes 2 input parameters of type character(*) and integer, and returns 1 output parameter of type integer. The function computes the hash code for the given key using the Jenkins algorithm described by Bob Jenkins at the specified URL. The range parameter should be a power of 2, and the 32-bit algorithm is used.", "input": "", "output": "function b3hs_hash_key_jenkins (key, range) result (code)\n  integer, parameter       :: kind_i32 = selected_int_kind(10)\n  character(*), intent(in) :: key\n  integer, intent(in)      :: range\n  integer                  :: code\n\n  integer                  :: len_key\n  integer(kind_i32)        :: a\n  integer(kind_i32)        :: b\n  integer(kind_i32)        :: c\n  integer                  :: c_i\n  integer                  :: k\n\n! hash the key into a code, using the algorithm\n! described by bob jenkins at:\n!  http://burtleburtle.net/bob/hash/doobs.html\n!\n! note that range should be a power of 2, and\n! that the 32-bit algorithm is used\n\n  len_key = len_trim(key)\n\n  a = -1640531527_kind_i32 ! 0x9e3779b9\n  b = a\n  c = 305419896_kind_i32   ! 0x12345678\n\n  k = 1\n\n  char_loop : do\n\n     if(len_key < 12) exit char_loop\n\n! pack the key into 32 bits\n\n     a = a + ichar(key(k+0:k+0))  + ishft(ichar(key(k+1:k+1)), 8) + &\n     &       ishft(ichar(key(k+2:k+2)), 16) + ishft(ichar(key(k+3:k+3)), 24)\n     b = b + ichar(key(k+4:k+4))  + ishft(ichar(key(k+5:k+5)), 8) + &\n     &       ishft(ichar(key(k+6:k+6)), 16) + ishft(ichar(key(k+7:k+7)), 24)\n     c = c + ichar(key(k+8:k+8))  + ishft(ichar(key(k+9:k+9)), 8) + &\n     &       ishft(ichar(key(k+10:k+10)), 16) + ishft(ichar(key(k+11:k+11)), 24)\n\n! mix it up\n\n     call b3hs_hash_key_jenkins_mix_()\n\n     k = k + 12\n\n     len_key = len_key - 12\n\n  end do char_loop\n\n  c = c + len_key\n\n! process remaining bits\n\n  select case(len_key)\n  case(11)\n     c = c + ishft(ichar(key(k+10:k+10)), 24) + ishft(ichar(key(k+9:k+9)), 16) + &\n     &       ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(10)\n     c = c + ishft(ichar(key(k+9:k+9)), 16) + ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(9)\n     c = c + ishft(ichar(key(k+8:k+8)), 8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(8)\n     b = b + ishft(ichar(key(k+7:k+7)), 24) + ishft(ichar(key(k+6:k+6)), 16) + &\n     &       ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(7)\n     b = b + ishft(ichar(key(k+6:k+6)), 16) + ishft(ichar(key(k+5:k+5)), 8) + &\n     &       ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(6)\n     b = b + ishft(ichar(key(k+5:k+5)), 8) + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(5)\n     b = b + ichar(key(k+4:k+4))\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(4)\n     a = a + ishft(ichar(key(k+3:k+3)), 24) + ishft(ichar(key(k+2:k+2)), 16) + &\n     &       ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(3)\n     a = a + ishft(ichar(key(k+2:k+2)), 16) + ishft(ichar(key(k+1:k+1)), 8) + &\n     &       ichar(key(k:k))\n  case(2)\n     a = a + ishft(ichar(key(k+1:k+1)), 8) + ichar(key(k:k))\n  case(1)\n     a = a + ichar(key(k:k))\n  end select\n\n  call b3hs_hash_key_jenkins_mix_()\n\n  c_i = int(c)\n  code = iand(c_i, range - 1) + 1\n\n! finish\n\n  return\n\ncontains\n\n  subroutine b3hs_hash_key_jenkins_mix_\n\n! mix a, b and c\n\n    a = ieor(a - b - c, ishft(c, -13))\n    b = ieor(b - c - a, ishft(a, 8))\n    c = ieor(c - a - b, ishft(b, -13))\n\n    a = ieor(a - b - c, ishft(c, -12))\n    b = ieor(b - c - a, ishft(a, 16))\n    c = ieor(c - a - b, ishft(b, -5))\n\n    a = ieor(a - b - c, ishft(c, -3))\n    b = ieor(b - c - a, ishft(a, 10))\n    c = ieor(c - a - b, ishft(b, -15))\n\n! finish\n\n    return\n\n  end subroutine b3hs_hash_key_jenkins_mix_\n\nend function b3hs_hash_key_jenkins\n"}, {"instruction": "Create a Fortran function named f that takes a single input parameter of type real, dimension(1:3,1:3). The function should return a single output parameter of type real. The purpose of the function is to calculate the determinant of a 3x3 matrix using the given input matrix.", "input": "", "output": "    function f(a)\n      implicit none\n        real :: f\n        real, intent(in), dimension(1:3,1:3) :: a\n        \n          f=a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))-a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))+a(1,3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))   \n    end function f\n"}, {"instruction": "Create a Fortran function named c to calculate the cofactor matrix of a given 3x3 input matrix. The input parameter is a 3x3 matrix of real numbers, and the output is the 3x3 cofactor matrix of real numbers.", "input": "", "output": "    function c(a)\n      implicit none\n        real, dimension(1:3,1:3) :: c,co\n        real, intent(in), dimension(1:3,1:3) :: a\n        \n          co(1,1)=(-1)**(1+1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))\n          co(1,2)=(-1)**(1+2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\n          co(1,3)=(-1)**(1+3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))\n          co(2,1)=(-1)**(2+1)*(a(1,2)*a(3,3)-a(1,3)*a(3,2))\n          co(2,2)=(-1)**(2+2)*(a(1,1)*a(3,3)-a(1,3)*a(3,1))\n          co(2,3)=(-1)**(2+3)*(a(1,1)*a(3,2)-a(1,2)*a(3,1))\n          co(3,1)=(-1)**(3+1)*(a(1,2)*a(2,3)-a(1,3)*a(2,2))\n          co(3,2)=(-1)**(3+2)*(a(1,1)*a(2,3)-a(1,3)*a(2,1))\n          co(3,3)=(-1)**(3+3)*(a(1,1)*a(2,2)-a(1,2)*a(2,1))    \n      \n          c=transpose(co)\n    end function c\n"}, {"instruction": "Create a Fortran function named \"largest\" to find the largest value in an array of real numbers. The function should have 1 input parameter of type real array with unspecified size and intent \"in\" and \"target\". The output parameter should be of type real and intent \"pointer\".", "input": "", "output": "function largest(arr) result(value)\nimplicit none\nreal, dimension(:), intent(in), target :: arr\nreal, pointer :: value\ninteger :: i\nnullify(value)\nallocate(value)\nvalue => arr(1)\ndo i = 2, size(arr)\n  if (arr(i) > value) then\n    value => arr(i)\n  end if\nend do\nend function largest\n"}, {"instruction": "Write a Fortran function named round_scalar that rounds a floating-point number to a specified number of decimal digits. The function takes 2 input parameters with test_data type ['real(8)', 'integer'] and returns 1 output parameter with test_data type ['real(8)'].", "input": "", "output": "      function round_scalar(fnumb, idigits) result(res)\n      ! rounds fnumb to idigits decimal digits (scalar)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(in)  :: fnumb\n         integer, intent(in)  :: idigits\n         real(8)  :: res\n         \n         !### var ###!\n         integer :: imuldiv\n         \n         !### code ###!\n         imuldiv = 10 ** idigits\n         res = real(int(fnumb * imuldiv + 0.5d0),8) / imuldiv\n         \n      end function\n"}, {"instruction": "Write a Fortran function named nearby that checks if a given real number is within a specified distance from a range defined by two other real numbers. The number of input arguments is 3 and the test_data type is [real*8, real*8, real*8]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "      function nearby(a,b,bola)\n      implicit none\n      real*8, intent(in) :: a,b,bola\n      logical :: nearby\n      nearby = .false.\n      if ((b-bola .le. a) .and. (a .le. b+bola)) then\n        nearby = .true.\n      end if\n!     print*, b-bola, \"<=\", a, \"<=\",b+bola ,\" :: \", nearby\n      end function nearby\n"}, {"instruction": "Provide a Fortran function named to_s_int_ to convert an integer to a string. The function takes 1 input argument of type integer and returns 1 output argument of type character(len=500).", "input": "", "output": "  function to_s_int_ (value)\n    implicit none\n    character(len=500):: to_s_int_\n    integer, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_int_ = adjustl(trim(result))\n  end function to_s_int_\n"}, {"instruction": "Create a Fortran function named strip_ that takes a character string as input and returns a modified string with leading and trailing spaces removed. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type character(len=500).", "input": "", "output": "  function strip_(value)\n    implicit none\n    character(len=500):: strip_\n    character(len=*), intent(in) :: value\n    strip_ = trim(adjustl(value))\n  end function strip_\n"}, {"instruction": "Write a Fortran function named strip_length_ that takes an input string and an integer length. The input parameters are of type character(len=*) and integer respectively, and the output parameter is of type character(len= length). This function trims the input string and adjusts the length to the specified value.", "input": "", "output": "  function strip_length_(value, length)\n    implicit none\n    character(len=*), intent(in) :: value\n    integer, intent(in) :: length\n    character(len= length):: strip_length_\n    strip_length_ = trim(adjustl(value))\n  end function strip_length_\n"}, {"instruction": "Create a Fortran function named \"integerequal\" to compare two integer numbers and return a logical value indicating whether they are equal or not. The function should accept 2 integer input parameters and return 1 logical output parameter. The test_data type for input parameters is ['integer', 'integer'], and for the output parameter is ['logical'].", "input": "", "output": "  function integerequal (number1, number2 ) result (resultvalue)\n    integer , intent (in) :: number1, number2\n    logical :: resultvalue \n\n    resultvalue = .false.\n\n    if ( number1 .eq. number2 ) then\n       resultvalue = .true.\n    else \n       resultvalue = .false.\n    end if\n  end function integerequal\n"}, {"instruction": "Create a Fortran function named stringequal to compare two strings and return a logical value to indicate whether they are equal. The number of input arguments is 2 and the test_data type is ['character(*) ', 'character(*) ']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "  function stringequal (str1, str2 ) result (resultvalue)\n    character(*) , intent (in) :: str1, str2\n    logical :: resultvalue \n\n    resultvalue = .false.\n\n    if ( str1 .eq. str2 ) then\n       resultvalue = .true.\n    end if\n  end function stringequal\n"}, {"instruction": "Create a Fortran function named legendrep to calculate the value of the nth order Legendre polynomial at a given real value x. The function takes 2 input parameters of type real (kind=8) and integer, and returns 1 output parameter of type real (kind=8).", "input": "", "output": "function legendrep(n,x) result(fac)\n    !implicit none\n    real (kind=8) :: fac\n    real (kind=8), intent(in) :: x\n    integer, intent(in) :: n\n    real (kind=8), dimension(n+1) :: poly\n    integer :: i\n\n    select case (n)\n        case (0)\n        poly(1) = 1\n        fac = poly(1)\n\n        case (1)\n        poly(2) = x\n        fac = poly(2)\n\n        case default\n        poly(1) = 1\n        poly(2) = x\n    end select\n\n    do i=3,n+1\n        poly(i) = ((2*(i-1)-1)*x*poly(i-1) - (i-2)*poly(i-2))/(i-1)\n    end do\n    fac = poly(n+1)\nend function legendrep\n"}, {"instruction": "Create a Fortran function named g to calculate the Gaussian term. The function takes 2 input parameters of type real(kind=8) and returns 1 output parameter of type real(kind=8). The input parameters are v and v0, and the output parameter is g. The function computes g as the exponential of -(v/v0)^2d0.", "input": "", "output": "    function g(v, v0)\n        ! gaussian term\n        \n        implicit none\n\n        real(kind=8), intent(in) :: v\n        real(kind=8), intent(in) :: v0\n        real(kind=8) :: g\n\n        g = exp(-(v/v0)**2d0) \n\n    end function\n"}, {"instruction": "Create a Fortran function named remove_temp_files to generate a command that deletes temporary files based on the input filename. The function takes 1 input parameter of type character(len=*), and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    function remove_temp_files(fname) result (cmd)\n        implicit none\n        character(len=*) :: fname\n        character(len=:), allocatable :: plt\n        character(len=:), allocatable :: dat\n        character(len=:), allocatable :: cmd\n\n        plt = 'plot/'//fname//'*.plt'\n        dat = 'plot/'//fname//'*.dat'\n\n        cmd = 'rm '//plt//' '//dat\n        return\n    end function\n"}, {"instruction": "Create a Fortran function named plot_fname that takes a character string as input and returns another character string. The input parameter has a test_data type of ['character(len=*)'], and the output parameter has a test_data type of ['character(len=:), allocatable']. This function concatenates the input string with 'plot/' and '.plt' to create a file path and returns it.", "input": "", "output": "    function plot_fname(fname) result (path)\n        implicit none\n        character(len=*) :: fname\n        character(len=:), allocatable :: path\n        path = 'plot/'//fname//'.plt'\n        return\n    end function\n"}, {"instruction": "Write a Fortran function named \"predicate\" to determine if a certain mathematical predicate is true or false. The function takes 2 input parameters of type integer and returns 1 output parameter of type logical. The input parameters are n and r, and the output parameter is predicate.", "input": "", "output": "  function predicate(n,r)\n    implicit none\n    integer, intent(in) :: n, r\n    integer             :: i\n    double precision    :: temp\n    logical             :: predicate\n\n    predicate=.false.\n    temp=1.0\n    do i=1,r\n       temp=temp*(n-(r-i)) ! gets larger\n       temp=temp/(r-i+1)   ! gets smaller\n       if (temp>1000000.0) then\n          predicate=.true.\n          exit\n       end if\n    end do\n    \n  end function predicate\n"}, {"instruction": "Create a Fortran function named is_sorted to determine if an array of real numbers is sorted in ascending order. The function should take 1 input parameter of type real, dimension(:), and return 1 output parameter of type logical. The function should use the imperative tone.", "input": "", "output": "    function is_sorted(values) result(sorted_value)\n        implicit none\n        real, dimension(:), intent(in) :: values\n        logical :: sorted_value\n        integer :: i\n\n        sorted_value = .true.\n        do i = 2, size(values)\n            if (values(i) < values(i - 1)) then\n                sorted_value = .false.\n                exit\n            end if\n        end do\n    end function is_sorted\n"}, {"instruction": "Write a Fortran function named pad that takes 3 input arguments of type integer, dimension(:), integer, and integer. The function returns 1 output argument of type integer, dimension(max(len, size(a))). The function pads the input array with the specified initial value to match the specified length.", "input": "", "output": "    pure function pad(a, initval, len)\n        integer, intent(in), dimension(:) :: a\n        integer, intent(in) :: initval, len\n        integer, dimension(max(len, size(a))) :: pad\n        integer :: i\n\n        pad = initval\n\n        ! copy whatever is possible from a\n        do i=1, size(a)\n            pad(i) = a(i)\n        end do\n    end function pad\n"}, {"instruction": "Create a Fortran function named outerproduct that takes a single real number as input. The function is designed to calculate the outer product of the input real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function outerproduct(a)\nimplicit none\nreal, intent(in) :: a\nreal :: outerproduct\n    outerproduct = 0.\nend function outerproduct\n"}, {"instruction": "Create a Fortran function named comm_create_group that takes 3 integer inputs (ngid, nprocs, key) and returns an integer output (ngid_dst). The function computes ngid_dst as the sum of ngid and the product of key and nprocs.", "input": "", "output": "  function comm_create_group(ngid, nprocs, key) result(ngid_dst)\n    implicit none\n    integer, intent(in) :: ngid, nprocs, key\n    integer :: ngid_dst\n    ngid_dst = ngid + key * nprocs\n  end function\n"}, {"instruction": "Create a Fortran function called number_of_lines_in_file to determine the number of lines in a given file. The function takes 1 input parameter of type integer (assumed to be the file unit number) and returns 1 output parameter of type integer representing the number of lines in the file.", "input": "", "output": "    function number_of_lines_in_file(iunit) result(n_lines)\n\n    implicit none\n\n    integer,intent(in)  :: iunit   !! the file unit number\n                                     !! (assumed to be open)\n    integer :: n_lines   !! the number of lines in the file\n\n    character(len=1) :: tmp\n    integer :: istat\n\n    rewind(iunit)\n    n_lines = 0\n    do\n        read(iunit,fmt='(a1)',iostat=istat) tmp\n        if (is_iostat_end(istat)) exit\n        n_lines = n_lines + 1\n    end do\n    rewind(iunit)\n\n    end function number_of_lines_in_file\n"}, {"instruction": "Create a Fortran function named couple_global_id that takes 3 integer input parameters (iorb, jorb, norb) and returns 1 integer output parameter. The test_data type for the input parameters is ['integer', 'integer', 'integer'], and for the output parameter is ['integer']. The function computes a global identifier based on the input parameters and assigns the result to the output parameter, id.", "input": "", "output": "      function couple_global_id(iorb,jorb,norb) result(id)\n        implicit none\n        integer, intent(in) :: iorb,jorb,norb\n        integer :: id\n        !local variables\n        integer :: ii,jj\n        ii=max(iorb,jorb)\n        jj=min(iorb,jorb)\n\n        if (ii > norb .or. jj > norb) then\n           print *,'error',ii,jj,norb\n           stop\n        end if\n        \n        id=ii+(jj-1)*norb\n      end function couple_global_id\n"}, {"instruction": "Write a Fortran function named couple_global_id that takes 3 input arguments of type integer: iorb, jorb, and norb. It produces 1 output argument of type integer. The purpose of the function is to compute the global identifier 'id' based on the input arguments. The function uses the imperative style to define the function and perform the necessary calculations.", "input": "", "output": "      pure function couple_global_id(iorb,jorb,norb) result(id)\n        implicit none\n        integer, intent(in) :: iorb,jorb,norb\n        integer :: id\n        !local variables\n        integer :: ii,jj\n        ii=max(iorb,jorb)\n        jj=min(iorb,jorb)\n        id=ii+(jj-1)*norb\n      end function couple_global_id\n"}, {"instruction": "Create a Fortran function named to_rna that transforms a given DNA sequence into its corresponding RNA sequence. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(dna)).", "input": "", "output": "  function to_rna(dna)\n      character(*) :: dna\n      character(len(dna)) :: to_rna\n      integer :: i\n\n      do i = 1,len(dna)\n        select case (dna(i:i))\n            case ('g')\n                to_rna(i:i) = 'c'\n            case ('c')\n                to_rna(i:i) = 'g'\n            case ('t')\n                to_rna(i:i) = 'a'\n            case ('a')\n                to_rna(i:i) = 'u'\n            case default\n                to_rna = ''\n                return\n        end select\n      end do\n\n  end function to_rna\n"}, {"instruction": "Create a Fortran function named loggamma that takes a single input parameter of type double precision and returns a value of type double precision.The function computes the logarithm of the gamma function.", "input": "", "output": "  function loggamma(s)\n    double precision, intent(in) :: s\n    double precision :: loggamma\n    double precision :: x, v, w\n    x = s\n    v = 1.0d0\n    do while (x < cn)\n       v = v * x\n       x = x + 1.0d0\n    end do\n    w = 1.0d0 / (x * x)\n    loggamma = ((((((((b16 / (16.0d0 * 15.0d0)) * w &\n         + (b14 / (14.0d0 * 13.0d0))) * w &\n         + (b12 / (12.0d0 * 11.0d0))) * w &\n         + (b10 / (10.0d0 * 9.0d0))) * w &\n         + (b8 / (8.0d0 * 7.0d0))) * w &\n         + (b6 / (6.0d0 * 5.0d0))) * w &\n         + (b4 / (4.0d0 * 3.0d0))) * w &\n         + (b2 / (2.0d0 * 1.0d0))) / x &\n         + 0.5d0 * log2pi - log(v) - x + (x - 0.5d0) * log(x)\n    return\n  end function loggamma\n"}, {"instruction": "Create a Fortran function named \"psi\" that takes a double precision input parameter \"s\" and returns a double precision output. The function computes the psi (digamma) function for the input parameter \"s\" using a series expansion and logarithm calculation. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function psi(s)\n    double precision, intent(in) :: s\n    double precision :: psi\n    double precision :: x, v, w\n    x = s\n    v = 0.0d0\n    do while (x < cn)\n       v = v + 1.0d0 / x\n       x = x + 1.0d0\n    end do\n    w = 1.0d0 / (x * x)\n    v = v + ((((((((b16 / 16.0d0) * w &\n         + (b14 / 14.0d0)) * w &\n         + (b12 / 12.0d0)) * w &\n         + (b10 / 10.0d0)) * w &\n         + (b8 / 8.0d0)) * w &\n         + (b6 / 6.0d0)) * w &\n         + (b4 / 4.0d0)) * w &\n         + (b2 / 2.0d0)) * w &\n         + 0.5d0 / x\n    psi = log(x) - v\n  end function psi\n"}, {"instruction": "Create a Fortran function named polygamma to calculate the polygamma function. The function takes 2 input parameters of type integer and double precision. The output is a single value of type double precision.", "input": "", "output": "  function polygamma(n, s)\n    integer, intent(in) :: n\n    double precision, intent(in) :: s\n    double precision :: polygamma\n    integer :: k\n    double precision :: x, t, u, v, w\n    x = s\n    u = 1.0d0\n    do k = 1-n, -1\n       u = u * k\n    end do\n    v = 0.0d0\n    do while (x < cn)\n       v = v + 1.0d0 / x**(n+1)\n       x = x + 1.0d0\n    end do\n    w = x * x\n    t = (((((((b16 &\n         * (n + 15.0d0) * (n + 14.0d0) / (16.0d0 * 15.0d0 * w) + b14) &\n         * (n + 13.0d0) * (n + 12.0d0) / (14.0d0 * 13.0d0 * w) + b12) &\n         * (n + 11.0d0) * (n + 10.0d0) / (12.0d0 * 11.0d0 * w) + b10) &\n         * (n +  9.0d0) * (n +  8.0d0) / (10.0d0 *  9.0d0 * w) + b8) &\n         * (n +  7.0d0) * (n +  6.0d0) / ( 8.0d0 *  7.0d0 * w) + b6) &\n         * (n +  5.0d0) * (n +  4.0d0) / ( 6.0d0 *  5.0d0 * w) + b4) &\n         * (n +  3.0d0) * (n +  2.0d0) / ( 4.0d0 *  3.0d0 * w) + b2) &\n         * (n +  1.0d0) * n / (2.0d0 * 1.0d0 * w) + 0.5d0 * n / x + 1.0d0\n    polygamma = u * (t / x**n + n*v)\n  end function polygamma\n"}, {"instruction": "Create a Fortran function named file_size to retrieve the size of a file in bytes. The function takes 1 input argument of type character(len=*) to specify the filename and returns 1 output argument of type integer to store the file size.", "input": "", "output": "function file_size(filename) !! file size (in bytes)\ncharacter(len=*), intent(in) :: filename\ninteger  :: file_size, fstat_buff(13), status\n!! through compiler flag -d_gnuf90_, if using gnu compiler:\n#ifdef _gnuf90_\n  call stat(filename, fstat_buff, status)\n  file_size = fstat_buff(8)\n  if (status /= 0)  file_size = 0  ! file doesn't exist\n#else\n  inquire(file=filename, size=file_size)  \n  if (file_size < 0)  file_size = 0\n#endif\nend function\n"}, {"instruction": "Write a Fortran function named incr2 that takes an integer input and returns an integer output. The number of input parameters is 1, and the test_data type is ['integer(c_int), value']. The number of output parameters is 1, and the test_data type is ['integer(c_int)']. The function adds 20 to the input integer and returns the result.", "input": "", "output": "function incr2(input) bind(c)\n  use iso_c_binding\n  implicit none\n  integer(c_int), value :: input\n  integer(c_int) :: incr2\n  incr2 = input + 20\nend function incr2\n"}, {"instruction": "Write a Fortran function named optval_ll1 that returns a logical value. This function takes 2 input parameters, where the first input is optional and of type logical, and the second input is of type logical. The output parameter is a single logical value.", "input": "", "output": "    pure elemental function optval_ll1(x, default) result(y)\n    logical, intent(in), optional :: x\n    logical, intent(in) :: default\n    logical :: y\n\n    if (present(x)) then\n       y = x\n    else\n       y = default\n    end if\n  end function optval_ll1\n"}, {"instruction": "Create a pure Fortran function named optval_character to handle optional input arguments for character data types. The number of input arguments is 2, with the test data type ['character(len=*), optional', 'character(len=*)']. The number of output arguments is 1, with the test data type ['character(len=:), allocatable'].", "input": "", "output": "  pure function optval_character(x, default) result(y)\n    character(len=*), intent(in), optional :: x\n    character(len=*), intent(in) :: default\n    character(len=:), allocatable :: y\n\n    if (present(x)) then\n       y = x\n    else\n       y = default\n    end if\n  end function optval_character\n"}, {"instruction": "Create a Fortran function named dbset2dstrlen to handle the setting of 2D string length. The function takes 1 input parameter of type integer and returns an integer as output.", "input": "", "output": "\t\tfunction dbset2dstrlen(len) !! ------------------------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbset2dstrlen\n\t\t\tinteger, intent(in) :: len\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'attempt to set 2d string length is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbset2dstrlen !! -------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbmkoptlist to handle the allocation of an options list. It takes 2 input arguments of type integer: maxopts and optlist_id. It has 1 output argument of type integer. If the allocation of an options list is inconsistent with the use of the silo proxy module, the function will print an error message and exit.", "input": "", "output": "\t\tfunction dbmkoptlist(maxopts, optlist_id) !! ----------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbmkoptlist\n\t\t\tinteger, intent(in) :: maxopts\n\t\t\tinteger, intent(in) :: optlist_id\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'allocation of an options list is inconsistent ' // &\n\t\t\t\t\t\t 'with use of silo proxy module. exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbmkoptlist !! ---------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbaddiopt to add an option to an options list. The function takes 3 input parameters of type integer (optlist_id, option, ivalue) and returns an integer.", "input": "", "output": "\t\tfunction dbaddiopt(optlist_id, option, ivalue) !! -----------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbaddiopt\n\t\t\tinteger, intent(in) :: optlist_id\n\t\t\tinteger, intent(in) :: option\n\t\t\tinteger, intent(in) :: ivalue\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'adding an option to an options list is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbaddiopt !! -----------------------------------------------\n"}, {"instruction": "Create a Fortran function named dbclose that takes an integer input argument. When called, this function will print a message indicating an inconsistency in the use of a silo proxy module and then stop the program. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "\t\tfunction dbclose(dbid) !! -----------------------------------------------\n\n\t\t\t\n\t\t\t\n\t\t\tinteger\t\t\t\t:: dbclose\n\t\t\tinteger, intent(in) :: dbid\n\t\t\t\n\t\t\t\n\t\t\tprint '(a)', 'attempt to close silo-hdf5 database file is ' // &\n\t\t\t\t\t\t 'inconsistent with use of silo proxy module. ' // &\n\t\t\t\t\t\t 'exiting ...'\n\t\t\tstop\n\t\t\t\n\t\t\t\n\t\tend function dbclose !! -------------------------------------------------\n"}, {"instruction": "Create a Fortran function named get_model_time that takes a single real*8 input argument. Set the input argument \"t\" to the value of \"tday\" and assign a value of 0 to the output integer \"ret\".", "input": "", "output": "function get_model_time(t) result(ret)\n  integer :: ret\n  real*8 :: t\n  t=tday\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_ocean_prev_time to calculate the time difference between two ocean time variables. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function get_ocean_prev_time(t) result(ret)\n  integer :: ret\n  real*8 :: t\n  t=tocean-(tos-tosm)\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named distance_matrix that takes a 2D array of double precision numbers as input. The function computes the distance matrix based on the input coordinates. The number of input parameters is 1, with the test_data type ['double precision, dimension(:,:)']. The function returns an allocatable 2D array of double precision numbers as the distance matrix. The number of output parameters is 1, with the test_data type ['double precision, allocatable, dimension(:,:)'].", "input": "", "output": "function distance_matrix(coords) result(dmat)\n\n    double precision, dimension(:,:), intent(in) :: coords\n\n    double precision, allocatable, dimension(:,:) :: dmat\n\n    integer :: n, i, j\n\n    n = size(coords, dim=1)\n\n    allocate(dmat(n,n))\n\n    do i = 1, n\n        do j = i, n\n\n            dmat(i,j) = norm2(coords(i,:) - coords(j,:))\n            dmat(j,i) = dmat(i,j)\n\n        enddo\n    enddo\n\nend function distance_matrix\n"}, {"instruction": "Create a Fortran function named is_alpha_index that takes a single input argument of type character(len=1) and returns a single output argument of type logical. The function checks if the input character is a lowercase letter, and the result is true if it is, otherwise false.", "input": "", "output": "  pure function is_alpha_index(c) result(res)\n    character(len=1), intent(in) :: c\n    logical :: res\n    res = index( &\n        string = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', &\n        substring = c) > 0\n  end function\n"}, {"instruction": "Create a Fortran function named is_alpha_select to determine if a single character is an alphabet. The function takes 1 input argument of type character(len=1) and returns 1 output argument of type logical. The test_data types are ['character(len=1)'] and ['logical'] respectively.", "input": "", "output": "  pure function is_alpha_select(c) result(res)\n    character(len=1), intent(in) :: c\n    logical :: res\n    select case(iachar(c))\n      case (65:90, 97:122)\n        res = .true.\n      case default\n        res = .false.\n    end select\n  end function\n"}, {"instruction": "Create a Fortran function named horner to perform the Horner's method for polynomial evaluation. The function takes 2 input arguments, where the first argument is a one-dimensional array of real numbers and the second argument is a real number. The function returns a single real number as the result.", "input": "", "output": "  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = 0.0\n    do i = size (coeffs), 1, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n"}, {"instruction": "Create a Fortran function named upper_triangular to compute the upper triangular form of a given matrix. The function takes 1 input parameter of type real with the format dimension(:, :), and returns 1 output parameter of type real with the format dimension(size(mat, 1), size(mat, 2)).", "input": "", "output": "  pure function upper_triangular(mat) result(a_)\n    real, dimension(:, :), intent(in) :: mat\n    real, dimension(size(mat, 1), size(mat, 2)) :: a, a_\n    integer, dimension(size(mat, 2)) :: r  ! row permutation/index set\n    real :: scaling_factor\n    integer :: i, m, n, col, row, row_\n\n    m = size(mat, 2)\n    n = size(mat, 1)\n    a = mat\n\n    row = 1\n    col = 1\n    r = (/(i, i=1,m)/)\n\n    do while (row <= m .and. col <= n)\n      ! find row with highest magnitude in the current column\n      row_ = maxloc(abs(a(col, r(row:))), dim=1) - 1 + row\n\n      if (a(col, r(row_)) == 0.0) then\n        col = col + 1\n        cycle\n      endif\n\n      ! swap rows\n      r([row, row_]) = r([row_, row])\n\n      ! normalize row\n      scaling_factor = a(col, r(row))\n      a(col:, r(row)) = a(col:, r(row)) / scaling_factor\n\n      ! zero the pivot column for remaining rows\n      ! by subtracting off a scaled version of the current row\n      forall (i=row+1:m) a(col+1:, r(i)) = a(col+1:, r(i)) &\n          - a(col, r(i)) * a(col+1:, r(row))\n      a(col, r(row+1:)) = 0.0\n\n      row = row + 1\n      col = col + 1\n    enddo\n\n    ! perform reordering\n    forall (i=1:m) a_(:, i) = a(:, r(i))\n  end function\n"}, {"instruction": "Create a Fortran pure function named substitution to perform matrix substitution using Gaussian elimination. The function takes one input argument of type real, with a 2D array of any size. The output is a 2D array of real numbers with the same dimensions as the input array.", "input": "", "output": "  pure function substitution(mat) result(a)\n    real, dimension(:, :), intent(in) :: mat\n    real, dimension(size(mat, 1), size(mat, 2)) :: a\n    integer :: i, j, m\n\n    m = size(mat, 2)\n    a = mat\n\n    do i = m - 1, 1, -1\n      do j = i + 1, m\n        a(:, i) = a(:, i) - a(j, i) * a(:, j)\n      enddo\n    enddo\n  end function\n"}, {"instruction": "Provide a Fortran function named principal_quantum_number to calculate the principal quantum number based on an input real number. The function takes 1 input argument of type real and returns 1 output argument of type integer.", "input": "", "output": "    function principal_quantum_number(res) result(n_max)\n        implicit none\n        real :: res, tmp_res = 0\n        integer :: i = 0, j, n_max\n        do while (tmp_res<=res)\n            j = i - 2\n            do while (j>=1 .or. j>=0)\n                tmp_res = tmp_res + 2 * j + 1\n                if (tmp_res>res) exit\n                j = j - 2\n            end do\n            i = i + 1\n        end do\n        n_max = i\n    end function principal_quantum_number\n"}, {"instruction": "Create a Fortran function named azimuthal_quantum_number to calculate the azimuthal quantum number (l_max) based on the input values of res and n_max. The number of input arguments is 2, and the test_data type is [real, integer]. The number of output arguments is 1, and the test_data type is [integer].", "input": "", "output": "    function azimuthal_quantum_number(res, n_max) result(l_max)\n        implicit none\n        real :: res, tmp_res, tmp_res1 = 0, tmp_res2 = 0, diff1, diff2\n        integer :: i = 0, q = 0, w = 1, j, n_max, l_max\n        do i = 0, n_max\n            if (i==n_max) then\n                tmp_res1 = tmp_res\n                do while(tmp_res1<res)\n                    tmp_res1 = tmp_res1 + 2 * q + 1\n                    if (tmp_res1 >res) then\n                        exit\n                    end if\n                    q = q + 2\n                end do\n                tmp_res2 = tmp_res\n                do while(tmp_res2<res)\n                    tmp_res2 = tmp_res2 + 2 * w + 1\n                    if (tmp_res2 >res) then\n                        exit\n                    end if\n                    w = w + 2\n                end do\n                diff1 = abs(tmp_res1 - res)\n                diff2 = abs(tmp_res2 - res)\n                if (diff2>diff1) then\n                    l_max = q\n                else\n                    l_max = w\n                end if\n                exit\n            end if\n            j = i - 2\n            do while(j>=0 .or. j>=1)\n                tmp_res = tmp_res + 2 * j + 1\n                j = j - 2\n            end do\n        end do\n    end function azimuthal_quantum_number\n"}, {"instruction": "Write a Fortran function named improve_radius to calculate the improved radius based on the given parameters. The function takes 4 input arguments of type real, real, integer, and integer. The output is a single real value.", "input": "", "output": "    function improve_radius(rs, bor_radius, l_max, n_max) result(radius)\n        implicit none\n        real :: rs, bor_radius, radius\n        integer :: i, j, l_max, n_max, total_quantum = 0\n        do i = 0, n_max\n            if (i==n_max) then\n                j = l_max - 2\n                do while(j>=0 .or. j>=1)\n                    total_quantum = total_quantum + 2 * j + 1\n                    j = j - 2\n                end do\n                exit\n            end if\n            j = i - 2\n            do while(j>=0 .or. j>=1)\n                total_quantum = total_quantum + 2 * j + 1\n                j = j - 2\n            end do\n        end do\n        radius = (total_quantum * rs**3 * bor_radius**3)**(1.0 / 3.0)\n    end function improve_radius\n"}, {"instruction": "Create a Fortran function named comb to calculate the result of a specific mathematical combination equation. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is denoted as intent(in) and the output is denoted as result(r). Use a do loop to iteratively calculate the combination equation, with the final result assigned to the output parameter.", "input": "", "output": "function comb(n) result(r)\n\tinteger, intent(in) :: n\n\tinteger :: r, i\n\t\n\tr = 1\n\tdo i=3,n\n\t\tr = r+(i-1)\n\tend do\n\t\nend function comb\n"}, {"instruction": "Create a Fortran function named nstore_nemlmodel that takes in a single input parameter of type c_ptr and returns an integer.", "input": "", "output": "            function nstore_nemlmodel(model) bind(c)\n                  use iso_c_binding\n                  implicit none\n                  integer :: nstore_nemlmodel\n                  type(c_ptr), value :: model\n            end function\n"}, {"instruction": "Define a Fortran function named alpha_nemlmodel that takes two input parameters, a type(c_ptr) and a double precision value, and returns a double precision value. This function is intended to be used with C interface, as indicated by the \"bind(c)\" attribute.", "input": "", "output": "            function alpha_nemlmodel(model, temperature) bind(c)\n                  use iso_c_binding\n                  implicit none\n                  double precision :: alpha_nemlmodel\n                  type(c_ptr), value :: model\n                  double precision, value :: temperature\n            end function\n"}, {"instruction": "Create a Fortran function named tnx to calculate the value of the nth term in the Taylor series expansion of the trigonometric function tan(x). The function takes 2 input parameters of type real and integer, and returns 1 output parameter of type real.", "input": "", "output": "function tnx(x, n) \n    implicit none\n    real, parameter :: pi = acos(-1.0) \n    real:: x, tnx \n    integer:: n, i\n    real, dimension(0:n):: vector\n    vector(0) = 1\n    vector(1) = x \n    if(n .le. 1) then \n        tnx = vector(n)\n    else\n        do i = 1, n-1 \n            vector(i+1) = 2.0*x*vector(i) - vector(i-1) \n        enddo\n        tnx = vector(n)\n    endif\n    return\nend function tnx\n"}, {"instruction": "Create a Fortran function named optval_int to return the value of an integer option, allowing for an optional input. The function has 2 input parameters of type integer, with the first parameter being optional. The number of input arguments is 2 and the test_data type is ['integer, optional', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function optval_int(opt, default) result(val)\n        integer, intent(inout), optional :: opt\n        integer, intent(in) :: default\n        integer :: val\n\n        if (present(opt)) then\n            val = opt\n        else\n            val = default\n        end if\n\n    end function optval_int\n"}, {"instruction": "Write a Fortran function named addonebv that takes an integer value as input and returns an integer value as output. The input parameter is of type integer with the attribute value. The output parameter is also of type integer. The function adds 1 to the input integer value and assigns the result to the output parameter.", "input": "", "output": "  function addonebv(x) result(y)\n    implicit none\n    integer, value :: x\n    integer :: y\n    x = 8\n    y = x + 1\n  end function addonebv\n"}, {"instruction": "Create a Fortran function named mr_char_string_upper that takes a character string as input and returns the uppercase version of the input string. The number of input arguments is 1 and the test_data type is ['character(   *   ) ']. The number of output arguments is 1 and the test_data type is ['character( len(string) )']. Use the imperative tone and reflect the features of Fortran function in the instruction.", "input": "", "output": "  function mr_char_string_upper( string ) result( string_upper )\n\n    implicit none\n\n    character(   *   ) , intent(in ) :: string\n\n    character( len(string) )         :: string_upper\n\n    integer :: idx_ascii_char\n    integer :: i_char\n\n    do i_char = 1 , len(string)\n\n      idx_ascii_char = iachar( string(i_char:i_char) )\n\n      if( idx_ascii_char >= 97 .and. idx_ascii_char <= 122 ) then\n        string_upper(i_char:i_char) = achar( idx_ascii_char - 32 )\n      else\n        string_upper(i_char:i_char) = string(i_char:i_char)\n      end if\n\n    end do\n\n  end function mr_char_string_upper\n"}, {"instruction": "Write a Fortran function named swap_f8 that takes a single input parameter of type real(b_sz) and returns a single output parameter of type real(b_sz). This function is intended to swap the byte order of the input real number.", "input": "", "output": "        function swap_f8(input) result(output)\n            implicit none\n            integer(4), parameter  :: b_sz =  8\n            real(b_sz), intent(in) :: input \n            real(b_sz)             :: output \n\n            integer(1) :: byte_arr(b_sz), byte_arr_tmp(b_sz)\n            integer(1) :: i\n\n            byte_arr_tmp =  transfer(input, byte_arr_tmp)\n\n            do i = 1,b_sz\n                byte_arr(i) =  byte_arr_tmp(1 + b_sz - i)\n            enddo\n\n            output =  transfer(byte_arr, output)\n        end function swap_f8 \n"}, {"instruction": "Write a Fortran function named eqrange, which takes 3 input parameters of type integer: y, ygroup, and groupsize. The output parameter is an integer array of size 2*groupsize. The function calculates and returns the eqrangeout array based on the input parameters.", "input": "", "output": "pure function eqrange(y,ygroup,groupsize) result(eqrangeout)\n  integer, intent(in) :: y,ygroup,groupsize\n  integer, dimension(2*groupsize) :: eqrangeout\n  integer, parameter :: infty=huge(1)\n  integer, dimension(groupsize) :: equil,nequil\n  equil(1) = y\n  equil(2:(groupsize-ygroup))=0\n  if (ygroup > 0) then\n     equil((groupsize-ygroup+1):groupsize)=1\n  end if\n  nequil = 1 - equil\n  eqrangeout(1:groupsize) = -infty*equil+(y+ygroup)*nequil\n  eqrangeout((groupsize+1):(2*groupsize)) = (y+ygroup-1)*equil+infty*nequil\nend function eqrange\n"}, {"instruction": "Create a Fortran function named conduit_blueprint_mcarray_to_contiguous to convert a multi-dimensional C array to a contiguous array. The function takes 2 input parameters of type c_ptr, passed by value. The output parameter is a logical of type c_bool. Use the imperative tone in the instructions.", "input": "", "output": "       function conduit_blueprint_mcarray_to_contiguous(cnode,cdest) result(res) &\n                bind(c, name=\"conduit_blueprint_mcarray_to_contiguous\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value, intent(in) :: cnode\n            type(c_ptr), value, intent(in) :: cdest\n            logical(c_bool) ::res\n        end function conduit_blueprint_mcarray_to_contiguous\n"}, {"instruction": "Write a Fortran function named ocean_roughness that calculates the roughness length for the ocean surface based on the input friction velocity (ustar). The function takes 1 input argument of type real, and returns 1 output argument of type real. The test_data type for input is ['real'], and for the output is ['real'].", "input": "", "output": "    function ocean_roughness(ustar) result(z0)\n        implicit none\n        real, intent(in) :: ustar\n        real :: z0\n\n        ! approximately from beljaars (1995?) in ecmwf model\n        z0 = 8e-6 / max(ustar,1e-7)\n    end function ocean_roughness\n"}, {"instruction": "Write a Fortran function named countchar that counts the number of instances of a single character in a given character string. The number of input arguments is 2, and the test_data type is ['character(len=*)', 'character']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function countchar(str1,solo)\n! count the number of instances of the single character in a character string.\n! useful when parsing a comma-separated list, for example.\n! count the commas and add 1 to get the number of items in the list.\n\ninteger                      :: countchar\ncharacter(len=*), intent(in) :: str1\ncharacter,        intent(in) :: solo\n\ninteger :: i\n\ncountchar = 0\ndo i = 1,len_trim(str1)\n   if (str1(i:i) == solo) countchar = countchar + 1\nenddo\n\nend function countchar\n"}, {"instruction": "Create a Fortran function named failure to determine if an error occurred during program execution. The function takes 2 input parameters of type character(len=*) and integer. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The output is a single logical value.", "input": "", "output": "    function failure(msg,ierr)\n        use, intrinsic :: iso_fortran_env, only: error_unit\n        character(len=*), intent(in) :: msg\n        integer, intent(in) :: ierr\n        logical :: failure\n        \n        failure = (ierr /= 0)\n        if (failure) then\n            write(error_unit,*) trim(msg),': ierr = ',ierr\n        end if\n    end function failure\n"}, {"instruction": "Create a Fortran function named power_2_check to determine if the input integer is a power of 2. The function should take 1 input parameter of type integer and return 1 output parameter of type logical.", "input": "", "output": "  function power_2_check( n )\n    implicit none\n    logical :: power_2_check\n    integer,intent(in)  :: n\n    real(8) :: x\n    integer :: i\n    x = log(dble(n))/log(2.0d0)\n    i = nint(x)\n    if ( abs(x-i) < 1.d-10 ) then\n       power_2_check = .true.\n    else\n       power_2_check = .false.\n    end if\n  end function power_2_check\n"}, {"instruction": "Create a Fortran function named bit_reverse to calculate the bitwise reverse of an integer. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function bit_reverse( i, n )\n    implicit none\n    integer :: bit_reverse\n    integer,intent(in) :: i, n\n    integer :: len_bit,ipos,i_br\n    len_bit = nint( log(dble(n))/log(2.0d0) )\n    i_br = 0\n    do ipos=0,len_bit-1\n       call mvbits( i, ipos, 1, i_br, len_bit-1-ipos )\n    end do\n    bit_reverse = i_br\n  end function bit_reverse\n"}, {"instruction": "Create a Fortran function named bin to calculate the binomial coefficient. The function takes 2 input parameters of type integer, n and k. It returns 1 output parameter of type real*8.", "input": "", "output": "          function bin(n, k)\n\n              implicit none\n              integer, intent (in) :: n\n              integer, intent (in) :: k\n              integer :: i\n              real*8 :: bin\n\n              bin = 1\n\n              do i=1,k\n                  bin = bin * (n - i + 1) / i\n              enddo\n\n              return\n\n          end function bin\n"}, {"instruction": "Create a Fortran function named accboys that calculates the Boys function value for a given real*8 number and integer.The number of input arguments is 2 with test_data type ['real*8', 'integer']. The number of output arguments is 1 with test_data type ['real*8']. Use the imperative tone to instruct the creation of this function.", "input": "", "output": "    function accboys(x,n)\n        real*8 :: accboys\n        real*8,intent(in) :: x\n        integer,intent(in) :: n\n        integer,parameter :: nit = 4\n        real*8 :: tdts(nit)\n        real*8 :: tresults(nit)\n        integer :: ngs\n        integer :: i,n2,j\n        real*8 :: dt,t,tresult,tresult12,tresult23,tresult34,tresult123,tresult234\n        ! ================================================\n        n2 = n*2\n        ngs = 25\n        ! naive grid integral.\n        do i = 1,nit\n            ngs = ngs*4\n            dt = 1./ngs\n            if (n2 == 0) then\n                tresult = 0.5\n            else\n                tresult = 0\n            endif\n            t = dt\n            do j = 1,ngs\n                tresult = tresult+exp(-x*t*t)*(t**n2)\n                t = t+dt\n            enddo\n            tresult = tresult+exp(-x*t*t)*(t**n2)/2\n            tresult = tresult*dt\n            tdts(i) = dt\n            tresults(i) = tresult\n        enddo\n        ! neville extrapolation to zero step.\n        tresult12 = (-tdts(2))*(tresults(1)-tresults(2))/(tdts(1)-tdts(2))+tresults(2)\n        tresult23 = (-tdts(3))*(tresults(2)-tresults(3))/(tdts(2)-tdts(3))+tresults(3)\n        tresult34 = (-tdts(4))*(tresults(3)-tresults(4))/(tdts(3)-tdts(4))+tresults(4)\n        tresult123 = (-tdts(3))*(tresult12-tresult23)/(tdts(1)-tdts(3))+tresult23\n        tresult234 = (-tdts(4))*(tresult23-tresult34)/(tdts(2)-tdts(4))+tresult34\n        accboys = (-tdts(4))*(tresult123-tresult234)/(tdts(1)-tdts(4))+tresult234\n    end function\n"}, {"instruction": "Create a Fortran function named sdf_string_lowercase that takes a string as input with the type character(len=*) and returns a modified string with all letters converted to lowercase. The function has 1 input parameter and 1 output parameter, both of type character.", "input": "", "output": "  function sdf_string_lowercase(string_in) result(string_out)\n\n    character(len=*), parameter :: lwr = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=*), parameter :: upr = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=*), intent(in) :: string_in\n    character(len=len(string_in)) :: string_out\n    integer :: i, idx\n\n    string_out = string_in\n\n    do i = 1, len(string_out)\n      idx = index(upr, string_out(i:i))\n      if (idx /= 0) string_out(i:i) = lwr(idx:idx)\n    end do\n\n  end function sdf_string_lowercase\n"}, {"instruction": "Write a Fortran function called linearinterpolate that performs linear interpolation between two real numbers. The function takes 3 input arguments of type real(kind=8) (y1, y2, and mu) and returns 1 output argument of type real(kind=8).", "input": "", "output": "   function linearinterpolate(y1, y2, mu)\n      real(kind=8), intent(in)  :: y1, y2, mu\n      real(kind=8) :: linearinterpolate\n      linearinterpolate =  y1*(1.0d0 - mu) + y2*mu\n      return\n   end function linearinterpolate\n"}, {"instruction": "Create a Fortran function named get_string_value to extract a substring from a given input string. The function should take 1 input argument with the test_data type of ['character(len=*)'] and return 1 output argument with the test_data type of ['character(len=len(line))']. The function is responsible for finding the substring after the \":=\" symbol in the input string.", "input": "", "output": "function get_string_value( line ) result( keyword )\n    character(len=*)         :: line\n    character(len=len(line)) :: keyword\n\n    integer          :: k\n\n    k = index(line, ':=' )\n    k = k + 2\n    keyword = adjustl(line(k:))\n\nend function get_string_value\n"}, {"instruction": "Write a Fortran function named det3 to calculate the determinant of a 3x3 matrix using the input arrays p1, p2, and p3. The number of input arguments is 3 and the test_data type is ['double precision, dimension(3)', 'double precision, dimension(3)', 'double precision, dimension(3)']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function det3(p1, p2, p3) result(d)\n\n    implicit none\n\n    double precision, dimension(3), intent(in) :: p1, p2, p3\n    double precision :: d\n\n    d = p1(1)*p2(2)*p3(3) + p1(3)*p2(1)*p3(2) + p1(2)*p2(3)*p3(1) &\n      - p1(3)*p2(2)*p3(1) - p1(1)*p2(3)*p3(2) - p1(2)*p2(1)*p3(3)\n\n  end function det3\n"}, {"instruction": "Write a Fortran function named get_arithmetic_operations that takes a string of characters as input. The input parameter should be of type character with variable length. The function should return an integer.", "input": "", "output": "    function get_arithmetic_operations(varstring)\n    ! => create scratch files 334 and 335 containing (respectively) the lists of variables and operators\n    ! note: the first operators (corresponding to the first variable) is automatically '+'\n    ! return the number of variables/operations\n        character(len=*), intent(in):: varstring\n        integer:: get_arithmetic_operations\n        character(len=1), dimension(2), parameter:: operators = (/'+', '-'/) ! legal arithmetic operators\n        integer:: i0, i1\n        open(unit=334, status='scratch') ! individual variables\n        open(unit=335, status='scratch') ! operators\n        i0 = 1\n        i1 = 1\n        get_arithmetic_operations = 1\n        write(unit=335, fmt='(a)') '+'\n        do i1 = 1,len(varstring)\n            if (any(operators == varstring(i1:i1))) then\n                write(unit=334, fmt='(a)') trim(adjustl(varstring(i0:i1-1)))\n                write(unit=335, fmt='(a)') varstring(i1:i1)\n                i0 = i1+1\n                get_arithmetic_operations = get_arithmetic_operations + 1\n            end if\n        end do\n        write(unit=334, fmt='(a)') trim(adjustl(varstring(i0:)))\n        rewind(unit=334)\n        rewind(unit=335)\n    end function\n"}, {"instruction": "Create a Fortran function named nfeb to compute the number of days in February for a given year. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter represents the year for which the number of days in February is to be determined. Use the if-else statements to check if the year is a leap year and calculate the number of days accordingly.", "input": "", "output": "   function nfeb ( year ) result (num_days)\n   \n      ! compute the number of days in february for the given year\n   \n      integer :: year\n      integer :: num_days\n   \n      num_days = 28 ! by default, february has 28 days ...\n      if (mod(year,4).eq.0) then  \n         num_days = 29  ! but every four years, it has 29 days ...\n         if (mod(year,100).eq.0) then\n            num_days = 28  ! except every 100 years, when it has 28 days ...\n            if (mod(year,400).eq.0) then\n               num_days = 29  ! except every 400 years, when it has 29 days.\n            end if\n         end if\n      end if\n   \n   end function nfeb\n"}, {"instruction": "Create a Fortran function named r_wrap that takes 3 input arguments of type real(kind(0.d0)) and returns 1 output argument of the same type. The function computes the wrapped value of the input parameter 'r' based on the range determined by the parameters 'l' and 'l_half'. If 'r' is greater than 'l_half', 'r_wrap' is computed as 'r - l'. If 'r' is less than -'l_half', 'r_wrap' is computed as 'r + l'. Otherwise, 'r_wrap' is assigned the value of 'r'.", "input": "", "output": "pure function r_wrap(r, l, l_half)\n    real(kind(0.d0)), intent(in) :: r, l, l_half\n    real(kind(0.d0)) :: r_wrap\n\n    if (r > l_half) then \n        r_wrap = r - l\n    else if (r < -l_half) then\n        r_wrap = r + l\n    else\n        r_wrap = r\n    end if\nend function\n"}, {"instruction": "Create a Fortran function named model_function that takes a single real number as input and returns a real number as output. Ensure that the input parameter is of kind=4 and the output parameter is also of kind=4. The function should add 1.0 to the input value and display the input and output values.", "input": "", "output": "function model_function(x) result(y)\n  real(kind=4), intent(in) :: x\n  real(kind=4) :: y\n  y = x + 1.0\n  write(*, '(\"model a: \",f10.5,\" -> \",f10.5)') x, y\nend function model_function\n"}, {"instruction": "Create a Fortran function named next_position to calculate the updated position on a game board based on the current position and the result of a dice roll. The function takes 2 input arguments of type integer, position, and rollscore, and returns 1 output argument of type integer.", "input": "", "output": "    function next_position(position,rollscore)\n        implicit none\n        integer, intent(in) :: position,rollscore\n        integer :: next_position,t\n        \n        t = position + rollscore\n\t\tnext_position = mod(t,10)\n\t\t\n\t\tif (next_position == 0) then\n\t\t\tnext_position = 10\n\t\tend if\n    end function next_position\n"}, {"instruction": "Write a Fortran function named mfact that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    recursive function mfact (x) result (res)\n      integer, intent(in) :: x\n      integer :: res\n      integer i\n      i = 0\n      !$acc routine  ! { dg-error \"unexpected \\\\\\!\\\\\\$acc routine\" }\n      if (x < 1) then\n         res = 1\n      else\n         res = x * mfact (x - 1)\n      end if\n    end function mfact\n"}, {"instruction": "Create a Fortran function named to_s_int_ to convert an integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character with a length of 500.", "input": "", "output": "  function to_s_int_(value)\n    !! category: fruit_util\n    !! convert integer to string\n    character(len=500):: to_s_int_\n    integer, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_int_ = adjustl(trim(result))\n  end function to_s_int_\n"}, {"instruction": "Create a Fortran function named to_s_logical_ that takes a logical input argument and returns two output arguments. The input argument should be of type logical, and the output arguments should be of type character(len=500) and to_s_logical_(value). This function is designed to convert a logical value to a string.", "input": "", "output": "  function to_s_logical_(value)\n    !! convert logical to string\n    character(len=500):: to_s_logical_\n    logical, intent(in) :: value\n    character(len=500) :: result\n    write (result, *) value\n    to_s_logical_ = adjustl(trim(result))\n  end function to_s_logical_\n"}, {"instruction": "Create a Fortran function named csr_index to find the index of a specific element within a compressed sparse row (CSR) matrix. The function takes 4 input parameters of type integer: i, j, ja (an array), and ia (an array). The output parameter is a single integer representing the index of the element within the CSR matrix.", "input": "", "output": "function csr_index(i,j,ja,ia) result(kij)\n  integer,intent(in)::i,j\n  integer,dimension(:),intent(in)::ja,ia\n  integer::kij\n\n  do kij=ia(i),ia(i+1)-1\n    select case(ja(kij)-j)\n    case(0)\n      return\n    end select\n  end do\n\n  kij=-1\nend function\n"}, {"instruction": "Create a Fortran function named readinputfile to read data from a binary input file and process it. The function takes 7 input parameters of types integer, character(len=*), and various dimensions of allocatable arrays of real numbers, and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction readinputfile(ilun, sinputfile, ivtime, rvu, rvv, rvw, rvt) result(iretcode)\n\t\n\t\t! routine arguments\n\t\tinteger, intent(in)\t\t\t\t\t\t\t\t:: ilun\n\t\tcharacter(len=*), intent(in)\t\t\t\t\t:: sinputfile\n\t\tinteger, dimension(:), allocatable, intent(out)\t:: ivtime\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvu\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvv\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvw\n\t\treal, dimension(:), allocatable, intent(out)\t:: rvt\n\t\tinteger\t\t\t\t\t\t\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\tinteger\t\t:: ierrcode\n\t\tinteger\t\t:: inumdata\n\t\tinteger\t\t:: idata\n\t\tinteger(2)\t:: itimestamp, iu, iv, iw, it\n\t\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! count how many data are available, and reserve workspace based on this information\n\t\topen(ilun, file=sinputfile, status='old', action='read', access='stream', iostat=ierrcode)\n\t\tif(ierrcode /= 0) then\n\t\t\tiretcode = 1\n\t\t\tclose(ilun)\n\t\t\treturn\n\t\tend if\n\t\tinumdata = 0\n\t\tdo\n\t\t\t\n\t\t\t! get data in binary form\n\t\t\tread(10, iostat=ierrcode) itimestamp, iv, iu, iw, it\n\t\t\tif(ierrcode /= 0) exit\n\t\t\t\n\t\t\t! retain data record pertaining to sonic quadruples only\n\t\t\tif(itimestamp > 3600 .or. itimestamp < 0) cycle\n\t\t\tinumdata = inumdata + 1\n\t\t\t\n\t\tend do\n\t\tif(inumdata <= 0) then\n\t\t\tiretcode = 2\n\t\t\tclose(ilun)\n\t\t\treturn\n\t\tend if\n\t\tallocate(ivtime(inumdata), rvu(inumdata), rvv(inumdata), rvw(inumdata), rvt(inumdata))\n\t\trewind(ilun)\n\t\t\n\t\t! perform actual data read\n\t\tidata = 0\n\t\tdo\n\t\t\t\n\t\t\t! get data in binary form\n\t\t\tread(10, iostat=ierrcode) itimestamp, iu, iv, iw, it\n\t\t\tif(ierrcode /= 0) exit\n\t\t\t\n\t\t\t! retain data record pertaining to sonic quadruples only\n\t\t\tif(itimestamp > 3600 .or. itimestamp < 0) cycle\n\t\t\tidata = idata + 1\n\t\t\tivtime(idata) = itimestamp\n\t\t\tif(iu > -9990 .and. iv > -9990 .and. iw > -9990 .and. it > -9990) then\n\t\t\t\trvu(idata) = iu / 100.\n\t\t\t\trvv(idata) = iv / 100.\n\t\t\t\trvw(idata) = iw / 100.\n\t\t\t\trvt(idata) = it / 100.\n\t\t\telse\n\t\t\t\trvu(idata) = -9999.9\n\t\t\t\trvv(idata) = -9999.9\n\t\t\t\trvw(idata) = -9999.9\n\t\t\t\trvt(idata) = -9999.9\n\t\t\tend if\n\t\t\t\n\t\tend do\n\t\tclose(ilun)\n\t\t\n\tend function readinputfile\n"}, {"instruction": "Write a Fortran function named imaxloc that returns the index of the maximum value in a real, one-dimensional array. The function takes 1 input parameter with test_data type ['real, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "   function imaxloc(array)\n      real, dimension(:), intent(in) :: array\n      integer :: imaxloc\n      integer, dimension(1) :: imax\n      imax = maxloc(array)\n      imaxloc = imax(1)\n   end function imaxloc\n"}, {"instruction": "Create a Fortran pure function named dirname that takes two input arguments of type character(*), and allocatable, and returns one output argument of type character(:),allocatable. This function scans the input string for the last occurrence of the specified delimiter and returns the substring containing the directory name.", "input": "", "output": "pure function dirname(instr,  delm)\n\ncharacter(*), intent(in) :: instr\ncharacter(*), intent(in) :: delm\ncharacter(:),allocatable :: dirname\ninteger :: idx\n\nidx = scan(instr, delm, back=.true.)\ndirname = instr(1:idx-1)\n\nend function dirname\n"}, {"instruction": "Create a Fortran function named whole to determine if a given double precision number is a whole number. The function should take 1 input argument of type double precision and return 1 output argument of type logical.", "input": "", "output": "  pure function whole(x)\n    implicit none\n    double precision, intent(in) :: x\n    logical                      :: whole\n    whole = (mod(x,1.0) == 0.0)\n  end function whole\n"}, {"instruction": "Create a Fortran function named f that calculates the value of the sine function at 3 times the input parameter x minus 0.1. The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function f(x)\n\n  implicit none\n\n  real,intent(in) :: x !! funci\u00f3n con ra\u00edces desconocidas en i=[a,b]\n  real::f\n\n  f = sin(3*x-0.1)\n\n  end function\n"}, {"instruction": "Create a Fortran function named dimenumb to determine the number of digits in an integer input. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": " function dimenumb(inum)\n \n!***********************************************************************\n!     \n\n!     of an integer number\n!     originally written in jetspin by m. lauricella et al.\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n\n  implicit none\n\n  integer,intent(in) :: inum\n  integer :: dimenumb\n  integer :: i\n  real(kind=4) :: tmp\n\n  i=1\n  tmp=real(inum,kind=4)\n  do \n    if(tmp< 10.e0 )exit\n    i=i+1\n    tmp=tmp/ 10.e0\n  enddo\n\n  dimenumb=i\n\n  return\n\n end function dimenumb\n"}, {"instruction": "Provide a Fortran function named ifrac that converts a double precision real number to an integer by truncating the decimal part. The number of input arguments is 1, and the test_data type is ['double precision']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "      function ifrac(r)\r\n        implicit none\r\n        double precision :: r\r\n        integer :: ifrac\r\n\r\n        ifrac=r\r\n        if (r.ge.0) return\r\n        if (r.eq.ifrac) return\r\n        ifrac = ifrac - 1\r\n       end function ifrac\r\n"}, {"instruction": "Create a Fortran function called set_initial_timestep_src to set the initial time step value. The function takes 1 input parameter of type real*8. The output is an integer return value.", "input": "", "output": "function set_initial_timestep_src(init_timestep) result(ret)\n  integer :: ret\n  real*8 :: init_timestep\n\n  h0=init_timestep\n  ret = 0\n\nend function set_initial_timestep_src\n"}, {"instruction": "Write a Fortran function called mercury_set_rmax to set the maximum distance for a Mercury simulation. The function takes 1 input parameter of type real*8. The output is an integer.", "input": "", "output": "function mercury_set_rmax(r_max) result(ret)\n    integer :: ret\n    real*8 :: r_max\n    rmax = r_max\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function called mercury_set_cefac that takes a single real*8 input parameter and returns an integer output. The input parameter should be of type real*8, and the output parameter should be of type integer. The function sets the value of a variable called cefac to the input parameter and then sets the return value to 0.", "input": "", "output": "function mercury_set_cefac(cefac_n1) result(ret)\n    integer :: ret\n    real*8 :: cefac_n1\n    cefac = cefac_n1\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function named g that takes a real number as input and returns it as output. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "  function g(y)\n    != unit 'a :: y\n    real :: y, j, g\n    j = y\n    g = j\n  end function g\n"}, {"instruction": "Create a Fortran function named func_interpolate_real32_points to interpolate a value between two points based on given x and y values. The function takes 5 input parameters of type real(kind = real32) representing x1, x2, y1, y2, and x, and returns 1 output parameter of the same type representing the interpolated value.", "input": "", "output": "elemental function func_interpolate_real32_points(x1, x2, y1, y2, x) result(ans)\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare input variables ...\n    real(kind = real32), intent(in)                                             :: x\n    real(kind = real32), intent(in)                                             :: x1\n    real(kind = real32), intent(in)                                             :: x2\n    real(kind = real32), intent(in)                                             :: y1\n    real(kind = real32), intent(in)                                             :: y2\n\n    ! declare output variables ...\n    real(kind = real32)                                                         :: ans\n\n    ! calculate value ...\n    ans = (y1 * (x2 - x) + y2 * (x - x1)) / (x2 - x1)\nend function func_interpolate_real32_points\n"}, {"instruction": "Create a Fortran function named lsame that compares two characters and returns a logical value indicating whether they are the same or not. The function takes 2 input parameters of type character and returns 1 output parameter of type logical.", "input": "", "output": "      function lsame(ca,cb)\n      implicit none\n      character :: ca , cb\n      logical :: lsame\n      intent (in) ca , cb\n      end function lsame\n"}, {"instruction": "Create a Fortran function called file_slurp to read the contents of a file and store them in a character array. The function takes 1 input parameter of type character(len=*), representing the filename, and returns 1 output parameter of type character(len=:), allocatable, which contains the content of the file.", "input": "", "output": "\tfunction file_slurp(filename) result(file)\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tinteger :: filesize\n\t\tcharacter(len=:), allocatable :: file\n\n\t\topen(unit=10, file=filename, action=\"read\", &\n\t\t\tform=\"unformatted\", access=\"stream\")\n\t\tinquire(unit=10, size=filesize)\n\t\tallocate(character(len=filesize) :: file)\n\t\tread(10) file\n\t\tclose(10)\n\tend function\n"}, {"instruction": "Create a Fortran function named ncolumns to determine the number of columns in a string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "\tfunction ncolumns(string)\n\tinteger :: ncolumns\n\tcharacter(len=*) :: string\n\tcharacter(len=1) :: ch, chprev\n\tinteger :: i, l, blanks\n\t\tl = len(trim(string))\n\t\tblanks = 1\n\t\tchprev = string(1:1)\n\t\tdo i = 2, l\n\t\t\tch = string(i:i)\t\t\t\n\t\t\tif (ch /= ' ' .and. chprev == ' ') then\n\t\t\t\tblanks = blanks + 1\n\t\t\tendif\t\t\t\n\t\t\tchprev = ch\n\t\tenddo\n\t\tncolumns = blanks - 1\n\tend function ncolumns\n"}, {"instruction": "Write a Fortran function called ez that calculates the value of the function E(z) for a given input zprime. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The function uses the cosmological parameters omegal and omegam to compute the value of E(z) according to the given formula.", "input": "", "output": "function ez(zprime)\nimplicit none\nreal*8 :: zprime,ez,omegal,omegam\nomegal=0.734\nomegam=0.266\n\nez=1.0/sqrt(omegal+omegam*(1.0+zprime)**3)\nend function\n"}, {"instruction": "Write a Fortran function named haversine to calculate the great circle distance between two geographical points. The function takes 4 input parameters of type real*8: deglon1, deglon2, deglat1, and deglat2. It returns one output parameter of type real*8: dist.", "input": "", "output": "      function haversine(deglon1,deglon2,deglat1,deglat2) result (dist)\n          ! great circle distance -- adapted from matlab \n          real*8,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real*8 :: a,c,dist,dlat,dlon,lat1,lat2\n \n          dlat = deg2rad*(deglat2-deglat1)\n          dlon = deg2rad*(deglon2-deglon1)\n          lat1 = deg2rad*(deglat1)\n          lat2 = deg2rad*(deglat2)\n          a = ( sin(0.5d0*dlat) )**2 + &\n                cos(lat1) * cos(lat2) * ( sin(0.5d0*dlon) )**2\n          c = 2d0*asin( sqrt(a) )\n          dist = rearth*c\n      end function haversine\n"}, {"instruction": "Create a Fortran function named first_x_deriv to calculate the first derivative of a one-dimensional array. The function takes 4 input parameters of types real, integer, real, and integer, and an output parameter of type real. The input parameters are an array of real numbers, an integer index, a real step size, and an integer direction. The function returns the first derivative of the array at the specified index based on the given step size and direction.", "input": "", "output": "        pure function first_x_deriv(f, i, dx, direction)\n\n                real, intent (in), dimension (:) :: f\n                integer, intent (in) :: i\n                real, intent (in) :: dx\n                integer, intent (in) :: direction\n\n                real :: first_x_deriv\n\n                first_x_deriv = 0.0\n\n                if (direction == 1) then\n                        first_x_deriv = (f(i) - f(i-1))/dx\n                else if (direction == -1) then\n                        first_x_deriv = (f(i) - f(i+1))/dx\n                end if\n\n        end function first_x_deriv\n"}, {"instruction": "Create a Fortran function named second_x_deriv to calculate the second derivative of a function with respect to x. The function takes 3 input parameters: an array of real numbers, an integer, and a real number. The output is a real number. The input parameter types are ['real, dimension(:)', 'integer', 'real'], and the output parameter type is ['real'].", "input": "", "output": "        pure function second_x_deriv(f, i, dx)\n\n                real, intent (in), dimension (:) :: f\n                integer, intent (in) :: i\n                real, intent (in) :: dx\n\n                real :: second_x_deriv\n\n                second_x_deriv = (                                     &\n                  -735*f(i-8)+15360*f(i-7)                             &\n                  -156800*f(i-6)+1053696*f(i-5)                        & \n                  -5350800*f(i-4)+22830080*f(i-3)                      & \n                  -94174080*f(i-2)+538137600*f(i-1)                    & \n                  -924708642*f(i+0)                                    & \n                  +538137600*f(i+1)-94174080*f(i+2)                    & \n                  +22830080*f(i+3)-5350800*f(i+4)                      & \n                  +1053696*f(i+5)-156800*f(i+6)                        & \n                  +15360*f(i+7)-735*f(i+8))/(302702400*dx**2)\n\n        end function second_x_deriv\n"}, {"instruction": "Create a Fortran function named dfdx that takes in four input parameters: a real, two-dimensional array 'f', an integer 'x', an integer 's', and a real, one-dimensional array 'fd_coeff'. The function returns a real value. The function calculates the derivative of 'f' with respect to 'x' using finite differencing, and the result is stored in the variable 'dfdx'.", "input": "", "output": "        pure function dfdx(f, x, s, fd_coeff)\n\n                real, intent (in), dimension (:, :) :: f\n                integer, intent (in) :: x\n                integer, intent (in) :: s\n                real, intent (in), dimension (2) :: fd_coeff\n\n                real :: dfdx\n                integer :: i\n\n                dfdx = 0.0\n\n                do i = 1, 2\n                dfdx = dfdx + fd_coeff(i) * (f(x + i, s) - f(x - i, s))\n                end do\n\n        end function dfdx\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor (GCD) of two integer numbers. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  function gcd(m0,n0)\n    implicit none\n    integer :: gcd,m0,n0\n    integer :: m,n,mtmp,loop\n\n    if ( m0 >= n0 ) then\n       m=m0\n       n=n0\n    else\n       m=n0\n       n=m0\n    end if\n\n    do loop=1,10000\n       if ( n == 0 ) exit\n       mtmp = n\n       n = mod(m,n)\n       m = mtmp\n    end do\n\n    gcd = m\n\n  end function gcd\n"}, {"instruction": "Define a Fortran function named gamma that computes the gamma function. The input parameter is a real*8 type, and the output parameter is also a real*8 type.", "input": "", "output": "  function gamma(x)\n  implicit none\n!\n! purpose:\n\n!\n! input:\n\n!\n! returns:\n!   gamma(x)\n!\n! coded:\n!   02/02/06  john haynes (haynes@atmos.colostate.edu)\n!   (original code of unknown origin)\n\n! ----- inputs -----\n  real*8, intent(in) :: x\n  \n! ----- outputs -----\n  real*8 :: gamma\n\n! ----- internal -----  \n  real*8 :: pi,ga,z,r,gr\n  real*8 :: g(26)\n  integer :: k,m1,m\n       \n  pi = acos(-1.)    \n  if (x ==int(x)) then\n    if (x > 0.0) then\n      ga=1.0\n      m1=x-1\n      do k=2,m1\n        ga=ga*k\n      enddo\n    else\n      ga=1.0+300\n    endif\n  else\n    if (abs(x) > 1.0) then\n      z=abs(x)\n      m=int(z)\n      r=1.0\n      do k=1,m\n        r=r*(z-k)\n      enddo\n      z=z-m\n    else\n      z=x\n    endif\n    data g/1.0,0.5772156649015329, &\n           -0.6558780715202538, -0.420026350340952d-1, &\n           0.1665386113822915,-.421977345555443d-1, &\n           -.96219715278770d-2, .72189432466630d-2, &\n           -.11651675918591d-2, -.2152416741149d-3, &\n           .1280502823882d-3, -.201348547807d-4, &\n           -.12504934821d-5, .11330272320d-5, &\n           -.2056338417d-6, .61160950d-8, &\n           .50020075d-8, -.11812746d-8, &\n           .1043427d-9, .77823d-11, &\n          -.36968d-11, .51d-12, &\n          -.206d-13, -.54d-14, .14d-14, .1d-15/\n    gr=g(26)\n    do k=25,1,-1\n      gr=gr*z+g(k)\n    enddo \n    ga=1.0/(gr*z)\n    if (abs(x) > 1.0) then\n      ga=ga*r\n      if (x < 0.0) ga=-pi/(x*ga*sin(pi*x))\n    endif\n  endif\n  gamma = ga\n  return\n  end function gamma\n"}, {"instruction": "Write a Fortran function named unquote to extract the content of a quoted string. The function takes 1 input argument with the test_data type of ['character(len=*)'] and returns 1 output argument with the test_data type of ['character(len=:),allocatable'].", "input": "", "output": "    pure function unquote(str) result(v)\n    character(len=*),intent(in):: str\n    character(len=:),allocatable:: v\n    integer:: l\n    if(str(1:1)=='\"' .or. str(1:1)==\"'\") then\n        l=len_trim(str)\n        v=str(2:l-1)\n    else\n        v=str\n    endif\n    end function\n"}, {"instruction": "Create a Fortran function named quote that takes a string as input and returns the string enclosed in double quotes. The input parameter is of type character(len=*) and the output parameter is of type character(len=:),allocatable.", "input": "", "output": "    pure function quote(str) result(v)\n    character(len=*),intent(in):: str\n    character(len=:),allocatable:: v\n    if(len_trim(str)==0) then\n        v='\"\"'\n        return\n    endif\n    if(str(1:1)=='\"'.or.str(1:1)==\"'\") then\n        v=str\n    else\n        v='\"'//trim(str)//'\"'\n    endif\n    end function\n"}, {"instruction": "Create a Fortran function named is_red that takes an integer input argument and returns a logical value. The input parameter is of type integer, and the output parameter is of type logical. This function checks if the input integer is equal to a predefined constant value \"red\" and returns true if it matches, or false otherwise.", "input": "", "output": "  function is_red(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == red) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_red\n"}, {"instruction": "Create a Fortran function named is_red_a that takes an integer input argument and returns a logical value. The input parameter has a test_data type of ['integer'], and the output parameter has a test_data type of ['logical']. This function checks if the input integer is equal to a predefined value red_a and returns true if it is, otherwise it returns false.", "input": "", "output": "  function is_red_a(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == red_a) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_red_a\n"}, {"instruction": "Create a Fortran function named is_green to check if the input integer value corresponds to the color green. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  function is_green(x) result(is)\n    integer, intent(in) :: x\n    logical :: is\n    if (x == green) then\n      is = .true.\n    else\n      is = .false.\n    end if\n  end function is_green\n"}, {"instruction": "Create a Fortran function named return_char2. This function takes 1 input parameter of type integer(c_int) and returns 1 output parameter of type character(c_char). The function uses the iso_c_binding module. The function converts the input integer to a character using the achar function and returns the result as a character.", "input": "", "output": "function return_char2(i) result(output) bind(c,name='return_char2')\n  use iso_c_binding\n  implicit none\n  integer(c_int) :: i\n  character(c_char) :: j\n  character(c_char) :: output\n\n  j = achar(i)\n  output = j\nend function return_char2\n"}, {"instruction": "Write a Fortran function named file_of_unit that takes an integer input argument and returns the name of the file connected to the specified unit. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character (len=1000)'].", "input": "", "output": "function file_of_unit(iu) result(file_name)\r\n! return name of file connected to unit iu, \"\" if unopened\r\ninteger, intent(in)  :: iu\r\ncharacter (len=1000) :: file_name\r\nlogical              :: opened\r\ninquire(unit=iu,opened=opened)\r\nif (opened) then\r\n   inquire (unit=iu,name=file_name)\r\nelse\r\n   file_name = \"\"\r\nend if\r\nend function file_of_unit\r\n"}, {"instruction": "Create a Fortran function named strtolcase that takes two input parameters: an integer and a character array of length n. The function returns a character array of length n. The purpose of the function is to convert the lowercase characters in the input string to uppercase.", "input": "", "output": " function strtolcase(str,n)\n !********************************************************\n    implicit none\n    integer :: strcapa = 65    ! from write(*,*) \"a:\",ichar(\"a\")\n    integer :: strcapz = 90    ! etc\n    !integer :: strlowa = 97\n    !integer :: strlowz = 122\n    integer :: casediff = 32   ! = 97-65  = 122-90\n    integer :: i,n,ich\n    character(len=n) :: strtolcase\n    character(len=n) :: str\n    !-----------------------\n\n    strtolcase = str\n\n    do i=1,n\n       ich = ichar(strtolcase(i:i))\n       if( ich>=strcapa .and. ich<=strcapz ) strtolcase(i:i) = char(ich+casediff)\n    enddo\n\n end function strtolcase\n"}, {"instruction": "Create a Fortran function called remove_from_character_onwards that takes 3 input parameters: an integer, a character string of length n, and a single character. It returns 2 output parameters: a character string of length n, and the function remove_from_character_onwards.", "input": "", "output": " function remove_from_character_onwards(string_in,n,charact)\n !********************************************************\n  implicit none\n  integer,intent(in) :: n\n  character(len=n),intent(in)::string_in\n  character(len=n) ::remove_from_character_onwards\n  integer :: position_of_charact\n  character(len=1) :: charact\n\n  position_of_charact=index(string_in, charact, .false.)!.false. means returns the position of the first substring from the left\n  !write(*,*)'start_of_comment',start_of_comment\n\n  if(position_of_charact.eq.0)then\n    remove_from_character_onwards=string_in\n  else\n    remove_from_character_onwards=string_in(:position_of_charact-1)\n  endif\n end function remove_from_character_onwards\n"}, {"instruction": "Write a Fortran function named outside that takes a real number as input and returns a real number as output. The function calculates the square of the input, passes it to a nested function named inside, doubles the result, and assigns it to the output variable. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "  function outside(x)\n    != unit 'a :: x\n    real :: x, k, m, outside\n    k = x\n    outside = inside(k) * 2\n    m = outside\n  contains\n    function inside(y)\n      != unit 'a ** 2 :: inside\n      real :: y, inside\n      inside = y * y\n    end function inside\n  end function outside\n"}, {"instruction": "Write a Fortran function named hdgrid_masked_nbrs_kernel to calculate the number of neighboring cells that satisfy a specified mask criterion. The function takes 1 input parameter of type real, dimension(1:9) and returns 1 output parameter of type real.", "input": "", "output": "function hdgrid_masked_nbrs_kernel(input_mask) result(number_nbrs)\n\nimplicit none\n\nreal, intent(in), dimension(1:9) :: input_mask\n\n!local variables\ninteger :: i  !a counter\nreal  :: number_nbrs  !the calculated flow direction to return\n number_nbrs = 0.0\n if (input_mask(5) == 1.0) then\n    do i = 1,9\n      if(i==5) cycle\n      if(input_mask(i) == 1.0) number_nbrs = number_nbrs + 1.0\n    enddo\n end if\n\nend function hdgrid_masked_nbrs_kernel\n"}, {"instruction": "Create a Fortran function named file_exists to check if a file with the given filename exists. The function should take 1 input parameter of type character(len=*) and return 1 output parameter of type logical. The input parameter represents the filename to be checked, and the output parameter indicates whether the file exists or not.", "input": "", "output": "\tfunction file_exists(filename) result (exists)\n\t\timplicit none\n\t\tcharacter(len=*), intent(in) :: filename\n\t\tlogical :: exists\n\t\tinquire(file=filename, exist=exists)\n\tend function file_exists\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci sequence up to the given integer input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function fib(n) result(r)\n    implicit none\n    integer :: n, r\n\n    if (n < 2) then\n      r = n\n    else\n      r = fib(n - 1) + fib(n - 2)\n    endif\n  end function fib\n"}, {"instruction": "Write a Fortran function named fibtailauxiliary to compute the Fibonacci sequence using tail recursion. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be in the order: n, prevfib, fib, and the output argument should be named r.", "input": "", "output": "  recursive function fibtailauxiliary(n, prevfib, fib) result(r)\n    implicit none\n    integer :: n, prevfib, fib, r\n\n    if (n == 0) then\n      r = prevfib\n    else\n      r = fibtailauxiliary(n - 1, fib, prevfib + fib)\n    endif\n  end function fibtailauxiliary\n"}, {"instruction": "Write a Fortran function named random_integers that generates an array of random integers. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer array with dimension n.", "input": "", "output": "   function random_integers(n) result(z)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n\n      integer, dimension(n) :: z\n      ! local data\n      integer :: i\n      real :: r\n      ! processing\n      do i=1,n\n         call random_number(r)\n         z(i) = int(2147483448.*r)\n      end do\n   end function random_integers\n"}, {"instruction": "Provide a Fortran function code named random_reals to generate an array of random double precision numbers. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [double precision, dimension(n)].", "input": "", "output": "   function random_reals(n) result(r)\n      implicit none\n      ! dummy argumentss\n      integer, intent(in) :: n\n\n      double precision, dimension(n) :: r\n      ! local data\n      integer :: i\n      integer, allocatable :: seed(:)\n      ! processing\n      call random_number(r)\n   end function random_reals\n"}, {"instruction": "Create a Fortran function named concordance_index to calculate the concordance index for survival or reliability data. The function takes 4 input parameters of types integer, double precision array, double precision array, and double precision array. It returns a single output parameter of type double precision.", "input": "", "output": "function concordance_index (event_times, predictions, event_observed, rows) result(cindex)\n  double precision :: cindex, paircount, csum\n  integer, intent(in) :: rows\n  double precision, dimension(rows), intent(in) :: event_times, predictions, event_observed\n  double precision :: time_a, pred_a, event_a, time_b, pred_b, event_b\n  integer :: a, b\n  logical :: valid_pair\n\n  ! default values\n  paircount = 0\n  csum = 0\n  cindex = 0\n\n  do a=1, rows-1\n    time_a = event_times(a)\n    pred_a = predictions(a)\n    event_a = event_observed(a)\n    ! start at a+1 to avoid double counting\n    do b=a+1, rows\n      time_b = event_times(b)\n      pred_b = predictions(b)\n      event_b = event_observed(b)\n\n      ! check if it's a valid comparison\n      if (event_a == 1 .and. event_b == 1) then\n        ! two events can always be compared\n        valid_pair = .true.\n      else if (event_a == 1 .and. time_a < time_b) then\n        ! if b is censored, then a must have event first\n        valid_pair = .true.\n      else if (event_b == 1 .and. time_b < time_a) then\n        ! if a is censored, then b must have event first\n        valid_pair = .true.\n      else\n        ! not valid to compare this pair\n        valid_pair = .false.\n      end if\n\n      if (valid_pair) then\n        paircount = paircount + 1\n\n        ! check concordance\n        if (pred_a == pred_b) then\n          csum = csum + 0.5\n        else if (time_a < time_b .and. pred_a < pred_b) then\n          csum = csum + 1.0\n        else if (time_b < time_a .and. pred_b < pred_a) then\n          csum =csum + 1.0\n        !else\n        ! csum = csum + 0\n        end if\n      end if\n    end do\n  end do\n\n  ! calculate c-index.\n  if (paircount > 0) then\n    cindex = csum / paircount\n  else\n    cindex = 0.5\n  end if\n\nend function concordance_index\n"}, {"instruction": "Create a Fortran function named interp2 to interpolate values from a 2D grid. The function takes 5 input parameters of type real(kind=8) and dimension(:), and one output parameter of type real(kind=8). The input parameters represent grid coordinates and values, while the output parameter represents the interpolated value.", "input": "", "output": "  function interp2(x, y, v, xq, yq) result(vq)\n    real(kind = 8) :: vq\n    real(kind = 8), intent(in) :: xq, yq\n    real(kind = 8), dimension(:), intent(in) :: x, y\n    real(kind = 8), dimension(:,:), intent(in) :: v\n    integer(kind = 4) :: nx, ny, i1, i2, j1, j2\n    real(kind = 8) :: x1, x2, y1, y2, v11, v21, v12, v22\n    real(kind = 8) :: n(4), ax(4), ay(4), av(4)\n\n    nx = size(v, 1)\n    ny = size(v, 2)\n    i1 = minloc(xq - x, dim = 1, mask = xq .ge. x)\n    j1 = minloc(yq - y, dim = 1, mask = yq .ge. y)\n    i2 = i1 + 1\n    j2 = j1 + 1\n\n    if ( i1 .eq. nx .and. j1 .ne. ny ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      v11 = v(i1,j1)\n      v21 = 0.d0\n      v12 = v(i1,j2)\n      v22 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      v11 = v(i1,j1)\n      v21 = v(i2,j1)\n      v12 = 0.d0\n      v22 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      v11 = v(i1,j1)\n      v21 = 0.d0\n      v12 = 0.d0\n      v22 = 0.d0\n    else\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      v11 = v(i1,j1)\n      v21 = v(i2,j1)\n      v12 = v(i1,j2)\n      v22 = v(i2,j2)\n    end if\n\n    ax = [ x2, x1, x2, x1 ]\n    ay = [ y2, y2, y1, y1 ]\n    av = [ v11, v21, v12, v22 ]\n    n = dabs( (ax - xq) * (ay - yq) ) / dabs( (x2 - x1) * (y2 - y1) )\n    vq = dot_product(av, n)\n    return\n  end function interp2\n"}, {"instruction": "Write a Fortran function named minmod2 that calculates the minimum of the absolute values of two real(8) numbers, considering their signs. The function takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8). The function should be used to compute the minimum value between the absolute values of the input real(8) numbers while considering their signs.", "input": "", "output": "function minmod2(a, b) result(m)\n    real(8), intent(in) :: a, b\n    real(8) :: m\n    m = ( sign(1.0d0, a) + sign(1.0d0, b) )/2.0d0*&\n        min(abs(a), abs(b))\nend function minmod2\n"}, {"instruction": "Create a Fortran function named minmod3 that takes three double precision real numbers as input parameters. The input parameters should be of type real(8). The function returns a single double precision real number as the output parameter. The function calculates the minimum of the absolute values of the input parameters and returns the result after applying the minmod function.", "input": "", "output": "function minmod3(a, b, c) result(m)\n    real(8), intent(in) :: a, b, c\n    real(8) :: m\n    m = dble(int( ( sign(1.0d0, a) + sign(1.0d0, b) + sign(1.0d0, c) )/3.0d0))*&\n        min(abs(a), abs(b), abs(c))\nend function minmod3\n"}, {"instruction": "Provide a Fortran function named to_str that converts an integer to a string. The function takes 1 input argument of type integer. The output is a single string of length 20. Use the imperative tone to write the instructions.", "input": "", "output": "    function to_str(k)\n        ! {{{\n        integer, intent(in) :: k\n        ! ---\n        character(len=20) :: to_str\n        ! }}}\n        write (to_str, *) k\n        to_str = adjustl(to_str)\n    end function to_str    \n"}, {"instruction": "Create a Fortran function named load_pnm to read a PNM (Portable Any Map) image file and store its contents in a 3D array. The function takes one input parameter of type character(*) representing the filename and returns one output parameter of type integer, allocatable, and dimension(:, :, :), representing the image array.", "input": "", "output": "  function load_pnm(filename) result(img_array)\n    !!! load_pnm\n    !!!\n    !!!   input:\n    !!!     filename(character): input filename.\n    !!!   output:\n    !!!     img_array(integer, 3d): image array.\n    !!!                             even if the image is grayscale/monochrome, the array is 3d.\n    implicit none\n    character(*), intent(in) :: filename\n    integer, allocatable, dimension(:, :, :) :: img_array\n    character(len=2) :: pnm_type\n    integer :: i, j\n    integer :: width, height, max_value, n_layer\n    integer :: iostatus = 1\n    integer, allocatable :: row(:), div_row(:), mod_row(:)\n\n    open (10, file=filename, status=\"old\", action=\"read\", position=\"rewind\")\n    read (10, *, iostat=iostatus) pnm_type\n    read (10, *, iostat=iostatus) width, height\n\n    if (pnm_type == \"p1\") then\n      n_layer = 1\n    else if (pnm_type == \"p2\") then\n      n_layer = 1\n      read (10, *, iostat=iostatus) max_value\n    else if (pnm_type == \"p3\") then\n      n_layer = 3\n      read (10, *, iostat=iostatus) max_value\n    else\n      print *, \"pnm header must be in (p1, p2, p3), the header is \", pnm_type\n      stop 1 ! how raise error?\n    end if\n\n    allocate (img_array(n_layer, height, width))\n\n    allocate (row(width*n_layer))\n    div_row = ([(i, i=0, (width*n_layer) - 1)]/n_layer) + 1 ! 1, 1, 1, 2, 2, 2, ...\n    mod_row = (mod([(i, i=0, (width*n_layer) - 1)], n_layer)) + 1 ! 1, 2, 3, 1, 2, 3, ...\n    do i = 1, height\n      read (10, *, iostat=iostatus) row\n      do j = 1, size(row)\n        img_array(mod_row(j), i, div_row(j)) = row(j)\n      end do\n      if (iostatus < 0) then\n        exit\n      end if\n    end do\n    close (10)\n    deallocate (row, div_row, mod_row)\n  end function load_pnm\n"}, {"instruction": "Create a Fortran function named diag that takes a 2D array of real numbers as input and returns a 1D array containing the elements of the main diagonal of the input array. The number of input arguments is 1 and the test_data type is ['real, dimension(:,:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(min(size(a,dim=1),size(a,dim=2)))'].", "input": "", "output": "  function diag (a) result (d)\n    real, dimension(:,:), intent(in) :: a\n    real, dimension(min(size(a,dim=1),size(a,dim=2))) :: d\n    integer :: i\n    do i = 1, min(size(a, dim = 1), size(a, dim = 2))\n       d(i) = a(i,i)\n    end do\n  end function diag\n"}, {"instruction": "Create a Fortran function named project_coords to transform 3D coordinates to 2D screen coordinates. The function takes 1 input parameter of type real array with 3 elements. The output is an integer array with 2 elements.", "input": "", "output": "    function project_coords(pos)\n\n        real, dimension(3), intent(in) :: pos\n        integer, dimension(2) :: project_coords\n\n        project_coords(1) = nint(xscale * (ez * pos(1) / pos(2)) + halfw)\n        project_coords(2) = nint(-ez * pos(3) / pos(2) + halfh)\n\n    end function\n"}, {"instruction": "Create a Fortran function named get_color_number that takes a single input argument of type character(*) and returns an integer value. The function should map the input color name to a corresponding number as follows: \"white\" to 0, \"red\" to 1, \"green\" to 2, \"blue\" to 3, \"magenta\" to 4, \"yellow\" to 5, \"cyan\" to 6, and any other input to 0.", "input": "", "output": "    function get_color_number(col)\n\n        character(*), intent(in) :: col\n        integer :: get_color_number\n\n        select case (col)\n\n            case (\"white\")\n                get_color_number = 0\n            case (\"red\")\n                get_color_number = 1\n            case (\"green\")\n                get_color_number = 2\n            case (\"blue\")\n                get_color_number = 3\n            case (\"magenta\")\n                get_color_number = 4\n            case (\"yellow\")\n                get_color_number = 5\n            case (\"cyan\")\n                get_color_number = 6\n            case default\n                get_color_number = 0\n\n        end select\n\n    end function\n"}, {"instruction": "Provide a Fortran function named charfromangle that takes a single real input argument and returns a character based on the value of the input. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [character]. The function uses a select case construct to determine the character to be returned based on the input value.", "input": "", "output": "    function charfromangle(angle)\n\n        character :: charfromangle\n        real, intent(in) :: angle\n\n        select case (nint(angle*(180/pi)))\n\n            case (-23 : 23)\n                charfromangle = \"-\"\n            case (24 : 68)\n                charfromangle = \"\\\"\n            case (69 : 113)\n                charfromangle = \"|\"\n            case (114 : 165)\n                charfromangle = \"/\"\n            case (166 :)\n                charfromangle = \"-\"\n            case (-68 : -24)\n                charfromangle = \"/\"\n            case (-113 : -69)\n                charfromangle = \"|\"\n            case (-165 : -114)\n                charfromangle = \"\\\"\n            case (: -166)\n                charfromangle = \"-\"\n\n        end select\n\n    end function\n"}, {"instruction": "Create a Fortran function named get_length_needed that calculates the number of digits needed to represent an integer. The function takes 1 input argument of type integer. The number of input arguments is 1, and the test_data type is ['integer']. It returns 1 output argument of type integer. The function should be used as follows:\n```fortran\nresult = get_length_needed(input_integer)\n```", "input": "", "output": "    pure function get_length_needed(a)\n\n        integer, intent(in) :: a\n        integer :: get_length_needed\n\n        if (a < 0) then\n            get_length_needed = int(log(real(-a))/log(10.0))+2\n        else\n            get_length_needed = int(log(real(a))/log(10.0))+1\n        end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named count_lines to determine the number of lines in a file. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input parameter represents the file unit number.", "input": "", "output": "function count_lines(un_file) result(n)\nimplicit none\ninteger:: un_file, n, k\ncharacter*1:: junk\nrewind(un_file); n=0\ndo\n        read(un_file,*,iostat=k) junk\n        if (k/=0) exit\n        n=n+1\nenddo\nrewind(un_file)\nend function count_lines\n"}, {"instruction": "Create a Fortran function named selector that takes three input parameters: an optional integer, a string of variable length, and an array of strings. The function returns a single output parameter of type character with a length of 128. The purpose of the function is to display a menu with options and allow the user to select a choice. The selected choice is returned as the output of the function.", "input": "", "output": "  function selector(title, options, n) result(choice)\n    integer, optional, intent(in) :: n\n    character(len=*), intent(in) :: title\n    character(len=*),dimension(:),intent(in) :: options\n    !character(len=:), allocatable :: choice ! requires deallocation\n    !allocate(character(len=8)::choice)\n    character(len=128) :: choice\n    integer :: i, l, ios\n    l = merge(n, size(options), present(n))\n    if (l .lt. 1) stop 'silly input'\n    if (len(choice) .lt. len(options(1))) stop 'menu choices are excessively long'\n    i = 0\n    do while ((ios.ne.0) .or. ((i.lt.1) .or. (l.lt.i)))\n       write(6,*) title\n       write(6,\"(i8,': ',a)\")(i,options(i),i=1,l)\n       read(5,*,iostat=ios,end=666) i\n    end do\n    choice = options(i)\n    return\n666 continue\n    stop 'unexpected end of file'\n  end function selector\n"}, {"instruction": "Create a Fortran function named ran to generate a random number using the linear congruential method. The function takes 1 input argument of type integer(k4b) and returns 1 output argument of type real. The input parameter is intended to be modified within the function.", "input": "", "output": "      function ran(idum)\n    \n      implicit none\n      \n      integer, parameter :: k4b=selected_int_kind(9)\n      integer(k4b), intent(inout) :: idum\n      real :: ran\n      integer(k4b), parameter :: ia=16807\n      integer(k4b), parameter :: im=2147483647\n      integer(k4b), parameter :: iq=127773\n      integer(k4b), parameter :: ir=2836\n      real, save :: am\n      integer(k4b), save :: ix=1\n      integer(k4b), save :: iy=-1,k\n      \n      if (idum <= 0 .or. iy < 0) then\n          am=nearest(1.0,-1.0) / im\n          iy = ior(ieor(888889999,abs(idum)),1)\n          ix = ieor(777755555,abs(idum))\n          idum = abs(idum) + 1\n      end if\n      ix=ieor(ix,ishft(ix,13))\n      ix=ieor(ix,ishft(ix,-17))\n      ix=ieor(ix,ishft(ix,5))\n      k = iy / iq\n      iy = ia * (iy-k*iq) - ir * k\n      if (iy < 0) iy = iy + im\n      ran=am*ior(iand(im,ieor(ix,iy)),1)\n      end function ran \n"}, {"instruction": "Create a Fortran function named check_early_termination that evaluates whether the termination condition is met based on the number of evaluations, maximum allowed evaluations, and a critical estimation flag. The function takes 3 input parameters of type integer, integer, and logical. It returns 1 output parameter of type logical.", "input": "", "output": "function check_early_termination(maxfun, num_eval, crit_estimation) result(is_termination)\n\n    !/* external objects    */\n\n    logical                         :: is_termination\n\n    integer, intent(in)             :: num_eval\n    integer, intent(in)             :: maxfun\n\n    logical, intent(in)             :: crit_estimation\n\n!------------------------------------------------------------------------------\n! algorithm\n!------------------------------------------------------------------------------\n\n    is_termination = (num_eval == maxfun) .and. crit_estimation .and. (.not. maxfun == zero_int)\n\n    ! we also want to allow for a gentle termination by the user.\n    if (.not. is_termination) inquire(file='.stop.respy.scratch', exist=is_termination)\n\nend function\n"}, {"instruction": "Create a Fortran function named wrap_string_index that takes three input parameters of type character(len=*), integer, and integer, and one output parameter of type integer. This function finds the index of the last space (' ') in the substring of the input string, starting at position 'istart' and within 'width' characters. If the string is shorter than 'width', the function returns 0.", "input": "", "output": "  function wrap_string_index(string,istart,width) result(w)\n\n    ! finds last space (' ') in string at or before position 'width' of substring string(istart:)\n    ! returns index of space, or 0 if string is shorter than width.\n    character(len=*),intent(in)::string\n    integer,intent(in)::istart\n    integer,intent(in)::width\n    integer::w\n    integer::lstring,i\n    lstring=len(string)\n    if(lstring.le.istart+width-1) then\n      w=0\n    else\n      i=istart+width !because we can accept the final character of a word being at the extremity of the line\n      do while(string(i:i).ne.' ')\n        i=i-1\n        if(i.eq.0) exit\n      end do\n      if(i.eq.0) then\n        w=istart+width-1 ! if no spaces, truncate string mid-stream\n      else\n        w=i\n      end if\n    end if\n    return\n  end function wrap_string_index\n"}, {"instruction": "Create a Fortran function named opt_takes_value to check if the input argument corresponds to a specific type. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "  function opt_takes_value(type) result (l)\n    integer,intent(in)::type\n    logical::l\n    l=.false.\n    if((type.eq.arg_int).or.(type.eq.arg_float).or.(type.eq.arg_char)) l=.true.\n    return\n  end function opt_takes_value\n"}, {"instruction": "Write a Fortran function named hex to convert an integer representing a byte into a hexadecimal string. The function should have 1 input parameter with the test_data type ['integer'] and 1 output parameter with the test_data type ['character(len=2)']. Use the imperative tone in the instructions.", "input": "", "output": "   function hex(byte)\n      integer, intent(in) :: byte\n      character(len=2) :: hex\n      character(len=1), parameter :: hex_digits(0:15) = (/ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' /)\n      integer :: m1, m2\n\n      m1 = mod(byte,16)\n      m2 = mod(byte/16,16)\n      hex = hex_digits(m2)//hex_digits(m1)\n      \n   end function\n"}, {"instruction": "Create a Fortran function named xorshift32 to perform the XORSHIFT32 algorithm. The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "  pure function xorshift32(i)\n    implicit none\n    integer(4), intent(in) :: i\n    integer(4) :: xorshift32\n    if (i == 0) then\n      xorshift32 = 1231767121\n    else\n      xorshift32 = i\n    end if\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, 13))\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, -17))\n    xorshift32 = ieor(xorshift32, ishft(xorshift32, 15))\n  end function xorshift32\n"}, {"instruction": "Create a Fortran function named all_ones_consecutive to determine if an array of 18 integers contains consecutive ones. The function should take 1 input parameter of type integer, dimension(18), and return 1 output parameter of type logical.", "input": "", "output": "\tfunction all_ones_consecutive(array)\n\t\tinteger, dimension(18) :: array\n\t\tlogical :: all_ones_consecutive\n\t\tinteger :: first_one_index, last_one_index, i, sum_result\n\n\t\ti = 1\n\t\tdo while(i <= 18)\n\t\t\tif(array(i) == 1) then\n\t\t\t\tfirst_one_index = i\n\t\t\t\texit\n\t\t\tend if\n\t\t\ti = i + 1\n\t\tend do\n\n\t\ti = 18\n\t\tdo while(i >= 1)\n\t\t\tif(array(i) == 1) then\n\t\t\t\tlast_one_index = i\n\t\t\t\texit\n\t\t\tend if\n\t\t\ti = i - 1\n\t\tend do\n\n\t\tsum_result = 0\n\t\tdo i = first_one_index, last_one_index\n\t\t\tsum_result = sum_result + array(i)\n\t\tend do\n\n\t\tif(last_one_index - first_one_index + 1 == sum_result) then\n\t\t\tall_ones_consecutive = .true.\n\t\telse\n\t\t\tall_ones_consecutive = .false.\n\t\tend if\t\t\t\t\t\t\n\tend function all_ones_consecutive\n"}, {"instruction": "Create a Fortran function named lnprefsol to calculate the natural logarithm of a preference factor. The function takes 3 input parameters of types integer(8), integer(8), and real(8). The output is a single real(8) value.", "input": "", "output": "function lnprefsol(dn, n1at, vol) result(res)\n  real(8) :: res\n  ! type(solubdata), intent(in) :: sd\n  integer(8), intent(in) :: dn, n1at\n  real(8), intent(in) :: vol\n  real(8) :: pref, dnr, nar\n  integer :: i\n  pref = 1.0\n  if(abs(dn) < 10_8) then\n    if(dn > 0_8) then\n      do i  = 1,dn\n        pref = pref * vol / real(n1at + i, 8)\n      end do\n    else\n      do i = 0, -dn-1\n        pref = pref * real(n1at - i, 8) / vol\n      end do\n    end if\n    res = log(pref)\n  else\n    dnr = real(dn, 8)\n    nar = real(n1at, 8)\n    res = dnr*log(vol) - log_gamma(nar+dnr) + log_gamma(nar)\n  end if\nend function\n"}, {"instruction": "Write a Fortran function named decay that calculates the decay function for a given input array and parameters. The function takes 3 input parameters of type double precision, including a 2D array, a single value, and an integer. The output is a double precision 2D array of size natoms x natoms. Use the imperative tone and specify the input and output parameter types as requested.", "input": "", "output": "function decay(r, invrc, natoms) result(f)\n\n    implicit none\n\n    double precision, intent(in), dimension(:,:) :: r\n    double precision, intent(in) :: invrc\n    integer, intent(in) :: natoms\n    double precision, dimension(natoms, natoms) :: f\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n\n    f = 0.5d0 * (cos(pi * r * invrc) + 1.0d0)\n\n\nend function decay\n"}, {"instruction": "Create a Fortran function named concat that takes two integer arrays as input and returns a concatenated integer array as output. The number of input arguments is 2 and the test_data type is ['integer, allocatable, dimension(:)', 'integer, allocatable, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, allocatable, dimension(:)'].", "input": "", "output": " function concat (ia, ib) result (ic)\n   integer, allocatable, dimension(:) :: ia, ib, ic\n   if (allocated (ia) .and. allocated (ib)) then\n     ic = [ia, ib]\n   else if (allocated (ia)) then\n     ic = ia\n   else if (allocated (ib)) then\n     ic = ib\n   end if\n end function concat\n"}, {"instruction": "Write a Fortran function named get_index that calculates the index of a variable in a multi-dimensional array based on the given latitude, longitude, level, and variable type. The function takes 4 input parameters of type integer: lat_index, lon_index, lev_index, and var_type. It returns a single output parameter of type integer.", "input": "", "output": "function get_index(lat_index, lon_index, lev_index, var_type)\n!------------------------------------------------------------------\n!\ninteger,  intent(in) :: lat_index, lon_index, lev_index, var_type\ninteger              :: get_index\n\nget_index = 1 + var_type + (lev_index - 1)*state_num_3d      &\n                         + (lat_index - 1)*state_num_3d*nz   &\n                         + (lon_index - 1)*state_num_3d*nz*ny\n\nend function get_index\n"}, {"instruction": "Write a Fortran function named nccf_free_coord to free the memory associated with a coordinate ID. The function takes 1 input parameter of type integer(c_int) and value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "       function nccf_free_coord(coordid) result(stat) &\n         &                           bind(c, name=\"nccf_free_coord\")\n          use iso_c_binding\n          implicit none\n          integer(c_int), value     :: coordid\n          integer(c_int)            :: stat\n       end function\n"}, {"instruction": "Create a Fortran function named sils_idiag that calculates the displacement from the start of an assembled matrix, of order ix, to the diagonal entry in its row iy. The function will take 2 input parameters of type integer (ix, iy) and return an output parameter of type integer.", "input": "", "output": "       function sils_idiag( ix, iy )\n\n!  obtain the displacement from the start of the assembled matrix (of order ix)\n!  of the diagonal entry in its row iy\n\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n\n       integer :: sils_idiag\n       integer, intent( in ) :: ix, iy\n\n       sils_idiag = ( ( iy - 1 ) * ( 2 * ix - iy + 2 ) ) / 2\n       return\n\n\n       end function sils_idiag\n"}, {"instruction": "Create a Fortran function named csndset to calculate the hindered settling correction for noncohesive sediment of class ns. The function should have 3 input parameters of type integer, real, and real, and 1 output parameter of type real. The function should be defined using the imperative tone.", "input": "", "output": "function csndset(snd,sden,iopt)\n  !\n  ! change record\n  ! **  calculates hindered settling correction for class ns noncohesive\n  ! **  sediment\n\n  implicit none\n  \n  integer :: iopt\n  real :: csndset,snd,sden,ropt\n\n  ropt=float(iopt)\n  csndset=(1.-sden*snd)**ropt\n\nend function\n"}, {"instruction": "Create a Fortran function named \"kron\" to compute the Kronecker product of two matrices. The number of input arguments is 2 with the test_data type ['real(kind=8), dimension(:,:)','real(kind=8), dimension(:,:)']. The number of output arguments is 1 with the test_data type ['real(kind=8), dimension(size(a,1)*size(b,1),size(a,2)*size(b,2))'].", "input": "", "output": "function kron(a,b) result(c)\n!\n!   copyright 2017, viktor reshiak, all rights reserved.\n!\n!\n!   purpose\n!   =======\n!   kronecker product of two matrices\n!\n!\n!   in\n!   ==\n!   1) na1 - first  dimension of array a\n!   2) na2 - second dimension of array a\n!   3) a   - array\n!   4) nb1 - first  dimension of array b\n!   5) nb2 - second dimension of array b\n!   6) b   - array\n!\n!\n!   inout\n!   =====\n!   1) c  - resulting matrix\n!\n!\n\timplicit none\n\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    ! dummy arguments\n    real(kind=8), intent(in), dimension(:,:) :: a\n    real(kind=8), intent(in), dimension(:,:) :: b\n\n    real(kind=8), dimension(size(a,1)*size(b,1),size(a,2)*size(b,2))    :: c\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    integer(kind=4) :: i, j\n    integer(kind=4), dimension(2) :: sh_a, sh_b\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    sh_a = shape(a)\n    sh_b = shape(b)\n\n    do i = 1,sh_a(1)\n        do j = 1,sh_a(2)\n            c((i-1)*sh_b(1)+1:i*sh_b(1),(j-1)*sh_b(2)+1:j*sh_b(2)) = a(i,j) * b\n        enddo\n    enddo\n\nend function kron\n"}, {"instruction": "Create a Fortran function named new_ext that takes two input parameters of type character with unspecified length. This function aims to add a new file extension to the given file name. The number of input arguments is 2, and the test_data type is ['character(len = *)', 'character(len = *)']. It also returns an output parameter of type character with a length of 256. The function should be used as follows: `new_ext(file_name, extension)`.", "input": "", "output": "function new_ext(file_name, extension)\n\n    implicit none\n    character(len = *), intent(in)  :: file_name  ! file to add new extension to\n    character(len = *), intent(in)  :: extension  ! new extension to add\n    character(len = 256)            :: new_ext    ! file name with new extension\n    integer                         :: dot_pos    ! position of extension dot\n\n    dot_pos = scan(trim(file_name), '.', back = .true.)\n    if (dot_pos > 0) then\n        new_ext = file_name(1:dot_pos - 1) // extension\n    else\n        new_ext = trim(file_name) // extension\n    end if\n\nend function new_ext\n"}, {"instruction": "Create a Fortran function named s_hssw_bolt to calculate the value of s based on the given input parameters. The function takes 4 input arguments of type real*8, namely phi, t, lambda, and k. It returns 1 output argument of type real*8.", "input": "", "output": "  function s_hssw_bolt(phi,t,lambda,k) result(s)\n    implicit none\n    real * 8, intent(in) :: phi !volume fraction value\n    real * 8, intent(in) :: t !temperature\n    real * 8, intent(in) :: lambda !square well range\n    real * 8, intent (in) :: k !value of the wave vector\n    real * 8 :: s, x, lk, k3, l3\n    k3=k * k * k\n    x = exp(1.d0/t) - 1.d0\n    lk = lambda * k\n    s = 0.d0\n    if (k > 0.075d0) then\n      s = sin(lk) - sin(k) + k * cos(k) - lk * cos(lk)\n      s = s * x\n      s = s + k * cos(k) - sin(k)\n      s = s / k3\n    else\n      l3 = lambda * lambda * lambda\n      s = (x * (l3 - 1.d0) - 1.d0) / 3.d0\n    end if\n    s = 1.d0 + (24.d0 * phi * s )\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named s_hssw_stos to perform a complex mathematical computation. The function takes 4 input parameters of type real * 8 and returns 1 output parameter of type real * 8. This function implements a series of mathematical operations involving complex numbers and constants to compute a result based on the input parameters.", "input": "", "output": "  function s_hssw_stos (phi,t,lambda,k) result(s)\n    implicit none\n    integer :: i1\n    real * 8, intent(in) :: phi, t, lambda, k\n    real * 8 :: s\n    real * 8 :: a0,a01,l1,l2,s1,s2,s3,sw_tau !f(t) parameters\n    real * 8 :: alpha1,alpha2,alpha3,beta1,beta2,beta3,beta4,gamma0,gamma1,gamma2 !l2 parameters\n    real * 8 :: lam1,lam2,lam3,lam4,lam5,lam6,tau1,tau2 !convenient dummies variables\n    complex * 16 :: ftp,ftm,gtp,gtm !f(t),f(-t),g(t),g(-t)\n    real * 8 :: ftdum1,ftdum2,ftdum3\n    real * 8 dum1,dum2,dum3\n    complex * 16 :: im\n    real * 8 dumeta\n    dumeta=phi\n    im=(0.d0,1.d0)\n    !allocate (ftp(kpoints))\n    !allocate (ftm(kpoints))\n    !allocate (gtp(kpoints))\n    !allocate (gtm(kpoints))\n    lam1=lambda\n    lam2=lam1**2\n    lam3=lam1**3\n    lam4=lam1**4\n    lam5=lam1**5\n    lam6=lam1**6\n    !a0\n    a0=exp(1.d0/t)-1.d0\n    !a0 prima\n    a01=a0*((lam1-1.d0)**2)\n    !print*, \"a01=\",a01\n    !square well tau\n    sw_tau=1.d0/(12.d0*a0*lam1*(lam1-1.d0))\n    tau1=1.d0/sw_tau\n    !print*, \"tau1=\",tau1\n    tau2=1.d0/(sw_tau**2)\n    !print*, \"tau2=\",tau2\n    !alpha 1\n    alpha1=2.d0*a01*(2.d0+lam1)+((1.d0+(4.d0*lam1)+lam2-3.d0*a01)*tau1/6.d0)\n    !print*, \"alpha1\", alpha1\n    !alpha2\n    alpha2=3.d0+a01*(7.d0+2.d0*lam1-3.d0*lam2)-((7.d0+lam1+16.d0*lam2+a01*&\n    &(23.d0+15.d0*lam1+15.d0*lam2+7.d0*lam3))*tau1/12.d0)\n    !print*, \"alpha2\", alpha2\n    !alpha3\n    alpha3=-2.d0-2.d0*a01*(1.d0+2.d0*lam1+3.d0*lam2)+((7.d0+lam1-2.d0*lam2+a01*&\n    &(7.d0+15.d0*lam1+21.d0*lam2+11.d0*lam3+6.d0*lam4))*tau1/6.d0)\n    !print*, \"alpha3\", alpha3\n    !beta1\n    beta1=-4.d0-4.d0*a01*(2.d0+lam1)-(tau2/3.d0)+((5.d0+2.d0*lam1-lam2+3.d0*a01)*tau1/3.d0)\n    !print*, \"beta1\", beta1\n    !beta2\n    beta2=6.d0+6.d0*a01*(3.d0+2.d0*lam1+lam2)+4.d0*(a01**2)*((2.d0+lam1)**2)&\n    &-((9.d0*(3.d0+lam1)+a01*(59.d0+51.d0*lam1+3.d0*lam2-5.d0*lam3)&\n    &+12.d0*(a01**2)*(2.d0+lam1))*tau1/6.d0)+((31.d0+8.d0*lam1+18.d0*lam2&\n    &-4.d0*lam3+lam4+12.d0*a01*(5.d0+lam1)+9.d0*(a01**2))*tau2/36.d0)\n    !print*, \"beta2\", beta2\n    !beta3\n    beta3=-4.d0-12.d0*a01*(1.d0+lam1+lam2)-4.d0*(a01**2)*(2.d0+lam1)*(1.d0&\n    &+2.d0*lam1+3.d0*lam2)+((3.d0*(4.d0+lam1+lam2)+a01*(29.d0&\n    &+36.d0*lam1+30.d0*lam2+7.d0*lam3-3.d0*lam4)+(a01**2)&\n    &*(17.d0+43.d0*lam1+30.d0*lam2+lam3-lam4))*tau1/3.d0)-((29.d0+13.d0*lam1&\n    &+27.d0*lam2+7.d0*lam3-4.d0*lam4+a01*(68.d0+80.d0*lam1+80.d0*lam2+16.d0*lam3&\n    &+7.d0*lam4+lam5)+3.d0*(a01**2)*(13.d0+13.d0*lam1+lam2-3.d0*lam3))*tau2/36.d0)\n    !print*, \"beta3\", beta3\n    !beta4 be ware, modified from the article\n    dum1=(1.d0+a01*(1.d0+2.d0*lam1+3.d0*lam2))**2\n    dum2=2.d0*a01*(7.d0+15.d0*lam1+15.d0*lam2+5.d0*lam3+6.d0*lam4)\n    dum3= a01*a01*(1.d0+2.d0*lam1+3.d0*lam2)*(7.d0+15.d0*lam1+3.d0*lam2-lam3)\n    dum2=7.d0+lam1+4.d0*lam2+dum2+dum3\n    beta4=dum1-(dum2*tau1/6.d0)\n    dum1=49.d0+38.d0*lam1+9.d0*lam2+8.d0*lam3+16.d0*lam4\n    dum2=2.d0*a01*(49.d0+88.d0*lam1+112.d0*lam2+80.d0*lam3+35.d0*lam4-4.d0*lam5)\n    dum3=a01*a01*(49.d0+138.d0*lam1+219.d0*lam2+124.d0*lam3+27.d0*lam4+18.d0*lam5+lam6)\n    dum1=dum1+dum2+dum3\n    dum1=dum1*tau2/144.d0\n    beta4=beta4+dum1\n    !print*, \"beta4\",beta4\n    !gamma0\n    gamma0=1.d0+lam1-(tau1/6.d0)\n    !print*, \"gamma0\",gamma0\n    !gamma1\n    gamma1=2.d0*(1.d0+lam1-lam2)-((3.d0+lam3)*tau1/6.d0)\n    !print*, \"gamma1\",gamma1\n    !gamma2\n    gamma2=lam1*(-4.d0*lam1+((2.d0+3.d0*lam1+lam2+lam3)*tau1/3.d0))\n    !print*, \"gamma2\",gamma2\n    !l2\n    l2=-1.d0+(alpha1*dumeta)+(alpha2*dumeta**2)+(alpha3*dumeta**3)+((1.d0+2.d0*dumeta)*&\n    &dsqrt(1.d0+(beta1*dumeta)+(beta2*dumeta**2)+(beta3*dumeta**3)+(beta4*dumeta**4)))\n    l2=l2/(12.d0*dumeta*(gamma0+gamma1*dumeta+gamma2*dumeta**2))\n    !print*, \"l2\",l2\n    !l1\n    l1=1.d0+0.5d0*dumeta+2.d0*dumeta*(1.d0+lam1+lam2)*l2-0.5d0*dumeta*a01*(3.d0+2.d0*lam1+lam2)\n    l1=l1/(1.d0+2.d0*dumeta)\n    !print*, \"l1\",l1\n    !s1\n    s1=(-1.5d0+2.d0*(1.d0+lam1+lam2)*l2-0.5d0*(3.d0+2.d0*lam1+lam2)*a01)!care inconsistency\n    s1=s1*(dumeta/(1.d0+2.d0*dumeta))\n    !print*, \"s1\",s1\n    !s2\n    s2=(-1.d0+dumeta+2.d0*(1.d0-2.d0*dumeta*lam1*(1.d0+lam1))*l2-(1.d0-dumeta*((1.d0+lam1)**2))*a01)\n    s2=s2/(2.d0*(1.d0+2.d0*dumeta))\n    !print*, \"s2\",s2\n    !s3\n    s3=(-(((1.d0-dumeta)**2)/(12.d0*dumeta))-(0.5d0*(lam1+1.d0)-dumeta*lam2)*l2)\n    s3=s3+(4.d0+2.d0*lam1-dumeta*(3.d0*lam2+2.d0*lam1+1.d0))*(a01/12.d0)\n    s3=s3/(1.d0+2.d0*dumeta)\n    !print*, \"s3\",s3\n    !f(t)->f(ik)\n    ftdum1=l1+(l2/(lam1-1.d0))-a0*(lam1-1.d0)\n    ftdum2=l2/(lam1-1.d0)\n    ftdum3=lam1-1.d0\n    !do i1=1, kpoints\n      !ftp(i1)=cmplx(1.d0+a0,0)+cmplx(0.d0,ftdum1*k(i1))-(cmplx(a0,ftdum2*k)*exp(cmplx(0.d0,-ftdum3*k)))\n      !ftp(i1)=-ftp(i1)/cmplx((1.d0-s2*(k**2)),(s1*k-s3*(k**3)))/(12.d0*eta)\n      !ftm(i1)=cmplx(1.d0+a0,0)+cmplx(0.d0,-ftdum1*k)-(cmplx(a0,-ftdum2*k)*exp(cmplx(0.d0,ftdum3*k)))\n      !ftm(i1)=-ftp(i1)/cmplx(12.d0*eta*(1.d0-s2*(k**2)),-12.d0*eta*(s1*k-s3*(k**3)))\n      ftp=(1.d0+a0+ftdum1*(im*k))-(a0+ftdum2*(im*k))*exp(-ftdum3*(im*k))\n      ftp=ftp/(1.d0+(s1*(im*k))+(s2*(im*k)**2)+(s3*(im*k)**3))\n      ftp=-ftp/(12.d0*dumeta)\n      ftm=(1.d0+a0+ftdum1*(-im*k))-(a0+ftdum2*(-im*k))*exp(-ftdum3*(-im*k))\n      ftm=ftm/(1.d0+(s1*(-im*k))+(s2*(-im*k)**2)+(s3*(-im*k)**3))\n      ftm=-ftm/(12.d0*dumeta)\n      !g(t)->g(ik)\n      !gtp(i1)=cmplx(0.d0,k)*ftp(i1)*exp(cmplx(0.d0,-k))/(cmplx(1.d0,0.d0)+12.d0*eta*ftp(i1)*exp(cmplx(0.d0,-k)))\n      gtp=(im*k)*ftp*exp(-im*k)/(1.d0+12.d0*dumeta*ftp*exp(-im*k))\n      !g(-t)->g(-ik)\n      !gtm(i1)=cmplx(0.d0,-k)*ftm(i1)*exp(cmplx(0.d0,k))/(cmplx(1.d0,0.d0)+12.d0*eta*ftm(i1)*exp(cmplx(0.d0,k)))\n      gtm=(-im*k)*ftm*exp(im*k)/(1.d0+12.d0*dumeta*ftm*exp(im*k))\n\n      s=realpart((gtp-gtm)/(im*k))\n      s=1.d0-(12.d0*dumeta*s)\n      !s=realpart(gtm(i1))\n    !end do\n  end function\n"}, {"instruction": "Create a Fortran function named u_hssw that takes two 8-byte real numbers as input parameters, denoted as r and lambda, and returns a single 8-byte real number as the output parameter. The function checks if the value of r falls within the range of 1 and lambda; if it does, the function returns -1.0, otherwise, it returns 0.0.", "input": "", "output": "  function u_hssw(r,lambda) result(u)\n    implicit none\n    real * 8, intent(in) :: r,lambda\n    real * 8 :: u\n    if ( 1.d0 <= r .and. r <= lambda) then\n      u = -1.d0\n    else\n      u = 0.d0\n    end if\n  end function\n"}, {"instruction": "Write a Fortran function named f_phic_aux that calculates the value of a polynomial function. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The input and output parameters must be of type real*8.", "input": "", "output": "  function f_phic_aux(phi) result(f)\n    implicit none\n    real * 8, intent(in) :: phi\n    real * 8 :: f\n    real * 8 :: phi5, phi4, phi3, phi2\n    phi2 = phi  * phi\n    phi3 = phi2 * phi\n    phi4 = phi3 * phi\n    phi5 = phi4 * phi\n    f = -phi5 + 5.d0*phi4 -4.d0*phi3 -20.d0*phi2 -5.d0*phi + 1.d0\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named p_root_hssw_aux to compute the value of p based on the provided input parameters. The function has 4 input parameters of type real * 8: ft, lambda, pc, and phi, and 1 output parameter of type real * 8.", "input": "", "output": "  function p_root_hssw_aux(ft,lambda,pc,phi) result(p)\n    implicit none\n    real * 8, intent(in) :: ft, lambda, pc,phi\n    real * 8 :: p\n    real * 8 :: phi2,phi3,phim3\n    phi2 = phi * phi\n    phi3 = phi2 * phi\n    phim3 = (1.d0 - phi) ** 3\n    p = (phi * (1.d0 + phi + phi2 - phi3) / phim3) - (4.d0 * (lambda ** 3 - 1.d0)* ft * phi2) - pc\n  end function\n"}, {"instruction": "Create a Fortran function named roots_phi_s_aux that takes 3 real*8 input parameters: ft, lambda, and phi. The function calculates a result of type real*8 and returns it as the output parameter.", "input": "", "output": "  function roots_phi_s_aux(ft,lambda,phi) result(f)\n    implicit none\n    real * 8, intent(in) :: ft,lambda,phi\n    real * 8 :: f\n    real * 8 :: a\n    real * 8 :: phim4, phi2\n    phi2 = phi * phi\n    phim4 = (1.d0 - phi) ** 4\n    a = -8.d0 * ft * (lambda ** 3 - 1.d0)\n    f = a * phi * phim4 + 8.d0 * phi - 2.d0 * phi2 + phim4\n  end function\n"}, {"instruction": "Create a Fortran function named p1 that takes two 8-byte real numbers as input arguments and returns an 8-byte real number as the output. The function computes a mathematical expression based on the input values and returns the result.", "input": "", "output": "  function p1(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,k3, ka2,a2,a3\n    ka = k*a\n    k3 = k**3\n    a2 = a*a\n    ka2 = ka*ka\n    if (ka < 0.075 ) then\n        a3=a2*a\n        p = ( (10.d0 - ka2)/(30.d0) )\n        p = p * a3\n    else\n      p = ( sin(ka) - ka * cos(ka) ) / k3\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named p2 to compute the value of p based on the input parameters k and a. The input parameters are both of type real * 8. The function returns a single output parameter p, which is also of type real * 8.", "input": "", "output": "  function p2(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,k2,k4, ka2, a4\n    ka = k*a\n    k2 = k**2\n    ka2 = ka * ka\n    k4 = k2 * k2\n    a4 = a**4\n    if (ka < 0.075 ) then\n      p = (2.d0/k4) + a4*(0.25d0 - (1.d0 / 36.d0) * ka2)\n    else\n      p = ( 2.d0*ka*sin(ka) +( 2.d0-ka2 )*cos(ka) ) / k4\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named p4 that takes two double precision real numbers as input arguments. The input arguments have the test_data type ['real * 8', 'real * 8']. The function returns a double precision real number as its output, with the test_data type ['real * 8']. This function computes a mathematical operation using the input arguments and conditional statements to determine the value to be returned.", "input": "", "output": "  function p4(k,a) result(p)\n    implicit none\n    real * 8, intent(in) :: k,a\n    real * 8 :: p\n    real * 8 :: ka,ka2,ka4,k2,k4,k6,a6,a4\n    ka = k*a\n    ka2 = ka * ka\n    ka4 = ka2 * ka2\n    k2 = k*k\n    k4 = k2 * k2\n    k6 = k4 * k2\n    ka2 = ka * ka\n    a6 = a**6\n    a4 = a**4\n    if (ka < 0.075 ) then\n      p = (-24.d0/k6) + a6 * ( (1.d0/6.d0) - (1.d0/48.d0) * ka2 )\n    else\n      p = ( (4.d0*ka*(ka2-6.d0))* sin(ka) - (ka4 - 12.d0*ka2 + 24.d0) * cos(ka) ) / k6\n    end if\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named find_sizes to calculate the sizes of clusters in a labelled matrix. The function takes two input parameters: a 2D array of integers labelled_matrix and an integer num_labels. It returns one output parameter: an allocatable 1D array of integers sizes.", "input": "", "output": "        function find_sizes(labelled_matrix, num_labels) result(sizes)\n            !! count the number of sites belonging to each cluster\n            !! in the labelled matrix.\n\n            integer, dimension(:), allocatable :: sizes\n                !! array of cluster sizes. the i'th element is the size of\n                !! the cluster with label i.\n\n            integer, dimension(:,:), intent(in) :: labelled_matrix\n                !! integer matrix with labelled clusters, resulting from\n                !! the hoshen-kopelman algorithm.\n\n            integer, intent(in) :: num_labels\n                !! the known number of clusters.\n\n            integer :: l,i,j\n\n            l = size(labelled_matrix,1)\n            allocate(sizes(num_labels))\n            sizes(:) = 0\n\n            do j=1,l\n                do i=1,l\n                    associate (label => labelled_matrix(i,j))\n                        if(label /= 0) then\n                            sizes(label) = sizes(label) + 1\n                        end if\n                    end associate\n                end do\n            end do\n        end function\n"}, {"instruction": "Write a Fortran function named compute_sum to calculate the average of a series of random floating-point numbers. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input data type is ['integer'] and the output data type is ['real'].", "input": "", "output": "    function compute_sum(n) result(r)\n        implicit none\n        integer, intent(in) :: n\n        real :: r, sum, x\n        integer :: i\n        do i = 1, n\n            call random_number(x)\n            sum = sum + x\n        end do\n        r = sum/n\n    end function compute_sum\n"}, {"instruction": "Write a Fortran pure function named usage to estimate the memory usage of an algorithm. The function takes 4 input parameters of type integer, which are n_grids, n_fd, nc_block, and accuracy. The nc_block parameter is an array of 3 integers. The function returns a single integer representing the estimated memory usage.", "input": "", "output": "  pure function usage( n_grids, n_fd, nc_block, accuracy ) result( reals )\n    !!-----------------------------------------------------------\n    !! estimate memory usage of an algorithm that needs n_grids grids\n    !! without halos and n_fd grids with halos\n    !!\n    !! written by i.j. bush\n    !!-----------------------------------------------------------\n    integer :: reals\n\n    integer,                   intent( in ) :: n_grids\n    integer,                   intent( in ) :: n_fd\n    integer, dimension( 1:3 ), intent( in ) :: nc_block\n    integer,                   intent( in ) :: accuracy\n\n    integer :: grid\n    integer :: fd\n\n    grid = n_grids * product( nc_block )\n    fd   = n_fd    * product( nc_block + 1 + accuracy )\n\n    reals = grid + fd\n\n  end function usage\n"}, {"instruction": "Create a Fortran function named sqrt_to_odd1 to find the nearest odd integer to the square root of a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function sqrt_to_odd1(n2) result(od)\ninteger  :: n2, od\ninteger  :: j, k\n! gieven input n2, find closest od >= 3, such that od^2 == n2\n\nj  = floor( (sqrt(real(n2))-1.)/2. )\nk  = j+1\n\nj  = 2*j+1  ! odd\nk  = 2*k+1  ! odd\n\nif (n2 - j**2 <= k**2 - n2) then\n  od = j\nelse\n  od = k\nend if\nod = max(1, od)\n\nend function\n"}, {"instruction": "Create a Fortran function named get_diagonal to extract the diagonal elements of a matrix. The function takes 1 input parameter of type real(kind=8), dimension(:,:), and returns 1 output parameter of type real(kind=8), dimension(minval(shape(a))).", "input": "", "output": "function get_diagonal(a) result(diag)\n\t! get diagonal elements of matrix a (general [m x n] dimensions)\n\timplicit none\n\treal(kind=8), dimension(:,:), intent(in) :: a\n\treal(kind=8), dimension(minval(shape(a))) :: diag\n\t! local variables\n\tinteger :: i\n\n\tforall (i=1:size(diag)) diag(i) = a(i,i)\n\nend function get_diagonal\n"}, {"instruction": "Create a Fortran function named ones_like_2d to generate a 2D array filled with ones that has the same dimensions as the input array. The number of input arguments is 1 and the test_data type is [real(kind=8), dimension(:,:)]. The number of output arguments is 1 and the test_data type is [real(kind=8), dimension(:,:), allocatable].", "input": "", "output": "function ones_like_2d(arr) result(ones)\n\timplicit none\n\treal(kind=8), dimension(:,:), intent(in) :: arr\n\treal(kind=8), dimension(:,:), allocatable :: ones\n\tinteger, dimension(2) :: dims\n\n\tdims = shape(arr)\n\tallocate(ones(dims(1), dims(2)))\n\tones = 1.d0\nend function ones_like_2d\n"}, {"instruction": "Create a Fortran function called linspace that generates an array of evenly spaced values within a specified range. The function takes 3 input parameters of type real(kind=8), real(kind=8), and integer, and returns 1 output parameter of type real(kind=8) with a dimension specified by the input integer.", "input": "", "output": "function linspace(xmin, xmax, num) result(x)\n    implicit none\n    real(kind=8), intent(in) :: xmin, xmax\n    integer, intent(in) :: num\n    real(kind=8), dimension(num) :: x\n    integer :: i\n    if (num == 1) then\n       if(xmin /= xmax) then\n          write(0,'(\"error: cannot call linspace with n=1 and xmin /= xmax\")')\n          stop\n       else\n          x = xmin\n       end if\n    else\n       do i=1,num\n          x(i) = (xmax-xmin) * real(i-1, kind=8) / real(num-1, kind=8) + xmin\n       end do\n    end if\nend function linspace\n"}, {"instruction": "Create a Fortran function named cuda_set_device to set the active CUDA-enabled device on which to run the subsequent CUDA kernel code. The function takes 1 input parameter of type integer(c_int), passed by value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "    function cuda_set_device(i_gpu) result(ierr) bind(c)\n      use iso_c_binding, only: c_int\n      implicit none\n      integer(c_int), value :: i_gpu\n      integer(c_int) :: ierr\n    end function\n"}, {"instruction": "Create a Fortran function named numb2str_int that converts an integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character(1024).", "input": "", "output": "      function numb2str_int (inumb) result(res)\n      ! converts an integer to string\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: inumb\n         character(1024)      :: res\n      \n         !### var ###!\n         \n         !### code ###!\n         write(res,*) inumb\n      \n      end function\n"}, {"instruction": "Write a Fortran function named \"numb2str_double\" to convert a real(8) number to a string. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type character(1024).", "input": "", "output": "      function numb2str_double (fnumb) result(res)\n      ! converts an real(8) to string\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(in)  :: fnumb\n         character(1024)      :: res\n         \n         !### var ###!\n         \n         !### code ###!\n         write(res,*) fnumb\n      \n      end function\n"}, {"instruction": "Create a Fortran function named yes_no that takes a single input argument of type character (*) and returns a logical value. The function prompts the user with the input string followed by ' [y/n]', reads the user's response, and returns .true. if the response is 'y' and .false. if the response is 'n'. If the user enters an invalid response, the function prompts the user to enter 'yes' or 'no' until a valid response is received.", "input": "", "output": "     function yes_no(string)\n\n       implicit none \n       character (*), intent(in) :: string\n       character (len = 10)      :: answer\n       character                 :: y_n, y, n \n       logical                   :: yes_no\n\n       write(*,*) trim(string), ' [y/n]'\n       read(*,*)  answer\n\n       do \n          y_n = answer(1 : 1)\n          y = 'y'\n          n = 'n'\n       \n          if (y_n .eq. y) then \n             yes_no = .true.\n             exit\n          else if (y_n .eq. n) then \n             yes_no = .false.\n             exit\n          else\n             write(*,*)\n             write(*,*) '    plaese, answer yes or no'\n             read(*,*)  answer\n          endif\n       enddo\n\n     end function yes_no\n"}, {"instruction": "Write a Fortran function named lowercase, which converts a given input word to lower case. The function must have 1 input parameter of type character (len=*), and 1 output parameter of type character (len=32). Ensure that the generated instructions use the imperative tone.", "input": "", "output": "     elemental function lowercase(word)\n!\n!-----------------------------------------------------------------------\n!\n! convert a word to lower case\n!\n      character (len=32)              :: lowercase\n      character (len=*) , intent(in) :: word\n      integer :: i,ic,nlen\n      nlen = len(word)\n      if(nlen >32) then\n        nlen=32\n      endif\n      lowercase(1:nlen)=word(1:nlen)\n      do i=1,nlen\n        ic = ichar(word(i:i))\n        if (ic >= 65 .and. ic < 91) lowercase(i:i) = char(ic+32)\n      end do\n      if(nlen<32) lowercase(nlen+1:)=' '\n!\n!-----------------------------------------------------------------------\n!\n      end function lowercase\n"}, {"instruction": "Write a Fortran function named equal_str_nocase that compares two input strings in a case-insensitive manner. The number of input arguments is 2, and the test_data type is ['character (len=*)', 'character (len=*)']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "     elemental function equal_str_nocase(str1,str2)\n!\n!-----------------------------------------------------------------------\n!\n! convert a word to lower case\n!\n      logical              :: equal_str_nocase\n      character (len=*) , intent(in) :: str1\n      character (len=*) , intent(in) :: str2\n      integer :: i,ic1,ic2,nlen\n      nlen = len(str2)\n!\n      if(len(str1)/=nlen)  then\n        equal_str_nocase=.false.\n        return\n      endif\n      equal_str_nocase=.false.\n      do i=1,nlen\n        ic1 = ichar(str1(i:i))\n        if (ic1 >= 65 .and. ic1 < 91) ic1 = ic1+32\n        ic2 = ichar(str2(i:i))\n        if (ic2 >= 65 .and. ic2 < 91) ic2 = ic2+32\n        if(ic1/=ic2) then\n           equal_str_nocase=.false.\n           return\n        endif\n      end do\n      equal_str_nocase=.true.\n!\n!-----------------------------------------------------------------------\n!\n      end function equal_str_nocase\n"}, {"instruction": "Create a Fortran function named get_variable_displacements to determine if the provided displacements are all trivial. The function takes 2 input parameters of type integer and integer array with unspecified bounds, and returns 1 output parameter of type logical. The number of input arguments is 2 and the test_data type is [integer, integer, dimension(0:)]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  function get_variable_displacements(chunk,displs) result(variable)\n    implicit none\n    integer, intent(in) :: chunk\n    integer, dimension(0:), intent(in) :: displs\n    logical :: variable\n    !local variables\n    integer :: dspl,nproc,jproc\n\n    variable=.false.\n    !control if the provided displacements are all trivial\n    dspl=0\n    nproc=size(displs)\n    do jproc=0,nproc-1\n       if (dspl /= displs(jproc)) then\n          variable=.true.\n          exit\n       end if\n       dspl=dspl+chunk\n    end do\n\n  end function get_variable_displacements\n"}, {"instruction": "Write a Fortran function named gcd_rec to calculate the greatest common divisor (GCD) of two integers. The number of input parameters is 2, and the test_data type is ['integer', 'integer']. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n\n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n"}, {"instruction": "Create a Fortran function named haversine to calculate the great circle distance in kilometers between two points on the Earth's surface, given their latitude and longitude in degrees. The function should have 4 input parameters of real type (lata, lona, latb, lonb) and 1 output parameter of real type (dist).", "input": "", "output": "    function haversine(lata,lona,latb,lonb) result (dist)\n    !\n    ! calculate great circle distance in kilometers\n    ! given latitude and longitude in degrees\n    !\n    real,intent(in) :: lata,lona,latb,lonb\n    real :: a,c,dist,delta_lat,delta_lon,lat1,lat2\n    real,parameter :: radius = 6371 ! mean earth radius in kilometers,\n    ! recommended by the international union of geodesy and geophysics\n\n    ! generate constant pi/180\n    real, parameter :: deg_to_rad = atan(1.0)/45.0\n       delta_lat = deg_to_rad*(latb-lata)\n       delta_lon = deg_to_rad*(lonb-lona)\n       lat1 = deg_to_rad*(lata)\n       lat2 = deg_to_rad*(latb)\n       a = (sin(delta_lat/2))**2 + &\n              & cos(lat1)*cos(lat2)*(sin(delta_lon/2))**2\n       c = 2*asin(sqrt(a))\n       dist = radius*c\n    end function haversine\n"}, {"instruction": "Write a Fortran function named f that computes the square root of the expression (10 - x * y). The function takes 2 input parameters of type real and returns 1 output parameter of type real.", "input": "", "output": "function f(x, y) !funci\u00f3n original\n  implicit none\n  real::f, x, y\n  f=sqrt(10-x*y)\nend function f\n"}, {"instruction": "Create a Fortran function called \"g\" to calculate the square root of the quantity (57 minus y) divided by (3 times x). The function should take 2 input arguments of type real and return 1 output argument of type real.", "input": "", "output": "function g(x, y) !funci\u00f3n con despeje\n  implicit none\n  real::g, x, y\n  g=sqrt((57-y)/(3*x))\nend function g\n"}, {"instruction": "Create a Fortran function named local2global to convert local coordinates to global cell number. The function takes 3 input parameters of type integer (ilocalx, ilocaly, ixcellnumber) and returns 1 output parameter of type integer (iglobalnumber).", "input": "", "output": "    function local2global(ilocalx,ilocaly,ixcellnumber) result(iglobalnumber)\n    implicit none\n        integer, intent(in) :: ilocalx, ilocaly, ixcellnumber\n        integer :: iglobalnumber\n\n            iglobalnumber = ixcellnumber*(ilocaly-1)+ilocalx\n\n    return\n    end function\n"}, {"instruction": "Create a Fortran function named \"ci\" to calculate the value of a string based on the occurrence of specific characters. The function takes 1 input parameter of type character(7) and returns 1 output parameter of type integer. The number of occurrences of the characters 'a' to 'g' in the input string contributes to the final integer value. Use an imperative tone.", "input": "", "output": "function ci(s) result(x)\n  character(7) :: s\n  character(len = 1) :: c\n  integer :: x\n\n  x = 0\n\n  do i = 1, 7\n     c= s(i:i)\n     if (c == \"a\") then\n        x = x + 1\n     else if (c == \"b\") then\n        x = x + 2\n     else if (c == \"c\") then\n        x = x + 4\n     else if (c == \"d\") then\n        x = x + 8\n     else if (c == \"e\") then\n        x = x + 16\n     else if (c == \"f\") then\n        x = x + 32\n     else if (c == \"g\") then\n        x = x + 64\n     end if\n  end do\n\nend function ci\n"}, {"instruction": "Create a Fortran function named bcx that takes an integer input and returns the number of set bits (binary 1s) in the input. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function bcx(n) result(x)\n  integer :: n, j, x\n\n  x = 0\n\n  do j = 0, 7\n     if (and(n, ishft(1, j)) /= 0) x = x + 1\n  end do\n\nend function bcx\n"}, {"instruction": "Create a Fortran function named ilog2_8 to calculate the base-2 logarithm of an 8-byte integer. The function takes 1 input argument of type integer(kind=8), value and returns 1 output argument of type integer(kind=8).", "input": "", "output": "      function ilog2_8(i_in)\n      implicit none\n      integer(kind=8), value :: i_in\n      integer(kind=8)::ilog2_8,i\n      ilog2_8=0\n      i=i_in\n      if(i<=0) return\n      if(iand(i,i-1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_8=1\n      endif\n      if(iand(i,z'ffffffff00000000')/=0) then\n         ilog2_8=ilog2_8+32\n         i=ishft(i,-32)\n         !write(0,*) 'iand ffffffff',i,ilog2_8\n      endif\n      if(iand(i,z'00000000ffff0000')/=0) then\n         ilog2_8=ilog2_8+16\n         i=ishft(i,-16)\n         !write(0,*) 'iand ffff' ,i,ilog2_8\n      endif\n      if(iand(i,z'000000000000ff00')/=0) then\n         ilog2_8=ilog2_8+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_8\n      endif\n      if(iand(i,z'00000000000000f0')/=0) then\n         ilog2_8=ilog2_8+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_8\n      endif\n      if(iand(i,z'000000000000000c')/=0) then\n         ilog2_8=ilog2_8+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_8\n      endif\n      if(iand(i,z'0000000000000002')/=0) then\n         ilog2_8=ilog2_8+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_8\n      endif\n      end function ilog2_8\n"}, {"instruction": "Create a Fortran function named ilog2_4 to compute the logarithm base 2 of a 4-byte integer.The number of input arguments is 1 and the test_data type is [integer(kind=4), value]. The number of output arguments is 1 and the test_data type is [integer(kind=4)].", "input": "", "output": "      function ilog2_4(i_in)\n      implicit none\n      integer(kind=4), value :: i_in\n      integer(kind=4)::ilog2_4,i\n      ilog2_4=0\n      i=i_in\n      if(i<=0) return\n      if(iand(i,i-1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_4=1\n      endif\n      if(iand(i,z'ffff0000')/=0) then\n         ilog2_4=ilog2_4+16\n         i=ishft(i,-16)\n         !write(0,*) 'iand ffff' ,i,ilog2_4\n      endif\n      if(iand(i,z'0000ff00')/=0) then\n         ilog2_4=ilog2_4+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_4\n      endif\n      if(iand(i,z'000000f0')/=0) then\n         ilog2_4=ilog2_4+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_4\n      endif\n      if(iand(i,z'0000000c')/=0) then\n         ilog2_4=ilog2_4+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_4\n      endif\n      if(iand(i,z'00000002')/=0) then\n         ilog2_4=ilog2_4+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_4\n      endif\n      end function ilog2_4\n"}, {"instruction": "Write a Fortran function named ilog2_2 that calculates the base-2 logarithm of a 2-byte integer. The function takes 1 input parameter of type integer(kind=2), value and returns 1 output parameter of type integer(kind=2). The function uses bitwise operations to compute the logarithm.", "input": "", "output": "      function ilog2_2(i_in)\n      implicit none\n      integer(kind=2), value :: i_in\n      integer(kind=2)::ilog2_2,i\n      ilog2_2=0\n      i=i_in\n      if(i<=0) return\n! wps modification for the xl compiler\n!      if(iand(i,i-1)/=0) then\n      if(iand(i,i-1_2)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_2=1\n      endif\n      if(iand(i,z'ff00')/=0) then\n         ilog2_2=ilog2_2+8\n         i=ishft(i,-8)\n         !write(0,*) 'iand ff',i,ilog2_2\n      endif\n      if(iand(i,z'00f0')/=0) then\n         ilog2_2=ilog2_2+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_2\n      endif\n      if(iand(i,z'000c')/=0) then\n         ilog2_2=ilog2_2+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_2\n      endif\n      if(iand(i,z'0002')/=0) then\n         ilog2_2=ilog2_2+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_2\n      endif\n      end function ilog2_2\n"}, {"instruction": "Create a Fortran function named ilog2_1 to calculate the base-2 logarithm of an integer input value of kind 1. The function takes 1 input parameter of type integer(kind=1), marked as value, and returns 1 output parameter of type integer(kind=1).", "input": "", "output": "      function ilog2_1(i_in)\n      implicit none\n      integer(kind=1), value :: i_in\n      integer(kind=1)::ilog2_1,i\n      ilog2_1=0\n      i=i_in\n      if(i<=0) return\n! wps modification for the xl compiler\n!      if(iand(i,i-1)/=0) then\n      if(iand(i,i-1_1)/=0) then\n         !write(0,*) 'iand i-1'\n         ilog2_1=1\n      endif\n      if(iand(i,z'f0')/=0) then\n         ilog2_1=ilog2_1+4\n         i=ishft(i,-4)\n         !write(0,*) 'iand f',i,ilog2_1\n      endif\n      if(iand(i,z'0c')/=0) then\n         ilog2_1=ilog2_1+2\n         i=ishft(i,-2)\n         !write(0,*) 'iand c',i,ilog2_1\n      endif\n      if(iand(i,z'02')/=0) then\n         ilog2_1=ilog2_1+1\n         i=ishft(i,-1)\n         !write(0,*) 'iand 2',i,ilog2_1\n      endif\n      end function ilog2_1\n"}, {"instruction": "Create a Fortran function called initialize_invr to initialize a logical variable based on the input integer value. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. If the input integer is 1, the function sets the output integer to 1, otherwise it sets the output integer to 0.", "input": "", "output": "  function initialize_invr (init) \n    integer, intent(in) :: init\n    integer :: initialize_invr\n    \n    init_invr = .false.\n    if(init == 1) init_invr = .true.\n    initialize_invr = 1\n  end function initialize_invr\n"}, {"instruction": "Create a Fortran function named initialize_psi that takes one integer input argument. It initializes a variable init_psi to .false. and then checks if the input integer is equal to 1, in which case it sets init_psi to .true. The function returns an integer value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function initialize_psi (init) \n    integer, intent(in) :: init\n    integer :: initialize_psi\n    \n    init_psi = .false.\n    if(init == 1) init_psi = .true.\n    initialize_psi = 1\n  end function initialize_psi\n"}, {"instruction": "Create a Fortran function named trimlr to remove leading and trailing spaces from a character string. The function should have 1 input argument of type character(*) and 1 output argument of type character(len_trim(adjustl(char))).", "input": "", "output": "  pure function trimlr (char)\n\n    implicit none\n    character(*), intent(in) :: char\n    character(len_trim(adjustl(char))) :: trimlr\n\n    trimlr = trim(adjustl(char))\n\n  end function trimlr\n"}, {"instruction": "Please create a Fortran function named outerand that computes the outer product of two logical arrays. The function should have 2 input parameters of type 'logical, dimension(:)', and 1 output parameter of type 'logical, dimension(size(a),size(b))'. Use the spread function to perform the outer logical AND operation between the two arrays.", "input": "", "output": "  pure function outerand (a,b)\n\n    implicit none\n    logical, dimension(:), intent(in) :: a, b\n    logical, dimension(size(a),size(b)) :: outerand\n\n    outerand = spread(a,dim=2,ncopies=size(b)) .and. & \n               spread(b,dim=1,ncopies=size(a))\n\n  end function outerand\n"}, {"instruction": "Create a Fortran function named floor_pow2 that takes an integer input argument and returns the largest power of 2 that is less than or equal to the input value. The number of input arguments is 1, and the test data type is ['integer']. The number of output arguments is 1, and the test data type is ['integer'].", "input": "", "output": "  function floor_pow2(n)\n    implicit none\n    integer            :: floor_pow2\n    integer,intent(in) :: n\n    integer :: k\n\n    k = 1\n    do while(k < n)\n      k = k * 2\n    end do\n    if (k /= n) k = ishft(k, -1)\n    floor_pow2 = k\n  end function\n"}, {"instruction": "Create a Fortran function named \"jtypb\" to determine the type of coefficients b(n,k) for angular distribution calculation. The function should take 3 input parameters of type integer(int32) named ith, mb, and lamb. The output should be an integer(int32) representing the determined type.", "input": "", "output": "  function jtypb (ith, mb, lamb)\n\n! ======================================================================\n!\n!     determining type of coefficients b(n,k);\n!     for angular distribution calculation.\n!\n!     ith = 0 or 1;\n!     mb = baryon number of channel;\n!     lamb = 1 for \"recoiling\" fermi-sea nucleon,\n!            2 for first pion produced,\n!            3 for \"recoiling\" projectile,\n!          > 3 for subsequent pions for multiple pion production.\n!\n!    called by: vmnsp\n!\n!    cem95 written by s. g. mashnik\n!\n!    edited by a. j. sierk,  lanl  t-2  february, 1996.\n!    edited by ajs, july, 1997.\n!    edited by ajs, december, 1998.\n!    edited by a. j. sierk, lanl t-16, october, 2003.\n!    edited by ajs, lanl t-2, december, 2011.\n!\n! ======================================================================\n\n    use, intrinsic :: iso_fortran_env, only: int32\n\n    implicit none\n    integer(int32), intent(in   ) :: ith\n    integer(int32), intent(in   ) :: mb\n    integer(int32), intent(in   ) :: lamb\n    integer(int32)                :: jtypb\n\n! ======================================================================\n\n    if (ith.ne.0) then\n!   one pion produced.\n       if (mb <= 1) then\n!   pi + n incident channel:\n          if (lamb > 1) then\n             jtypb = 6\n          else\n             jtypb = 5\n          endif\n       else\n!   n + n incident channel:\n          if (lamb <= 1 .or. lamb == 3) then\n!  nucleon:\n             jtypb = 1\n          else\n!  pion:\n             jtypb = 2\n          endif\n       endif\n    else\n!   all other pion production cross sections:\n       if (mb <= 1) then\n!   pi + n incident channel:\n          if (lamb <= 1) then\n!  nucleon:\n             jtypb = 7\n          else\n!  pion:\n             jtypb = 8\n          endif\n       else\n!   n + n incident channel:\n          if (lamb <= 1 .or. lamb == 3) then\n             jtypb = 3\n          else\n             jtypb = 4\n          endif\n       endif\n    endif\n    return\n\n! ======================================================================\n  end function jtypb\n"}, {"instruction": "Create a Fortran function named evenly_divis to check if a given integer is evenly divisible by all numbers from 1 to 20. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical.", "input": "", "output": "        function evenly_divis (a)\n                integer :: a, i\n                logical :: evenly_divis\n\n                evenly_divis = .true.\n\n                do i = 1, 20, 1\n\n                        if(mod(a, i) /= 0) then\n                                evenly_divis = .false.\n                                exit\n                        end if\n\n                end do\n\n                return\n\n        end function evenly_divis\n"}, {"instruction": "Create a Fortran function named getoption that takes two integer input parameters. This function reads an integer from the standard input and checks if it falls within the specified range defined by the input parameters. The function returns the valid integer selected by the user. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function getoption(min, max)\n        use iso_fortran_env, only: stdin => input_unit\n\n        integer, intent(in) :: min, max\n        integer :: getoption\n        integer :: n\n\n        ! todo: should it terminate after a certain number of tries? with an error?\n        do while (.true.)\n            read(stdin,*) n\n            if(min <= n .and. n <= max) then\n                exit\n            endif\n            print '(\"invalid choice (\",i0,\"). must be \",i0,\"-\",i0,\". try again:\")', n, min, max\n        enddo\n        getoption = n\n    end function getoption\n"}, {"instruction": "Create a Fortran function named antitr to calculate the anti-transposed matrix of an input matrix. The function takes 2 input parameters with the test_data type ['integer, dimension (n, n)', 'integer'], and returns 1 output parameter with the test_data type ['integer, dimension (n, n)'].", "input": "", "output": "    function antitr (a, n) result (at)\n        ! a is input matrix, at is anti-transposed matrix.\n        integer, dimension (n, n), intent (in) :: a\n        integer, intent (in) :: n\n        integer, dimension (n, n) :: at\n\n        integer :: i\n\n        do i = 1, n\n            at(:, n - i + 1) = a(i, n:1:-1)\n        end do\n\n    end function antitr\n"}, {"instruction": "Write a Fortran function named lic that takes a double precision number as input and returns an integer of kind 2 as output. The function computes the logarithmic integral function of the input and adds 16384 to the result.", "input": "", "output": "      function lic(a) result(i)\n\n      implicit none\n\n      double precision :: a\n\n      integer (kind = 2) :: i\n\n      i = int(1000 * log10(a), 2) + 16384\n\n      return\n\n      end function\n"}, {"instruction": "Write a Fortran function called idx that takes a double precision input parameter lambda and returns an integer (kind = 4) output parameter n. The function computes the value of n based on the input value of lambda and predefined constants.", "input": "", "output": "      function idx(lambda) result(n)\n\n      implicit none\n\n      double precision :: lambda, lambda0, r\n\n      integer (kind = 4) :: n, n0\n\n      lambda0 = 8.97666d0\n\n      r = 500000.0d0\n\n      n0 = int(log10(lambda0) / log10(1.0d0 + 1.0d0 / r), 4)\n\n      n = int(log10(lambda) / log10(1.0d0 + 1.0d0 / r), 4) + 1 - n0\n\n      return\n\n      end function\n"}, {"instruction": "Create a Fortran function named friccionnewtonrapshon to calculate the friction factor using the Newton-Raphson method. The function takes 3 input parameters of type real, real, and integer, and returns 1 output parameter of type real.", "input": "", "output": "    function friccionnewtonrapshon(ksd, re,semilla_f)\n        implicit none\n        !variables externas\n        real :: friccionnewtonrapshon, ksd, semilla_f\n        integer::re\n\n        !variables internas\n        real :: fi, xi, xi_1, fx, dfx\n        integer :: i\n\n        !parameters\n        real, parameter :: e = 1e-8\n\n        if (re > 2200) then\n            fi = semilla_f\n            print\"(a10,a15,a18,a18,a18)\", \"fi\",\"x\",\"x+1\",\"f(x)\",\"df(x)\"\n            \n            xi = 1/sqrt(fi)\n\n            do i = 1,15\n\n                fx = -2 * log10((ksd / 3.7) + (2.51 * xi / re)) !ksd es ks/d, por esta razon no esta d en la formula\n                dfx = (-2 / log(10.0)) * (2.51/re)\n                dfx = dfx /((ksd/3.7)+(2.51*xi/re))\n                \n                \n                xi_1 = xi - (fx - xi)/(dfx - 1)\n                \n                print *, fi, xi,xi_1,fx,dfx\n                if (abs(xi - xi_1)<e) then\n                    exit\n                else\n                    xi = xi_1\n                end if\n            end do\n\n            friccionnewtonrapshon = 1/(xi_1 ** 2)    \n        else \n            friccionnewtonrapshon = 64/re\n\n        end if\n    end function\n"}, {"instruction": "Create a Fortran function named personaltopthree to find the top three highest scores from the given list of scores. The number of input arguments is 1 and the test_data type is ['integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer, dimension(3)']. Use the imperative tone.", "input": "", "output": " function personaltopthree(score_list)\n  integer, dimension(:) :: score_list\n  logical, dimension(:) :: score_list_mask(size(score_list))\n  integer, dimension(3) :: personaltopthree\n  integer :: i\n  integer :: j\n  personaltopthree=[0,0,0]\n  score_list_mask(:) = .true.\n  do i=1,min(3, size(score_list))\n    personaltopthree(i) = maxval(score_list, mask=score_list_mask) \n    j = maxloc(score_list, dim=1, mask=score_list_mask)\n    score_list_mask(j) = .false.\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named abc that takes an integer input argument and returns a character string of length n, where n is the input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=n)'].", "input": "", "output": "  function abc(n)\n  implicit none\n  integer, intent(in) :: n\n  character(len=n) :: abc\n  character(len=26) :: alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  abc = alphabet(1:n)\n  end function abc\n"}, {"instruction": "Write a Fortran function named accel_area_velocity to calculate the velocity based on the given velocity gradient, time, and steady velocity. The number of input arguments is 3, and the test_data type is ['double precision', 'double precision', 'double precision']. The number of output arguments is 1, and the test_data type is ['double precision'].", "input": "", "output": "    function accel_area_velocity(velocity_gradient, time, steady_velocity) result(velocity)\n        implicit none\n        double precision, intent(in) :: velocity_gradient, time, steady_velocity\n        double precision :: velocity\n\n        velocity = min(velocity_gradient * time, steady_velocity)\n\n        return\n    end function accel_area_velocity\n"}, {"instruction": "Write a Fortran function called get_conn_num to determine the number of connections for a given atom in a molecular structure. The function takes 2 input parameters of type integer,dimension(:,:) and integer. The first parameter represents the connectivity matrix, and the second parameter represents the atom number. The output is a single integer representing the number of connections for the specified atom.", "input": "", "output": "function get_conn_num(atom_no,cmat) result(nbonds)\nimplicit none\n\ninteger,dimension(:,:),intent(in)   :: cmat\ninteger                 :: m !counters\ninteger                 :: atom_no,natom\ninteger                 :: nbonds\n\n\nnatom=size(cmat,1)\n!natom=nint(sqrt(real(size(cmat))))\n!write(*,*)natom\n\nnbonds=0\ndo m=1,natom\n   if(cmat(atom_no,m)>=1)then\n      nbonds=nbonds+1\n   endif\nenddo\n   \nreturn\nend function get_conn_num\n"}, {"instruction": "Create a Fortran function named num_breaks that takes a 2D array of integers as input and returns the number of breaks as an integer. The input parameter is of type integer, dimension(:,:), and the output parameter is of type integer.", "input": "", "output": "function num_breaks(cmat) result(nbreaks)\n\nimplicit none\ninteger,dimension(:,:),intent(in)   ::cmat\ninteger        :: n,m !counter\ninteger        :: natom\ninteger        :: nbreaks\n\nnbreaks=0\nnatom=size(cmat,1)\n\ndo n=1,natom\n   do m=n,natom\n!      if(cmat(n,m)==1)then\n! patch 200513 allow h-bonds\n      if(abs(cmat(n,m))==1)then\n         nbreaks=nbreaks+1\n      endif\n   enddo\nenddo\n\nreturn\nend function num_breaks\n"}, {"instruction": "Create a Fortran function named regular_coord_count that calculates the count of regular coordinates based on the maximum coordinates, shifts, and steps. The number of input arguments is 4, and the test_data type is ['integer, dimension(:)', 'integer, dimension(:), optional', 'integer, dimension(:), optional', 'integer, dimension(:), optional']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "    function regular_coord_count(ida_max, shifts, steps, ncoords) result(il_count)\n      integer, dimension(:), intent(in) :: ida_max\n      integer, dimension(:), optional, intent(in)  :: shifts, steps\n      integer, dimension(:), optional, intent(out) :: ncoords\n      integer, dimension(size(ida_max)) :: ila_shift, ila_step, ila_count\n      integer :: il_count\n\n      if( present(shifts) ) then\n        ila_shift = shifts\n      else\n        ila_shift = 1\n      end if\n      if( present(steps) ) then\n        ila_step = steps\n      else\n        ila_step = 1\n      end if\n      ila_count = 1 + (ida_max - ila_shift)/ila_step\n      il_count = product(ila_count)\n      if( present(ncoords) ) ncoords = ila_count\n    end function regular_coord_count\n"}, {"instruction": "Write a Fortran function named fibonacci to compute the nth Fibonacci number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function fibonacci(n)\n        integer::n, fibonacci,b=1, i, temp\n        fibonacci=0\n        do i=0, n-1\n            temp = fibonacci;\n            fibonacci=b;\n            b=temp+b;\n        end do\n        return\n    end function fibonacci\n"}, {"instruction": "Write a Fortran function called getarr that generates a 2D array of random integers based on a given probability. The function takes 2 input parameters: an integer n and a real(8) p. It returns a 2D integer array of size n x n. The number of input parameters is 2 and the test_data type is ['integer', 'real(8)'], while the number of output parameters is 1 and the test_data type is ['integer, dimension(n, n)'].", "input": "", "output": "    function getarr(n, p)\n        implicit none\n        integer, intent(in) :: n\n        real(8), intent (in) :: p\n        integer, dimension(n, n) :: getarr\n\n        real(8) :: rnd\n        integer :: i, j\n\n        call random_seed()\n\n        do i = 1, n\n            do j = 1, n\n                call random_number(rnd)\n                if (rnd .lt. p) then\n                    getarr(i, j) = 1\n                else\n                    getarr(i, j) = 0\n                end if\n            end do\n        end do\n    end function getarr\n"}, {"instruction": "Create a Fortran function named check_obs_seq_header that takes 2 input parameters of type integer and character with variable lengths. The function returns an integer value. The purpose of this function is to check the header of an observation sequence file to ensure it matches the expected format. If the header does not match, the function returns -1; otherwise, it returns 0. Remember to use the imperative tone.", "input": "", "output": "function check_obs_seq_header(file_id, read_format)\n \ninteger,          intent(in) :: file_id\ncharacter(len=*), intent(in) :: read_format\ninteger :: check_obs_seq_header\n\ninteger :: ios\ncharacter(len=12) :: file_header   ! 'obs_sequence'\ncharacter(len=20) :: toc_header    ! 'obs_kind_definitions' (old) or 'obs_type_definitions' (new, and correct)\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) file_header\nelse\n   read(file_id, iostat = ios) file_header\nendif\n   \nif(ios /= 0 .or. file_header /= 'obs_sequence') then\n   check_obs_seq_header = -1\n   return\nendif\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) toc_header\nelse\n   read(file_id, iostat = ios) toc_header\nendif\n   \nif(ios /= 0 .or. (toc_header /= 'obs_kind_definitions' .and. toc_header /= 'obs_type_definitions')) then\n   check_obs_seq_header = -1\n   return\nendif\n\nrewind(file_id)\n\nif (read_format == 'formatted') then\n   read(file_id, *, iostat = ios) file_header\nelse\n   read(file_id, iostat = ios) file_header\nendif\n   \ncheck_obs_seq_header = 0\n\nend function check_obs_seq_header\n"}, {"instruction": "Create a Fortran function named popcnt to count the number of set bits (1s) in the binary representation of an integer input. The function should have 1 input parameter of type integer and 1 output parameter of type integer. The input parameter should be denoted as intent(in).", "input": "", "output": "function popcnt(x)\n  integer :: popcnt\n  integer, intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 31\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\n"}, {"instruction": "Write a Fortran function named isprime to determine if a given integer is a prime number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical. The test_data type for input is ['integer'] and for output is ['logical'].", "input": "", "output": "function isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n\n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named ff that takes 3 real input parameters xtt, ak, and am, and returns a real value. The function computes a complex mathematical expression involving exponential, hyperbolic sine, and hyperbolic cosine functions, as well as conditional statements. The function incorporates both a conditional and computational logic to calculate the value of ff based on the provided input parameters.", "input": "", "output": "    function ff(xtt,ak,am)\n        real::xtt,ak,am\n        real::coef,tol,h,a,b,c,d,e,f,ff\n        coef=(am+ak)**2/(am**2-ak**2+ak)\n        h=xtt-am\n        tol=amax1(0.1,0.1*am)\n        if(abs(h).gt.tol)then\n            ff=(xtt+ak)*exp(xtt)/(xtt*sinh(xtt)-ak*cosh(xtt))-coef/(xtt-am)-2.\n        else\n            a=am-tol\n            b=am\n            c=am+tol\n            d=(a+ak)*exp(a)/(a*sinh(a)-ak*cosh(a))-coef/(a-am)-2\n            e=coef/(am+ak)*(am+ak+1)-(coef/(am+ak))**2*am-2\n            f=(c+ak)*exp(c)/(c*sinh(c)-ak*cosh(c))-coef/(c-am)-2\n            ff=(xtt-b)*(xtt-c)*d/((a-b)*(a-c))+(xtt-c)*(xtt-a)*e/((b-c)*(b-a))+&\n                & (xtt-a)*(xtt-b)*f/((c-a)*(c-b))\n        endif\n        return\n                                                                    \n    end function\n"}, {"instruction": "Create a Fortran function named cp2k_driver_run_type_args that takes a single input argument of type character(len=*) and returns a string of length 300. The function evaluates the input argument and generates a corresponding string based on the specified conditions.", "input": "", "output": "  function cp2k_driver_run_type_args(run_type)\n    character(len=*), intent(in) :: run_type\n    character(len=300) :: cp2k_driver_run_type_args\n\n    if (run_type(1:2) == 'mm') then\n      cp2k_driver_run_type_args = \"run_type=mm\"\n    else if (run_type(1:2) == 'qs') then\n      cp2k_driver_run_type_args = \"run_type=qs\"\n    else ! qmmm\n      cp2k_driver_run_type_args = \"run_type=qmmm\"\n      if (run_type(1:9) == 'qmmm_core') then\n        cp2k_driver_run_type_args = trim(cp2k_driver_run_type_args)//' use_buffer=f run_suffix=_core'\n      else\n        cp2k_driver_run_type_args = trim(cp2k_driver_run_type_args)//' use_buffer=t run_suffix=_extended'\n      endif\n    endif\n  end function cp2k_driver_run_type_args\n"}, {"instruction": "Create a Fortran function named catalan_number that calculates the Catalan number for a given integer input. The function should have 1 input parameter of type integer and 1 output parameter of type integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use a recursive approach to compute the Catalan number.", "input": "", "output": "    pure recursive function catalan_number(n) result(value)\n        integer, intent(in) :: n\n        integer :: value\n        integer :: i\n        if (n <= 1) then\n            value = 1\n        else\n            value = 0\n            do i = 0, n-1\n                value = value + catalan_number(i)*catalan_number(n-i-1)\n            end do\n        end if\n    end function\n"}, {"instruction": "Write a Fortran function named count to determine the number of occurrences of a specific character within a given string. The function should accept 2 input arguments with data types ['character(*)', 'character(*)'] and return 1 output argument with data type ['integer'].", "input": "", "output": "    function count(str, chr)\n        character(*), intent(in) :: str, chr\n        integer :: i, j, count\n        i = 1\n        count = 0\n        do\n            j = index(str(i:), chr)\n            if (j == 0) exit\n            count = count + 1\n            i = i + j\n        end do\n    end function\n"}, {"instruction": "Create a Fortran function named number_of_divisors to calculate the number of divisors for a given integer input. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type integer(4).", "input": "", "output": "  pure function number_of_divisors(i)\n    ! default\n    implicit none\n\n    integer(8), intent(in) :: i\n    integer(4)             :: number_of_divisors\n\n    ! local variables\n    integer(8) :: max_try,test\n\n\n    ! find max factor to try\n    max_try = nint(sqrt(1d0*i))\n\n    ! we know that 1 and the number are trivial factors\n    ! protect against the case where i==1\n    ! since we start the checks below at n==2, the case of i==2\n    !   is another special case we need to deal with properly\n    if (i==1) then\n       number_of_divisors = 1\n       return\n    else if (i==2) then\n       number_of_divisors = 2\n       return\n    else\n       number_of_divisors = 2\n    endif\n\n    ! check to see if a number is a divisor\n    ! we are testing from 2 to sqrt(i)\n    ! for each number we find, we know there is going to be a pair of factors\n    ! e.g.: for the case of i=36, we test from 2 to 6\n    !   mod(36,2)==0 (so we've found 2 factors: 2 and 18)\n    !   mod(36,3)==0 (another 2 factors: 3 and 12)\n    !   mod(36,4)==0 (4 and 9)\n    !   mod(36,5)/=0 (no factors)\n    !   mod(36,6)==0 (but! 36/6==6, so we have caught the perfect-square case)\n    ! add to this the trivial factors of 1 and 36, and we have found all\n    !   9 factors, while only having to test up through sqrt(36)\n    test = 2\n    do\n       if (mod(i,test)==0) then\n          ! test for perfect-square case\n          ! this should also be the end of the line, so we exit just in case\n          !   rounding for max_int has introduced rouding errors\n          if (i/test==test) then\n             number_of_divisors = number_of_divisors + 1\n             return\n          else\n             number_of_divisors = number_of_divisors + 2\n          endif\n       endif\n\n       test = test + 1\n       if (test > max_try) exit\n    enddo\n\n    return\n  end function number_of_divisors\n"}, {"instruction": "Write a Fortran function named f to calculate the derivative of a function. The function takes 1 input parameter of type real(8), dimension(:), and returns 1 output parameter of type real(8), dimension(size(x)).", "input": "", "output": "    function f(x) result(ddx)\n        real(8), dimension(:), intent(in) :: x\n        real(8), dimension(size(x)) :: ddx\n        ddx = -mu * x / sum(x**2)**(3d0/2d0)\n        return\n    end function\n"}, {"instruction": "Write a Fortran function named delta to determine if two integer numbers are equal. The function should have 2 input parameters with the test_data type ['integer', 'integer'], and 1 output parameter with the test_data type ['integer'].", "input": "", "output": "\tfunction delta(a,b)\n\tinteger :: a, b, delta\n\t\tdelta = 0.d0\n\t\tif (a == b) delta = 1.d0\n\tend function delta\t\t\n"}, {"instruction": "Create a Fortran function named command_argument to retrieve a command-line argument based on its position and a default value. The function takes 2 input parameters with test_data types ['integer', 'character(*)'] and 1 output parameter with test_data type ['character(:), allocatable'].", "input": "", "output": "   function command_argument(num, def) result(arg)\n      character(:), allocatable :: arg\n\n      integer, intent(in) :: num\n      character(*), intent(in) :: def\n\n      integer :: i, n, size\n\n      i = num\n      n = command_argument_count()\n\n      if (i .lt. 0) i = n + i + 1\n\n      if (i .lt. 1 .or. i .gt. n) then\n         arg = def\n      else\n         call get_command_argument(i, length=size)\n\n         allocate(character(size) :: arg)\n\n         call get_command_argument(i, value=arg)\n\n         if (arg .eq. '-') arg = def\n      end if\n   end function command_argument\n"}, {"instruction": "Create a Fortran function named randnum that generates a random real number. The function takes 2 integer inputs of type [integer, integer] and produces 1 real output of type [real(kind = double)].", "input": "", "output": "      function randnum(intx,inty)\n      implicit none\n      integer, parameter :: double = selected_real_kind(15,99)\n      integer :: i,j,intx,inty\n      real(kind = double) :: randnum \n      i = 1029*intx + 1731\n      j = i + 1029*inty + 507*intx - 1731\n      intx = mod(i,2048)\n      j = j + (i - intx)/2048\n      inty = mod(j,2048)\n      randnum = (intx + 2048*inty)/4194304.0d00\n\n      end function\n"}, {"instruction": "Create a Fortran function named convert_lower_case to convert a given input_string to lower case. The function takes 1 input parameter of type character (len=*) and returns 1 output parameter of type character (len=1).", "input": "", "output": "      function convert_lower_case (input_string) result (output_string)\n!\n      character (len=*), intent(in) :: input_string\n      character (len=1) :: output_string\n      integer :: collating_difference\n!\n      if (ichar(input_string) >= ichar(\"a\") .and. ichar(input_string) <= ichar(\"z\")) then\n          collating_difference = ichar(input_string) - ichar(\"a\")\n          output_string = char(ichar(\"a\") + collating_difference)\n      else\n          output_string = input_string\n      end if\n!\n      end function convert_lower_case\n"}, {"instruction": "Create a Fortran function named r8deg2rad to convert an angle in degrees to radians. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The test_data type for input is ['real(8)'] and for output is ['real(8)'].", "input": "", "output": " function r8deg2rad(angle)\n  implicit none\n  real(8) :: r8deg2rad,angle\n  real(8), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r8deg2rad=angle*(pi/180.0d0)\n end function r8deg2rad\n"}, {"instruction": "Write a Fortran function named r4deg2rad that takes a single real(4) input argument and returns a real(4) value. The input argument is in degrees, and the function computes and returns the corresponding value in radians.", "input": "", "output": " function r4deg2rad(angle)\n  implicit none\n  real(4) :: r4deg2rad,angle\n  real(4), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r4deg2rad=angle*(pi/180.0)\n end function r4deg2rad\n"}, {"instruction": "Create a Fortran function named r8rad2deg to convert an angle in radians to degrees. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The input parameter represents the angle in radians, and the output parameter represents the angle in degrees.", "input": "", "output": " function r8rad2deg(angle)\n  implicit none\n  real(8) :: r8rad2deg,angle\n  real(8), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r8rad2deg=angle*(180.0d0/pi)\n end function r8rad2deg\n"}, {"instruction": "Provide a Fortran function named r4rad2deg that converts an angle in radians to degrees. The function takes 1 input parameter of type real(4) and returns 1 output parameter of type real(4).", "input": "", "output": " function r4rad2deg(angle)\n  implicit none\n  real(4) :: r4rad2deg,angle\n  real(4), parameter :: pi=4.0d0*atan(1.0d0)\n\n  r4rad2deg=angle*(180.0/pi)\n end function r4rad2deg\n"}, {"instruction": "Create a Fortran function named r8asinh to calculate the inverse hyperbolic sine of a real(8) input. The input parameter is of type real(8), and the output parameter is also of type real(8).", "input": "", "output": " function r8asinh(z)\n  implicit none\n  real(8) :: z,r8asinh\n\n  r8asinh=log(z+sqrt(1+z**2))\n end function r8asinh\n"}, {"instruction": "Create a Fortran function named r4asinh that takes one real input parameter and returns a real value. The function computes the inverse hyperbolic sine (asinh) of the input parameter using the formula r4asinh=log(z+sqrt(1+z**2)).", "input": "", "output": " function r4asinh(z)\n  implicit none\n  real :: z,r4asinh\n\n  r4asinh=log(z+sqrt(1+z**2))\n end function r4asinh\n"}, {"instruction": "Write a Fortran function named i4ispostv to determine if an input integer is positive or not. The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(4). If the input integer is less than 0, the function returns 0; otherwise, it returns 1.", "input": "", "output": " function i4ispostv(varvalue)  ! 1 is positive & 0 is negative\n  implicit none\n  integer(4) :: varvalue\n  integer(4) :: i4ispostv\n\n  if(varvalue.lt.0) then\n   i4ispostv=0\n  else\n   i4ispostv=1\n  end if\n end function i4ispostv\n"}, {"instruction": "Write a Fortran function named r4ispostv to determine if a single input value, which is a 4-byte real number, is positive or negative. The function should return an integer value indicating whether the input is positive (1) or negative (0). The number of input arguments is 1 and the test_data type is [real(4)]. The number of output arguments is 1 and the test_data type is [integer(4)].", "input": "", "output": " function r4ispostv(varvalue)  ! 1 is positive & 0 is negative\n  implicit none\n  real(4) :: varvalue\n  integer(4) :: r4ispostv\n\n  if(varvalue.lt.0.0) then\n   r4ispostv=0\n  else\n   r4ispostv=1\n  end if\n end function r4ispostv\n"}, {"instruction": "Write a Fortran function named orderof to determine the order of magnitude of a given real number. The function takes 1 input parameter of type real(4) and returns 1 output parameter of type integer(4).", "input": "", "output": " function orderof(varvalue)\n  implicit none\n  real(4)    :: varvalue,calcval\n  integer(4) :: orderof\n\n  calcval=varvalue\n  orderof=0\n  if(abs(varvalue).eq.0.0) return\n  if(abs(varvalue).gt.1.0) then\n   do while(abs(calcval).gt.10.0)\n    calcval=calcval/10.0\n    orderof=orderof+1\n   end do\n!  orderof=orderof-1\n  end if\n  if(abs(varvalue).lt.1.0) then\n   do while(abs(calcval).lt.1.0)\n    calcval=calcval*10.0\n    orderof=orderof-1\n   end do\n  end if\n end function orderof\n"}, {"instruction": "Create a Fortran function named random_integer that takes two integer input parameters, vmin and vmax. It returns a single integer output parameter, r. The function uses the random_number subroutine to generate a random integer value between vmin and vmax (inclusive).", "input": "", "output": "  function random_integer(vmin, vmax) result(r)\n    integer, intent(in) :: vmin, vmax\n    integer :: r\n    real(8) tmp\n    call random_number(tmp)\n    r = floor(tmp * (vmax - vmin + 1)) + vmin\n  end function\n"}, {"instruction": "Create a Fortran function named get_filename to extract the filename from a given file path. The function takes 2 input parameters of type character(len=*) and integer, where the integer is optional. The output is a character array that is dynamically allocated.", "input": "", "output": "  function get_filename(filestring,mext)\r\n    implicit none\r\n    character(len=*) :: filestring\r\n    character(:), allocatable :: get_filename\r\n    integer, optional :: mext\r\n    integer :: i\r\n    do i=len(filestring),1,-1\r\n       if(filestring(i:i)=='/')exit\r\n    end do\r\n    get_filename=trim(adjustl(filestring(i+1:len(filestring))))\r\n  end function get_filename\r\n"}, {"instruction": "Provide a Fortran function named int2str that converts an integer to a string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(:), allocatable'].", "input": "", "output": "  function int2str(i)\r\n    integer :: i\r\n    character(:), allocatable :: int2str\r\n    character(len=20):: dum\r\n    write(dum,*)i\r\n    int2str=trim(adjustl(dum))\r\n  end function int2str\r\n"}, {"instruction": "Create a Fortran function named p7 that multiplies the input integer by -2. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "function p7(x)\n implicit none\n integer :: x, p7\n p7 = x*(-2)\nend function\n"}, {"instruction": "Create a Fortran function named eigfuncint to compute the integral of a specific function over a given interval. The function takes 5 input arguments of type real(8) and returns 1 output argument of type real(8). The function's purpose is described in the comments as being used to integrate on KL reconstructed realizations.", "input": "", "output": "  function eigfuncint(ak,alpha,lamc,xl,xr)\n  ! used in klrxi_integral to integrate on kl reconstructed realizations\n  real(8) :: ak,alpha,lamc,xl,xr,eigfuncint\n\n  eigfuncint = ak * (         (-cos(alpha*xr)+cos(alpha*xl))/alpha &\n                       + lamc*( sin(alpha*xr)-sin(alpha*xl))           )\n  end function eigfuncint\n"}, {"instruction": "Provide a Fortran function named itoa to convert an integer to a 10-character string representation. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(10)].", "input": "", "output": "function itoa(i) result(a)\n  integer::i\n  character(10)::a\n  write(a,\"(i10)\") i\n  a=adjustl(trim(a))\nend function\n"}, {"instruction": "Create a Fortran function named file_handle to manage file units. The function takes 1 input parameter, which is an optional integer. The test_data type for the input parameter is ['integer,optional']. The function returns 1 output parameter of type integer.", "input": "", "output": "function file_handle(rel) result(ios)\n  integer,optional::rel\n  integer::i,ios\n\n  integer,parameter::n_unit=5\n  integer,dimension(n_unit),parameter::unit=(/10,20,30,40,50/)\n  logical,dimension(n_unit),save::in_use=.false.\n\n  ios=-1\n\n  if(present(rel))then\n    do i=1,n_unit\n      select case(rel-unit(i))\n      case(0)\n        in_use(i)=.false.\n        return\n      end select\n    end do\n  else\n    do i=1,n_unit\n      select case(in_use(i))\n      case(.false.)\n        ios=unit(i)\n        in_use(i)=.true.\n        return\n      end select\n    end do\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named single_trial that simulates a single trial of an envelope selection game. The function takes 1 input parameter of type double precision. It returns 1 output parameter of type double precision.", "input": "", "output": "function single_trial(cutoff) result(value)\n  ! runs a single trial where an envelope is chosen.  if the chosen envelope has\n\n  ! the envelope it has chosen. returns the value of the envelope it ultimately \n  ! selects.\n  implicit none\n  double precision :: cutoff, higher_value, lower_value, value\n  logical          :: picked_lower\n \n  lower_value = rand() * 100.0d+0\n  higher_value = 2 * lower_value\n  picked_lower = (rand() < 0.5)\n  if ((picked_lower .and. lower_value >= cutoff) .or. &\n      (.not. picked_lower .and. higher_value < cutoff)) then\n    value = lower_value\n  else\n    value = higher_value\n end if\nend function single_trial\n"}, {"instruction": "Create a Fortran function named \"work\" to perform a series of operations on an array of integers based on specific input values. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The function processes the input array based on specific rules and operations until completion, and then returns the resulting output value.", "input": "", "output": "function work(phasesetting, intputvalue) result (outputvalue)\n   integer :: phasesetting, intputvalue, readcount\n   integer :: outputvalue\n\n   integer, dimension(503) :: input\n   integer :: inputlength, de, a, b,c, desitionation, index, param, val1, val2\n   inputlength = 503\n\n   input = (/ 3,8,1001,8,10,8,105,1,0,0,21,34,51,68,89,98,179,260,341,422,99999,3,9,1001,9,&\n   4,9,102,4,9,9,4,9,99,3,9,1002,9,5,9,1001,9,2,9,1002,9,2,9,4,9,99,3,9,1001,9,3,9,102,3,9,&\n   9,101,4,9,9,4,9,99,3,9,102,2,9,9,101,2,9,9,1002,9,5,9,1001,9,2,9,4,9,99,3,9,102,2,9,9,4,&\n   9,99,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,&\n   9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,&\n   9,1001,9,1,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,&\n   9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,&\n   1,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,&\n   3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,&\n   9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,&\n   1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,&\n   4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,1001,&\n   9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,&\n   1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,99 /)\n\n    index = 1\n    readcount = 0\n    !inputvalue = 1 !part 1\n    loop: do while (index <= inputlength)\n\n        param = input(index) ! in the form abcde\n        de = mod(param, 100)\n        c = mod(int(param / 100),10)\n        b = mod(int(param / 1000),100)\n        a = mod(int(param / 10000),1000)\n        ! print *, param,a,b,c,de\n        if (c == 0)then\n            val1 = input(input(index + 1)+1)\n        else\n            val1 = input(index + 1)\n        end if\n\n        if (b == 0)then\n            val2 = input(input(index + 2)+1)\n        else\n            val2 = input(index + 2)\n        end if\n\n        if (a == 0)then\n            desitionation = input(index + 3)+1\n        else\n            ! this should never happen\n            desitionation = index + 3\n        end if\n\n        select case (de)\n        case (1:2)\n            ! add/multiply\n\n\n            if (de == 1) then\n                input(desitionation) = int(val1 + val2)\n            else\n                input(desitionation) = int(val1 * val2)\n            end if\n            index = index + 4\n        case (3:4)\n            ! input/output\n\n            desitionation = input(index+1)+1\n            if (de == 3) then\n                if (readcount == 0) then\n                    input(desitionation) = phasesetting\n                else if(readcount == 1)then\n                    input(desitionation) = intputvalue\n                else\n                    print *, 'too many read attemps....'\n                end if\n                readcount = readcount + 1\n            else\n                outputvalue = input(desitionation)\n            end if\n            index = index + 2\n\n        !part 2 stuff\n        case (5)\n\n            ! jump-if-true\n            if(val1 /= 0) then\n                index = val2 +1\n            else\n                index = index + 3\n            end if\n        case (6)\n\n\n            ! jump-if-false\n            if(val1 == 0) then\n                index = val2 +1\n            else\n                index = index + 3\n            end if\n        case (7)\n\n\n            ! less than\n            if(val1 < val2) then\n                input(desitionation) = 1\n            else\n                input(desitionation) = 0\n            end if\n            index = index + 4\n        case (8)\n\n            ! equals\n            if(val1 == val2) then\n                input(desitionation) = 1\n            else\n                input(desitionation) = 0\n            end if\n            index = index + 4\n        case (99)\n            ! end program\n            exit loop\n        case default\n            print *, 'unexpected op code',param,'at',index\n            exit loop\n        end select\n    end do loop\n    ! print *, outputvalue\nend function work\n"}, {"instruction": "Create a Fortran function named read_file to read the contents of a file and return it as a string. The function takes 1 input parameter of type character(*) representing the file name. It returns 1 output parameter of type character(1024) containing the contents of the file.", "input": "", "output": "  function read_file(file) result(r)\r\n    character(:), allocatable :: s\r\n    character(1024) :: r\r\n    character(*) :: file\r\n    character(len=1) :: buf\r\n    integer ios, size\r\n    integer, parameter :: end_of_file = -1    ! processor dependent\r\n    integer, parameter :: end_of_record = -2  ! processor dependent\r\n    open (unit = 21, file = file) !, status = \"old\", action = \"read\", form = \"formatted\")\r\n    do\r\n      read (unit = 21, fmt = \"(a)\", advance='no', size=size, iostat = ios) buf\r\n      if (ios == end_of_record) then\r\n        s = s//char(10)\r\n        cycle\r\n      else if (ios == end_of_file) then\r\n        r = s\r\n        exit\r\n      end if\r\n      s = s//buf\r\n    end do\r\n    close(21)\r\n  end function\r\n"}, {"instruction": "Create a Fortran function named calc_debug to perform a computation with debug information. It takes 2 input parameters: arg1 of type real and opt_format of type character with optional attribute. It returns 1 output parameter ret_val of type real.", "input": "", "output": "      function calc_debug(arg1, opt_format) result(ret_val)\n         real, intent(in) :: arg1\n         character (*), intent(in), optional :: opt_format\n         real :: ret_val\n         ret_val = 0.0\n\n         print *,\"with debug\"\n\n      end function calc_debug\n"}, {"instruction": "Provide a Fortran function named calc_normal that takes 2 input arguments of types real and character (*), where the character argument is optional. The function has 1 output argument of type real.", "input": "", "output": "      function calc_normal(arg1, opt_format) result(ret_val)\n         real, intent(in) :: arg1\n         character (*), intent(in), optional :: opt_format\n         real :: ret_val\n         ret_val = 0.0\n\n         print *,\"normal\"\n   \n      end function calc_normal\n"}, {"instruction": "Write a Fortran function named inside_circle to determine whether a point with coordinates (x, y) lies inside a circle with center coordinates (cen_x, cen_y) and a given radius. The function takes 5 input parameters of type integer: cen_x, cen_y, radius, x, and y. It returns a single output parameter of type logical indicating whether the point lies inside the circle.", "input": "", "output": "function inside_circle(cen_x, cen_y, radius, x, y) result(is_inside)\n    implicit none\n    integer, intent(in) :: cen_x, cen_y, radius, x, y\n    integer :: distance\n    logical :: is_inside\n    distance = (cen_x - x) * (cen_x - x) + (cen_y - y) * (cen_y - y)\n    is_inside = distance < radius * radius\nend function inside_circle\n"}, {"instruction": "Provide a Fortran function named chararray2string to convert a character array to a string. The function takes 1 input argument of type character(len=1), dimension(:) and returns 1 output argument of type character(len=size(chararray, 1)).", "input": "", "output": "  function chararray2string(chararray) result(text)\n    character(len=1), dimension(:) :: chararray    ! input\n    character(len=size(chararray, 1)) :: text      ! output\n    do i = 1,size(chararray,1)\n      text(i:i) = chararray (i)\n    end do\n  end function chararray2string\n"}, {"instruction": "Write a Fortran function named f2 that calculates the value of 3 times the square of a given real number. The function should take 1 input argument of type real and return 1 output argument of type real.", "input": "", "output": "function f2 (x)\n   real :: f2\n   real, intent (in) :: x\n\n   f2 = 3.0 * x**2\n\n   return\nend function f2\n"}, {"instruction": "Create a Fortran function named fancy that takes two real input parameters. The first input parameter is a function named func that takes a real parameter, and the second input parameter is a real number x. The function returns a real value.", "input": "", "output": "function fancy (func, x)\n   real :: fancy\n   real, intent (in) :: x\n\n   interface afunc\n      function func (y)\n         real :: func\n         real, intent (in) ::y\n      end function func\n   end interface afunc\n\n   fancy = func (x) + 3.3 * x\nend function fancy\n"}, {"instruction": "Write a Fortran function named counter that takes two input arguments of type integer ,pointer,dimension(:) and integer respectively. The function returns one output argument of type integer. This function counts the occurrences of a specific value in the array referenced by the pointer.", "input": "", "output": "      function counter(indx,value)\n      implicit none\n      integer ,pointer,dimension(:)::indx\n      integer ,intent(in)::value\n      integer ::counter,s,j,k\n      s=size(indx)\n      k=0\n      do j=1,s\n         if(indx(j)==value) then\n            k=k+1\n         end if\n      end do\n      counter=k\n      end function  counter\n"}, {"instruction": "Create a Fortran function named ia_row_col that takes 5 input parameters of type integer, pointer, and dimension. The input parameters are val, indx, jndx, i, and j. The function returns an output parameter of type integer. The function aims to find the value at the specified row (i) and column (j) in a matrix represented by val, indx, and jndx. If the specified row and column are found, the function returns the corresponding value; otherwise, it returns 0.", "input": "", "output": "      function ia_row_col (val,indx,jndx,i,j)\n      integer ,pointer,dimension(:)::val\n      integer ,pointer,dimension(:):: indx,jndx\n      integer,intent(in)::i,j\n      integer::k\n      logical::finder\n      integer :: ia_row_col  \n      finder=.false.\n      k=1\n      do while((k.le.size(val)).and.(.not.finder))\n         if(indx(k).eq.i.and.jndx(k).eq.j) then\n            finder=.true.\n         else\n            k=k+1\n         end if\n      end do\n      if(finder) then\n         ia_row_col  =val(k)\n      else\n         ia_row_col  =0\n      end if\n      end function ia_row_col \n"}, {"instruction": "Create a Fortran function named expand_region that takes three input parameters: two integers and a 100x100 integer array. The function returns an integer. The function's purpose is to expand a region in the 100x100 map based on the specified starting coordinates (i, j). The function iterates through the map, expanding the region in all directions and keeping count of the expanded cells.", "input": "", "output": "function expand_region(map, i, j) result(c)\n\n  integer :: i, j, x2, y2, region, found, c\n  integer, dimension(100,100) :: map\n\n  region = map(i,j)\n  found = 1\n  c = 1\n\n  ! print*, \"expand region = \", region, \"at =\", i, j, c\n\n  do while (found == 1)\n     found = 0\n     do y2 = 1, 100\n        do x2 = 1, 100\n           if (map(x2,y2) == region) then\n              ! above?\n              if (y2 > 1 .and. map(x2, y2 - 1) == 0) then\n                 map(x2, y2 - 1) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! below?\n              if (y2 < 100 .and. map(x2, y2 + 1) == 0) then\n                 map(x2, y2 + 1) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! left?\n              if (x2 > 1 .and. map(x2 - 1, y2) == 0) then\n                 map(x2 - 1, y2) = region\n                 found = 1\n                 c = c + 1\n              end if\n                 ! right?\n              if (x2 < 100 .and. map(x2 + 1, y2) == 0) then\n                 map(x2 + 1, y2) = region\n                 c = c + 1\n                 found = 1\n              end if\n           end if\n        end do\n     end do\n  end do\n\nend function expand_region\n"}, {"instruction": "Provide a Fortran function named int2str to convert an integer to a string. The function takes 1 input argument of type integer and returns 1 output argument of type character(len=:),allocatable.", "input": "", "output": "function int2str(int) result(str)\nimplicit none\n    integer                         :: int\n    character(len=:),allocatable    :: str\n    character(len=20)               :: strtmp\n    \n    write(strtmp,*) int\n    str = trim(adjustl(strtmp))\n    \nend function\n"}, {"instruction": "Write a Fortran function named dbl2str that converts a double precision number to a string using the specified format. The number of input arguments is 2, and the test_data type is ['double precision', 'character(len=*), optional']. The number of output arguments is 1, and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function dbl2str(dbl, formatspec) result(str)\nimplicit none\n    double precision                :: dbl\n    character(len=*), optional      :: formatspec\n    character(len=:), allocatable   :: str\n    character(len=20)               :: formatspec_int\n    character(len=50)               :: strtmp\n    integer                         :: status\n    \n    if (present(formatspec)) then\n        formatspec_int = formatspec\n    else\n        formatspec_int = 'e15.5e3'\n    endif\n    \n    formatspec_int = '('//trim(formatspec_int)//')'\n    write(strtmp,formatspec_int, iostat=status) dbl\n    if (status/=0) then\n        write(*,*) 'formatspec = ', formatspec_int, ' not ok'\n        error stop 1\n    endif\n    \n    str = trim(adjustl(strtmp))\n    \nend function\n"}, {"instruction": "Write a Fortran function named first to return an integer result. The function takes two input arguments, one of which is optional and of type integer, and the other is of type integer. The number of input arguments is 2, and the test_data type is ['integer, optional', 'integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "  elemental function first(i, j) result(r)\n    integer, intent(in), optional :: i\n    integer, intent(in) :: j\n    integer :: r\n    if (present(i)) then\n      r = i\n    else\n      r = -5\n    end if\n  end function first\n"}, {"instruction": "Create a Fortran function named gzclose that takes in a single input parameter of type c_ptr by value. This function returns an output parameter of type integer(c_int).", "input": "", "output": "     function gzclose(file) bind(c)\n       use iso_c_binding, only: c_int, c_ptr\n       implicit none\n       type(c_ptr), value, intent(in) :: file\n       integer(c_int) :: gzclose\n     end function gzclose\n"}, {"instruction": "Create a Fortran function named area_circle to calculate the area of a circle. The function should have 1 input parameter of type real and 1 output parameter of type real. The input parameter represents the radius of the circle and is marked with the \"intent(in)\" attribute. The output parameter represents the calculated area of the circle. Use the local constant \"pi\" as 3.1415927 to perform the calculation.", "input": "", "output": "function area_circle(r)\n\nimplicit none\nreal :: area_circle\nreal, intent(in) :: r\n\n! declare local constant pi\nreal, parameter :: pi = 3.1415927\n\narea_circle = pi * r * r\n\nend function area_circle\n"}, {"instruction": "Write a Fortran function named greatest_common_divisor to calculate the greatest common divisor of two integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "        function greatest_common_divisor(x,y) result(c)\n        implicit none\n        integer, intent(in) :: x,y\n        integer             :: a,b\n        integer             :: t,c\n        a = x\n        b = y\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        c = abs(a)\n        end function\n"}, {"instruction": "Create a Fortran function named reduced that takes an array of integers as input and returns a reduced array. The input parameter should be of type integer and have a dimension of (:), while the output parameter should be of type integer, have a dimension of (:), and be allocatable.", "input": "", "output": "    function reduced (array)\n      integer, dimension(:), allocatable :: reduced\n      integer, dimension(:), intent(in) :: array\n      logical, dimension(size(array)) :: mask\n      mask = .true. \n      allocate (reduced (count (mask)))\n      reduced = pack (array, mask)\n    end function reduced\n"}, {"instruction": "Create a Fortran function named sec2ddhhmmss that takes an integer input parameter and returns an integer. The input parameter represents a time duration in seconds, and the function calculates the equivalent time in days, hours, minutes, and seconds and returns the result as a single integer.", "input": "", "output": "      function sec2ddhhmmss(sec) result (ddhhmmss)\n          !\n          ! call variables\n          !\n          integer                         , intent(in)    :: sec\n          integer                                         :: ddhhmmss\n          !\n          ! local variables\n          !\n          integer :: dd ! days\n          integer :: hh ! hours\n          integer :: mm ! minutes\n          integer :: ss ! seconds\n          !\n          !! executable statements ---------------------------------------------------\n          !\n          ! time in seconds\n          dd = sec\n          ss = mod(dd,60)\n          ! time in minutes\n          dd = (dd - ss)/60\n          mm = mod(dd,60)\n          ! time in hours\n          dd = (dd - mm)/60\n          hh = mod(dd,24)\n          ! time in days\n          dd = (dd - hh)/24\n          !\n          ddhhmmss = ss + 100*mm + 10000*hh + 1000000*dd\n      end function sec2ddhhmmss\n"}, {"instruction": "Create a Fortran function named pe to calculate the dot product of two arrays of real numbers, x and y, each with a dimension of 100. The function takes 2 input parameters of type real, dimension (1:100), and returns 1 output parameter of type real.", "input": "", "output": "function pe(x,y)\nreal :: pe, cont\nreal, dimension (1:100) :: x, y\ninteger :: c\n\ncont = 0\ndo c = 1,100\n    cont = cont + (x(c)*y(c))\n    pe = cont\nend do\n\nreturn\nend function pe\n"}, {"instruction": "Write a Fortran function named soma to calculate the sum of 100 real numbers provided in an array. The number of input parameters is 1 with the test_data type ['real, dimension (1:100)'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "function soma(x)\nreal :: soma, cont\nreal, dimension (1:100) :: x\ninteger :: c\n\ncont = 0\ndo c = 1,100\n    cont = cont + x(c)\n    soma = cont\nend do\n\nreturn\nend function soma\n"}, {"instruction": "Create a Fortran function named isdigit to check if a single character input is a digit or not. The function takes 1 input parameter of type character(1) and returns 1 output parameter of type logical. The input test_data type is ['character(1)'] and the output test_data type is ['logical'].", "input": "", "output": "    pure function isdigit(singlechar) result(stringisdigit)\n#if defined dll_enabled && !defined cfi_enabled\n        !dec$ attributes dllexport :: isdigit\n#endif\n        character(1), intent(in)    :: singlechar\n        logical                     :: stringisdigit\n        character(*), parameter     :: digit(10) = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        integer                     :: j\n        stringisdigit = .false.\n        loopoverdigit: do j = 1,10\n            if (singlechar==digit(j)) then\n                stringisdigit = .true.\n                exit loopoverdigit\n            end if\n        end do loopoverdigit\n    end function isdigit\n"}, {"instruction": "Create a Fortran function named isinteger that takes a single input argument of type character(*) and returns a logical value. The function checks whether the input string represents an integer and sets the logical output accordingly. Remember to handle the situation where the input string is empty or contains non-integer characters.", "input": "", "output": "    pure function isinteger(string) result(stringisinteger)\n#if defined dll_enabled && !defined cfi_enabled\n        !dec$ attributes dllexport :: isinteger\n#endif\n        character(*), intent(in)    :: string\n        logical                     :: stringisinteger\n        character(*), parameter     :: digit(10) = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        integer                     :: i, j\n        do i = 1,len(string)\n            stringisinteger = .false.\n            loopoverdigit: do j = 1,10\n                if (string(i:i)==digit(j)) then\n                    stringisinteger = .true.\n                    exit loopoverdigit\n                end if\n            end do loopoverdigit\n            if (.not.stringisinteger) return\n        end do\n    end function isinteger\n"}, {"instruction": "Create a Fortran function named compress that removes double whitespaces and spaces before a comma or dot in the input string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=len(a)).", "input": "", "output": "pure function compress(a) result(t)\n! ... removes all double whites and spaces before a comma or dot\n\ncharacter(len=*), intent(in)   :: a\ncharacter(len=len(a))          :: t\n\n! ... local variables\n! ...\ninteger i,n\n\n! ... remove leading whitespaces\n! ...\nt = adjustl(a)\nn = len_trim(t)\n\n! ... replace tabs by whitespaces\n! ...\ndo i=1,n\n  if (iachar(t(i:i)).eq.9) t(i:i) = ' '\nenddo\n\n! ... remove all double whites\n! ...\n10 i = index(t,'  ')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i+1:) = t(i+2:)\n     n = n - 1\n     goto 10\n   endif\n\n! ... remove space-commas\n! ...\n20 i = index(t,' ,')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i:) = t(i+1:)\n     n = n - 1\n     goto 20\n   endif\n\n! ... remove space-dots\n! ...\n30 i = index(t,' .')\n   if ((i.gt.0).and.(i.lt.n)) then\n     t(i:) = t(i+1:)\n     n = n - 1\n     goto 30\n   endif\n\nend function compress\n"}, {"instruction": "Write a Fortran function named filename_append that takes 3 input parameters of type character (with optional third parameter), and returns a single output parameter of type character with a length of 280. The function appends the basename and optional extension to the path and constructs the full filename.", "input": "", "output": "pure function filename_append(path,basename,ext) result(filename)\n\ncharacter(len=*), intent(in)           :: path\ncharacter(len=*), intent(in)           :: basename\ncharacter(len=*), intent(in), optional :: ext\ncharacter(len=280)                     :: filename\n\n! ... local variables\n! ...\ninteger i\ncharacter(len=180) lpath,lbase,lext\n\nlpath = ''\nlext  = ''\n\ni = len_trim(path)\nif (i.eq.0) then\n  lpath = './'\nelse\n  if (path(i:i).eq.'/') then\n    lpath = trim(path)\n  else\n    lpath = trim(path)//'/'\n  endif\nendif\n\nif (basename(1:2).eq.'./') then\n  lbase = trim(basename(3:))\nelse\n  lbase = trim(basename)\nendif\n\nif (present(ext)) then\n  i = len_trim(ext)\n  if (i.gt.0) then\n    if (ext(1:1).eq.'.') then\n      lext = trim(ext)\n    else\n      lext = '.'//trim(ext)\n    endif\n  endif\nendif\n\nfilename = trim(lpath)//trim(lbase)//trim(lext)\n\nend function filename_append\n"}, {"instruction": "Create a Fortran function named getfieldcount to determine the number of fields in a character record delimited by a specified character. The function takes 2 input parameters of type character(*) and character, and returns 1 output parameter of type integer.", "input": "", "output": "      function getfieldcount( record, delimiter ) result( nfields )\n\n      implicit none\n\n      character(*) :: record\n      character    :: delimiter\n      integer      :: nfields\n\n      integer i\n      logical infield\n      logical isdel\n\n      nfields = 0\n      infield = .false.\n      do i = 1, len( record )\n        isdel = ( record( i:i ) .eq. delimiter )\n\n! check for start of field\n        if ( .not. infield .and. .not. isdel ) then\n           nfields = nfields+1\n           infield = .true.\n           cycle\n        end if\n\n! check for end of field\n        if ( infield .and. isdel ) then\n          infield = .false.\n          cycle\n        end if\n      end do \n       \n      return\n      end function getfieldcount\n"}, {"instruction": "Write a Fortran function named getparsednumber to count the number of fields in a character string that are separated by a specified delimiter. The function takes 2 input parameters of types character(*) and character, and returns 1 output parameter of type integer.", "input": "", "output": "      function getparsednumber( record, delimiter ) result( nfields )\n\n      implicit none\n\n      character(*) :: record\n      character    :: delimiter\n      integer      :: nfields\n\n      integer i\n\n      nfields = 1\n      do i = 1, len( record )\n        if ( index( delimiter, record( i:i ) ) .gt. 0 ) nfields = nfields+1\n      end do\n\n      return\n      end function getparsednumber\n"}, {"instruction": "Create a Fortran function named isperfect to determine if a given integer is a perfect number. The function takes 1 input parameter of type integer and returns 1 output parameter of type logical. The input parameter's test_data type is ['integer'], and the output parameter's test_data type is ['logical'].", "input": "", "output": "function isperfect(n)\n  logical :: isperfect\n  integer, intent(in) :: n\n  integer :: i, factorsum\n\n  isperfect = .false.\n  factorsum = 1\n  do i = 2, int(sqrt(real(n)))\n     if(mod(n, i) == 0) factorsum = factorsum + i + (n / i)\n  end do\n  if (factorsum == n) isperfect = .true.\nend function isperfect\n"}, {"instruction": "Create a Fortran function named \"phixxinfluence\" to calculate the Hessian matrix in global coordinates based on panel parameters and field point coordinates. The function takes 5 input parameters of type real(8) and returns 1 output parameter of type real(8), dimension (3,3).", "input": "", "output": "   function phixxinfluence (point, center, area, coordsys, qlocal) result (hessmatrix)\n\n     implicit none\n     ! fuildpoint, center of panel, result\n       real(8),dimension(3) :: point, center, plocal\n     ! matrix t with voectors i, j, k for panel\n       real(8),dimension(3,3) :: coordsys\n     ! panel comes in local coordinates\n       real(8),dimension(2,4) :: qlocal\n     ! the x and y value  \n       real(8) :: area\n       real(8), dimension (4) :: corner_x ! the x component of each corner\n       real(8), dimension (4) :: corner_y ! the y component of each corner \n     ! pi\n       real(8), parameter :: pi= 4.d0*datan(1.d0)\n     ! name k+1\n       integer, dimension(4), parameter :: kp1 = (/ 2, 3, 4, 1 /)\n       integer :: k\n       real(8), dimension (4) :: d ! length of panel side k between point q_k and q_k+1\n       real(8), dimension (4) :: m ! ratios of y and x coordinate difference of panel corners (local coordinates)\n       real(8), dimension (4) :: r ! distance from field point to the 4 corners\n       real(8), dimension (4) :: e\n       real(8), dimension (4) :: h\n       real(8), dimension (4) :: rho\n       real(8), dimension (4) :: lambda\n       real(8) :: phi_xx, phi_yx, phi_zx, phi_xy\n       real(8) :: phi_yy, phi_zy, phi_xz, phi_yz, phi_zz\n       real(8), dimension (3,3) :: hesslocal ! hessian matrix in local coordinate\n       real(8), dimension (3,3) :: hessmatrix !hessian matrix in global coordinate\n  \n     ! transfer the point p into the local coordinate system\n       plocal = matmul( transpose( coordsys), point-center)\n\n      ! x value\n      corner_x= qlocal(1,:)\n      ! y value\n      corner_y= qlocal(2,:)\n      \n      ! the length of panel side k between point q(k) and q(k+1)\n      do k = 1,4\n         d(k) = dsqrt((corner_x(kp1(k))-corner_x(k))**2 &\n                + (corner_y(kp1(k))-corner_y(k))**2)\n         \n         ! ratio of y and x coordinate differences of panel corners\n         if (d(k)==0) then \n              m(k)= 0 \n         else\n              m(k) = (corner_y(kp1(k))-corner_y(k)) &\n                      & / (corner_x(kp1(k))-corner_x(k))\n         end if\n      end do\n      \n      do k = 1,4\n         ! distance of field points form corner k\n         ! x is plocal(1)\n         ! y is plocal(2)\n         ! z is plocal(3)\n         r(k)   = dsqrt( (plocal(1)-corner_x(k))**2 &\n                   & + (plocal(2)-corner_y(k))**2 &\n                   & + plocal(3)**2)\n         e(k)   = (plocal(1)-corner_x(k))**2 + (plocal(3))**2\n         h(k)   = (plocal(1)-corner_x(k)) * (plocal(2)-corner_y(k))\n      end do  \n      \n      do k = 1,4\n        rho(k) = r(k)*r(kp1(k)) + &\n               & (plocal(1)-corner_x(k))*(plocal(1)- corner_x(kp1(k)))&\n               & + (plocal(2)-corner_y(k))*(plocal(2)-corner_y(kp1(k)))&\n               & + plocal(3)**2\n       lambda(k) = ((plocal(1)-corner_x(k))*(plocal(2)-corner_y(kp1(k)))&\n                & - (plocal(1) - corner_x(kp1(k)))*(plocal(2)-corner_y(k)))\n      end do\n      \n      ! the starting value of the second order dericatives\n       phi_xx = 0.\n       phi_xy = 0.\n       phi_xz = 0.\n       phi_yx = 0.\n       phi_yy = 0.\n       phi_yz = 0.\n       phi_zx = 0.\n       phi_zy = 0.\n       phi_zz = 0.       \n\n       do k = 1,4\n         phi_xx = phi_xx + 2*(corner_y(kp1(k))-corner_y(k)) / &\n                & ((r(k)+r(kp1(k)))**2-d(k)**2)      &\n                & *((plocal(1)-corner_x(k))/r(k) +   &\n                & (plocal(1)-corner_x(kp1(k)))/r(kp1(k)))\n       end do\n       phi_xx = -1./(4.*pi)*phi_xx\n       \n       do k= 1,4\n         phi_yx = phi_yx + (-2)*(corner_x(kp1(k))-corner_x(k)) &\n                & / ((r(k)+r(kp1(k)))**2-d(k)**2)   &\n                & *((plocal(1)-corner_x(k))/r(k)    &\n                & + (plocal(1)-corner_x(kp1(k)))/r(kp1(k)))\n       end do\n       phi_yx = -1./(4.*pi)*phi_yx\n       \n       do k = 1,4\n         phi_zx = phi_zx + plocal(3)*(corner_y(kp1(k))-corner_y(k))&\n               & *(r(k)+r(kp1(k)))/(r(k)*r(kp1(k))) / rho(k)\n       end do\n       phi_zx = -1./(4.*pi)*phi_zx    \n       \n       do k = 1,4\n         phi_xy = phi_xy + 2*(corner_y(kp1(k))-corner_y(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( (plocal(2)-corner_y(k))/r(k) &\n                & +(plocal(2)-corner_y(kp1(k)))/r(kp1(k)) )\n       end do\n       phi_xy = -1./(4.*pi)*phi_xy\n       \n       do k = 1,4\n         phi_yy = phi_yy + (-2*(corner_x(kp1(k))-corner_x(k))) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )             &\n                & *( (plocal(2)-corner_y(k))/r(k)              &\n                & + (plocal(2)-corner_y(kp1(k)))/r(kp1(k)) )\n       end do\n       phi_yy = -1./(4.*pi)*phi_yy \n       \n       do k = 1,4\n         phi_zy = phi_zy - plocal(3)*(corner_x(kp1(k))-corner_x(k)) &\n                & *(r(k)+r(kp1(k)))/(r(k)*r(kp1(k))) / rho(k)\n       end do\n       phi_zy = -1./(4.*pi)*phi_zy    \n       \n       do k = 1,4\n         phi_xz = phi_xz + 2*(corner_y(kp1(k))-corner_y(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( plocal(3)/r(k) + plocal(3)/r(kp1(k)) )\n       end do\n       phi_xz = -1./(4.*pi)*phi_xz\n       \n       do k = 1,4\n         phi_yz = phi_yz - 2*(corner_x(kp1(k))-corner_x(k)) &\n                & /( (r(k)+r(kp1(k)))**2-d(k)**2 )          &\n                & *( plocal(3)/r(k)+plocal(3)/r(kp1(k)) )\n       end do\n       phi_yz = -1./(4.*pi)*phi_yz\n       \n       do k = 1,4\n         phi_zz = phi_zz+lambda(k)*(r(k)+r(kp1(k))) &\n                & /(r(k)*r(kp1(k))*rho(k))\n       end do\n       phi_zz = -1./(4.*pi)*phi_zz\n       \n       hesslocal(1,1) = phi_xx\n       hesslocal(1,2) = phi_xy\n       hesslocal(1,3) = phi_xz\n       hesslocal(2,1) = phi_yx\n       hesslocal(2,2) = phi_yy\n       hesslocal(2,3) = phi_yz\n       hesslocal(3,1) = phi_zx\n       hesslocal(3,2) = phi_zy\n       hesslocal(3,3) = phi_zz\n   \n       hessmatrix = matmul(coordsys,hesslocal)\n       hessmatrix = matmul(hessmatrix,transpose(coordsys))\n       \n       ! return to caller\n       return\n\n\n  end function phixxinfluence\n"}, {"instruction": "Write a Fortran function named key_is_valid that takes a single input argument of type character(len=*) and returns a logical value. The function checks if the input contains only valid characters, including space, 0-9, A-Z, a-z, and underscore, and returns true if all characters are valid; otherwise, it returns false.", "input": "", "output": "    pure function key_is_valid(chars)\n        character(len=*), intent(in) :: chars\n        logical :: key_is_valid\n        character(len=1) :: char\n        integer :: i\n\n        do i = 1, len(chars)\n            char = chars(i:i)\n\n            select case (ichar(char))\n            case (32, 48:57, 65:90, 95, 97:122)\n                ! space, 0-9, a-z, _, a-z\n                ! key_is_valid = .true.\n            case default\n                key_is_valid = .false.\n                return\n            end select\n\n        end do\n\n        key_is_valid = .true.\n\n    end function key_is_valid\n"}, {"instruction": "Create a Fortran function named area_circle to calculate the area of a circle based on the provided radius. The function takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. Use the formula area_circle = pi * r * r, where pi is a predefined constant and r is the radius of the circle.", "input": "", "output": "function area_circle(r)\nimplicit none\n\nreal*8, parameter :: pi = 3.1415927\nreal*8, intent(in) :: r\nreal*8 :: area_circle\n\narea_circle = pi * r * r\nreturn\n\nend function area_circle\n"}, {"instruction": "Write a Fortran function named imaxloc to find the index of the maximum value in a real array. The function should take 1 input parameter of type real, with a dimension of (:), and provide 1 output parameter of type integer.", "input": "", "output": "  function imaxloc (array)\n    real, dimension (:), intent (in) :: array\n    integer :: imaxloc\n    integer, dimension (1) :: imax\n    imax = maxloc(array)\n    imaxloc = imax(1)\n  end function imaxloc\n"}, {"instruction": "Create a Fortran function named halfadder to perform a logical half adder operation. The function takes 3 input parameters of type logical and returns 1 output parameter of type logical. The input parameters are a, b, and c, and the output parameter is c.", "input": "", "output": "function halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n"}, {"instruction": "Create a Fortran function named rform that calculates the formation rate in cubic centimeters per second. This function takes 2 input parameters of type real, representing the values of z and t. It returns a single output parameter of type real, which represents the formation rate.", "input": "", "output": "function rform(t,z) ! formation rate in cm^3 s^-1\n real :: rform,z,t\n real, parameter :: tref=102\n rform=3.5e-18*z*t**.5/(1+t/tref)**2*mu\n if(t.gt.tform) rform=0\nend function \n"}, {"instruction": "Write a Fortran function named taudiss1 that computes the dissipation time scale (tau) based on the input parameters t and n, both of type real. The function takes 2 input arguments of type real and returns 1 output argument of type real. The function uses the imperative tone and calculates the dissipation time scale according to the given parameters and conditions.", "input": "", "output": " function taudiss1(t,n) result(tau)\n  real :: tau\n  real, intent(in) :: t,n\n  real, parameter :: tref=3162,tauref=3.2e10,tmin=3000,tmax=10000\n!  if(t.lt.tmin) then\n!   tau=tauref*(tref/tmin)**12/n \n!   return\n!  endif\n  if(t.gt.tmax) then\n   tau=tauref*(tref/tmax)**12/n\n   return\n  endif  \n  tau=tauref*(tref/t)**12/n\n end function\n"}, {"instruction": "Create a Fortran function named two_n_choose_n to calculate the value of \"2n choose n\". The function takes 1 input parameter of type integer(4) and returns 1 output parameter of type integer(8). The input parameter represents the value of n for which the \"2n choose n\" is calculated.", "input": "", "output": "  pure function two_n_choose_n(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(8)             :: two_n_choose_n\n\n    ! local variables\n    integer(4) :: i\n\n    two_n_choose_n = 1\n    do i=1,n\n       two_n_choose_n = two_n_choose_n * (n+i)/i\n    enddo\n\n    return\n  end function two_n_choose_n\n"}, {"instruction": "Write a Fortran function named lcg to implement a linear congruential generator (LCG) algorithm. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type integer. The test_data types for input and output parameters are ['integer(8)'] and ['integer'] respectively.", "input": "", "output": "  function lcg(s)\n    integer :: lcg\n    integer(8) :: s\n    if (s == 0) then\n       s = 104729_8\n    else\n       s = mod(s, 4294967296_8)\n    end if\n    s = mod(s * 279470273_8, 4294967291_8)\n    lcg = int(mod(s, int(huge(0), 8)), kind(0))\n  end function lcg\n"}, {"instruction": "Create a Fortran function named \"number_of_divisors\" to calculate the number of divisors of a given integer. The function should have 1 input parameter with a test_data type of ['integer'] and 1 output parameter with a test_data type of ['integer']. Use the imperative tone.", "input": "", "output": "    function number_of_divisors(val) result(ret)\n        integer, intent(in) :: val\n        integer :: ret, i, x\n\n        ret = 0\n        x = int(sqrt(real(val)))\n        do i = 1, x - 1\n            if (mod(val, i) == 0) ret = ret + 2\n        end do\n        if (mod(val, x) == 0) ret = ret + 1\n    end function number_of_divisors\n"}, {"instruction": "Create a Fortran function named sum_to that calculates the sum of integers from 1 to the given input integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function sum_to(n) result(r)\n    implicit none\n    integer :: r\n    integer, intent(in) :: n\n\n    r = 0\n\n    if (n == 0) then\n      return\n    end if\n\n    r = n + sum_to(n-1)\n\n  end function sum_to\n"}, {"instruction": "Write a Fortran function named chisq to calculate the chi-square value. The function takes 3 input parameters of type double precision: x, x0, and dx. It returns 1 output parameter of type double precision. If dx is not equal to 0, the chi-square value is computed using the formula (x-x0)^2/dx^2; otherwise, a warning message is displayed and the chi-square value is set to 100000.", "input": "", "output": "function chisq(x,x0,dx)\n!------------------------------------------------------------------------------------    \n implicit none \n double precision, intent(in) :: x,x0,dx\n double precision :: chisq\n \n if(dx.ne.0) then \n  chisq=(x-x0)**2/dx**2\n else\n  write(*,*) 'warning, dx = 0'\n  chisq=100000. \n endif\n \nend function chisq\n"}, {"instruction": "Create a Fortran function named to_lower_index that takes a single input parameter of type character(len=1) and returns a single output parameter of the same type. The function converts the input character to lowercase and returns the result.", "input": "", "output": "  pure function to_lower_index(c) result(res)\n    character(len=1), intent(in) :: c\n    character(len=1) :: res\n\n    integer :: i\n    character(len=26), parameter :: &\n      upper = \"abcdefghijklmnopqrstuvwxyz\", &\n      lower = \"abcdefghijklmnopqrstuvwxyz\"\n\n    res = c\n    i = index(upper, c)\n    if (i > 0) res = lower(i:i)\n  end function\n"}, {"instruction": "Create a Fortran function named gamln1 to calculate the natural logarithm of the gamma function for a given input. The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "function gamln1 (a) result(fn_val)\n!-----------------------------------------------------------------------\n!     evaluation of ln(gamma(1 + a)) for -0.2 .le. a .le. 1.25\n!-----------------------------------------------------------------------\nimplicit none\ndouble precision, intent(in) :: a\ndouble precision             :: fn_val\n\ndouble precision :: w, x, &\n             p0 =  .577215664901533d+00, p1 =  .844203922187225d+00,  &\n             p2 = -.168860593646662d+00, p3 = -.780427615533591d+00,  &\n             p4 = -.402055799310489d+00, p5 = -.673562214325671d-01,  &\n             p6 = -.271935708322958d-02,   &\n             q1 =  .288743195473681d+01, q2 =  .312755088914843d+01,  &\n             q3 =  .156875193295039d+01, q4 =  .361951990101499d+00,  &\n             q5 =  .325038868253937d-01, q6 =  .667465618796164d-03,  &\n             r0 = .422784335098467d+00,  r1 = .848044614534529d+00,  &\n             r2 = .565221050691933d+00,  r3 = .156513060486551d+00,  &\n             r4 = .170502484022650d-01,  r5 = .497958207639485d-03,  &\n             s1 = .124313399877507d+01,  s2 = .548042109832463d+00,  &\n             s3 = .101552187439830d+00,  s4 = .713309612391000d-02,  &\n             s5 = .116165475989616d-03\n!----------------------\nif (a >= 0.6d0) go to 10\nw = ((((((p6*a + p5)*a + p4)*a + p3)*a + p2)*a + p1)*a + p0)/  &\n    ((((((q6*a + q5)*a + q4)*a + q3)*a + q2)*a + q1)*a + 1.0d0)\nfn_val = -a*w\nreturn\n\n10 x = (a - 0.5d0) - 0.5d0\nw = (((((r5*x + r4)*x + r3)*x + r2)*x + r1)*x + r0)/  &\n    (((((s5*x + s4)*x + s3)*x + s2)*x + s1)*x + 1.0d0)\nfn_val = x*w\nreturn\nend function gamln1\n"}, {"instruction": "Create a Fortran function named iday that takes three integer input parameters (yyyy, mm, dd) representing a calendar date and returns a single integer output parameter (ival) representing the day of the year. The function should calculate the day of the year based on the input date using a specific formula.", "input": "", "output": " function iday(yyyy, mm, dd) result(ival)\n!====iday is a companion to calend; given a calendar date, yyyy, mm,\n!           dd, iday is returned as the day of the year.\n!           example: iday(1984, 4, 22) = 113\n\n integer, intent(in) :: yyyy, mm, dd\n integer             :: ival\n\n ival = 3055*(mm+2)/100 - (mm+10)/13*2 -91 +  &\n       (1-(modulo(yyyy, 4)+3)/4              &\n        + (modulo(yyyy, 100) + 99)/100 -        &\n       (modulo(yyyy, 400)+399)/400)*(mm+10)/13 + dd\n\n return\n end function iday\n"}, {"instruction": "Create a Fortran function named fact_i to calculate the factorial of an input integer number. The input argument is of type integer. The output argument is of type real(kind=8).", "input": "", "output": "       function fact_i(n)\n       \n        integer, intent(in) :: n\n        real(kind=8) :: fact_i\n        integer :: i\n\n        fact_i = 1.d0\n        do i = 2, n\n            fact_i = fact_i * i\n        enddo\n        \n       end function fact_i\n"}, {"instruction": "Create a Fortran function named chomp_substring_char_char to remove a specified substring from a given string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    pure function chomp_substring_char_char(string, substring) result(chomped_string)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        character(len=:), allocatable :: chomped_string\n        integer :: last, nsub\n\n        last = len(string)\n        nsub = len(substring)\n        if (nsub > 0) then\n            do while(string(last-nsub+1:last) == substring)\n                last = last - nsub\n            end do\n        end if\n        chomped_string = string(1:last)\n\n    end function chomp_substring_char_char\n"}, {"instruction": "Write a Fortran function named starts_with_char_char that checks whether a given string starts with a specified substring. The function takes 2 input arguments with test_data type ['character(len=*)', 'character(len=*)'] and 1 output argument with test_data type ['logical'].", "input": "", "output": "    pure function starts_with_char_char(string, substring) result(match)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        logical :: match\n        integer :: nsub\n\n        nsub = len(substring)\n        if (len(string) < nsub) then\n            match = .false.\n            return\n        end if\n        match = string(1:nsub) == substring\n\n    end function starts_with_char_char\n"}, {"instruction": "Create a Fortran function named ends_with_char_char to determine if a given string ends with a specific substring. The function should take 2 input arguments of type character(len=*) and return 1 output argument of type logical. The test_data types for input and output are ['character(len=*)', 'character(len=*)'] and ['logical'] respectively.", "input": "", "output": "    pure function ends_with_char_char(string, substring) result(match)\n        character(len=*), intent(in) :: string\n        character(len=*), intent(in) :: substring\n        logical :: match\n        integer :: last, nsub\n\n        last = len(string)\n        nsub = len(substring)\n        if (last < nsub) then\n            match = .false.\n            return\n        end if\n        match = string(last-nsub+1:last) == substring\n\n    end function ends_with_char_char\n"}, {"instruction": "Create a Fortran function named padl_char_pad_with that takes 3 input parameters: a character string, an integer representing the desired output length, and a single character to pad with. The output parameter is a character with a length equal to the maximum of the input string length or the specified output length. The function aims to left-pad the input string with the specified character to achieve the desired output length.", "input": "", "output": "    pure function padl_char_pad_with(string, output_length, pad_with) result(res)\n        character(len=*), intent(in) :: string\n        integer, intent(in) :: output_length\n        character(len=1), intent(in) :: pad_with\n        character(len=max(len(string), output_length)) :: res\n        integer :: string_length\n\n        string_length = len(string)\n\n        if (string_length < output_length) then\n            res = repeat(pad_with, output_length - string_length)\n            res(output_length - string_length + 1 : output_length) = string\n        else\n            res = string\n        end if\n\n    end function padl_char_pad_with\n"}, {"instruction": "Create a Fortran pure function named n_c_r to calculate the binomial coefficient \"n choose r\" using the input parameters n and r, both of type integer. The function returns a single integer result of type integer(16).", "input": "", "output": "    pure function n_c_r(n, r) result(bin)\n        integer(16)         :: bin\n        integer, intent(in) :: n\n        integer, intent(in) :: r\n\n        integer(16)         :: num\n        integer(16)         :: den\n        integer             :: i\n        integer             :: k\n        integer, parameter  :: primes(*) = [2,3,5,7,11,13,17,19]\n        num = 1\n        den = 1\n        do i=0,r-1\n            num = num*(n-i)\n            den = den*(i+1)\n            if (i > 0) then\n                ! divide out common prime factors\n                do k=1,size(primes)\n                    if (mod(i,primes(k)) == 0) then\n                        num = num/primes(k)\n                        den = den/primes(k)\n                    end if\n                end do\n            end if\n        end do\n        bin = num/den\n    end function n_c_r\n"}, {"instruction": "Create a Fortran function named hash to generate a 32-bit integer hash value from an input text string. The function should accept 1 input parameter of type character(len=*) and return 1 output parameter of type integer.", "input": "", "output": "function hash(text) result(hashed)\n    implicit none\n    character(len=*), intent(in) :: text\n    integer                       :: hashed     ! 32-bit integers assumed\n\n    integer, parameter :: magic_numb = z'5d7a9f43'\n    integer            :: i, j\n\n    hashed = 0                              ! note: b was not initialized before\n    do i = 1, len_trim(text)\n        j = mod(i - 1, 4)*8\n        hashed = ieor(hashed, ishft(ichar(text(i:i)), j))\n    end do\n\n    hashed = abs(ieor(hashed, magic_numb))    ! why take the absolute value?\n\n    return\nend function hash\n"}, {"instruction": "Create a Fortran function named check_values_int that compares two integer values. The function takes 2 input arguments of type integer and returns 1 output argument of type logical.", "input": "", "output": "  function check_values_int( val1, val2 )\n    integer :: val1, val2\n    logical :: check_values_int\n\n    if( val1 == val2 ) then\n      check_values_int = .true.\n    else\n      check_values_int = .false.\n    endif\n  end function check_values_int\n"}, {"instruction": "Create a Fortran function named fp to calculate the derivative of a given real number. The function should take 1 input argument of type real and return 1 output argument of type real.", "input": "", "output": "function fp(x) !funci\u00f3n derivada\n  implicit none\n  real::fp, x\n  fp=cos(x)+sin(x)\nend function fp\n"}, {"instruction": "Create a Fortran function named distance that calculates the distance between two geographic coordinates on Earth. The function takes 4 input parameters of type real: lon1, lat1, lon2, and lat2. It returns a single output parameter of type real, representing the distance in meters.", "input": "", "output": "    function distance(lon1, lat1, lon2, lat2)\n    !\n    !>\\ author : fanghe zhao\n    !>\\ date : 10/2018\n    !>\\ details:\n\n    !\n        implicit none\n\n        real, parameter :: r_e = 6371 \n        real, intent(in) :: lon1, lat1, lon2, lat2\n        real :: distance\n        real :: dlon, dlat\n        real :: a, b\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n        a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n        b = 2 * atan2(sqrt(a), sqrt(1 - a))\n        distance = r_e * b * 1000\n\n        return\n    end function distance\n"}, {"instruction": "Write a Fortran function named pekerisroot that calculates the square root of a complex number. The function takes 1 input parameter of type complex (kind=8), and returns 1 output parameter of type complex (kind=8). If the real part of the input is greater than or equal to 0, the output is the square root of the input. Otherwise, the output is the square root of the negative of the input multiplied by (0.0d0, 1.0d0).", "input": "", "output": "function pekerisroot( z )\r\n\r\n  ! at one time, this was used to return the 'pekeris branch cut'     \r\n  ! which is just a particular branch of the square root that         \r\n  ! exposes many 'leaky' or 'virtual' modes.                          \r\n\r\n  ! the current version implements a particular branch that was convenient                                                   \r\n\r\n  implicit none\r\n  complex (kind=8), intent(  in ) :: z\r\n  complex (kind=8)                :: pekerisroot\r\n\r\n  if ( real( z ) >= 0.0d0 ) then \r\n     pekerisroot = sqrt( z ) \r\n  else \r\n     pekerisroot = ( 0.0d0, 1.0d0 ) * sqrt( -z ) \r\n  endif\r\n\r\nend function pekerisroot\r\n"}, {"instruction": "Write a Fortran function named ifirstchar that takes a character string as input and returns the position of the first non-space character in the string. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function ifirstchar(rec)\n    implicit none\n!\n! global variables\n!\n    integer         :: ifirstchar\n    character(*), intent(in)       :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    do i = 1, len(rec)\n       if (index(rec(i:i), ' ')==0) then\n          ifirstchar = i\n          return\n       endif\n    enddo\n    ifirstchar = 0\nend function ifirstchar\n"}, {"instruction": "Provide a Fortran function named ifirstletter, which takes a character string as input and returns the position of the first letter in the string. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function ifirstletter(rec)\n    implicit none\n!\n! global variables\n!\n    integer         :: ifirstletter\n    character(*)    :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n    integer                        :: i1\n    integer                        :: i2\n    integer                        :: i3\n    integer                        :: len_trim\n    integer                        :: l\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    !     geeft positie van eerste letter, niet nummer\n    l = len_trim(rec)\n    ifirstletter = 0\n    do i = 1, l\n       i1 = index('qwertyuiopasdfghjklzxcvbnm', rec(i:i))\n       i2 = index('qwertyuiopasdfghjklzxcvbnm', rec(i:i))\n       i3 = max(i1, i2)\n       if (i3/=0) then\n          ifirstletter = i\n          return\n       endif\n    enddo\nend function ifirstletter\n"}, {"instruction": "Create a Fortran function named pcol that takes three integer arguments of kind c_int: global_col, nblk, and np_cols. The function returns an integer of kind c_int. The purpose of the function is to compute the local column index based on the global column index, the block size, and the number of columns.", "input": "", "output": "   pure function pcol(global_col, nblk, np_cols) result(local_col)\n      use, intrinsic :: iso_c_binding, only : c_int\n      implicit none\n      integer(kind=c_int), intent(in) :: global_col, nblk, np_cols\n      integer(kind=c_int)             :: local_col\n      local_col = mod((global_col-1)/nblk,np_cols)\n   end function\n"}, {"instruction": "Create a Fortran function called prow to calculate the local row index based on the global row index, the block size, and the total number of rows. The function takes 3 input parameters of type integer(kind=c_int) and returns 1 output parameter of type integer(kind=c_int). The function should be used with imperative tone.", "input": "", "output": "   pure function prow(global_row, nblk, np_rows) result(local_row)\n      use, intrinsic :: iso_c_binding, only : c_int\n      implicit none\n      integer(kind=c_int), intent(in) :: global_row, nblk, np_rows\n      integer(kind=c_int)             :: local_row\n      local_row = mod((global_row-1)/nblk,np_rows)\n   end function\n"}, {"instruction": "Write a Fortran pure function named integer_to_string that converts an input integer to a string. The number of input arguments is 1, and the test_data type is [integer]. The number of output arguments is 1, and the test_data type is ['character(len=:),allocatable'].", "input": "", "output": "    pure function integer_to_string(i) result(s)\n\n    implicit none\n\n    integer,intent(in) :: i\n    character(len=:),allocatable :: s\n\n    integer :: istat\n\n    allocate( character(len=64) :: s )  ! should be big enough\n    write(s,fmt='(ss,i0)',iostat=istat) i\n    if (istat==0) then\n        s = trim(adjustl(s))\n    else\n        s = '***'\n    end if\n\n    end function integer_to_string\n"}, {"instruction": "Write a Fortran function named f_order to determine the order of an arithmetic operator based on the given command. The input parameter is a character string of any length, and the output parameter is an integer. The function will return the order of the arithmetic operator specified in the input command.", "input": "", "output": "  function f_order(command) result(order)\n    character(len=*), intent(in) :: command\n    integer :: order\n\n    order = 0\n    \n    select case(trim(command))\n\n    case('!=','==','>=','=>','<=','=<','=','<','>')\n       order = 1\n\n    case('+','-')\n       order = 10\n\n    case('*','/')\n       order = 100\n\n    case('**','^')\n       order = 1000\n\n    end select\n  end function f_order\n"}, {"instruction": "Create a Fortran function named calc_pi that calculates the value of pi using a Monte Carlo method. The function takes 1 input parameter of type integer(8) and returns 1 output parameter of type real(8). The input parameter represents the number of iterations to perform in the Monte Carlo simulation.", "input": "", "output": "  function calc_pi(n) result(pi)\n    implicit none\n    integer(8) :: accept\n    real(8) :: r(2), pi\n    integer(8), intent(in) :: n\n    integer(8) :: i\n\n    accept = 0\n\n    !$omp parallel do private(r,i) reduction(+:accept)\n    do i = 1, n\n       call random_number(r)\n       if (r(1)**2 + r(2)**2 <= 1) then\n          accept = accept + 1\n       end if\n    end do\n    !$omp end parallel do\n\n    pi = 4.0d0 * dble(accept)/dble(n)\n\n  end function calc_pi\n"}, {"instruction": "Create a Fortran function named \"du\" to calculate the gradient of the potential energy surface for a given set of particle positions. The function takes 2 input parameters: an integer \"nn\" representing the number of particles, and a real*8, 3-dimensional array \"pos\" representing the particle positions. It returns 1 output parameter: a real*8, 3-dimensional array \"du\" representing the gradient of the potential energy surface.", "input": "", "output": "        function du(nn,pos)\n\n            ! input\n            integer, intent(in) :: nn                   ! number of particles\n            real*8, dimension(nn,3), intent(in) :: pos  ! particle's position\n\n            ! output\n            real*8, dimension(nn,3) :: du               ! gradient of the pes\n\n            ! parameters\n            real*8, parameter :: k = 500 ! spring constant (todo: different force constant for different interactions)\n            real*8, parameter :: d = 1 ! equilibrium distance (todo: different equilibrium distance for different interactions)\n\n            ! intermediate variables\n            real*8 :: r, dx, dy, dz\n            integer :: i, j ! loop indices\n\n            du(:,:) = 0.0d0\n\n            do i = 1, nn-1\n                do j = i+1, nn\n                    dx = pos(i,1) - pos(j,1)\n                    dy = pos(i,2) - pos(j,2)\n                    dz = pos(i,3) - pos(j,3)\n\n                    r = dsqrt(dx**2 + dy**2 + dz**2)\n\n                    du(i,1) = du(i,1) - k * (d - r) / r * dx\n                    du(i,2) = du(i,2) - k * (d - r) / r * dy\n                    du(i,3) = du(i,3) - k * (d - r) / r * dz\n\n                    du(j,1) = du(j,1) + k * (d - r) / r * dx\n                    du(j,2) = du(j,2) + k * (d - r) / r * dy\n                    du(j,3) = du(j,3) + k * (d - r) / r * dz\n                end do\n            end do\n\n\n        end function\n"}, {"instruction": "Create a Fortran function named func that takes in 1 input argument of type logical. The test_data type is ['logical']. This function returns 1 output argument of type integer, which is allocatable. The test_data type is ['integer, allocatable']. The function allocates memory for the integer variable \"func\" if the input argument is true, and assigns the value 5332 to it. If \"func\" is already allocated, the function stops with an error code 8.", "input": "", "output": "  function func (alloc)\n    integer, allocatable ::  func\n    logical :: alloc\n    if (allocated (func)) stop 8\n    if (alloc) then\n      allocate(func)\n      func = 5332\n    end if\n  end function func\n"}, {"instruction": "Create a Fortran function named string_tolower, which takes a single input argument of type character with variable length. The output is a single argument of type character with the same variable length as the input. The function converts the input string to lowercase and returns the result.", "input": "", "output": "function string_tolower( string ) result (new) \n    character(len=*)           :: string \n\n    character(len=len(string)) :: new \n\n    integer                    :: i \n    integer                    :: k \n\n    length = len(string) \n    new    = string \n    do i = 1,len(string) \n        k = iachar(string(i:i)) \n        if ( k >= iachar('a') .and. k <= iachar('z') ) then \n            k = k + iachar('a') - iachar('a') \n            new(i:i) = achar(k) \n        endif \n    enddo \nend function string_tolower\n"}, {"instruction": "Create a Fortran function named xfunc to compute the value of a mathematical expression. The function takes 1 input argument of type real. The output is also of type real. The function calculates the value of (x^4)*log(x + sqrt(x^2+1)) and returns the result.", "input": "", "output": "\t  function xfunc(x)\n\t  \t\treal :: xfunc\n\t\t\treal :: x\n\t\t\txfunc = (x**4)*log(x + sqrt(x**2+1))\n\t\t\treturn\n\t  end function xfunc\n"}, {"instruction": "Create a Fortran function named iround that takes a single real number as input and returns the nearest integer value. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function iround(x) result(ival)\r\nimplicit none\r\n\r\nreal, intent(in)  :: x\r\ninteger           :: ival\r\n\r\nreal, parameter  :: half = 0.5\r\n\r\nival = int(x + sign(half,x))\r\nreturn\r\nend function iround\r\n"}, {"instruction": "Create a Fortran function named foo that takes an integer as input and returns a 4-character string. The input parameter should be of type integer, and the output parameter should be of type character with a length of 4. If the input value is less than 0, the output string should be \"1234\". Otherwise, the output string should be \"abcd\".", "input": "", "output": "  function foo (i) result (s)\n    integer, intent(in) :: i\n    character (len=4)   :: s, t\n    if (i < 0) then\n       s = \"1234\"\n    else\n       ! internal i/o, allowed recursive in f2003, see section 9.11\n       write (s, '(a)') \"abcd\"\n    end if\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"triplet\" that takes an integer input and returns an array of three integers. The input parameter should be of type integer. The output parameter should be of type integer array with dimension 3.\nThis function is designed to find a Pythagorean triplet (a set of three positive integers a, b, and c) where a^2 + b^2 = c^2, given a specific number.", "input": "", "output": "function triplet(number)\n    implicit none\n    integer, intent(in) :: number\n    integer, dimension(3) :: triplet\n    integer :: a, b, c\n\n    loopa: do a = 1, number\n        do b = a, number\n            c = number - a - b\n            if (a*a + b*b == c*c) then\n                exit loopa\n            end if\n        end do\n    end do loopa\n    \n    triplet(1) = a\n    triplet(2) = b\n    triplet(3) = c\n    \nend function triplet\n"}, {"instruction": "Write a Fortran function named model_function, which takes two input arguments of type character with variable length and pointer, and returns one output argument of type logical. The function copies the input character to the output character, allocates memory for the output, sets the output to true, and prints the output and its length.", "input": "", "output": "  function model_function(inputb, outputb) result(out)\n    character(len=*), intent(in) :: inputb\n    character(len=:), pointer :: outputb\n    logical :: out\n    out = .true.\n    allocate(character(len=len(inputb)) :: outputb)\n    outputb = inputb\n    write(*, '(\"model b: \",a,\" (length = \",i3,\")\")') outputb, len(outputb)\n  end function model_function\n"}, {"instruction": "Create a Fortran function named f that takes a real input argument and returns a real output. The function computes the value of f(x) = x - exp(-x). The function has 1 input parameter of type real and 1 output parameter of type real.", "input": "", "output": "function f(x)\r\n    implicit none\r\n    real::f !dummy variable\r\n    real::x !local variable\r\n    f=x-exp(-x)\nend function\r\n"}, {"instruction": "Create a Fortran function named \"fd\" that takes a single real input argument. This function computes a new real value using the formula: 1 + exp(-x). The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function fd(x)\r\n    implicit none\r\n    real::fd    !dummy variable\r\n    real::x     !local variable\r\n    fd=1+exp(-x)\nend function\r\n"}, {"instruction": "Write a Fortran function named dlclose that takes a single input argument of type \"type(c_ptr), value\" and returns an output of type \"integer(c_int)\". The function is intended to call the \"dlclose\" function from the C library to unload a shared library.", "input": "", "output": "      function dlclose(handle) bind(c,name=\"dlclose\")\n         ! int dlclose(void *handle);\n         use iso_c_binding\n         implicit none\n         integer(c_int) :: dlclose\n         type(c_ptr), value :: handle\n      end function\n"}, {"instruction": "Write a Fortran function named elem that takes 4 input arguments of type integer(kind=int32) and returns 1 output argument of type real(kind=real64). The function computes a value based on the input arguments according to a specific algorithm involving mathematical operations.", "input": "", "output": "    pure function elem(m, n, k, l)\r\n\r\n      use, intrinsic :: iso_fortran_env\r\n      implicit none\r\n\r\n      integer(kind=int32), intent(in) :: m, n, k, l\r\n      !real(kind=real128) :: elem\r\n      real(kind=real64) :: elem\r\n\r\n      integer(kind=int32) :: i\r\n\r\n      elem = 0.\r\n\r\n      if(m /= n - l + k) then\r\n        return\r\n      endif\r\n      if(n < l) then\r\n        return\r\n      endif\r\n      elem = 1.\r\n      ! apply creation operator\r\n      do i = 0, l - 1\r\n        !elem = elem * sqrt(real(n - i, 16))\r\n        elem = elem * sqrt(real(n - i, 8))\r\n      end do\r\n      ! apply anihilation operator\r\n      do i = 1, k\r\n        !elem = elem * sqrt(real(n - l + i, 16))\r\n        elem = elem * sqrt(real(n - l + i, 8))\r\n      end do\r\n\r\n    end function elem\r\n"}, {"instruction": "Create a Fortran function named \"nibble\" that takes an integer as input and returns a character. The input parameter is of type integer, and the output parameter is of type character. The function should convert the input integer to its corresponding hexadecimal digit and return it as a character.", "input": "", "output": "   pure function nibble(x)\n      integer, intent(in) :: x\n      character           :: nibble\n      select case (x)\n      case (0:9)\n         nibble = achar(iachar('0') + x)\n      case default\n         nibble = achar(iachar('a') - 10 + x)\n      end select\n   end function nibble\n"}, {"instruction": "Create a Fortran function named commadash that takes a string of length 25 as input and replaces any commas with dashes. The function should have 1 input parameter of type character(len=25) and 1 output parameter of type character(len=25).", "input": "", "output": "   function commadash(string)\r\n      character(len=25) :: commadash\r\n      character(len=25), intent(in) :: string \r\n      character(len=len(string)) :: temp\r\n      integer :: i\r\n\r\n      temp = string\r\n\r\n      do i=1, len(string)\r\n\r\n         if (temp(i:i)==',') temp(i:i) = '-'\r\n\r\n      end do\r\n    \r\n      commadash = temp\r\n      return         \r\n   end function commadash\r\n"}, {"instruction": "Create a Fortran function called noop_global_isum that takes an integer input argument and returns it as the output. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "        function noop_global_isum (var) result (noop_global_isum_result)\n\n        implicit none\n\n        integer, intent(in) :: var\n        integer :: noop_global_isum_result\n\n        noop_global_isum_result = var\n\n        end function noop_global_isum \n"}, {"instruction": "Create a Fortran function named noop_global_rsum to return a real value. It takes one input argument of type real and returns a real result.", "input": "", "output": "        function noop_global_rsum (var) result (noop_global_rsum_result)\n\n        implicit none\n\n        real, intent(in) :: var\n        real :: noop_global_rsum_result\n\n        noop_global_rsum_result = var\n\n        end function noop_global_rsum\n"}, {"instruction": "Write a Fortran function named fact to compute the factorial of a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "recursive function fact(n) result (fact_n)\n  implicit none\n  real :: fact_n\n  integer, intent (in) :: n\n  select case(n)\n  case(0)\n     fact_n=1.0\n  case(1:)\n     fact_n=n*fact(n-1)\n  case default\n     fact_n=0.0\n  end select\nend function fact\n"}, {"instruction": "Create a Fortran function named csedtaub to calculate the critical stress for bulk or mass erosion of cohesive material. The function takes 2 input parameters of type integer and real and returns 1 output parameter of type real. The number of input arguments is 2 and the test_data type is [integer, real].The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "function csedtaub(denbulk,iopt)\n\n  ! **  calculates critial stress for bulk or mass erosion of cohesive\n\n  ! **  iopt=1  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment drodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n  ! **  iopt=2  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment drodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n\n  ! change record\n\n  implicit none\n  \n  integer :: iopt\n  real :: csedtaub,denbulk,bulkden\n\n  if( iopt == 1 )then\n    bulkden=0.001*denbulk  ! *** pmc changed to prevent\n    if( bulkden <= 1.013 )then\n      csedtaub=0.0\n    else\n      csedtaub=0.001*(9.808*bulkden-9.934)\n    endif\n  elseif( iopt == 2 )then\n    bulkden=0.001*denbulk  ! *** pmc changed to prevent\n    if( bulkden <= 1.013 )then\n      csedtaub=0.0\n    else\n      csedtaub=0.001*(9.808*bulkden-9.934)\n    endif\n  else\n    stop 'csedtaub: bad sediment critical stress option! stopping!'\n  endif\n  !\nend function\n"}, {"instruction": "Write a Fortran function named binarysearch to perform a binary search on a sorted array. The function accepts 3 input parameters of types integer, real*8 array, and real*8, and returns 1 output parameter of type integer. The input array must be sorted in ascending order.", "input": "", "output": "    function binarysearch(array, length, val)\n        implicit none\n        integer :: length\n        real*8, dimension(length) :: array\n        real*8 :: val\n\n        integer :: binarysearch, ind\n\n        integer :: left, middle, right\n\n\n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            endif\n            middle = nint((left+right) / 2.0)\n\n            if (left .eq. (right-1)) then\n                binarysearch = left\n                return\n            elseif (array(middle).le.val) then\n                left = middle\n            elseif (array(middle).gt.val) then\n                right = middle\n            end if\n        end do\n\n        binarysearch = left\n    end function binarysearch\n"}, {"instruction": "Write a Fortran function named trs2a2 that initializes a real array of size m x m to zero. The function should take 3 input arguments of type integer - j, k, and m - and the output should be a real array of size m x m.", "input": "", "output": "  function trs2a2 (j, k, m)\n    real, dimension (1:m,1:m) :: trs2a2\n    integer, intent (in)      :: j, k, m\n    nglobal = nglobal + 1\n    trs2a2 = 0.0\n  end function trs2a2\n"}, {"instruction": "Create a Fortran function named refraction to calculate the angle of refraction based on the Snell's Law. The function should take 3 input arguments with test_data type ['real', 'real', 'real'] representing the incident angle (theta1), the refractive index of the initial medium (n1), and the refractive index of the final medium (n2). The function should return one output argument with test_data type ['real'] representing the angle of refraction.", "input": "", "output": "function refraction(theta1, n1, n2) \r\n    implicit none \r\n    real :: theta1\r\n    real :: n1\r\n    real :: n2\r\n    real :: refraction \r\n    \r\n    refraction = asin(sin(theta1) * n1 / n2)\r\n    return \r\nend function \r\n"}, {"instruction": "Create a Fortran function called rad2deg to convert radians to degrees. The function takes 1 input parameter of type real and returns 1 output parameter of type real. Use the formula rad2deg = rad / pi * 180.0 to perform the conversion. Remember to include the necessary Fortran function and parameter declaration keywords.", "input": "", "output": "function rad2deg(rad)\r\n    implicit none\r\n\treal,parameter :: pi = 3.14159265358979\r\n\treal :: rad\r\n\treal :: rad2deg\r\n\r\n    rad2deg = rad / pi * 180.0\r\n    return\r\nend function\r\n"}, {"instruction": "Provide a Fortran function named f6 that takes an integer input argument and returns a character string. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(n)']. The function should be able to accept an integer argument and return a character string.", "input": "", "output": "function f6 (n)\n  integer :: n\n  character(n) :: f6, e6\nentry e6 (n)\n  e6 = \"hello1\"\nend function\n"}, {"instruction": "Create a Fortran function named nc_count to calculate the new count based on the given dimensions, start, and count. The function takes 3 input arguments of type integer arrays with optional dimensions and calculates the new count based on the given conditions. The output is an integer array of the same size as the input dimensions.", "input": "", "output": "\tfunction nc_count(dims, start, count) result(count_new)\n\t\tinteger, dimension(:), intent(in) :: dims\n\t\tinteger, dimension(:), intent(in), optional :: start\n\t\tinteger, dimension(:), intent(in), optional :: count\n\t\tinteger, dimension(size(dims)) :: count_new\n\n\t\tif (present(start) .and. present(count)) then\n\t\t\tcount_new = count\n\t\t\twhere (count == -1)\n\t\t\t\tcount_new = dims - start + 1\n\t\t\tend where\n\t\telse\n\t\t\tcount_new = dims\n\t\tend if\n\tend function\n"}, {"instruction": "Create a Fortran function named \"dlclose\" that takes one input parameter of type \"type(c_ptr), value\" and returns an output parameter of type \"integer(c_int)\". The function should be used to call the \"dlclose\" function from the C standard library using the \"iso_c_binding\" module.", "input": "", "output": "        function dlclose(handle) bind(c, name=\"dlclose\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: dlclose\n            type(c_ptr), value :: handle\n        end function\n"}, {"instruction": "Create a Fortran function named evaluate_couplings to check whether the input string \"couplings\" contains only the characters \"y\" and \"n\". The function should take 1 input argument of type character(len=13) and return 1 output argument of type logical.", "input": "", "output": "      function evaluate_couplings(couplings)    result(rez)\n!--------------------------------------------------------------------\n\n! input string \"couplings\" i.e. checks whether\n! it contains the \"y\" and \"n\" characters only \n! \n!--------------------------------------------------------------------\n!\n      character(len=13), intent(in) :: couplings\n      logical::rez\n      integer::i\n      rez=.true.\n      do i=1, nr_of_avialable_couplings, 1\n         if(couplings(i:i).ne.'y'.and.couplings(i:i).ne.'n') then\n            rez=.false.\n            exit\n         end if\n      end do\n      end function evaluate_couplings\n"}, {"instruction": "Create a Fortran function named find_nr_of_couplings to calculate the number of occurrences of the character 'y' in a given input string. The function takes 1 input parameter of type character(len=13) and returns 1 output parameter of type integer. The name of the function is find_nr_of_couplings.", "input": "", "output": "      function find_nr_of_couplings(couplings)    result(irez)\n!--------------------------------------------------------------------\n\n! requested couplings i.e. the number of\n! \"y\" characters in the input string \"couplings\" \n! \n!--------------------------------------------------------------------\n!\n      character(len=13), intent(in) :: couplings\n      integer::irez\n      integer::i\n      irez=0\n      do i=1, nr_of_avialable_couplings, 1\n         if(couplings(i:i).eq.'y') irez=irez+1\n      end do\n      end function find_nr_of_couplings\n"}, {"instruction": "Create a Fortran function called dimension_row that takes two integer input parameters and returns one integer output parameter. When the absolute value of the first input parameter m is zero, the output parameter nmax is set to the value of the second input parameter nrank. Otherwise, the output parameter nmax is calculated as nrank minus the absolute value of m plus 1.", "input": "", "output": "function dimension_row (m, nrank) result (nmax)\r\n  implicit none\r\n  integer :: m, nrank, nmax\r\n!\r\n  if (abs(m) == 0) then\r\n    nmax = nrank\r\n  else\r\n    nmax = nrank - abs(m) + 1\r\n  end if      \r\nend function dimension_row      \r\n"}, {"instruction": "Create a Fortran function named \"iloc\" to determine the position of a particular variable within an array based on its identification number. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The function uses the \"select case\" construct to assign the position based on the identification number provided.", "input": "", "output": "    pure function iloc(iarr, nparm, numgr)\n\n        implicit none\n\n        integer, intent(in) :: iarr\n        integer, intent(in) :: nparm\n        integer, intent(in) :: numgr\n        integer :: iloc\n\n        select case (iarr)\n        case (2)\n            ! 2  actdif(numgr)\n            iloc = 1\n        case (3)\n            ! 3  b(nparm+1)  (opposite v, y;  follows aa)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 13*nparm + 9\n        case (4)\n            ! 4  beta(nparm+1)  (opposite v, y;  follows b)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 14*nparm + 10\n        case (5)\n            ! 5  bndkp(nparm) (follows actdif)\n            iloc = numgr + 1\n        case (6)\n            ! 6  coef(numgr)\n            iloc = numgr + nparm + 1\n        case (7)\n            ! 7  cofbnd(nparm)\n            iloc = 2*numgr + nparm + 1\n        case (8)\n            ! 8  confun(numgr,nparm+1)  (opposite pmat1)\n            iloc = 2*numgr + 2*nparm + 1\n        case (9)\n            ! 9  d(nparm+1)  (opposite v, y;  follows beta)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 15*nparm + 11\n        case (10)\n            !  10  dvec(nparm) (follows confun)\n            iloc = numgr*nparm + 3*numgr + 2*nparm + 1\n        case (11)\n            !  11  err1(numgr+3)\n            iloc = numgr*nparm + 3*numgr + 3*nparm + 1\n        case (12)\n            !  12  funtbl(numgr,nparm+1)\n            iloc = numgr*nparm + 4*numgr + 3*nparm + 4\n        case (13)\n            !  13  iact(numgr)\n            iloc = 1\n        case (14)\n            !  14  iact1(numgr)\n            iloc = numgr + 1\n        case (15)\n            !  15  icor(nparm+1)\n            iloc = 2*numgr + 1\n        case (16)\n            !  16  icor1(nparm+1)  (does not appear in program by name)\n            iloc = 2*numgr + nparm + 2\n        case (17)\n            !  17  icntyp(numgr)\n            iloc = 2*numgr + 2*nparm + 3\n        case (18)\n            !  18  ixrct(numgr+2*nparm)\n            iloc = 3*numgr + 2*nparm + 3\n        case (19)\n            !  19  iycct(nparm+1) (opposite kpivot)\n            iloc = 4*numgr + 4*nparm + 3\n        case (20)\n            !  20  iyrct(numgr+2*nparm)\n            iloc = 4*numgr + 5*nparm + 4\n        case (21)\n            !  21  jcntyp(numgr)\n            iloc = 5*numgr + 7*nparm + 4\n        case (22)\n            !  22  kcntyp(numgr)\n            iloc = 6*numgr + 7*nparm + 4\n        case (23)\n            !  23  kpivot(nparm+1)  (opposite iycct)\n            iloc = 4*numgr + 4*nparm + 3\n        case (24)\n            !  24  param1(nparm) (follows funtbl)\n            iloc = 2*numgr*nparm + 5*numgr + 3*nparm + 4\n        case (25)\n            !  25  parprj(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 4*nparm + 4\n        case (26)\n            !  26  parser(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 5*nparm + 4\n        case (27)\n            !  27  parwrk(nparm)\n            iloc = 2*numgr*nparm + 5*numgr + 6*nparm + 4\n        case (28)\n            !  28  picor(nparm+1,nparm+1)  (opposite v, y;  follows d)\n            iloc = nparm**2 + 3*numgr*nparm + 6*numgr + 16*nparm + 12\n        case (29)\n            !  29  pmat(nparm+1,numgr) (follows parwrk)\n            iloc = 2*numgr*nparm + 5*numgr + 7*nparm + 4\n        case (30)\n            !  30  pmat1(nparm+1,numgr)  (opposite confun)\n            iloc = 2*numgr + 2*nparm + 1\n        case (31)\n            !  31  ptnr(nparm+1) (follows pmat)\n            iloc = 3*numgr*nparm + 6*numgr + 7*nparm + 4\n        case (32)\n            !  32  ptnrr(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 8*nparm + 5\n        case (33)\n            !  33  r(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 9*nparm + 6\n        case (34)\n            !  34  save(nparm+1)\n            iloc = 3*numgr*nparm + 6*numgr + 10*nparm + 7\n        case (35)\n            !  35  v(numgr+2*nparm+1,nparm+2)  (with y, opposite aa, b, beta, d,\n            !    picor, zwork)\n            iloc = 3*numgr*nparm + 6*numgr + 11*nparm + 8\n        case (36)\n            !  36  vder(nparm) (follows y)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 18*nparm + 10\n        case (37)\n            !  37  vdern(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 19*nparm + 10\n        case (38)\n            !  38  vders(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 20*nparm + 10\n        case (39)\n            !  39  vec(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 21*nparm + 10\n        case (40)\n            !  40  wcoef(numgr)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 9*numgr + 22*nparm + 11\n        case (41)\n            !  41  wcoef1(numgr)  (does not appear in the program by name)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 10*numgr + 22*nparm + 11\n        case (42)\n            !  42  wpt(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 22*nparm + 11\n        case (43)\n            !  43  wvec(nparm)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 23*nparm + 11\n        case (44)\n            !  44  x(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 24*nparm + 11\n        case (45)\n            !  45  xkeep(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 25*nparm + 12\n        case (46)\n            !  46  xrk(nparm+1)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 11*numgr + 26*nparm + 13\n        case (47)\n            !  47  y(numgr+2*nparm)  (with v, opposite aa, b, beta, d, picor, zwork;  follows v)\n            iloc = 2*nparm**2 + 4*numgr*nparm + 8*numgr + 16*nparm + 10\n        case (48)\n            !  48  zwork(nparm)  (opposite v, y;  follows picor)\n            iloc = 2*nparm**2 + 3*numgr*nparm + 6*numgr + 18*nparm + 13\n        case default\n            ! 1  aa(nparm+1,nparm+1)  (opposite v, y; starts at v starting point)\n            iloc = 3*numgr*nparm + 6*numgr + 11*nparm + 8\n        end select\n\n    end function iloc\n"}, {"instruction": "Create a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output test_data types are ['integer'].", "input": "", "output": "\t\tfunction fact(i)\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t!\n\n\t\t!\n\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\t\timplicit none\n\t\t\tinteger ::\ti, j, fact\n\t\n\t\t\tif (i == 0) then\n\t\t\t\tfact = 1\t\n\t\t\telseif (i .lt. 0) then\n\t\t\t\tprint*, \"argument to fact must be positive\"\n\t\t\t\tstop\n\t\t\telse\n\t\t\t\tfact = 1\n\t\t\t\tdo j = 1, i\n\t\t\t\t\tfact = fact * j\n\t\t\t\tenddo\n\t\t\tendif\n\t\t\t\n\t\tend function fact\n"}, {"instruction": "Write a Fortran function named prm3 that takes an integer p and an array of 3 integers as input. The number of input arguments is 2 and the test_data type is ['integer', 'integer,dimension(3)']. The number of output arguments is 1 and the test_data type is ['integer,dimension(3)']. This function uses the prm array to rearrange the elements of the input array based on the value of p and returns the rearranged array as the result.", "input": "", "output": " pure function prm3(p,a)\n  implicit none\n  integer,intent(in) :: p\n  integer,dimension(3),intent(in)  :: a\n  integer,dimension(3) :: prm3\n  integer,dimension(3,6),parameter :: prm = reshape( &\n      source=(/   1,2,3,  2,3,1,   3,1,2,  3,2,1,  1,3,2 , 2,1,3 /), &\n      shape=(/ 3 ,6 /) )\n  prm3(:)=a(prm(:,p))\n  return\n end function\n"}, {"instruction": "Create a Fortran function named bvmv to calculate the bilinear form <x, array y> for a banded matrix. The function takes 6 input parameters: n (integer), k (integer), type (character), array (real array), x (real array), and y (real array). The output parameter is bvmv (real). The input parameter types should be ['integer', 'integer', 'character(len=1)', 'real(kind=8), dimension(n, *)', 'real(kind=8), dimension(n)', 'real(kind=8), dimension(n)'], and the output parameter type should be ['real(kind=8)'].", "input": "", "output": "    function bvmv(n, k, array, type, x, y)\n!=====================================================================\n!\n!   returns bvmv = <x,array y> for the band array.\n!\n!   the original size of array is n*n. the bandwidth of array is 2k-1\n!   for the non-symmetric case, and is k for symmetric case.\n!   the lower-band column storage mode is assumed.\n!---------------------------------------------------------------------\n!\n!   on entry\n!   --------\n!       n      the leading dimension.\n!       k      the band width.\n!       array  a banded matrix in the lower-band column storage mode.\n!              its element (i,j) represents the element (i,i+j-k) of\n!              the original matrix. for a symmetric matrix, only the\n!              lower diagonals are needed.\n!       type   'g' for general;\n!              's' for symmetric;\n!              'a' for \"almost\"  symmetric, as db2\n!       x      vector with length n.\n!       y      vector with length n.\n!\n!----------------------------------------------------------------------\n\n       real(kind=8) :: bvmv\n       integer, intent(in) :: n, k\n       character(len=1), intent(in) :: type\n       real(kind=8), dimension(n, *), intent(in) :: array\n       real(kind=8), dimension(n), intent(in) :: x, y\n\n       ! .. local variables\n\n       integer :: i, j, jp, kp\n\n       bvmv = 0.d0\n\n       if (type /= 'g') then\n\n          ! .. symmetric\n\n          do jp = 1, k - 1\n             do i = k + 1 - jp, n\n                j = i + jp - k\n                bvmv = bvmv + array(i, jp)*(x(i)*y(j) + x(j)*y(i))\n             end do\n          end do\n\n          ! .. make correction for 'a' (almost symmetric)\n\n          if (type == 'a') &\n             bvmv = bvmv + x(n - 1)*y(n)*(array(1, 1) - array(n, k - 1))\n\n       else\n\n          do jp = 1, k - 1\n             do i = k - jp + 1, n\n                j = i + jp - k\n                kp = 2*k - j\n                bvmv = bvmv + array(i, jp)*x(i)*y(j)\n                bvmv = bvmv + array(j, kp)*x(j)*y(i)\n             end do\n          end do\n\n       end if\n\n       ! .. add central diagonal\n\n       bvmv = bvmv + sum(array(:, k)*x(:)*y(:))\n\n    end function bvmv\n"}, {"instruction": "Create a Fortran function named f90add to calculate the sum of two integer numbers. The function should have 2 input parameters of type integer and 1 output parameter of type integer.", "input": "", "output": "function f90add(a, b) result(ret)\n  implicit none\n  integer :: a\n  integer :: b\n  integer :: ret\n  ret = a + b\nend function f90add\n"}, {"instruction": "Create a Fortran function named obstype that takes a single input parameter of type character (len= 80) and returns a single output parameter of the same type. The function reads a line of text and extracts the string that follows the keyword 'bogus'.", "input": "", "output": "function obstype (line) result (f_obstype)\n!------------------------------------------------------------------------------!\n\n  ! read in a line the string present after keyword 'bogus'\n\n!------------------------------------------------------------------------------!\n  implicit none\n  character (len= 80), intent(in) :: line\n\n  character (len= 80) :: f_obstype\n  integer :: b,c\n!------------------------------------------------------------------------------!\n\n!  find keyword bogus\n\n  do c = 1, len_trim (line) - 5\n     if (line (c:c+4) == 'bogus') exit\n  enddo\n\n  c = c + 5\n\n!  skip blank until next word\n\n  do b = c, len_trim (line)\n     if (line (b:b) /= ' ') exit\n  enddo\n\n!  string follows\n\n  f_obstype = trim (line (b:len_trim (line)))\n\nend function obstype\n"}, {"instruction": "Create a Fortran function named sensor, which takes a single input parameter of type character (len=80). The function should extract the first non-blank, non-point, non-number character and the subsequent characters until the next space from the input string, and return the extracted string as the output.", "input": "", "output": "function sensor (line) result (f_sensor)\n\n  ! read first in a string after numbers\n\n!------------------------------------------------------------------------------!\n  implicit none\n  character (len= 80), intent(in) :: line\n\n  character (len= 80) :: f_sensor\n  integer :: b,c\n!------------------------------------------------------------------------------!\n\n!  find the first non-blank, non point and non-number character\n\n  do c = 1, len_trim (line)\n     if (((iachar (line(c:c)) /= 32)  .and. &\n          (iachar (line(c:c)) /= 46)) .and. &\n          ((iachar (line(c:c)) .lt. 48)  .or.  &   \n          (iachar (line(c:c)) .gt. 57)))      &\n          exit\n  enddo\n\n  do b = c, len_trim (line)\n     if (line (b:b) == ' ') exit\n  enddo\n\n  f_sensor = line (c:b-1)\n\nend function sensor\n"}, {"instruction": "Create a Fortran function named sum_of_proper_divisors to calculate the sum of proper divisors of an integer input value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    function sum_of_proper_divisors(val) result(ret)\n        integer, intent(in) :: val\n        integer :: ret, i\n\n        ret = 1\n        do i = 2, int(sqrt(real(val)))\n            if (mod(val, i) == 0) then\n                if (val/i == i) then\n                    ret = ret + i\n                else\n                    ret = ret + i + val/i\n                end if\n            end if\n        end do\n    end function sum_of_proper_divisors\n"}, {"instruction": "Create a Fortran function named normalt that takes a double precision input argument and returns a double precision result. The function computes a mathematical expression involving the input argument and assigns the result to the output parameter. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function normalt(q) result(result)\n\n    double precision, intent(in) :: q\n    double precision :: q2, tmp, sum\n    double precision :: result\n\n    q2 = q*q\n    tmp = q\n    sum = 1.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum - 1.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum + 3.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum - 15.0d0 / tmp\n    tmp = tmp * q2\n    sum = sum + 105.0d0 / tmp\n    result = log(sum) - q2/2.0d0 - log2piover2\n  end function normalt\n"}, {"instruction": "Create a Fortran function named fun_calc_cl that takes a single real input argument. This function computes the chlorinity using the formula from Zeebe and Wolf-Gladrow (2001) and returns the result as a real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "  function fun_calc_cl(dum_s)\n    ! result variable\n    real::fun_calc_cl\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! chlorinity [zeebe and wolf-gladrow, 2001]\n    fun_calc_cl = dum_s/1.80655\n    if (fun_calc_cl < const_real_nullsmall) fun_calc_cl = const_real_nullsmall\n  end function fun_calc_cl\n"}, {"instruction": "Create a Fortran function named fun_calc_i to compute the ionic strength according to Millero [1982]. The function takes 1 input argument of type real and returns 1 output argument of type real. If the input argument is greater than a small constant, the function calculates the ionic strength using a specific formula; otherwise, it returns the small constant.", "input": "", "output": "  function fun_calc_i(dum_s)\n    ! result variable\n    real::fun_calc_i\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! the ionic strength calculated after millero [1982]\n    if (dum_s > const_real_nullsmall) then\n       fun_calc_i = 19.924*dum_s/(1000.0 - 1.005*dum_s)\n    else\n       fun_calc_i = const_real_nullsmall\n    end if\n  end function fun_calc_i\n"}, {"instruction": "Create a Fortran function named fun_calc_ca to calculate the total concentration of ca++ based on the input concentration. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  function fun_calc_ca(dum_s)\n    ! result variable\n    real::fun_calc_ca\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! total ca++ concentration estimated after millero [1982]\n    fun_calc_ca = 0.01028*dum_s/35.0\n    if (fun_calc_ca < const_real_nullsmall) fun_calc_ca = const_real_nullsmall\n  end function fun_calc_ca\n"}, {"instruction": "Create a Fortran function named fun_calc_btot to calculate the total concentration of boric acid in seawater based on the input value of seawater salinity. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone.", "input": "", "output": "  function fun_calc_btot(dum_s)\n    ! result variable\n    real::fun_calc_btot\n    ! dummy arguments\n    real,intent(in)::dum_s\n    ! total boroic acid in seawater estimated after uppstrom [1974]\n    ! note: this is to provide consistence with the 'co2sys' model of lewis and wallace\n    ! note: the alternative formulation is; btot = 0.000426*dum_s/35.0 [millero, 1982, 1995]\n    fun_calc_btot = 0.000416*dum_s/35.0\n    if (fun_calc_btot < const_real_nullsmall) fun_calc_btot = const_real_nullsmall\n  end function fun_calc_btot\n"}, {"instruction": "Write a Fortran function named fun_calc_lnkb to calculate the apparent ionization constant of boric acid. The function takes 7 input arguments of type real: dum_t, dum_rt, dum_t_ln, dum_s, dum_s_p05, dum_s_p15, dum_s_p20. It returns a single output of type real.", "input": "", "output": "  function fun_calc_lnkb(dum_t,dum_rt,dum_t_ln,dum_s,dum_s_p05,dum_s_p15,dum_s_p20)\n    ! result variable\n    real::fun_calc_lnkb\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_ln,dum_s,dum_s_p05,dum_s_p15,dum_s_p20\n    ! apparent ionization constant of boric acid [dickson, 1990]\n    ! note: total ph scale; [mol (kg-h20)-1]\n    fun_calc_lnkb = 148.0248 + 137.194*dum_s_p05 + 1.62247*dum_s &\n         & + (-8966.90 - 2890.51*dum_s_p05 - 77.942*dum_s + 1.726*dum_s_p15 - 0.0993*dum_s_p20)*dum_rt &\n         & + (-24.4344 - 25.085*dum_s_p05 - 0.2474*dum_s)*dum_t_ln &\n         & + 0.053105*dum_s_p05*dum_t\n  end function fun_calc_lnkb\n"}, {"instruction": "Create a Fortran function named fun_calc_lnksi that takes 4 real input parameters and returns a real output. The input parameters are dum_rt, dum_t_ln, dum_i, and dum_i_p05. The function calculates the dissociation constant of SiO2 using the Yao and Millero (1995) equation. The output is the calculated value of the dissociation constant.", "input": "", "output": "  function fun_calc_lnksi(dum_rt,dum_t_ln,dum_i,dum_i_p05)\n    ! result variable\n    real::fun_calc_lnksi\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_i,dum_i_p05\n    ! calculation of the dissociation constant of sio2 [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnksi = 117.40 - 8904.2*dum_rt - 19.334*dum_t_ln &\n         & + (3.5913 - 458.79*dum_rt)*dum_i_p05 + (-1.5998 + 188.74*dum_rt)*dum_i + (0.07871 - 12.1652*dum_rt)*dum_i*dum_i\n  end function fun_calc_lnksi\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkhf to calculate the dissociation constant of hydrogen fluoride. The function takes 2 input arguments of type real, and returns 1 output argument of type real. The input arguments are dummy variables representing temperature (dum_t) and ionic strength (dum_ion_p05). The function uses the Dickson and Riley (1979) equation to perform the calculation. Use the given formula to calculate the dissociation constant of HF and return the result.", "input": "", "output": "  function fun_calc_lnkhf(dum_t,dum_ion_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhf\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_ion_p05\n    ! calculation of the dissociation constant of hf [dickson and riley, 1979]\n    ! note: free ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkhf = 1590.2/dum_t - 12.641 + 1.525*dum_ion_p05\n  end function fun_calc_lnkhf\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp1 to compute the 1st dissociation constant of phosphoric acid in seawater. It takes 4 input arguments of type real: dum_t, dum_t_ln, dum_s, dum_s_p05. The output is a real value representing the calculated 1st dissociation constant.", "input": "", "output": "  function fun_calc_lnkp1(dum_t,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp1\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the 1st dissociation constant of phosphoric acid in seawater  [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp1 = 115.54 - 4576.752/dum_t - 18.453*dum_t_ln &\n         + (0.69171 - 106.736/dum_t)*dum_s_p05 + (-0.01844 - 0.65643/dum_t)*dum_s\n  end function fun_calc_lnkp1\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp2 that calculates the second dissociation constant of phosphoric acid in seawater. The function takes 4 input arguments of type real: dum_t, dum_t_ln, dum_s, and dum_s_p05. It returns a single real value as the result.", "input": "", "output": "  function fun_calc_lnkp2(dum_t,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp2\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the 2nd dissociation constant of phosphoric acid in seawater [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp2 = 172.1033 - 8814.715/dum_t - 27.927*dum_t_ln &\n         + (1.3566 - 160.340/dum_t)*dum_s_p05 + (-0.05778 + 0.37335/dum_t)*dum_s\n  end function fun_calc_lnkp2\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkp3 that calculates the 3rd dissociation constant of phosphoric acid in seawater according to the Yao and Millero (1995) equation. The function has 3 input parameters of type real: dum_t, dum_s, and dum_s_p05. It returns a single real output value.", "input": "", "output": "  function fun_calc_lnkp3(dum_t,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkp3\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_s,dum_s_p05\n    ! calculation of the 3rd dissociation constant of phosphoric acid in seawater [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkp3 = -18.126 - 3070.75/dum_t + &\n         (2.81197 + 17.27039/dum_t)*dum_s_p05 + (-0.09984 - 44.99486/dum_t)*dum_s\n  end function fun_calc_lnkp3\n"}, {"instruction": "Write a Fortran function named fun_calc_lnkhso4 to calculate the dissociation constant of hso4 according to the Dickson 1990 formula. The function takes 6 input parameters of type real: dum_rt, dum_t_ln, dum_i_p05, dum_i, dum_i_p15, and dum_i_p20. It returns a real value.", "input": "", "output": "  function fun_calc_lnkhso4(dum_rt,dum_t_ln,dum_i_p05,dum_i,dum_i_p15,dum_i_p20)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhso4\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_i_p05,dum_i,dum_i_p15,dum_i_p20\n    ! calculation of the dissociation constant of hso4 [dickson, 1990]\n    ! note: free ph scale; [mol (kg-h2o)-1]\n    fun_calc_lnkhso4 = 141.328 - 4276.1*dum_rt - 23.093*dum_t_ln &\n         & + (324.57 - 13856.0*dum_rt - 47.986*dum_t_ln)*dum_i_p05 &\n         & + (-771.54 + 35474.0*dum_rt + 114.723*dum_t_ln)*dum_i &\n         & -2698.0*dum_rt*dum_i_p15 + 1776.0*dum_rt*dum_i_p20\n  end function fun_calc_lnkhso4\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkhso4_khoo to calculate the dissociation constant of hso4 based on the Khoo et al. 1977 formula. The function should have 2 input parameters of type real, and the output should be a real value. The function should follow the free pH scale and return the result in units of [mol (kg-sol)^-1].", "input": "", "output": "  function fun_calc_lnkhso4_khoo(dum_t,dum_i_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkhso4_khoo\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_i_p05\n    ! calculation of the dissociation constant of hso4 [khoo et al. 1977]\n    ! note: free ph scale; [mol (kg-sol)-1] (???)\n    fun_calc_lnkhso4_khoo = log(10**(647.59/dum_t - 6.3451 + 0.019085*dum_t - 0.5208*dum_i_p05))\n  end function fun_calc_lnkhso4_khoo\n"}, {"instruction": "Create a Fortran function named fun_calc_lnkh2s to calculate the dissociation constant of hs using the equation: 225.838 - 13275.3*dum_rt - 34.6435*dum_t_ln + 0.3449*dum_s_p05 - 0.0274*dum_s. The function takes 4 input arguments of type real: dum_rt, dum_t_ln, dum_s, and dum_s_p05. It returns 1 output argument of type real.", "input": "", "output": "  function fun_calc_lnkh2s(dum_rt,dum_t_ln,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnkh2s\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s,dum_s_p05\n    ! calculation of the dissociation constant of hs [millero et al., 1988]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnkh2s = 225.838 - 13275.3*dum_rt - 34.6435*dum_t_ln + 0.3449*dum_s_p05 - 0.0274*dum_s\n  end function fun_calc_lnkh2s\n"}, {"instruction": "Create a Fortran function named fun_calc_lnknh4 to calculate the dissociation constant of NH4 based on the Yao and Millero (1995) formula. The function takes 4 input arguments of type real: dum_t, dum_rt, dum_s, and dum_s_p05. It returns a single real value as the result.", "input": "", "output": "  function fun_calc_lnknh4(dum_t,dum_rt,dum_s,dum_s_p05)\n    implicit none\n    ! result variable\n    real::fun_calc_lnknh4\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_s,dum_s_p05\n    ! calculation of the dissociation constant of nh4 [yao and millero, 1995]\n    ! note: sws ph scale; [mol (kg-sol)-1]\n    fun_calc_lnknh4 = -6285.33*dum_rt + 0.0001635*dum_t - 0.25444 + &\n         & (0.46532 - 123.7184*dum_rt)*dum_s_p05 + (-0.01992 + 3.17556*dum_rt)*dum_s\n  end function fun_calc_lnknh4\n"}, {"instruction": "Create a Fortran function named fun_calc_lnk1_roy that takes 5 real input parameters [dum_rt, dum_t_ln, dum_s_p05, dum_s, dum_s_p15] and returns a real output parameter. The function computes the first carbonic acid apparent ionization constant based on the provided formula. Use the intent(in) attribute to specify that the input parameters are read-only.", "input": "", "output": "  function fun_calc_lnk1_roy(dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15)\n    ! result variable\n    real::fun_calc_lnk1_roy\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15\n    ! first carbonic acid apparent ionization constant [roy et al., 1993]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnk1_roy = 2.83655 - 2307.1266*dum_rt - 1.5529413*dum_t_ln &\n         & + (-0.20760841 - 4.0484*dum_rt)*dum_s_p05 + 0.08468345*dum_s - 0.00654208*dum_s_p15\n  end function fun_calc_lnk1_roy\n"}, {"instruction": "Create a Fortran function named fun_calc_lnk2_roy that calculates the second carbonic acid apparent ionization constant according to the Roy et al. (1993) formula. The function should take 5 input arguments of type real: dum_rt, dum_t_ln, dum_s_p05, dum_s, dum_s_p15. It should return 1 output of type real.", "input": "", "output": "  function fun_calc_lnk2_roy(dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15)\n    ! result variable\n    real::fun_calc_lnk2_roy\n    ! dummy arguments\n    real,intent(in)::dum_rt,dum_t_ln,dum_s_p05,dum_s,dum_s_p15\n    ! second carbonic acid apparent ionization constant [roy et al., 1993]\n    ! note: total ph scale; [mol (kg-sol)-1]\n    fun_calc_lnk2_roy = -9.226508 - 3351.6106*dum_rt - 0.2005743*dum_t_ln &\n         & + (-0.106901773 - 23.9722*dum_rt)*dum_s_p05 + 0.1130822*dum_s - 0.00846934*dum_s_p15\n  end function fun_calc_lnk2_roy\n"}, {"instruction": "Create a Fortran function named fun_calc_lnq_co2 to calculate the natural logarithm of the equilibrium constant for the dissolution of CO2 in water. The function takes 3 input arguments of type real: dum_tr100, dum_rt, and dum_s. It returns a single output of type real.", "input": "", "output": "  function fun_calc_lnq_co2(dum_tr100,dum_rt,dum_s)\n    ! result variable\n    real::fun_calc_lnq_co2\n    ! dummy arguments\n    real,intent(in)::dum_tr100,dum_rt,dum_s\n    ! henry's law constant for co2 with concentrations as moles per kg of solution [weiss, 1974].\n    ! the dependence of the solubility coefficient on hydrostatic pressure is ignored.\n    fun_calc_lnq_co2 = -60.2409 + 93.4517*(100*dum_rt) + 23.3585*log(dum_tr100) &\n         & +dum_s*(0.023517 - 0.023656*(dum_tr100) + 0.0047036*(dum_tr100)**2)\n  end function fun_calc_lnq_co2\n"}, {"instruction": "Write a Fortran function named fun_calc_lnq_o2 that calculates the Henry's law constant for oxygen. The function takes 3 input arguments of type real: dum_tr100, dum_rt, and dum_s. It returns a single real value as the output.", "input": "", "output": "  function fun_calc_lnq_o2(dum_tr100,dum_rt,dum_s)\n    ! result variable\n    real::fun_calc_lnq_o2\n    ! dummy arguments\n    real,intent(in)::dum_tr100,dum_rt,dum_s\n    ! henry's law constant for o2 with concentrations as moles per kg of solution.\n    ! adapted from a formula from millero and sohn [1992] giving o2 solubility in units of umol kg-1,\n    ! back to a henry's law constant for o2 in units of mol kg-1 atm-1.\n    ! the dependence of the solubility coefficient on hydrostatic pressure is ignored.\n    fun_calc_lnq_o2 = -173.9894 + 255.5907*(100.0*dum_rt) + 146.4813*log(dum_tr100) - 22.2040*(dum_tr100) &\n         & + dum_s*(-0.037362 + 0.016504*(dum_tr100) - 0.0020564*(dum_tr100)**2) &\n         & - log(1.0e6) - log(0.20946)\n  end function fun_calc_lnq_o2\n"}, {"instruction": "Create a Fortran function named fun_calc_logkcal to calculate the solubility constant of calcite. This function takes 6 input arguments of real type: dum_t, dum_rt, dum_t_log, dum_s, dum_s_p05, and dum_s_p15. The output of the function is a real number. Use the following formula to compute the result: \n\nfun_calc_logkcal = -171.9065 - 0.077993*dum_t + 2839.319*dum_rt + 71.595*dum_t_log + (-0.77712 + 0.0028426*dum_t + 178.34*dum_rt)*dum_s_p05 - 0.07711*dum_s + 0.0041249*dum_s_p15", "input": "", "output": "  function fun_calc_logkcal(dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15)\n    ! result variable\n    real::fun_calc_logkcal\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15\n    ! calculation of the solubility constant of calcite.\n\n    fun_calc_logkcal = -171.9065 - 0.077993*dum_t + 2839.319*dum_rt + 71.595*dum_t_log &\n         & + (-0.77712 + 0.0028426*dum_t + 178.34*dum_rt)*dum_s_p05 - 0.07711*dum_s + 0.0041249*dum_s_p15\n  end function fun_calc_logkcal\n"}, {"instruction": "Write a Fortran function named fun_calc_logkarg that calculates the solubility constant of aragonite. The function takes 6 input arguments of type real: dum_t, dum_rt, dum_t_log, dum_s, dum_s_p05, and dum_s_p15. The output is a single real value representing the calculated solubility constant.", "input": "", "output": "  function fun_calc_logkarg(dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15)\n    ! result variable\n    real::fun_calc_logkarg\n    ! dummy arguments\n    real,intent(in)::dum_t,dum_rt,dum_t_log,dum_s,dum_s_p05,dum_s_p15\n    ! calculation of the solubility constant of aragonite.\n    fun_calc_logkarg = -171.945 - 0.077993*dum_t + 2903.293*dum_rt + 71.595*dum_t_log &\n         & + (-0.068393 + 0.0017276*dum_t + 88.135*dum_rt)*dum_s_p05 - 0.10018*dum_s + 0.0059415*dum_s_p15\n  end function fun_calc_logkarg\n"}, {"instruction": "Create a Fortran function named fun_corg_rfrac to calculate carbon isotope fractionation. The function takes 5 input parameters of type real and logical, and returns 1 output parameter of type real. The function computes the carbon isotope fractionation between dissolved inorganic carbon and particulate organic carbon. Use the imperative tone to define the function.", "input": "", "output": "  function fun_corg_rfrac(dum_t,dum_conc_co2,dum_co2_r13c,dum_corg_ef,dum_14c)\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real::fun_corg_rfrac\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    real::dum_t\n    real::dum_conc_co2\n    real::dum_co2_r13c\n    real::dum_corg_ef\n    logical::dum_14c\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    real::loc_kq\n    real::loc_delta_corg\n    real::loc_alpha\n    real::loc_r\n    ! -------------------------------------------------------- !\n    ! calculate carbon isotope fractionation between dic and poc\n    ! -------------------------------------------------------- !\n    ! note: double fractionation for 14c\n    loc_kq = const_d13c_dic_corg_q2_c + const_d13c_dic_corg_q2_x*dum_t + const_d13c_dic_corg_q2_x2*dum_t**2\n    loc_delta_corg = -dum_corg_ef + (dum_corg_ef - const_d13c_dic_corg_ed)*loc_kq/dum_conc_co2\n    if (dum_14c) loc_delta_corg = 2.0*loc_delta_corg\n    loc_alpha = 1.0 + loc_delta_corg/1000.0\n    loc_r = dum_co2_r13c/(1.0 - dum_co2_r13c)\n\n    fun_corg_rfrac = loc_alpha*loc_r/(1.0 + loc_alpha*loc_r)\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_corg_rfrac\n"}, {"instruction": "Create a Fortran function named boundary_npiece to determine the number of pieces in the boundary definition. The function takes 1 input argument of type integer. The output consists of 1 integer indicating the number of pieces. If boundary_npiece is less than or equal to 0, the domain is defined by triangle data files.", "input": "", "output": "function boundary_npiece(hole)\n!        ---------------\n\n!----------------------------------------------------\n! this routine gives the number of pieces in the boundary definition.\n! if boundary_npiece <= 0 the domain is given by triangle data files.\n!----------------------------------------------------\n\n!----------------------------------------------------\n\nimplicit none\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(in) :: hole\ninteger :: boundary_npiece\n!----------------------------------------------------\n! begin executable code\n\nboundary_npiece = 0\n\nend function boundary_npiece\n"}, {"instruction": "Write a Fortran function named fib_seq to generate the nth number in the Fibonacci sequence. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter test_data type is ['integer'], and the output parameter test_data type is ['integer'].", "input": "", "output": "    function fib_seq(n)\n        integer :: fib_seq\n        integer, intent(in) :: n\n        integer :: j, f_pp, f_p, f\n\n        f_pp = 0\n        f_p  = 1\n        do j = 2, n\n            f    = f_p + f_pp\n            f_pp = f_p\n            f_p  = f\n        end do\n        fib_seq = f\n        return\n    end function fib_seq\n"}, {"instruction": "Create a Fortran function named legendobs to return a specific description for a given integer input. The function takes 2 input parameters of type integer and integer array, and returns 1 output parameter of type character with a length of 52 characters.", "input": "", "output": " function legendobs(iarg,printcodsub)\n \n!***********************************************************************\n!     \n\n!     the integer contained in the printcod array\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: printcodsub\n  \n  character(len=52) :: legendobs\n  \n  legendobs=repeat(' ',52)\n  if(printcodsub(iarg)==1)then\n    legendobs='dens1 =  mean fluid density of first component    '\n  elseif(printcodsub(iarg)==2)then\n    legendobs='dens2 =  mean fluid density of second component   '\n  elseif(printcodsub(iarg)==3)then\n    legendobs='maxd1 =  max fluid density of first component     '\n  elseif(printcodsub(iarg)==4)then\n    legendobs='maxd2 =  max fluid density of second component    '\n  elseif(printcodsub(iarg)==5)then\n    legendobs='mind1 =  min fluid density of first component     '\n  elseif(printcodsub(iarg)==6)then\n    legendobs='mind2 =  min fluid density of second component    '\n  elseif(printcodsub(iarg)==7)then\n    legendobs='maxvx =  max fluid velocity of fluid mix along x  '\n  elseif(printcodsub(iarg)==8)then\n    legendobs='minvx =  min fluid velocity of fluid mix along x  '\n  elseif(printcodsub(iarg)==9)then\n    legendobs='maxvy =  max fluid velocity of fluid mix along y  '\n  elseif(printcodsub(iarg)==10)then\n    legendobs='minvy =  min fluid velocity of fluid mix along y  '\n  elseif(printcodsub(iarg)==11)then\n    legendobs='maxvz =  max fluid velocity of fluid mix along z  '\n  elseif(printcodsub(iarg)==12)then\n    legendobs='minvz =  min fluid velocity of fluid mix along z  '\n  elseif(printcodsub(iarg)==13)then\n    legendobs='cpur  =  remaining time to the end                '\n  elseif(printcodsub(iarg)==14)then\n    legendobs='cpue  =  elapsed time                             '\n  elseif(printcodsub(iarg)==15)then\n    legendobs='cpu   =  time for every print interval            '\n  elseif(printcodsub(iarg)==16)then\n    legendobs='t     =  unscaled time                            '\n  elseif(printcodsub(iarg)==17)then\n    legendobs='engke =  particle kinetic energy                  '\n  elseif(printcodsub(iarg)==18)then\n    legendobs='engcf =  configurational energy                   '\n  elseif(printcodsub(iarg)==19)then\n    legendobs='engto =  total energy                             '\n  elseif(printcodsub(iarg)==20)then\n    legendobs='tempp =  particle temperature                     '\n  elseif(printcodsub(iarg)==21)then\n    legendobs='maxpv =  max particle velocity                    '\n  elseif(printcodsub(iarg)==22)then\n    legendobs='pvx   =  mean particle velocity along x           '\n  elseif(printcodsub(iarg)==23)then\n    legendobs='pvy   =  mean particle velocity along y           '\n  elseif(printcodsub(iarg)==24)then\n    legendobs='pvz   =  mean particle velocity along z           '\n  elseif(printcodsub(iarg)==25)then\n    legendobs='fvx   =  mean fluid velocity along x              '\n  elseif(printcodsub(iarg)==26)then\n    legendobs='fvy   =  mean fluid velocity along y              '\n  elseif(printcodsub(iarg)==27)then\n    legendobs='fvz   =  mean fluid velocity along z              '\n  elseif(printcodsub(iarg)==28)then\n    legendobs='pfx   =  mean particle force along x              '\n  elseif(printcodsub(iarg)==29)then\n    legendobs='pfy   =  mean particle force along y              '\n  elseif(printcodsub(iarg)==30)then\n    legendobs='pfz   =  mean particle force along z              '\n  elseif(printcodsub(iarg)==31)then\n    legendobs='engrt =  rotational energy                        '\n  elseif(printcodsub(iarg)==32)then\n    legendobs='engkf =  fluid kinetic energy                     '\n  elseif(printcodsub(iarg)==33)then\n    legendobs='intph =  fluid interphase volume fraction         '\n  elseif(printcodsub(iarg)==34)then\n    legendobs='rminp =  min pair distance between particles      '\n  elseif(printcodsub(iarg)==35)then\n    legendobs='pvm   =  mean particle velocity module            '\n  elseif(printcodsub(iarg)==36)then\n    legendobs='pfm   =  mean particle force module               '\n  endif\n  legendobs=adjustl(legendobs)\n  \n  return\n  \n end function legendobs\n"}, {"instruction": "Create a Fortran function named legendobs_vtk that takes two input parameters: an integer iarg and an allocatable array of integers printcodsub. The output is a character string of length 52. The function should return a description corresponding to the integer value in the printcodsub array for vtk files. The function should be described using imperative tone.", "input": "", "output": " function legendobs_vtk(iarg,printcodsub)\n \n!***********************************************************************\n!     \n\n!      tothe integer contained in the printcod array for vtk files\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification october 2019\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: printcodsub\n  \n  character(len=52) :: legendobs_vtk\n  \n  legendobs_vtk=repeat(' ',52)\n  if(printcodsub(iarg)==1)then\n    legendobs_vtk='rho1  =  fluid density of first component         '\n  elseif(printcodsub(iarg)==2)then\n    legendobs_vtk='rho2  =  fluid density of second component        '\n  elseif(printcodsub(iarg)==3)then\n    legendobs_vtk='phase =  phase field of the two fluid components  '\n  elseif(printcodsub(iarg)==4)then\n    legendobs_vtk='vel   =  vector velocity field of the fluid       '\n  elseif(printcodsub(iarg)==5)then\n    legendobs_vtk='part  =  particle positions and orientations      '\n  endif\n  legendobs_vtk=adjustl(legendobs_vtk)\n  \n  return\n  \n end function legendobs_vtk\n"}, {"instruction": "Create a Fortran function named legendobs_xyz to return a specific string description based on the integer input iarg and the integer array xyzcod. The number of input parameters is 2, with test_data type ['integer', 'integer, allocatable, dimension(:)'], and the number of output parameters is 1 with test_data type ['character(len=52)'].", "input": "", "output": " function legendobs_xyz(iarg,xyzcod)\n \n!***********************************************************************\n!     \n\n!     the integer contained in the xyzcod array\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n \n  implicit none\n  \n  integer, intent(in) :: iarg\n  integer, intent(in), allocatable, dimension(:) :: xyzcod\n  \n  character(len=52) :: legendobs_xyz\n  \n  legendobs_xyz=repeat(' ',52)\n!  if(xyzcod(iarg)==1)then\n!    legendobs_xyz='char =  charge of the particle                    '\n!  else\n  if(xyzcod(iarg)==2)then\n    legendobs_xyz='mass =  mass of the particle                      '\n  elseif(xyzcod(iarg)==3)then\n    legendobs_xyz='radx =  radius of the particle along x            '\n  elseif(xyzcod(iarg)==4)then\n    legendobs_xyz='rady =  radius of the particle along y            '\n  elseif(xyzcod(iarg)==5)then\n    legendobs_xyz='radz =  radius of the particle along z            '\n  elseif(xyzcod(iarg)==6)then\n    legendobs_xyz='rad  =  radius of the spherical particle          '\n  elseif(xyzcod(iarg)==7)then\n    legendobs_xyz='vx   =  particle velocity along x                 '\n  elseif(xyzcod(iarg)==8)then\n    legendobs_xyz='vy   =  particle velocity along y                 '\n  elseif(xyzcod(iarg)==9)then\n    legendobs_xyz='vz   =  particle velocity along z                 '\n  elseif(xyzcod(iarg)==10)then\n    legendobs_xyz='ox   =  particle angular velocity along x         '\n  elseif(xyzcod(iarg)==11)then\n    legendobs_xyz='oy   =  particle angular velocity along y         '\n  elseif(xyzcod(iarg)==12)then\n    legendobs_xyz='oz   =  particle angular velocity along z         '\n  elseif(xyzcod(iarg)==13)then\n    legendobs_xyz='phi  =  first euler angle [\u2212pi,pi]                '\n  elseif(xyzcod(iarg)==14)then\n    legendobs_xyz='theta=  second euler angle [\u2212pi/2,pi/2]           '\n  elseif(xyzcod(iarg)==15)then\n    legendobs_xyz='psi  =  third euler angle [\u2212pi,pi]                '\n  endif\n  legendobs_xyz=adjustl(legendobs_xyz)\n  \n  return\n  \n end function legendobs_xyz\n"}, {"instruction": "Write a Fortran function named ampere_poisson_deriv to calculate the derivatives of the given input parameters. The function takes 8 input parameters of type real and dimension(3) and 7 input parameters of type real. It returns 1 output parameter of type real and dimension(3).", "input": "", "output": "  function ampere_poisson_deriv(u, vdi, ti0, tib, vde, te0, teb, nb) result(dudx)\n    ! az = u[1]; by = u[2]; pot = u[3]\n    implicit none\n    ! output\n    real, dimension(3) :: dudx\n    ! input\n    real, dimension(3), intent(in) :: u\n    real, intent(in) :: vdi, ti0, tib, vde, te0, teb, nb\n\n    ! local data\n    real :: exp_i0, exp_e0, exp_ib, exp_eb\n\n    exp_i0 = exp((-u(3) + vdi * u(1)) / ti0)\n    exp_e0 = exp((u(3) - vde * u(1)) / te0)\n    exp_ib = exp(-u(3) / tib)\n    exp_eb = exp(u(3) / teb)\n\n    ! d/dx (az)\n    dudx(1) = -u(2)\n    ! d/dx (by)\n    dudx(2) = vdi * exp_i0 - vde * exp_e0\n    ! d/dx (pot)\n    dudx(3) = -u(2) * (vdi / ti0 * exp_i0 + vde / te0 * exp_e0) &\n      &/ (exp_i0 / ti0 + nb * exp_ib / tib + exp_e0 / te0 + nb * exp_eb / teb)\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named charge_density to calculate the total charge density in Lembege-Pellat current sheet. The function takes 9 input arguments of type real (pot, az, vdi, ti0, tib, vde, te0, teb, nb) and returns 1 output argument of type real.", "input": "", "output": "  function charge_density(pot, az, vdi, ti0, tib, vde, te0, teb, nb) result(rho)\n    ! total charge density in lembege-pellat current sheet\n    implicit none\n    ! output\n    real :: rho\n    ! input\n    real, intent(in) :: pot, az, vdi, ti0, tib, vde, te0, teb, nb\n\n    rho = exp((-pot + vdi * az) / ti0) + nb * exp(-pot / tib)&\n      & - exp((pot - vde * az) / te0) - nb * exp(pot / teb)\n    return\n  end function\n"}, {"instruction": "Write a Fortran function named linspace that generates a set of linearly spaced numbers between a start and end value. The function should have 3 input parameters of real, real, and integer types, representing the start, end, and the number of samples respectively. The single output parameter should be an array of real numbers with a dimension defined by the number of samples.", "input": "", "output": "  function linspace(start, end, num) result(samples)\n    implicit none\n    ! input\n    real, intent(in) :: start, end\n    integer, intent(in) :: num\n    ! output\n    real, dimension(num) :: samples\n    ! local data\n    real :: step\n    integer :: j\n\n    step = (end - start) / real(num - 1)\n\n    samples = (/ (start + (j - 1) * step, j = 1, num) /)\n  end function\n"}, {"instruction": "Create a Fortran function named besself2 that calculates the value of a special function. The function should accept 4 input parameters of type integer: np, lp, n, and l. It should return a single output parameter of type real(kind=8).", "input": "", "output": "    function besself2(np,lp,n,l)\n      implicit none\n      integer, intent(in) :: np,lp,n,l\n      real(kind=8) :: besself2\n\n      besself2 = sqrt(gamma(np+lp+0.5d0) * gamma(n+l+0.5d0))\n\n    end function besself2\n"}, {"instruction": "Write a Fortran function named gammas_regular to calculate the regular part of a particular gamma factor. The function takes 5 input parameters of type integer (m, mp, l, lp, bigl) and returns 1 output parameter of type real(kind=8).", "input": "", "output": "    function gammas_regular(m,mp,l,lp,bigl)\n        implicit none\n        integer, intent(in) :: m, mp, l, lp,bigl\n        real(kind=8) :: gammas_regular\n\n        gammas_regular = gamma((l+lp+bigl+2*m+2*mp+3.d0)/2.d0) &\n            / gamma(l+m+3.d0/2.d0) / gamma(lp+mp+3.d0/2.d0)\n\n    end function gammas_regular\n"}, {"instruction": "Write a Fortran function named gammas_plusminus to compute the ratio of three gamma functions. The function takes 5 input parameters of type integer: m, mp, l, lp, and bigl. It returns 1 output parameter of type real(kind=8).", "input": "", "output": "    function gammas_plusminus(m,mp,l,lp,bigl)\n        implicit none\n        integer, intent(in) :: m, mp, l, lp, bigl\n        real(kind=8) :: gammas_plusminus\n\n        gammas_plusminus =  gamma((l+lp+bigl+2*m+2*mp+2.d0)/2.d0) &\n            / gamma(l+m+3.d0/2.d0) / gamma(lp+mp+3.d0/2.d0)\n\n    end function gammas_plusminus\n"}, {"instruction": "Write a Fortran function named grouppath to generate the path of a specific atom group based on the input integer itype. The function has 1 input parameter of type integer and 1 output parameter of type character with variable length and allocatable.", "input": "", "output": "  function grouppath(itype)\n    implicit none\n    integer,intent(in)::itype\n    character(len=:),allocatable::grouppath\n    character(len=100)::str\n    write(str,\"(a,i0,a)\") '/fleurinput/atomgroups/atomgroup[',itype,']'\n    grouppath=trim(str)\n  end function grouppath\n"}, {"instruction": "Write a Fortran function named countstringtokens that takes a single string input argument of type character(*) and returns the number of tokens in the input string as an integer output argument. The input argument should be of type ['character(*)'] and the output argument should be of type ['integer'].", "input": "", "output": "   function countstringtokens(line) result(tokencount)\n\n      implicit none\n\n      character(*), intent(in) :: line\n      integer                  :: tokencount\n\n      character(len=len(line)) :: templine\n      integer separatorindex\n\n      tokencount = 0\n\n      templine = trim(adjustl(line))\n\n      do while (templine.ne.'')\n         separatorindex = 0\n         separatorindex = index(templine,' ')\n         if (separatorindex.eq.0) then\n            templine = ''\n         else\n            templine = trim(adjustl(templine(separatorindex+1:)))\n         end if\n         tokencount = tokencount + 1\n      end do\n\n   end function countstringtokens\n"}, {"instruction": "Create a Fortran function called \"sim_geth_s\" that calculates a value based on the input parameters \"phi\" and \"d,\" both of which are real numbers. The function returns a real number as the output. If the value of \"phi\" is less than -d, the output is 0.0. If the value of \"phi\" is greater than d, the output is 1.0. Otherwise, the output is 0.5 times (phi + d) divided by d.", "input": "", "output": "function sim_geth_s(phi, d)\n  implicit none\n  real          :: sim_geth_s\n  real          :: phi\n\treal\t\t\t\t\t:: d\n\tsim_geth_s = 1.0\n\tif( phi < -d ) then\n\t\tsim_geth_s = 0.0\n\telse if( phi > d ) then\n\t\tsim_geth_s = 1.0\n\telse\n\t\tsim_geth_s = 0.5*(phi + d)/d\n\tend if\n  return\nend function sim_geth_s\n"}, {"instruction": "Create a Fortran function named sim_getminmod to calculate the minimum of two real numbers. The function should take 2 real numbers as input and return the minimum of the two numbers as a real output.", "input": "", "output": "function sim_getminmod(a, b)\n  implicit none\n  real          :: sim_getminmod\n  real          :: a, b\n!  sim_getminmod = 0.5*(sign(a, a) + sign(b, b))*min(abs(a), abs(b))\n  sim_getminmod = 0.0\n  if( abs(a) .lt. abs(b) ) then\n    sim_getminmod = a\n  else if( abs(a) .gt. abs(b) ) then\n    sim_getminmod = b\n  endif\n  return\nend function sim_getminmod\n"}, {"instruction": "Write a Fortran function named sim_getux to calculate the x-component of the velocity field. The function takes 6 input arguments of type real: x, y, z, omega, zmin, rmin. It returns 1 output argument of type real.", "input": "", "output": "function sim_getux(x, y, z, omega, zmin, rmin)\n\timplicit none\n\treal\t\t\t\t\t:: sim_getux\n\treal\t\t\t\t\t:: x, y, z, omega, zmin, rmin\n\treal\t\t\t\t\t:: r2, rl, theta\n\treal\t\t\t\t\t:: nx, ny, nz\n\treal\t\t\t\t\t:: ux, uy, uz\n\tr2 = x*x + y*y\n\trl = sqrt(r2)\n\ttheta = atan(x)\n\tnx = x/rl\n\tny = y/rl\n\tnz = z/rl\n\tux =-rl*omega*ny\n\tuy =+rl*omega*nx\n\tuz = 0.0\n\tux =-omega*y\n\tuy =+omega*x\n\tuz = 0.0\n\tif( rl < rmin .and. z > zmin ) then\n\t\tux = 0.0\n\t\tuy = 0.0\n\t\tuz = 0.0\n\tend if\n\tsim_getux = ux\n\treturn\nend function sim_getux\n"}, {"instruction": "Create a Fortran pure function named get_version_mmr to extract the major.minor.release part of a version string. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "pure function get_version_mmr(v)\n!! get the major.minor.release part of a version string\n!! cuts off further patch and arbitrary text\ncharacter(:), allocatable :: get_version_mmr\ncharacter(*), intent(in) :: v\n\ninteger :: i, j, k, e\n\nk = index(v, '.')\nj = index(v(k+1:), '.')\ni = scan(v(k+j+1:), '.-_ ')\nif (i == 0) then\n  e = len_trim(v)\nelse\n  e = k + j + i - 1\nend if\n\nget_version_mmr = v(:e)\n\nend function get_version_mmr\n"}, {"instruction": "Create a Fortran function named jfunc3 that takes three real*8 input parameters and returns a real*8 output. The function computes the value of (1 - exp(-(k + l) * t)) / (k + l).", "input": "", "output": "function jfunc3(k,l,t)\n\n    implicit none\n\n\n    real*8 :: k,l,t\n    real*8 :: jfunc3\n\n    jfunc3=(1.-exp(-(k+l)*t))/(k+l)\n\nend function jfunc3\n"}, {"instruction": "Create a Fortran function named hill_inh that calculates the Hill inhibition function. This function takes 3 input parameters of type integer, double precision, and double precision, and returns 1 output parameter of type double precision.", "input": "", "output": "function hill_inh(x, x0, n)\n   implicit none\n   integer, intent(in) :: n\n   double precision,intent(in) :: x, x0\n   double precision :: hill_inh\n   \n   double precision :: a\n   \n   a = (x/x0)**n\n   hill_inh = 1/(1+a)\n   \nend function hill_inh\n"}, {"instruction": "Create a Fortran function called root that takes an array of 10 real numbers as input and returns the sum of all the elements in the array. The input parameter should be of type real, dimension(10) and the output parameter should be of type real.", "input": "", "output": "\tfunction root(x) result(r)\n\t\treal, dimension(10) :: x\n\t\treal :: r\n\t\tinteger :: i\n\n\t\tr = 0\n\n\t\tdo i = 1, 10\n\t\t\tr = r + x(i)\n\t\tend do\n\n\tend function\n"}, {"instruction": "Create a Fortran function named l2_distance that calculates the L2 distance between two sets of points in high-dimensional space. The function takes 11 input parameters of types ['double precision, dimension(:,:)', 'double precision, dimension(:,:)', 'integer', 'integer', 'integer', 'integer', 'integer, dimension(:)', 'integer, dimension(:)', 'double precision, dimension(:)', 'double precision, dimension(:)', 'double precision, dimension(:,:)'], and returns 1 output parameter of type ['double precision'].", "input": "", "output": "function l2_distance(x1, x2, n1, n2, q1, q2, qall1, qall2, ksi1, ksi2, pd) result(aa)\n\n    implicit none\n\n    double precision, dimension(:,:), intent(in) :: x1\n    double precision, dimension(:,:), intent(in) :: x2\n\n    integer, intent(in) :: n1\n    integer, intent(in) :: n2\n\n    integer, intent(in) :: q1\n    integer, intent(in) :: q2\n\n    integer, dimension(:), intent(in) :: qall1\n    integer, dimension(:), intent(in) :: qall2\n\n    double precision, dimension(:), intent(in) :: ksi1 \n    double precision, dimension(:), intent(in) :: ksi2\n\n    double precision, dimension(:,:), intent(in) :: pd\n\n    double precision :: a, b, c, d, e\n    integer :: i, j, k, l\n\n    double precision :: aa\n    double precision :: ddist\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n    double precision, parameter :: t_width = pi / 4.0d0 ! ~0.7853981633974483\n    double precision, parameter :: d_width = 0.2d0\n    double precision, parameter :: cut_distance = 6.0d0\n    double precision, parameter :: r_width = 1.0d0\n    double precision, parameter :: c_width = 0.5d0\n\n    double precision, parameter :: inv_cut = pi / (2.0d0 * cut_distance)\n    double precision, parameter :: sqrt_pi = sqrt(pi)\n\n    double precision, parameter :: t_fast = -1.0d0 / (4.0d0 * t_width**2)\n    double precision, parameter :: d_fast = -1.0d0 / (4.0d0 * d_width**2)\n    double precision :: maxgausdist2 = (8.0d0 * d_width)**2\n\n    a = 1.0d0 / (sum(ksi1(:n1)) * sum(ksi2(:n2))) &\n        &  * sqrt_pi * d_width * r_width**4 * c_width**4 &\n        & * pd(q1, q2)\n    \n    b = 0.0d0\n\n    do i = 1,  n1\n        c = 0.0d0\n        if (x1(1,i) > cut_distance) exit\n\n        do j = 1, n2\n            d = 0.0d0\n\n            if (x2(1,j) > cut_distance) exit\n            ddist = (x1(1,i) - x2(1,j))**2\n\n            if (ddist < maxgausdist2) then\n\n                do k = 1, n1\n                    e = 0.0d0\n\n                    do l = 1, n2\n                         e = e + ksi2(l) * exp((x1(i+3,k) - x2(j+3,l))**2 * t_fast)\n\n                    enddo\n                    d = d + e * ksi1(k)\n\n                enddo\n                c = c + d * exp(ddist * d_fast) * ksi2(j) &\n                    & * pd(qall1(i), qall2(j))\n            endif\n\n        enddo\n        b = b + c * ksi1(i)\n\n    enddo\n\n    aa = a * b\n    \nend function l2_distance\n"}, {"instruction": "Create a Fortran function named count_digits to determine the number of digits in a given real*16 number. The function has 1 input parameter of type real*16. The output is an integer representing the count of digits in the input number.", "input": "", "output": "  pure function count_digits(n)\n    real*16, intent(in) :: n\n    real*16             :: temp\n    integer             :: count_digits\n\n    temp=log10(n)\n    count_digits=int(ceiling(temp))\n    if (temp==0.0) then\n       count_digits=1\n    else if (mod(temp,1.0q0)==0.0q0) then\n       count_digits=count_digits-1\n    end if\n\n  end function count_digits\n"}, {"instruction": "Create a Fortran function named matches to check if string1 is contained in string2. The function takes 2 input parameters of type character (len=*) and returns 1 output parameter of type logical. If string1 is found in string2, the function returns .true.; otherwise, it returns .false.", "input": "", "output": "function matches( string1, string2 )  \n  !-----------------------------------------------------------------------\n  !\n  ! ... .true. if string1 is contained in string2, .false. otherwise\n  !\n  implicit none\n  !\n  character (len=*), intent(in) :: string1, string2\n  logical                       :: matches\n  integer                       :: len1, len2, l  \n  !\n  !\n  len1 = len_trim( string1 )  \n  len2 = len_trim( string2 )  \n  !\n  do l = 1, ( len2 - len1 + 1 )  \n     !   \n     if ( string1(1:len1) == string2(l:(l+len1-1)) ) then  \n        !\n        matches = .true.  \n        !\n        return  \n        !\n     end if\n     !\n  end do\n  !\n  matches = .false.\n  ! \n  return\n  !\nend function matches\n"}, {"instruction": "Create a Fortran function named everett to compute the result of the Everett bilinear function. The function takes 2 input arguments of type double precision, named alpha and beta. It returns 1 output argument of type double precision. If the result is negative, it is set to 0.0d0.", "input": "", "output": "  function everett(alpha,beta )\n    ! description :\n    ! calcul de la fonction d'everett bilineaire.\n    implicit none\n    ! inputs :\n    double precision, intent(in)                            :: alpha, beta\n    ! outputs :\n    double precision                                        :: everett\n    \n    everett = -alpha*beta\n    if ( everett < 0.0d0 ) everett = 0.0d0\n    \n    return\n  end function everett\n"}, {"instruction": "Create a Fortran function named deverettdb to calculate the derivative of the bilinear Everett function. The function takes 2 input parameters of type double precision and returns 1 output parameter of type double precision. If the product of the input parameters is less than 0, the output is set to the negative value of the first input parameter; otherwise, the output is set to 0.", "input": "", "output": "  function deverettdb(alpha,beta )\n    ! description :\n    ! calcul de la derivee de la fonction d'everett bilineaire.\n    implicit none\n    ! inputs :\n    double precision, intent(in)                            :: alpha, beta\n    ! outputs :\n    double precision                                        :: deverettdb\n    \n    if ( alpha*beta < 0.0d0 ) then\n      deverettdb = -alpha\n    else\n      deverettdb = 0.0d0\n    end if\n    \n    return\n  end function deverettdb\n"}, {"instruction": "Create a Fortran function named pmod that calculates the positive remainder of a division operation. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters should be named a and b, while the output parameter should be named res.", "input": "", "output": "function pmod(a, b) result(res)\n   implicit none\n   integer, intent(in) :: a, b\n   integer :: res\n\n   res = mod(b + mod(a,b), b)\n\nend function\n"}, {"instruction": "Write a Fortran function named cleanstring that takes a single input parameter of type character(len=256) and returns a single output parameter of the same type. The function should remove any trailing whitespace from the input string and return the modified string.", "input": "", "output": "  function cleanstring(str)\n    use iso_c_binding\n    implicit none\n    character(len=256) :: cleanstring\n    character(len=256) :: str\n    cleanstring = trim(str)//c_null_char\n  end function\n"}, {"instruction": "Create a Fortran function named pi to approximate the value of pi using a Monte Carlo method. The function takes 1 input argument of type integer (samples) and returns 1 output argument of type real.", "input": "", "output": "  function pi(samples)\n    real :: pi\n    real :: coords(2), length\n    integer :: i, in_circle, samples\n\n    in_circle = 0\n    do i=1, samples\n      call random_number(coords)\n      coords = coords * 2 - 1\n      length = sqrt(coords(1)*coords(1) + coords(2)*coords(2))\n      if (length <= 1) in_circle = in_circle + 1\n    end do\n    pi = 4.0 * real(in_circle) / real(samples)\n  end function pi\n"}, {"instruction": "Create a Fortran function named quickaarr that takes one integer input argument, xind. The function returns an array of two integers as output. The input argument should be of type integer, and the output should be an integer array of dimension 2.", "input": "", "output": "  function quickaarr(xind)\n    implicit none\n    integer, dimension(2) :: quickaarr\n    integer, save :: temp(2)\n    integer,intent(in) :: xind\n    integer :: ind,q\n\n    ind=xind-1\n!orderflag 0\n    temp(2)           = mod(ind,2)+1\n!!       q=(ind-mod(ind,2))/2  no need\n    q=ind/2                   !! rounds down.\n    temp(1)           = q+1\n    quickaarr=temp\n  end function quickaarr\n"}, {"instruction": "Create a Fortran function named \"g\" that takes one real number as input and returns a real number. The function sets the output value to be equal to the input value.", "input": "", "output": "  function g(gx)\n    != unit 'b :: gx\n    real :: gx, gn, gm, g\n    gm = gx\n    gn = gm\n    g = gn\n  end function g\n"}, {"instruction": "Create a Fortran function named score to calculate the score using the given input integers. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input parameters are x and y, and the output parameter is score.", "input": "", "output": "  pure function score(x,y)\n    implicit none\n    integer, intent(in) :: x,y\n    integer             :: u,v,i,j,score\n\n    score=0\n    do i=1,x\n       u=(x+1-i)\n       do j=1,y\n          v=(y+1-j)\n          score=score+(u*v)\n       end do\n    end do\n    \n  end function score\n"}, {"instruction": "Write a Fortran function named uppercase to convert a single lowercase character to uppercase. The number of input arguments is 1, and the test_data type is ['character(len=1)']. The number of output arguments is 1, and the test_data type is ['character(len=1)'].", "input": "", "output": "function uppercase(str) result (strup)\n  character(len=1), intent(in) :: str\n  character(len=1) :: strup\n  strup=str\n  if ((ichar(str) >= ichar(\"a\")) .and. (ichar(str) <= ichar(\"z\"))) then \n     strup = char(ichar(\"a\")+ichar(str)-ichar(\"a\"))\n  end if\nend function uppercase\n"}, {"instruction": "Create a Fortran function named chease_chi_index to determine the index value for the \"chease\" code based on the input values of nchi and itheta. The function accepts 2 input parameters of type integer and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  function chease_chi_index(nchi,itheta)\n    integer, intent(in) :: nchi, itheta\n    integer :: chease_chi_index\n    ! when ichi = 0, itheta = (ntheta-1)/2 + 1\n    ! when itheta = 0, ichi = ntheta / 2\n    ! itheta  1 2 3 4 5 6 7 8 \n    ! ichi    5 6 7 8 1 2 3 4         \n    if (itheta > nchi/2) then \n       chease_chi_index = itheta - nchi/2\n    else\n       chease_chi_index = itheta + nchi/2\n    end if\n  end function chease_chi_index\n"}, {"instruction": "Create a Fortran function named roundton that rounds a real number to a specified number of decimal places. The function takes 2 input parameters of type real and integer, representing the number to be rounded and the number of decimal places, respectively. The function returns a single real value as the rounded number.", "input": "", "output": "  function roundton(x,n)\n    ! round to n decimal places\n    real,    intent(in)             :: x\n    integer, intent(in)             :: n\n    real                            :: roundton\n\n    real                            :: factor\n\n    factor=10**n\n    roundton=float(int(x * factor  + 0.5)) / factor\n\n  end function roundton\n"}, {"instruction": "Write a Fortran function named str_s1 that concatenates a given character string with a specified delimiter. The function takes in two input arguments of type character(len=*) and character(len=*), optional. It returns one output argument of type character(len=:), allocatable.", "input": "", "output": "  function str_s1(this,delim) result(res)\n    !! interfaced with str()\n  !====================================================================!\n  character(len=*), intent(in) :: this\n  character(len=*),optional, intent(in) :: delim\n  character(len=:),allocatable :: res\n  character(len=:),allocatable :: delim_\n  delim_=' '\n  if(present(delim)) delim_=delim\n  res = trim(this)//delim_\n  end function\n"}, {"instruction": "Create a Fortran function named appendstring that appends two strings together. The function takes 3 input parameters of types character(len=*) and an optional character(len=*) delimiter. It returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "  function appendstring(this,that,delim_) result(res)\n    !! append a string\n  !====================================================================!\n  character(len=*) :: this\n    !! string to append to\n  character(len=*) :: that\n    !! string to append\n  character(len=*),optional :: delim_\n    !! optional delimiter to separate the append\n  character(len=:), allocatable :: res\n    !! appended string\n  if (present(delim_)) then\n    res = trim(this)//trim(delim_)//trim(that)\n  else\n    res = trim(this)//trim(that)\n  endif\n  end function\n"}, {"instruction": "Create a Fortran function named predicate2 to check if a given condition involving two integer parameters is true. The function takes 2 input arguments of type integer and returns 1 output argument of type logical. The test_data type for input arguments is ['integer', 'integer'], and for the output argument is ['logical'].", "input": "", "output": "  pure function predicate2(n,m)\n    implicit none\n    integer, intent(in) :: n,m\n    integer             :: a,b,temp1,temp2,count\n    logical             :: predicate2\n\n    a=n\n    b=m\n    count=0\n    predicate2=.false.\n\n    temp2=mod(b,10)\n    do while (a>0)\n       temp1=mod(a,10)\n       if (temp1==temp2) then\n          b=b/10\n          temp2=mod(b,10)\n          count=count+1\n          if (count==3) then\n             predicate2=.true.\n             return\n          end if\n       end if\n       a=a/10\n    end do\n\n  end function predicate2\n"}, {"instruction": "Write a Fortran function named int2char that takes an integer as input and returns the corresponding character representation. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(:), allocatable'].", "input": "", "output": "  function int2char(i) result(res)\n    character(:),allocatable :: res\n    integer,intent(in) :: i\n    character(range(i)+2) :: tmp\n    write(tmp,'(i0)') i\n    res = trim(tmp)\n  end function int2char\n"}, {"instruction": "Create a Fortran function named f1 to perform a series of operations on an input integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function performs a loop with specific conditions and assigns a value to the output parameter based on the loop iteration.", "input": "", "output": "  function f1 (y)\n    integer, intent(in) :: y\n    integer :: i, f1, x\n    x = y\n    !$omp taskloop firstprivate(x)lastprivate(x)\n    do i = 0, 63\n      if (x .ne. 74) call abort\n      if (i .eq. 63) then\n        x = i + 4\n      end if\n    end do\n    f1 = x\n  end function f1\n"}, {"instruction": "Create a Fortran function named f3 that takes in three 64-bit integer arguments. The input arguments are of type integer(kind=8) and the test_data type is ['integer(kind=8)', 'integer(kind=8)', 'integer(kind=8)']. The function returns a single 64-bit integer result, and the test_data type is ['integer(kind=8)']. The function calculates a value by performing a taskloop and returns the result. Remember to use the imperative tone and reflect the features of Fortran function.", "input": "", "output": "  function f3 (a, b, c)\n    integer(kind=8), intent(in) :: a, b, c\n    integer(kind=8) :: i, f3\n    integer :: l\n    !$omp taskloop default(none) lastprivate (i, l)\n    do i = a, b, c\n      l = i\n    end do\n    !$omp end taskloop\n    f3 = l * 7 + i\n  end function f3\n"}, {"instruction": "Write a Fortran function named fib to calculate the Fibonacci number at the given position. The function has 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  recursive function fib(n) result(fib_n)\n    integer:: fib_n, n\n\n    if (n < 3) then\n      fib_n = 1\n    else\n      fib_n = fib(n-1) + fib(n-2)\n    end if\n\n  end function\n"}, {"instruction": "Write a Fortran function named odd_list that takes an array of integers as input. The number of input parameters is 1, and the test_data type is ['integer, dimension(:)']. The function returns an array of logical values indicating whether each element in the input array is odd. The number of output parameters is 1, and the test_data type is ['logical, dimension(size(a))'].", "input": "", "output": "  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n"}, {"instruction": "Write a Fortran function called i4_bit_lo0 that finds the position of the lowest bit in a 4-byte integer containing a 0. The function takes 1 input parameter of type integer(kind=4) and returns 1 output parameter of type integer.", "input": "", "output": "function i4_bit_lo0(num)\n  implicit none\n\n  integer(kind=4), intent(in) :: num\n  integer :: i4_bit_lo0\n\n  do i4_bit_lo0=1,bit_size(num)\n    if (.not. btest(num,i4_bit_lo0-1)) return\n  enddo\nend function i4_bit_lo0\n"}, {"instruction": "Write a Fortran function named log2 that takes an integer input argument and returns the base-2 logarithm of the input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function log2(vin) result(r)\n  implicit none\n  integer :: r\n  integer, intent(in) :: vin\n  integer :: v\n  r = 0\n  v = vin\n  do\n     v = ishft(v, -1)\n     if ( v == 0 ) exit\n     r = r + 1\n  end do\nend function log2\n"}, {"instruction": "Please create a Fortran recursive function named fact that calculates the factorial of a given integer. The function should take 1 input parameter of type integer and return 1 output parameter of type integer. The input parameter test_data type is ['integer'], and the output parameter test_data type is ['integer'].", "input": "", "output": "recursive function fact(i) result(j)\n    integer, intent(in) :: i\n    integer :: j\n    if (i == 1) then\n        j = 1\n    else\n        j = i * fact(i - 1)\n    end if\nend function fact\n"}, {"instruction": "Write a Fortran function named test1 that takes an integer input argument and returns an empty character string. The function accepts 1 input parameter with the type integer and returns 1 output parameter with the type character(n), where n is the length of the character string to be returned.", "input": "", "output": "function test1(n)\n  integer  :: n\n  character(n) :: test1\n  character(n) :: bar1\n  test1 = \"\"\n  return\nentry bar1()\n  bar1 = \"\"\nend function test1\n"}, {"instruction": "Create a Fortran function named get_line_count to calculate the number of lines in a specified file. The function takes 1 input argument of type character(len=*), denoting the filename, and returns 1 output argument of type integer, representing the number of lines in the file.", "input": "", "output": "    function get_line_count(filename) result (lines)\n        implicit none\n        character(len=*), intent(in) :: filename\n        integer :: fileunit,io\n        integer :: lines\n        \n        open(newunit=fileunit, file=filename, action='read', position='rewind')\n        lines = 0\n        do  \n            read(fileunit,*,iostat=io)\n            if ( io /= 0 ) exit\n            lines = lines + 1\n        end do\n        close(fileunit)\n    end function get_line_count\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function takes 1 input parameter of type integer, marked as value. The output is a single integer.", "input": "", "output": "    function factorial(n) result(fac)\n        implicit none\n        integer, value :: n\n        integer :: fac\n\n        fac = 1\n        do while (n > 1)\n            fac = fac*n\n            n = n - 1\n        end do\n    end function factorial\n"}, {"instruction": "Create a Fortran function named findx2harmpi to calculate the difference between the given theta value and a specific mathematical expression. The number of input arguments is 2, with test_data types ['real(kind=8)', 'real(kind=8), dimension(:)']. The number of output arguments is 1, with a test_data type of ['real(kind=8)'].", "input": "", "output": "        function findx2harmpi(x2,args) result(diff)\n        real(kind=8), intent(in) :: x2\n        real(kind=8), intent(in), dimension(:) :: args\n        real(kind=8) :: h, theta, diff\n        h=args(2); theta=args(1)\n        diff=theta-(pi/2.*(1.+x2)+((1.-h)/2.)*sin(pi*(1.+x2)))\n        end function findx2harmpi\n"}, {"instruction": "Write a Fortran function named findx2harmpi_array to calculate the difference between two arrays. The input consists of two parameters, both of real kind and arrays of different dimensions. The first input parameter is one-dimensional, and the second one is two-dimensional. The output is a one-dimensional real array of the same size as the input x2 array.", "input": "", "output": "        function findx2harmpi_array(x2,args) result(diff)\n        real(kind=8), intent(in), dimension(:) :: x2\n        real(kind=8), intent(in), dimension(:,:) :: args\n        real(kind=8) :: h\n        real(kind=8), dimension(size(x2)) :: theta, diff\n        h=args(1,2); theta=args(:,1)\n        diff=theta-(pi/2d0*(1.+x2)+((1d0-h)/2d0)*sin(pi*(1d0+x2)))\n        end function findx2harmpi_array\n"}, {"instruction": "Write a Fortran function named ftr that operates on an array of double-precision real numbers. The function takes 1 input argument of type real(kind=8), dimension(:), and returns 1 output argument of type real(kind=8), dimension(size(x)). The function computes the result based on the given input array and uses mathematical operations such as cosine and sine, and the merge function to conditionally populate the output array.", "input": "", "output": "        function ftr(x) result(res)\n          real(kind=8), intent(in), dimension(:) :: x\n          real(kind=8), dimension(size(x)) :: res\n          real(kind=8), dimension(size(x)) :: zero,one\n          zero=0.; one=1.\n          res=merge(zero,(64+cos(5*pi*x)+70*sin((pi*(-1+2*x))/2.)+5*sin((3*pi*(-1+2*x))/2.))/128.,x.le.0.)\n          res=merge(res,one,x.lt.1.)\n        end function ftr\n"}, {"instruction": "Create a Fortran function named calcrmks that computes the array r based on the input array x1 for Jon's simulations. The input parameter is a real array of kind 8 and dimension '(:)', while the output parameter is a real array of kind 8 and dimension 'size(x1)'.", "input": "", "output": "        function calcrmks(x1) result(r)\n          ! compute r given x1 for jon's simulations\n          ! jad 7/24/2011\n          real(kind=8), intent(in), dimension(:) :: x1\n!          real(kind=8), intent(in) :: xbr,npow2,cpow2,r0\n!          real(kind=8) :: npow2,cpow2,r0\n          real(kind=8), dimension(size(x1)) :: r, xi\n!          npow2=10d0\n          where(x1.gt.xbr)\n             xi=x1+cpow2*(x1-xbr)**npow2\n          elsewhere\n             xi=x1\n          endwhere\n!          write(6,*) 'calcrmks: ',r0,cpow2,npow2,xbr\n          r=r0+exp(xi)\n        end function calcrmks\n"}, {"instruction": "Create a Fortran function named calcrmks_single to compute a value based on the input x1. The input parameter is of type real(kind=8), and the output parameter is also of type real(kind=8).", "input": "", "output": "        function calcrmks_single(x1) result(r)\n          ! compute r given x1 for jon's simulations\n          ! jad 7/24/2011\n          real(kind=8), intent(in) :: x1\n!          real(kind=8), intent(in) :: xbr,npow2,cpow2,r0\n!          real(kind=8) :: npow2,cpow2,r0\n          real(kind=8)  :: r, xi\n!          npow2=10d0\n          if(x1.gt.xbr) then\n             xi=x1+cpow2*(x1-xbr)**npow2\n          else\n             xi=x1\n          endif\n          r=r0+exp(xi)\n        end function calcrmks_single\n"}, {"instruction": "Create a Fortran function named itoa to convert an integer to a character string. The function should have 1 input argument of type integer and 1 output argument of type character(:),allocatable. The input parameter is 'i' of type integer, and the output parameter is 'res' of type character(:),allocatable.", "input": "", "output": "\t\tfunction itoa(i) result(res)\n\t\t\tcharacter(:),allocatable :: res\n\t\t\tinteger,intent(in) :: i\n\t\t\tcharacter(range(i)+2) :: tmp\n\t\t\twrite(tmp,'(i0)') i\n\t\t\tres = trim(tmp)\n\t\tend function\n"}, {"instruction": "Create a Fortran function called set_boundary_innerxstate to set the inner boundary state variables. The function takes 5 input parameters of type real*8: rho_in, rhvx_in, rhvy_in, rhvz_in, and en_in. It returns a single output parameter of type integer.", "input": "", "output": "function set_boundary_innerxstate(rho_in,rhvx_in,rhvy_in,rhvz_in,en_in) result(ret)\n    implicit none\n    integer :: ret\n    real*8 :: rho_in,rhvx_in,rhvy_in,rhvz_in,en_in    \n    ret = 0\nend function  \n"}, {"instruction": "Create a Fortran function named set_parallel_decomposition to specify the parallel decomposition for a 3D domain. The function takes 3 input arguments of type integer (nx, ny, nz) to represent the domain size in the x, y, and z directions. The output parameter is an integer (ret) indicating the success of the operation.", "input": "", "output": "function set_parallel_decomposition(nx, ny, nz) result(ret)\n    implicit none\n    integer :: ret, ntotal\n    integer, intent(in) :: nx, ny, nz\n    ret = 0\nend function set_parallel_decomposition\n"}, {"instruction": "Create a Fortran function named get_timestep to retrieve the value of the output parameter outputvalue, which is an integer. The function has 1 input parameter of type integer and 1 output parameter of type integer. Set the outputvalue parameter to the desired value within the function.", "input": "", "output": "function get_timestep(outputvalue) result(ret)\n    implicit none\n    integer :: ret\n    integer, intent(out) :: outputvalue\n    ret = 0\nend function get_timestep\n"}, {"instruction": "Create a Fortran function named set_timestep to set the time step value. It takes 1 input parameter, an integer, and returns 1 output parameter, also an integer.", "input": "", "output": "function set_timestep(inputvalue) result(ret)\n    implicit none\n    integer :: ret\n    integer, intent(in) :: inputvalue\n    ret = 0\nend function set_timestep\n"}, {"instruction": "Create a Fortran function named set_gamma to assign the value 0 to the output variable. The function takes 1 input parameter of type double precision and returns 1 output parameter of type integer. The input parameter is named inputvalue and the output parameter is named ret.", "input": "", "output": "function set_gamma(inputvalue) result(ret)\n    implicit none\n    integer :: ret\n    double precision :: inputvalue\n    ret = 0\nend function\n"}, {"instruction": "Create a Fortran function named get_gamma to return an integer value. The function takes one input parameter of type double precision. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_gamma(outputvalue) result(ret)\n    implicit none\n    integer :: ret\n    double precision :: outputvalue\n    ret = 0\nend function\n"}, {"instruction": "Write a Fortran function named rastrigin to calculate the value of the Rastrigin function for a given input array of real numbers. The function takes 1 input parameter of type real(kind = 8), dimension(:) and returns 1 output parameter of type real(kind = 8).", "input": "", "output": "  function rastrigin(x) result(f)\n    real(kind = 8), dimension(:), intent(in) :: x\n    integer(kind = 4) :: n_dim\n    real(kind = 8) :: f, sum1\n\n    n_dim = size(x)\n    sum1 = sum( x**2 - 10.0d0 * cos( 2.0d0 * pi * x ) )\n    f = 10.0d0 * n_dim + sum1\n    return\n  end function rastrigin\n"}, {"instruction": "Create a Fortran function named repsi1 that calculates the function value of repsi1 based on the input parameter x. The input parameter is of type real and is marked as intent(in). The output parameter is also of type real.", "input": "", "output": "      function repsi1(x)  \n        implicit none\n        real, intent(in) :: x\n        real :: repsi1\n\n        real, parameter :: xmin=0.14e0, x1=0.7e0 ,xmax=1.9e0\n        real, parameter :: zeta32=2.404113806319188 ! 2*zeta(3)\n        real, parameter :: zeta54=4.147711020573480 ! 4*zeta(5)\n        real, parameter :: a0= 0.004211521868683916\n        real, parameter :: a1= 2.314767988469241000\n        real, parameter :: a2= 0.761843932767193200\n        real, parameter :: a3=-7.498711815965575000\n        real, parameter :: a4= 7.940030433629257000\n        real, parameter :: a5=-2.749533936429732000\n        real, parameter :: b0=-0.253862873373708200\n        real, parameter :: b1= 4.600929855835432000\n        real, parameter :: b2=-6.761540444078382000\n        real, parameter :: b3= 4.467238548899841000\n        real, parameter :: b4=-1.444390097613873500\n        real, parameter :: b5= 0.185954029179227070\n        real :: xi\n        if ( x .le. xmin) then             ! x < xmin=0.14 \n           repsi1=zeta32*x - zeta54*x*x*x  ! accurate to 0.1%\n        elseif (x .le. x1) then\n           repsi1=a5                       ! xmin < x < x1=0.7\n           repsi1=a4 + repsi1*x            ! accurate to 0.002%\n           repsi1=a3 + repsi1*x            ! a0 + a1*x + a2*x^2 +\n           repsi1=a2 + repsi1*x            ! a3* x^3 + a4*x^4 + a5*x^5\n           repsi1=a1 + repsi1*x\n           repsi1=a0 + repsi1*x\n        elseif (x .le. xmax) then          ! x1 < x < xmax=1.9\n           repsi1=b5                       ! accurate to 0.1%\n           repsi1=b4+repsi1*x              ! b0 + b1*x + b2*x^2 + \n           repsi1=b3+repsi1*x              ! b3*x^3 + b4*x^4 +\n           repsi1=b2+repsi1*x              ! b5*x^5\n           repsi1=b1+repsi1*x              \n           repsi1=b0+repsi1*x            \n        else\n           xi=1/x                          ! x > xmax=1.9\n           repsi1=-1.e0/30.e0              ! accurate to 0.08%\n           repsi1=repsi1*xi                ! 1/x - 1/6x^3 - 1/30x^5\n           repsi1=-1.e0/6.d0 + repsi1*xi   ! \n           repsi1=repsi1*xi                !\n           repsi1=1.e0 + repsi1*xi         !\n           repsi1=repsi1*xi                !\n        endif\n      end function repsi1\n"}, {"instruction": "Create a Fortran function named repsi2 to calculate the value of a function based on the input real number x. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "      function repsi2(x) \n        implicit none\n        real, intent(in) :: x\n        real :: repsi2\n        real, parameter :: xmin=0.18e0, x1=1.2e0 ,xmax=2.5e0\n        real, parameter :: zeta32=2.4041138063191880 ! 2*zeta(3)\n        real, parameter :: zeta512=12.44313306172044 ! 12*zeta(5)\n        real, parameter :: zeta730=30.250478321457685! 30*zeta(7)\n        real, parameter :: a0= 2.42013533575662130\n        real, parameter :: a1=-0.41115258967949336\n        real, parameter :: a2=-8.09116694062588400\n        real, parameter :: a3=-24.9364824558827640\n        real, parameter :: a4=114.8109056152471800\n        real, parameter :: a5=-170.854545232781960\n        real, parameter :: a6=128.8402466765824700\n        real, parameter :: a7=-50.2459090010302060 \n        real, parameter :: a8= 8.09941032385266400\n        real, parameter :: b0= 4.98436272402513600\n        real, parameter :: b1=-16.6546466531059530\n        real, parameter :: b2= 20.6941300362041100\n        real, parameter :: b3=-13.3726837850936920 \n        real, parameter :: b4= 4.83094787289278800 \n        real, parameter :: b5=-0.92976482601030100\n        real, parameter :: b6= 0.07456475055097825\n        real :: xi, xx\n        if ( x .le. xmin) then\n           xx=x*x\n           repsi2=zeta32 - zeta512*xx + zeta730*xx*xx ! x < xmin=0.18\n        elseif (x .le. x1) then                       ! accurate to 0.1%\n           repsi2=a8                                  !\n           repsi2=a7 + repsi2*x                       ! xmin < x < x1=1.2\n           repsi2=a6 + repsi2*x                       ! accurate to 0.01% \n           repsi2=a5 + repsi2*x                       ! a0 + a1*x + a2*x^2 +\n           repsi2=a4 + repsi2*x                       ! a3*x^3 + a4*x^4 +\n           repsi2=a3 + repsi2*x                       ! a5*x^5 + a6*x^6 +\n           repsi2=a2 + repsi2*x                       ! a7*x&7 + a8*x^8 \n           repsi2=a1 + repsi2*x\n           repsi2=a0 + repsi2*x \n        elseif (x .le. xmax) then                     ! x1 < x < xmax=2.5\n           repsi2=b6                                  ! accurate to 0.2%\n           repsi2=b5+repsi2*x                         ! b0 + b1*x + b2*x^2 +\n           repsi2=b4+repsi2*x                         ! b3*x^3 + b4*x^4 +\n           repsi2=b3+repsi2*x                         ! b5*x^5 + b6*x^6\n           repsi2=b2+repsi2*x          \n           repsi2=b1+repsi2*x          \n           repsi2=b0+repsi2*x          \n        else\n           xi=1/x                                     ! x > xmax=2.5\n           xi=xi*xi                                   ! accurate to 0.07%\n           repsi2= 1.e0/6.e0                          ! -1/x^2 + 1/2x^4 + \n           repsi2= 0.5e0 + repsi2*xi                  ! 1/6x^6\n           repsi2=-1. + repsi2*xi                     !\n           repsi2=repsi2*xi\n        endif\n      end function repsi2\n"}, {"instruction": "Create a Fortran function named stddev that calculates the standard deviation of a one-dimensional array of real numbers. The function takes 2 input parameters: an array of real numbers and an optional real number representing the mean. The output is a single real number representing the standard deviation.", "input": "", "output": "    function stddev(input, mean_in)\n        implicit none\n        real, dimension(:) :: input\n        real, intent(in), optional :: mean_in\n        real :: stddev\n        \n        real :: mean\n        integer :: x, n\n        \n        n = size(input)\n        \n        if (present(mean_in)) then\n            mean = mean_in\n        else\n            mean = sum(input) / n\n        endif\n        \n        stddev = sqrt( sum( (input - mean)**2 ) / (n-1) )\n        \n    end function stddev\n"}, {"instruction": "Create a Fortran function named ceil_power_of_two that takes an integer as input and returns the next power of two that is greater than or equal to the input number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function ceil_power_of_two(n)\n    implicit none\n    integer,intent(in) :: n\n    integer            :: ceil_power_of_two\n    integer :: x\n    x = n\n    x = ior(x, ishft(x, 1))\n    x = ior(x, ishft(x, 2))\n    x = ior(x, ishft(x, 4))\n    x = ior(x, ishft(x, 8))\n    x = ior(x, ishft(x, 16))\n    ceil_power_of_two = x - ishft(x, 1)\n  end function\n"}, {"instruction": "Provide a Fortran function named roundup_pow2 that takes one integer input argument and returns one integer output argument. This function computes the next power of 2 greater than or equal to the input integer and stores the result in the variable \"roundup_pow2\". Use bitwise operations to efficiently compute the next power of 2.", "input": "", "output": "  function roundup_pow2(n)\n    implicit none\n    integer,intent(in) :: n\n    integer            :: roundup_pow2,k\n\n    k = n - 1\n    k = ior(k, ishft(k,-1))\n    k = ior(k, ishft(k,-2))\n    k = ior(k, ishft(k,-4))\n    k = ior(k, ishft(k,-8))\n    k = ior(k, ishft(k,-16))\n\n    roundup_pow2 = k + 1\n  end function roundup_pow2\n"}, {"instruction": "Create a Fortran function named al4san_init_c that uses the iso_c_binding module to initialize the AL4SAN runtime system. The function takes 2 input parameters of type integer(kind=c_int), passed by value. The output is an integer(kind=c_int). The function is named al4san_init and is declared using the bind attribute with the name 'al4san_init'.", "input": "", "output": "         function al4san_init_c(cpus, gpus) &\n          & bind(c, name='al4san_init')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: al4san_init_c\n            integer(kind=c_int), value :: cpus, gpus\n         end function al4san_init_c\n"}, {"instruction": "Create a Fortran function named al4san_enable_c with one input parameter of type integer(kind=c_int) and marked as value. It also has one output parameter of type integer(kind=c_int). The function is used to enable a specific feature and returns a status code indicating the success or failure of the operation.", "input": "", "output": "         function al4san_enable_c(param) &\n          & bind(c, name='al4san_enable')\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int) :: al4san_enable_c\n            integer(kind=c_int), value :: param\n         end function al4san_enable_c\n"}, {"instruction": "Write a Fortran function named al4san_init_affinity_c to initialize the affinity of computing resources such as cores and GPUs. The function takes 3 input parameters of type 'integer(kind=c_int), value', 'integer(kind=c_int), value', and 'type(c_ptr), value'. It also returns 1 output parameter of type 'integer(kind=c_int)'. The function should be named al4san_init_affinity_c.", "input": "", "output": "         function al4san_init_affinity_c(cores,gpus,bindtab) &\n          & bind(c, name='al4san_init_affinity')\n            use iso_c_binding\n            integer(kind=c_int) :: al4san_init_affinity_c\n            integer(kind=c_int), value ::  cores, gpus\n            type(c_ptr), value :: bindtab\n         end function al4san_init_affinity_c\n"}, {"instruction": "Write a Fortran function named randint to generate a random integer within a specified range. The function takes 2 input arguments of type integer(16) and returns 1 output argument of type integer(16). The test_data type is ['integer(16)', 'integer(16)'] for input parameters and ['integer(16)'] for the output parameter.", "input": "", "output": "function randint(from, to) result (random_int)\n    implicit none\n    integer(16), intent(in) :: from, to\n    integer(16) :: random_int\n    real :: rng1\n    \n    call random_seed()\n    call random_number(rng1)\n    \n    random_int = int(from + int(rng1 * (to - from + 1)))\n    \nend function randint\n"}, {"instruction": "Create a Fortran function named \"j\" that takes two integer input parameters. The test_data type for the input parameters is ['integer', 'integer']. The function should return a single integer output parameter, with the test_data type ['integer']. The function should calculate the value of \"j\" using the input parameters according to the provided formula. Use the imperative tone to specify the requirements for the function.", "input": "", "output": "  pure function j(p,n)\n    implicit none\n    integer, intent(in) :: p,n\n    integer :: j\n    j=p-((p+n)/n-1)*n\n  end function j\n"}, {"instruction": "Write a Fortran function named index2coords that takes an integer index and a 3-element integer array representing the dimensions as input parameters and returns a 3-element integer array representing the coordinates. The input parameters should be of type integer and integer array with 3 elements. The output parameter should be of type integer array with 3 elements.", "input": "", "output": "function index2coords(ind,n) result(x)\n! ... gets the x=(i,j,k) and returns its index = (k-1)*nx*ny + (j-1)*nx + i\n\ninteger, intent(in)                 :: ind\ninteger, dimension(3), intent(in)   :: n  ! = (nx,ny,nz)\ninteger, dimension(3)               :: x  ! = (i,j,k)\n\n! ...\ninteger residual\n!ind = (x(3)-1)*n(2)*n(1) + (x(2)-1)*n(1) + x(1)\nx(1) = mod(ind-1,n(1)) + 1\n\nresidual = (ind - x(1))/n(1) + 1\nx(2) = mod(residual-1,n(2)) + 1\n\nx(3) = (residual - x(2))/n(2) + 1\n\nend function index2coords\n"}, {"instruction": "Create a Fortran function named num_of_lines that takes a file path as input and returns the number of lines in the file. The number of input arguments is 1 and the test_data type is ['character (len = *)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "      function num_of_lines(path_to_file) result(line_num)\n\n      character (len = *), intent(in) :: path_to_file\n\n      integer :: file_unit, line_num, io\n\n      file_unit = 13745\n     \n      open(unit = file_unit, file = path_to_file, action = 'read')\n\n      line_num = 0; io = 0\n\n      do while (io .eq. 0)\n\n         read(file_unit, *, iostat = io)\n\n         if (io .ne. 0) exit\n\n         line_num = line_num + 1\n\n      enddo\n\n      close(file_unit)\n\n      return\n\n      end function num_of_lines\n"}, {"instruction": "Create a Fortran function named cross_product_sngl to calculate the cross product of two 3-dimensional vectors. The function takes two input parameters, both of type real (kind=4) and dimension 3. The output is a single 3-dimensional real (kind=4) array.", "input": "", "output": "  function cross_product_sngl( a, b )\r\n    real (kind=4), dimension( 3 ) :: cross_product_sngl\r\n    real (kind=4), dimension( 3 ), intent(  in ) :: a, b\r\n\r\n    cross_product_sngl( 1 ) = a( 2 ) * b( 3 ) - a( 3 ) * b( 2 )\r\n    cross_product_sngl( 2 ) = a( 3 ) * b( 1 ) - a( 1 ) * b( 3 )\r\n    cross_product_sngl( 3 ) = a( 1 ) * b( 2 ) - a( 2 ) * b( 1 )\r\n\r\n  end function cross_product_sngl\r\n"}, {"instruction": "Create a Fortran function named combinations to calculate the number of combinations of a given number of items. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is labeled as num_items and the output parameter is labeled as num_combinations.", "input": "", "output": "    pure recursive function combinations(num_items) result(num_combinations)\n        integer, intent(in) :: num_items\n        integer :: num_combinations\n\n        if (num_items <= 1) then\n            num_combinations = 0\n        else\n            num_combinations = num_items - 1 + combinations(num_items - 1)\n        end if\n    end function\n"}, {"instruction": "Create a Fortran function named random_string that generates a random string composed of specified characters of a given length. The function takes 2 input parameters of types 'character(len=*)' and 'integer', and has 1 output parameter of type 'character(len=:),allocatable'.", "input": "", "output": "     function random_string(chars,length) result(out)\n\n     !$@(#) m_random::random_string(3f): create random string composed of provided characters of specified length\n\n     character(len=*),intent(in)     :: chars\n     integer,intent(in)              :: length\n     character(len=:),allocatable    :: out\n        real                         :: x\n        integer                      :: ilen   ! length of list of characters\n        integer                      :: which\n        integer                      :: i\n        ilen=len(chars)\n        out=''\n        if(ilen.gt.0)then\n           do i=1,length\n              call random_number(x)\n              which=nint(real(ilen-1)*x)+1\n              out=out//chars(which:which)\n           enddo\n        endif\n     end function random_string\n"}, {"instruction": "Create a Fortran function named \"ksicr\" to determine the relationship between two line segments based on their coordinates. The function takes 4 input parameters of type real(8): x1, y1, x2, and y2. It returns 1 output parameter of type integer.", "input": "", "output": "function ksicr (x1,y1,x2,y2)\n  implicit none\n  integer :: ksicr\n  real(8) :: x1,x2,y1,y2\n  if (y1*y2 .gt. 0.0) goto 600\n\n  if (x1*y2 .ne. x2*y1 .or. x1*x2 .gt. 0.0) goto 100\n\n  ksicr = 4\n  return\n\n100 if (y1*y2 .lt. 0.0) goto 300\n  if (y2.eq.0.0) goto 200\n  if (x1.gt.0.0) goto 600\n  if (y2.gt.0.0) goto 700\n  goto 800\n\n200 if (y1.eq.0.0 .or. x2.gt.0.0) goto 600\n  if (y1.gt.0.0) goto 800\n  goto 700\n\n300 if (y1.gt.0.0) goto 400\n  if (x1*y2 .ge. y1*x2) goto 600\n  ksicr = 2\n  return\n\n400 if (y1*x2.ge.x1*y2) goto 600\n  ksicr = -2\n  return\n\n600 ksicr = 0\n  return\n\n700 ksicr = 1\n  return\n\n800 ksicr = -1\n  return\n\nend function ksicr\n"}, {"instruction": "Create a Fortran function named eos3_ss to calculate the speed of sound using the provided equation. The function takes 5 input parameters of type real*8: gam, p_c, arho, al, apr. It returns a single output parameter of type real*8.", "input": "", "output": "function eos3_ss(gam, p_c, arho, al, apr)\n\nreal*8, intent(in) :: gam, p_c, arho, al, apr\n\nreal*8  :: pre, eos3_ss\n\n    pre = max(apr+al*p_c, 1.0d-14);\n    if (arho .lt. 1.0d-16) then\n      if (al .le. 100.0*g_alphamin) then\n        eos3_ss = 0.0\n      else\n        write(*,*) \"error: zero/negative density encountered in speed of sound calculation: \", arho\n        write(*,*) \"  volume-fraction: \", al\n        call exit\n      end if\n    else\n      eos3_ss = dsqrt(gam *pre/arho);\n    end if\n\nend function\n"}, {"instruction": "Create a Fortran function named set_y_plus to calculate the dimensionless distance from the wall (y_plus) using the given inputs. The function has 4 input parameters with test_data type ['double precision', 'double precision', 'double precision', 'double precision'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "    function set_y_plus(rho_w, mu_w, dudy_w, y) result(y_plus)\n        implicit none\n        double precision, intent(in) :: rho_w, mu_w, dudy_w, y   ! \u58c1\u8868\u9762\u3067\u306e\u5bc6\u5ea6\uff0c\u305b\u3093\u65ad\u5fdc\u529b\uff0c\u7c98\u6027\u4fc2\u6570\uff0c\u58c1\u304b\u3089\u306e\u5782\u76f4\u8ddd\u96e2\n        double precision :: y_plus\n\n        y_plus = sqrt(rho_w / mu_w * dudy_w) * y ! \u5b9a\u7fa9\u78ba\u8a8d!\n\n        return\n    end function set_y_plus\n"}, {"instruction": "Create a Fortran function named \"f\" that computes a mathematical expression involving the given input parameters. The function takes 2 input arguments of type double precision (t, x) and returns 1 output argument of type double precision.", "input": "", "output": "  function f(t,x) result(r)\n    double precision :: t, x\n    double precision :: r\n\n    r = (peak_h - ambient_h) * (t0 / (t+t0)) * &\n         dexp(-x / (four * diffusion_coefficient * (t+t0))) + ambient_h\n\n  end function f\n"}, {"instruction": "Create a Fortran function named e_electronic that calculates the electronic energy based on the density matrix, fock operator, and core Hamiltonian matrices. The function should have 4 input parameters of types integer, real*8, and dimension(kf,kf), and 1 output parameter of type real*8.", "input": "", "output": "        function e_electronic(kf,p,f,h) result(e_el)\n            ! -\n            !\n            ! -\n            !\n            ! source:\n            !   a. szabo and n. ostlund\n            !\n            ! -\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf\n            real*8, dimension(kf,kf), intent(in) :: p   ! density matrix\n            real*8, dimension(kf,kf), intent(in) :: f   ! fock operator\n            real*8, dimension(kf,kf), intent(in) :: h   ! core hamiltonian\n\n            ! intermediate variables\n            integer :: i, j                             ! loop indices\n\n            ! output\n            real*8 :: e_el                              ! electronic energy\n\n            e_el = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    e_el = e_el + 0.5d0 * p(j,i) * (h(i,j) + f(i,j))\n                end do\n            end do\n\n        end function e_electronic\n"}, {"instruction": "Create a Fortran function named e_electronic_spin to calculate the electronic energy based on given input parameters. The function takes 6 input parameters of types integer, real*8 arrays of dimensions kf x kf, and outputs a real*8 value.", "input": "", "output": "        function e_electronic_spin(kf,pa,fa,pb,fb,h) result(e_el)\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf\n            real*8, dimension(kf,kf), intent(in) :: pa      ! density matrix (alpha spin)\n            real*8, dimension(kf,kf), intent(in) :: pb      ! density matrix (beta spin)\n            real*8, dimension(kf,kf), intent(in) :: fa      ! fock operator (alpha spin)\n            real*8, dimension(kf,kf), intent(in) :: fb      ! fock operator (beta spin)\n            real*8, dimension(kf,kf), intent(in) :: h       ! core hamiltonian\n\n            ! intermediate variables\n            integer :: i, j                                 ! loop indices\n            real*8, dimension(kf,kf) :: ptot                ! total density matrix\n\n            ! output\n            real*8 :: e_el                              ! electronic energy\n\n            ptot = pa + pb\n\n            e_el = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    e_el = e_el + ptot(j,i) * h(i,j) + pa(j,i) * fa(i,j) + pb(j,i) * fb(i,j)\n                end do\n            end do\n\n            e_el = 0.5d0 * e_el\n\n        end function e_electronic_spin\n"}, {"instruction": "Create a Fortran function named e_nuclear to calculate the nuclear energy based on the total number of nuclei, nuclear charges, and nuclear positions. The number of input arguments is 3, and the test_data type is [integer, integer array, real*8 2D array]. The number of output arguments is 1, and the test_data type is [real*8].", "input": "", "output": "        function e_nuclear(nn,rn,zn) result(e_nu)\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: nn                       ! total number of nuclei\n            integer, dimension(nn), intent(in) :: zn        ! nuclear charges\n            real*8, dimension(nn,3), intent(in) :: rn       ! nuclear positions\n\n            ! intermediate variables\n            integer :: i, j                 ! loop variables\n\n            ! output\n            real*8 :: e_nu                  ! nuclear energy\n\n            e_nu = 0.0d0\n\n            do i = 1, nn\n                do j = i + 1, nn\n                    e_nu = e_nu + zn(i) * zn(j) / norm2(rn(i,1:3) - rn(j,1:3))\n                end do\n            end do\n\n        end function e_nuclear\n"}, {"instruction": "Provide a Fortran function named factorial to calculate the factorial of a given integer. The function accepts 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "    recursive function factorial(n) result(f)\n        implicit none\n        integer, intent(in) :: n\n        integer :: f\n        if (n < 2) then\n            f = 1\n        else\n            f = n*factorial(n - 1)\n        end if\n    end function factorial\n"}, {"instruction": "Create a Fortran function named square to calculate the square of an integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is of type integer.", "input": "", "output": "    function square(x) result(res)\n        implicit none\n        integer, intent(in) :: x\n        integer :: res\n        !integer, intent(out) :: res\n        res = x * x \n    end function square \n"}, {"instruction": "Create a Fortran function named to_upper to convert a given string to uppercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(strin)).", "input": "", "output": "    function to_upper(strin) result(strout)\n!\n!   original author: clive page\n!   utility code for conversion to upper case \n!\n     implicit none\n\n     character(len=*), intent(in) :: strin\n     character(len=len(strin)) :: strout\n     integer :: i,j\n\n     do i = 1, len(strin)\n          j = iachar(strin(i:i))\n          if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n               strout(i:i) = achar(iachar(strin(i:i))-32)\n          else\n               strout(i:i) = strin(i:i)\n          end if\n     end do\n\n    end function to_upper\n"}, {"instruction": "Write a Fortran function named bigtolittle that takes one input parameter of type integer(kind=4) and returns one output parameter of the same type. The function swaps the byte order of the input integer from big endian to little endian and assigns the result to the output parameter.", "input": "", "output": "function bigtolittle(i)\r\ninteger(kind=4), intent(in):: i\r\ninteger(kind=4):: bigtolittle\r\ninteger(kind=4):: j\r\ncall mvbits(i, 0, 8, j, 24)\r\ncall mvbits(i, 8, 8, j, 16)\r\ncall mvbits(i,16, 8, j,  8)\r\ncall mvbits(i,24, 8, j,  0)\r\nbigtolittle= j\r\nend function\r\n"}, {"instruction": "Create a Fortran function named fib that calculates the Fibonacci sequence with an input parameter of type integer and output parameter of type integer. The function should use recursion to compute the result.", "input": "", "output": "recursive function fib(n) result(r)\n!$omp declare simd(fib) inbranch\n   implicit none\n   integer  :: n, r\n\n   if (n <= 1) then\n      r = n\n   else \n      r = fib(n-1) + fib(n-2)\n   endif\n\nend function fib\n"}, {"instruction": "Write a Fortran function named model_function that takes two input arguments of type character(len=*) and character(len=:), pointer, and returns one output argument of type logical. The function copies the input string to the output string and prints the length of the output string.", "input": "", "output": "function model_function(inputa, outputa) result(out)\n  character(len=*), intent(in) :: inputa\n  character(len=:), pointer :: outputa\n  logical :: out\n  out = .true.\n  allocate(character(len=len(inputa)) :: outputa)\n  outputa = inputa\n  write(*, '(\"model a: \",a,\" (length = \",i3,\")\")') outputa, len(outputa)\nend function model_function\n"}, {"instruction": "Write a Fortran function named trim that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=len_trim(x)).", "input": "", "output": "function trim(x) result(r)\ncharacter(len=*),intent(in) :: x\ncharacter(len=len_trim(x)) :: r\ninteger :: i\ndo i = 1, len(r)\n    r(i:i) = x(i:i)\nend do\nend function\n"}, {"instruction": "Create a Fortran function named smoothstep1 that takes a single real input argument. The input test_data type is ['real']. The function must return a single real value as the output. The purpose of this function is to compute the smoothstep1 function, which is defined as x * x * (3 - 2 * x).", "input": "", "output": "   pure function smoothstep1(x)\n      implicit none\n      real :: smoothstep1\n      real, intent(in) :: x\n      smoothstep1 = x * x * (3 - 2 * x)\n   end function smoothstep1\n"}, {"instruction": "Create a Fortran function named smoothstep2 to calculate the smoothstep2 function of a given real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter should be passed using the intent(in) attribute.", "input": "", "output": "   pure function smoothstep2(x)\n      implicit none\n      real :: smoothstep2\n      real, intent(in) :: x\n      smoothstep2 = x * x * x * (x * (x * 6 - 15) + 10)\n   end function smoothstep2\n"}, {"instruction": "Write a Fortran function named pascaltriangle to calculate the value of a specific entry in Pascal's triangle. The function has 2 input parameters of type integer. The test_data type for input parameters is ['integer', 'integer']. The function returns 1 output parameter of type integer, with the test_data type being ['integer'].", "input": "", "output": "   pure function pascaltriangle(a, b)\n      implicit none\n      integer :: pascaltriangle\n      integer, intent(in) :: a, b\n      integer i\n      pascaltriangle = 1\n      do i = 0, b - 1\n         pascaltriangle = pascaltriangle * (a - i) / (i + 1)\n      end do\n   end function pascaltriangle\n"}, {"instruction": "Create a Fortran function named realexp that computes the exponential value of a real number raised to an integer power. The function takes 2 input parameters of type real and integer, and returns 2 output parameters of type real and realexp.", "input": "", "output": "  function realexp (base, exponent)\n    real :: realexp\n    real, intent(in) :: base\n    integer, intent(in) :: exponent\n    integer :: i\n\n    realexp = 1.0\n    if (exponent < 0) then\n       do i = exponent, -1\n          realexp = realexp / base\n       end do\n    else\n       do i = 1, exponent\n          realexp = realexp * base\n       end do\n    end if\n  end function realexp\n"}, {"instruction": "Create a Fortran function named factorial_good to calculate the factorial of a given integer.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    function factorial_good(n) result(f)\n        implicit none\n        integer, intent(in) :: n\n        integer :: f\n        integer :: fac, i\n        fac = 1\n        do i = 2, n\n            fac = fac*i\n        end do\n        f = fac\n    end function factorial_good\n"}, {"instruction": "Create a Fortran function named func to calculate the sine of 1.0 divided by the input parameter. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "    function func(x)\n        implicit none\n        real :: func\n        real, intent(in) :: x\n\n        func = sin(1.0 / x) ! strongly oscillating, needs many intervals\n        return\n    end function func\n"}, {"instruction": "Create a Fortran recursive function named greatest_common_factor to calculate the greatest common factor of two integers. The function should take 2 input arguments of type integer and return 1 output argument of type integer.", "input": "", "output": "  recursive function greatest_common_factor(a, b) result (gcf)\n    integer, intent(in) :: a, b\n    integer             :: gcf\n    \n    if (b == 0) then\n       gcf = a\n    else\n       gcf = greatest_common_factor(b, mod(a,b))\n    end if\n  end function greatest_common_factor\n"}, {"instruction": "Create a Fortran function named \"to_upper\" that takes a single input argument of type character(*) and returns a single output argument of type character(len(str)). The function should capitalize each lowercase letter in the input string and return the modified string as the output. Use the imperative tone in your instructions.", "input": "", "output": "        pure function to_upper (str) result (string)\n            implicit none\n            character(*), intent(in) :: str\n            character(len(str))      :: string\n\n            integer :: ic, i\n\n            character(26), parameter :: cap = \"abcdefghijklmnopqrstuvwxyz\"\n            character(26), parameter :: low =  \"abcdefghijklmnopqrstuvwxyz\"\n\n            ! capitalize each letter if it is lowecase\n            string = str\n            do i = 1, len_trim(str)\n                ic = index(low, str(i:i))\n                if (ic > 0) string(i:i) = cap(ic:ic)\n            end do\n        end function to_upper\n"}, {"instruction": "Write a Fortran function named angle to calculate the angle between two geographic coordinates given in latitude and longitude. The function takes 4 input parameters of type double precision (lat1i, lon1i, lat2i, lon2i) and returns 1 output parameter of type double precision (angle). The input test_data type is ['double precision', 'double precision', 'double precision', 'double precision'], and the output test_data type is ['double precision'].", "input": "", "output": "function angle(lat1i,lon1i,lat2i,lon2i)\nimplicit none\ndouble precision :: angle\ndouble precision, intent(in) :: lat1i,lon1i,lat2i,lon2i\ndouble precision :: lat1,lon1,lat2,lon2\ndouble precision, parameter :: pi=3.14159265358979323846264338327950288d0\n\nlat1=lat1i*pi/1.8d2 ; lon1=lon1i*pi/1.8d2\nlat2=lat2i*pi/1.8d2 ; lon2=lon2i*pi/1.8d2\n\nangle=atan2( sqrt( (cos(lat2)*sin(lon2-lon1))**2 + (cos(lat1)*sin(lat2) - &\n                   sin(lat1)*cos(lat2)*cos(lon2-lon1))**2) , &\n            sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2)*cos(lon2-lon1))\n\nangle=angle*1.8d2/pi\n\nend function angle\n"}, {"instruction": "Write a Fortran function named vg_se that takes 3 real input parameters, h, a, and n, and returns a real output parameter, se. The function computes the value of se using the formula se = (1 + (a * h)**n)**(-m), where m = 1 - 1 / n.", "input": "", "output": "  elemental function vg_se(h, a, n) result(se)\n    real, intent(in) :: h, a, n\n    real :: m, se\n\n    m = 1. - 1. / n\n    se = (1. + (a * h)**n)**(-m)\n  end function\n"}, {"instruction": "Create a Fortran elemental function named vg_pm to calculate the polarization magnitude of a material. The function takes 3 real input parameters (t, a, n) and returns 1 real output parameter (pm) representing the polarization magnitude.", "input": "", "output": "  elemental function vg_pm(t, a, n) result(pm)\n    real, intent(in) :: t, a, n\n    real :: m, me, pm\n\n    m = 1. - 1. / n\n    me = a * (.046 * m + 2.07 * m**2 + 19.5 * m**3) &\n       / (1. + 4.7 * m + 16. * m**2)\n    pm = 1. / a * (t**(1 / m) - 1.)**(1 / n)\n    pm = max(pm, me)\n  end function\n"}, {"instruction": "Write a Fortran function named vg_kr that calculates the value of kr using the given input parameters. The function has 3 input parameters of type real (t, a, n) and 1 output parameter of type real (kr).", "input": "", "output": "  elemental function vg_kr(t, a, n) result(kr)\n    real, intent(in) :: t, a, n\n    real :: m, kr\n\n    m = 1. - 1. / n\n    kr = sqrt(t) * (1. - (1. - t**(1. / m))**m)**2\n  end function\n"}, {"instruction": "Create a Fortran function named setstvel, which calculates the settling velocity of noncohesive sediment using Van Rijn's equations. The function takes 2 real input parameters (d and ssg) and returns 1 real output parameter (setstvel).", "input": "", "output": "function setstvel(d,ssg)\n\n  ! **  noncoheasive sediment settling and shields criteria\n  ! **  using van rijn's equations\n\n  ! change record\n\n  implicit none\n\n  real :: setstvel,d,ssg,visc,gp,gpd,sqgpd,rd,wset,tmp\n\n  visc=1.d-6\n  gp=(ssg-1.)*9.82\n  gpd=gp*d\n  sqgpd=sqrt(gpd)\n  rd=sqgpd*d/visc\n\n  ! **  settling velocity\n\n  if( d < 1.0e-4 )then\n    wset=sqgpd*rd/18.\n  endif\n  if( d >= 1.0e-4 .and. d < 1.e-3 )then\n    tmp=sqrt(1.+0.01*rd*rd)-1.\n    wset=10.0*sqgpd*tmp/rd\n  endif\n  if( d >= 1.e-3 )then\n    wset=1.1*sqgpd\n  endif\n  setstvel=wset\n\nend function\n"}, {"instruction": "Write a Fortran function named legendre that calculates the Legendre polynomial of degree n at the point x. The function has 2 input parameters of type integer and double precision, and 1 output parameter of type double precision.", "input": "", "output": "recursive function legendre(n, x)result(res)\n! provides p_n(x)\nimplicit none\ninteger, intent(in):: n\ndouble precision, intent(in) :: x\ndouble precision :: res\ninteger :: i\n\nif (n == 0) then\n res = 1.d0\nelse if (n == 1) then\n res = x\nelse\n res = ((2.d0*n-1.d0)*x*legendre(n-1, x)-(n-1)*legendre(n-2, x))/(n*1.d0)\nend if\n!\nend function legendre\n"}, {"instruction": "Write a Fortran function named matrix_combine that combines two nxn matrices into a single 2nxn matrix. The number of input arguments is 3, and the test_data type is [integer, double precision, dimension(n, n), double precision, dimension(n, n)]. The number of output arguments is 1, and the test_data type is [double precision, dimension(2*n, n)].", "input": "", "output": "function matrix_combine( n, mata, matb)result(matab)\nimplicit none\n! combine two nxn matrices\ninteger, intent(in) ::  n\ndouble precision, dimension(n, n), intent(in) :: mata, matb\ndouble precision, dimension(2*n, n) :: matab\n\nmatab(1:n, :) = mata\nmatab(n+1:2*n, : ) = matb\nend function matrix_combine\n"}, {"instruction": "Write a Fortran function named matrix_embed that embeds a smaller square matrix into a larger square matrix at specified row and column positions. The input parameters consist of 5 arguments: n (integer), mata (double precision matrix of size n x n), bign (integer), rpos (integer), and cpos (integer). The output parameter is a double precision matrix of size bign x bign.", "input": "", "output": "function matrix_embed(n, mata, bign, rpos, cpos)result(bigmatrix)\nimplicit none\ninteger, intent(in) :: n, bign, rpos, cpos\ndouble precision, dimension(n, n), intent(in) :: mata\ndouble precision, dimension(bign, bign) :: bigmatrix\nif (rpos+n-1 > bign .or. cpos+n-1 > bign) then\n print*, \"matrix sizes are not fit for embedding ... aborting execusion\"\n stop\nend if\nbigmatrix = 0.d0\nbigmatrix(rpos:, cpos:) =mata\n\nend function matrix_embed\n"}, {"instruction": "Create a Fortran function named repeat that takes an integer n and a double precision number as input. The function returns a double precision array of size n, initialized with the input number.", "input": "", "output": "function repeat(n, number)result(vector)\nimplicit none\ninteger, intent(in) :: n\ndouble precision,intent(in) :: number\ndouble precision, dimension(n) :: vector\nvector = number\nend function repeat\n"}, {"instruction": "Create a Fortran function named combine_vector to merge two arrays into one. The function takes 4 input parameters: na of type integer, va of type double precision array with dimension na, nb of type integer, and vb of type double precision array with dimension nb. The function returns a double precision array of dimension na+nb.", "input": "", "output": "function combine_vector(na, va, nb, vb)result(vab)\nimplicit none\ninteger, intent(in) ::  na, nb\ndouble precision, dimension(na), intent(in) :: va\ndouble precision, dimension(nb), intent(in) :: vb\ndouble precision, dimension(na+nb) :: vab\nvab = 0.d0\nvab(1:na) = va\nvab(na+1:nb+na) = vb\nend function combine_vector\n"}, {"instruction": "Write a Fortran function named clean to process and filter arrays of real numbers representing time, velocity, and wind components. The number of input arguments is 5, and their test_data type is ['real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable']. The number of output arguments is 1, and its test_data type is ['integer'].", "input": "", "output": "    function clean(rvtime, rvu, rvv, rvw, rvt) result(iretcode)\n\t\n        ! routine arguments\n        real, dimension(:), allocatable, intent(inout)  :: rvtime\n        real, dimension(:), allocatable, intent(inout)  :: rvu\n        real, dimension(:), allocatable, intent(inout)  :: rvv\n        real, dimension(:), allocatable, intent(inout)  :: rvw\n        real, dimension(:), allocatable, intent(inout)  :: rvt\n        integer                                         :: iretcode\n\t\t\n        ! locals\n        integer                         :: inumvalid\n        real, dimension(:), allocatable :: rvnewtime\n        real, dimension(:), allocatable :: rvnewu\n        real, dimension(:), allocatable :: rvnewv\n        real, dimension(:), allocatable :: rvneww\n        real, dimension(:), allocatable :: rvnewt\n        integer                         :: i\n        integer                         :: j\n\t\t\n        ! assume success (will falsify on failure)\n        iretcode = 0\n\t\t\n        ! check parameters (minimal)\n        if( &\n            .not.allocated(rvtime) .or. &\n            .not.allocated(rvu) .or. &\n            .not.allocated(rvv) .or. &\n            .not.allocated(rvw) .or. &\n            .not.allocated(rvt) &\n        ) then\n            iretcode = 1\n            return\n        end if\n        if(size(rvtime) <= 0 .or. size(rvu) <= 0 .or. size(rvv) <= 0 .or. size(rvw) <= 0 .or. size(rvt) <= 0) then\n            iretcode = 2\n            return\n        end if\n\t\t\n\t\t! transfer valid data\n        inumvalid = count(rvu > -9990.)\n        if(inumvalid <= 0) then\n            iretcode = 2\n            return\n        end if\n        allocate(rvnewtime(inumvalid))\n        allocate(rvnewu(inumvalid))\n        allocate(rvnewv(inumvalid))\n        allocate(rvneww(inumvalid))\n        allocate(rvnewt(inumvalid))\n        j = 0\n        do i = 1, size(rvtime)\n            if(rvu(i) > -9990.0) then\n                j = j + 1\n                rvnewtime(j) = rvtime(i)\n                rvnewu(j)    = rvu(i)\n                rvnewv(j)    = rvv(i)\n                rvneww(j)    = rvw(i)\n                rvnewt(j)    = rvt(i)\n            end if\n        end do\n\t\t\n    end function clean\n"}, {"instruction": "Create a Fortran function named \"mean\" to calculate the averages of signal values over specified time intervals. The function should have 5 input parameters of types real, dimension(:), real, real, dimension(:), allocatable, and real, dimension(:), allocatable. The output should be an integer.", "input": "", "output": "    function mean(rvtime, rvx, rdeltatime, rvavgtime, rvavgx) result(iretcode)\n\t\n        ! routine arguments\n        real, dimension(:), intent(in)                  :: rvtime       ! sequence of seconds in hour (not necessarily in ascending order)\n        real, dimension(:), intent(in)                  :: rvx          ! signal values corresponding to the times\n        real, intent(in)                                :: rdeltatime   ! time step (must be strictly positive)\n        real, dimension(:), allocatable, intent(out)    :: rvavgtime    ! seconds at beginning of each averaging step\n        real, dimension(:), allocatable, intent(out)    :: rvavgx       ! averages, on every time step\n        integer                                         :: iretcode     ! return code (0 = ok, non-zero = some problem)\n\t\t\n        ! locals\n        integer                             :: inumsteps\n        integer, dimension(:), allocatable  :: ivnumdata\n        integer                             :: i\n        integer                             :: iindex\n\t\t\n        ! assume success (will falsify on failure)\n        iretcode = 0\n\t\t\n        ! check parameters\n        if(size(rvtime) <= 0 .or. size(rvtime) /= size(rvx) .or. rdeltatime <= 0.) then\n            iretcode = 1\n            return\n        end if\n\t\t\n        ! compute number of steps and use it to reserve workspace\n        inumsteps = ceiling(3600. / rdeltatime)\n        allocate(ivnumdata(inumsteps), rvavgx(inumsteps), rvavgtime(inumsteps))\n        ivnumdata = 0\n        rvavgx    = 0.\n\t\t\n        ! sum step values\n        do i = 1, size(rvtime)\n            iindex = floor(rvtime(i) / rdeltatime) + 1\n            ivnumdata(iindex) = ivnumdata(iindex) + 1\n            rvavgx(iindex)    = rvavgx(iindex) + rvx(i)\n        end do\n\t\t\n\t\t! render averages\n        do i = 1, inumsteps\n            if(ivnumdata(i) > 0) then\n                rvavgx(i) = rvavgx(i) / ivnumdata(i)\n            else\n                rvavgx(i) = -9999.9\n            end if\n        end do\n\n        ! compute time values\n        rvavgtime = [(i*rdeltatime, i=0, inumsteps-1)]\n\t\t\n    end function mean\n"}, {"instruction": "Create a Fortran function named \"cov\" to calculate the covariance of two signals over time. The function takes 6 input parameters of types ['real, dimension(:)', 'real, dimension(:)', 'real, dimension(:)', 'real', 'real, dimension(:), allocatable', 'real, dimension(:), allocatable'], and 1 output parameter of type ['integer'].", "input": "", "output": "    function cov(rvtime, rvx, rvy, rdeltatime, rvavgtime, rvcovxy) result(iretcode)\n\n        ! routine arguments\n        real, dimension(:), intent(in)                  :: rvtime       ! sequence of seconds in hour (not necessarily in ascending order)\n        real, dimension(:), intent(in)                  :: rvx          ! signal values x corresponding to the times\n        real, dimension(:), intent(in)                  :: rvy          ! signal values y corresponding to the times\n        real, intent(in)                                :: rdeltatime   ! time step (must be strictly positive)\n        real, dimension(:), allocatable, intent(out)    :: rvavgtime    ! seconds at beginning of each averaging step\n        real, dimension(:), allocatable, intent(out)    :: rvcovxy      ! covariance, on every time step\n        integer                                         :: iretcode     ! return code (0 = ok, non-zero = some problem)\n        \n        ! locals\n        integer                             :: inumsteps\n        integer, dimension(:), allocatable  :: ivnumdata\n        real, dimension(:), allocatable     :: rvsumx\n        real, dimension(:), allocatable     :: rvsumy\n        real, dimension(:), allocatable     :: rvsumxy\n        integer                             :: i\n        integer                             :: iindex\n        \n        ! assume success (will falsify on failure)\n        iretcode = 0\n        \n        ! check parameters\n        if(size(rvtime) <= 0 .or. size(rvtime) /= size(rvx) .or. size(rvtime) /= size(rvy) .or. rdeltatime <= 0.) then\n            iretcode = 1\n            return\n        end if\n        \n        ! compute number of steps and use it to reserve workspace\n        inumsteps = ceiling(3600. / rdeltatime)\n        allocate(ivnumdata(inumsteps), rvcovxy(inumsteps), rvavgtime(inumsteps))\n        allocate(rvsumx(inumsteps), rvsumy(inumsteps), rvsumxy(inumsteps))\n        ivnumdata = 0\n        rvsumx    = 0.\n        rvsumy    = 0.\n        rvsumxy   = 0.\n        \n        ! sum step values\n        do i = 1, size(rvtime)\n            iindex = floor(rvtime(i) / rdeltatime) + 1\n            ivnumdata(iindex) = ivnumdata(iindex) + 1\n            rvsumx(iindex)    = rvsumx(iindex)  + rvx(i)\n            rvsumy(iindex)    = rvsumy(iindex)  + rvy(i)\n            rvsumxy(iindex)   = rvsumxy(iindex) + rvx(i)*rvy(i)\n        end do\n        \n        ! render averages\n        do i = 1, inumsteps\n            if(ivnumdata(i) > 0) then\n                rvcovxy(i) = (rvsumxy(i)/ivnumdata(i) - (rvsumx(i)/ivnumdata(i))*(rvsumy(i)/ivnumdata(i)))\n            else\n                rvcovxy(i) = -9999.9\n            end if\n        end do\n        \n        ! compute time values\n        rvavgtime = [(i*rdeltatime, i=0, inumsteps-1)]\n        \n        ! leave orderly\n        deallocate(rvsumx, rvsumy, rvsumxy)\n        \n    end function cov\n"}, {"instruction": "Write a Fortran function named \"intentoutfunc\" that assigns the value 216 to the output parameter \"dummyarg\" and returns the value 343. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  function intentoutfunc(dummyarg)\n    integer, intent(out) :: dummyarg\n    integer  :: intentoutfunc\n\n    dummyarg = 216\n    intentoutfunc = 343\n  end function intentoutfunc\n"}, {"instruction": "Create a Fortran function named intentinoutfunc that takes an integer argument and returns an integer. The input argument is of type integer, and the output is also of type integer. The function sets the input argument to 216 and returns 343.", "input": "", "output": "  function intentinoutfunc(dummyarg)\n    integer, intent(inout) :: dummyarg\n    integer  :: intentinoutfunc\n\n    dummyarg = 216\n    intentinoutfunc = 343\n  end function intentinoutfunc\n"}, {"instruction": "Create a Fortran function named factorial to calculate the factorial of a given integer. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  recursive function factorial(i) result (rs)\n    integer :: rs\n    integer, intent(in) :: i\n    if ( i <= 1 ) then\n      rs = 1\n    else\n      rs = i * factorial(i - 1)\n    end if\n  end function factorial\n"}, {"instruction": "Write a Fortran function named calcthmmks to calculate theta based on the input arrays x2 and x1. The number of input arguments is 2, and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1, and the test_data type is ['real, dimension(size(x2))']. Use the imperative tone to instruct the use of this function.", "input": "", "output": "        function calcthmmks(x2,x1) result(theta)\n          real, intent(in), dimension(:) :: x2, x1\n          real, dimension(size(x2)) :: theta,thetag,thetaj,d\n          real :: a,b,c\n          a=mks_smooth\n          b=poly_xt\n          c=poly_alpha\n          thetag=pi*x2+(1.-hslope)/2.*sin(2.*pi*x2)\n          thetaj=d*(2.*x2-1.)*(1.+((2.*x2-1.)/b)**c/(1.+c))+pi/2.\n          d=pi/(2.+2./(b**c+c*b**c))\n          theta=thetag+exp(-a*d*x1)\n        end function calcthmmks\n"}, {"instruction": "Write a Fortran function named output_terminal that takes a character string as input and returns another character string. The input parameter should have a length of any size, and the output parameter should have a length of 35 characters.", "input": "", "output": "\tfunction output_terminal(terminal) result(f_result)\n!***********************************************************************************\n\timplicit none\n\tcharacter(len=*),intent(in)\t:: terminal\n\tinteger, parameter\t\t:: nc=35\n\tcharacter(len=nc)\t\t:: f_result\n!***********************************************************************************\n\tselect case(terminal)\n\t\tcase('ps')\n\t\t\tf_result='postscript landscape color'\n\t\tcase default\n\t\t\tf_result=terminal\n\tend select\n!***********************************************************************************\n\tend function output_terminal\n"}, {"instruction": "Write a Fortran function called hdgrid_fdir_kernel that calculates the flow direction based on a 3x3 input orography section provided as a one-dimensional array. The input parameter is a real*8 array with dimensions (1:9), and the output parameter is a real*8 value. If multiple minimum values exist, the function selects the first unless there is another one in the center of the cell, in which case the flow direction is set to 5 (a sink point).", "input": "", "output": "function hdgrid_fdir_kernel(orog_section) result(flow_direction)\n\n!kernel for find the flow direction (given as a number from 1-9 according to\n!the directions given by a numeric keypad on a keyboard; this number must be\n!have type float64/real*8 even though it only ever takes integer values to\n!satify type checking. if muliply mimimum occur then take the first unless\n!there is another one in the centre of the cell in which case set flow to 5\n!(a sink point)\n\n!note: should ideally replace real*8 with a more modern select_real_kind based\n!kind specification\n\nimplicit none\n\n!variables with intent in\n!a 3 by 3 input orography section flattened into a single dimensional array\nreal*8, intent(in), dimension(1:9) :: orog_section\n\n!local variables\ninteger :: i               !a counter\ninteger :: min_coord       !the coordinate of the minimum value\nreal*8  :: flow_direction  !the calculated flow direction to return\n!the flow directions; simply an array initialised with counting numbers\nreal*8, dimension(1:9) :: flow_directions = [(real(i,8),i=1,9)]\n\n !find the location of the first minimum in orog_section\n min_coord = minloc(orog_section,1)\n !and use that as an index to find the flow direction\n flow_direction = flow_directions(min_coord)\n !check if this grid cell is also a minimum\n if ( orog_section(5) == minval(orog_section) ) then\n    flow_direction = 5\n end if\n\nend function hdgrid_fdir_kernel\n"}, {"instruction": "Write a Fortran function named ticker to determine the type of character to be used for a progress indicator. The function takes 1 input parameter of type integer and returns 1 output parameter of type character. The input test_data type is ['integer'], and the output test_data type is ['character'].", "input": "", "output": "  pure function ticker(ncall) result(t)\n    implicit none\n    integer, intent(in) :: ncall\n    character :: t\n    select case(modulo(ncall,4))\n    case(0)\n       t='|'\n    case(1)\n       t='/'\n    case(2)\n       t='-'\n    case(3)\n       t=achar(92) !the backslash\n    end select\n  end function ticker\n"}, {"instruction": "Create a Fortran function named bad_factorial to calculate the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "function bad_factorial(n) result(nfac)\r\ninteger, intent(in) :: n\r\ninteger             :: nfac\r\ninteger             :: j\r\ninteger             :: i = 1 ! has same effect as line below\r\n! integer, save       :: i = 1\r\ndo j=2,n\r\n   i = i*j\r\nend do\r\nnfac = i\r\nend function bad_factorial\r\n"}, {"instruction": "Create a Fortran pure function named str that converts an integer into a character string. The function takes 1 input argument of type integer and returns 1 output argument of type character(:), allocatable.", "input": "", "output": "  pure function str(x) result(y)\n    integer, intent(in) :: x\n    character(:), allocatable :: y\n    character(128) :: tmp\n    write(tmp, '(g0)') x\n    y = trim(tmp)\n  end function str\n"}, {"instruction": "Write a Fortran function named detect_ncol_in_buf to determine the number of columns in a character buffer. The function takes 1 input parameter of type character(len=240) and returns 1 output parameter of type integer.", "input": "", "output": "function detect_ncol_in_buf(buf) result(ncol)\n implicit none\n integer :: i, ncol\n character(len=24), allocatable :: sbuf(:)\n character(len=240), intent(in) :: buf\n\n if(len_trim(buf) == 0) then\n  ncol = 0\n  return\n end if\n\n ncol = 1\n do while(.true.)\n  allocate(sbuf(ncol))\n  read(buf,*,iostat=i) sbuf(1:ncol)\n  deallocate(sbuf)\n  if(i /= 0) exit\n  ncol = ncol + 1\n end do ! for while\n\n ncol = ncol - 1\n return\nend function detect_ncol_in_buf\n"}, {"instruction": "Write a Fortran recursive function named binom to calculate the binomial coefficient \"n choose r\" where n and r are input integers. The function returns a real*8 value as the result. The number of input parameters is 2 and the test_data type is ['integer', 'integer'], while the number of output parameters is 1 with the test_data type being ['real*8'].", "input": "", "output": "      recursive function binom(n,r) result(res)\n        implicit none\n        integer :: n,r\n        real*8 :: res\n        real*8 :: tmp\n\n        if(n==r .or. r==0) then\n           res = 1.0\n        else if (r==1) then\n           res = real(n)\n        else\n           res = real(n)/real(n-r)*binom(n-1,r)\n        end if\n      end function binom\n"}, {"instruction": "Create a Fortran function named ran0 to generate a random number using the combined Marsaglia shift sequence and Park-Miller sequence. The function should accept 1 input argument of type integer(k4b) and return 1 output argument of type real.", "input": "", "output": "function ran0(idum)\n!----\n! random number generator from numerical recipes in fortran 90, press et al.\n!----\n\nimplicit none\n\n! arguments\nreal :: ran0\ninteger, parameter :: k4b = selected_int_kind(9)\ninteger(k4b), intent(inout) :: idum\n\n! local variables\ninteger(k4b), parameter :: ia=16807\ninteger(k4b), parameter :: im=2147483647\ninteger(k4b), parameter :: iq=127773\ninteger(k4b), parameter :: ir=2836\nreal, save :: am\ninteger(k4b), save :: ix = -1\ninteger(k4b), save :: iy = -1\ninteger(k4b), save :: k\n\n! initialize\nif (idum.le.0.or.iy.lt.0) then\n    am = nearest(1.0,-1.0)/real(im)\n    iy = ior(ieor(888889999,abs(idum)),1)\n    ix = ieor(777755555,abs(idum))\n\n    ! set idum positive\n    idum = abs(idum)+1\nendif\n\n! marsaglia shift sequence with period 2^32\u22121\nix = ieor(ix,ishft(ix,13))\nix = ieor(ix,ishft(ix,-17))\nix = ieor(ix,ishft(ix,5))\n\n! park-miller sequence by schrage\u2019s method, period 2^31\u22122.\nk = iy/iq\niy = ia*(iy-k*iq)-ir*k\nif (iy.lt.0) then\n    iy = iy+im\nendif\n\n! combine the two generators with masking to ensure nonzero value\nran0 = am*ior(iand(im,ieor(ix,iy)),1)\n\nend function\n"}, {"instruction": "Provide a Fortran function named myadd to calculate the sum of two integer numbers. The function should have 2 input parameters of type integer and 1 output parameter of type integer. When using this function, provide two integer numbers as input arguments, and the function will return their sum as the output.", "input": "", "output": "function myadd(iarg1, iarg2)\n  implicit none\n  integer :: myadd\n  integer, intent(in) :: iarg1, iarg2\n  myadd = iarg1 + iarg2\nend function myadd\n"}, {"instruction": "Create a Fortran function named is_digit to check if a given character is a digit. The function takes 1 input parameter of type character and returns 1 output parameter of type logical. The input parameter should be tested for the type 'character' and the output parameter for the type 'logical'.", "input": "", "output": "function is_digit(str)  result(res)\n  character     ,intent(in)     ::      str                                                                     !< input character string to be checked for didgits\n  logical                       ::      res                                                                     !< output indicator whether of not the input character is a number\n  select case   (str)\n  case  ('0':'9')\n    res =       .true.\n  case default\n    res =       .false.\n  end select\nend function\n"}, {"instruction": "Create a Fortran function named logical_to_string_0d that takes a single input parameter of type logical. The output is a character string. If the input logical value is true, the function returns \"t\"; otherwise, it returns \"f\".", "input": "", "output": "pure function logical_to_string_0d( var ) result(str)\n  logical                                               ,intent(in)     ::      var                             !< logical to be converted into a string\n  character(:)  ,allocatable                                            ::      str                             !< character corresponding to the input number\n  if ( var ) then\n    str =       \"t\"\n  else\n    str =       \"f\"\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named length_from_format to determine the length of a format string. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type integer.", "input": "", "output": "pure function length_from_format( fmt ) result(length)\n  character(*)                                          ,intent(in)     ::      fmt\n  integer                                                               ::      length\n  character(1)  ::      cdum\n  length        =       0\n  cdum  =       fmt\nend function\n"}, {"instruction": "Create a Fortran function named is_a_number to check if a given string is a valid numeric value. The function should take 1 input parameter of type character(*) and return 1 output parameter of type logical.", "input": "", "output": "pure function is_a_number( string )\n  character(*)                                  ,intent(in)     ::      string                                  !< string to be checked for validity as a numeric\n  logical                                                       ::      is_a_number                              !< indicator of numeric value stored in the input string\n  real(8)                                                       ::      number\n  integer                                                       ::      ios\n  read(string,*,iostat=ios) number                                                                                         ! converting the input string into a real number\n  is_a_number    =  ( ios == 0 )\nend function\n"}, {"instruction": "Write a Fortran function named get_triangular_number to compute the triangular number given two input integers, nstates and nranks. The number of input parameters is 2 and the test_data type is ['integer', 'integer']. The number of output parameters is 1 and the test_data type is ['integer'].", "input": "", "output": "    function get_triangular_number(nstates, nranks) result(triangular_number)\n        integer, intent(in) :: nstates, nranks\n        integer :: triangular_number\n\n        integer :: idx\n\n        triangular_number = nstates\n        do idx = 1, nranks-1\n            triangular_number = triangular_number*(nstates+idx)\n        end do\n\n        do idx = nranks, 2, -1\n            triangular_number = triangular_number/idx\n        end do\n    end function get_triangular_number\n"}, {"instruction": "Create a Fortran function named count_collatz that takes an integer input parameter and returns the number of steps required to reach the value 1 in the Collatz sequence. The input parameter is of type integer(4), and the output parameter is also of type integer(4).", "input": "", "output": "  pure function count_collatz(n)\n    ! default\n    implicit none\n\n    integer(4), intent(in) :: n\n    integer(4)             :: count_collatz\n\n    ! local variables\n    integer(4) :: nsteps\n    integer(8) :: n1\n\n    ! compute length of collatz chain\n    n1     = n\n    nsteps = 0\n    do while (n1 /= 1)\n       if (mod(n1,2)==0) then\n          n1 = n1/2\n       else\n          n1 = 3*n1+1\n       endif\n       nsteps = nsteps + 1\n    enddo\n\n    count_collatz = nsteps\n    return\n  end function count_collatz\n"}, {"instruction": "Write a Fortran function named iseq_v to compare each element of a double precision vector with a scalar value, using a specified tolerance level. The number of input arguments is 3, and the test_data type is ['double precision, dimension(:)', 'double precision', 'integer']. The number of output arguments is 1, and the test_data type is ['logical, dimension(size(x1))'].", "input": "", "output": "function iseq_v(x1,x2,n) !comparison between a vector and a scalar\n\timplicit none\n\tdouble precision, dimension(:), intent(in) :: x1\n\tdouble precision, intent(in) :: x2\n\tinteger, intent(in) :: n\t\n\tinteger i\n\tlogical, dimension(size(x1)) :: iseq_v\n\t\n\tdo i=1,size(x1)\n\t\tif (abs(x1(i)-x2).lt.0.5d0*10.**(-n)) then\n\t\t\tiseq_v(i)=.true.\n\t\telse\n\t\t\tiseq_v(i)=.false.\n\t\tend if\n\tend do\n\t\n\treturn\nend function iseq_v\n"}, {"instruction": "Write a Fortran function called iseq_vv to compare two vectors and return a logical array indicating element-wise equality. The function takes 3 input parameters of type double precision, dimension(:), double precision, dimension(:), and integer. The output parameter is a logical array of the same size as the input vectors. Use the imperative tone to describe the function's purpose and signature.", "input": "", "output": "function iseq_vv(x1,x2,n) !comparison between two vectors\n\timplicit none\n\tdouble precision, dimension(:), intent(in) :: x1,x2\n\tinteger, intent(in) :: n\t\n\tinteger i\n\tlogical, dimension(size(x1)) :: iseq_vv\n\t\n\tdo i=1,size(x1)\n\t\tif (abs(x1(i)-x2(i)).lt.0.5d0*10.**(-n)) then\n\t\t\tiseq_vv(i)=.true.\n\t\telse\n\t\t\tiseq_vv(i)=.false.\n\t\tend if\n\tend do\n\t\n\treturn\nend function iseq_vv\n"}, {"instruction": "Create a Fortran function named ifactorial to calculate the factorial of a given integer. The function should take 1 input parameter of type integer and return 1 output parameter of type integer.", "input": "", "output": "function ifactorial(n)\n!===============================================================================\n\n!===============================================================================\n  integer, intent(in) :: n\n  integer             :: ifactorial,i\n  ifactorial=1\n  do i=1,n\n    ifactorial=ifactorial*i\n  enddo\n  return\nend function ifactorial\n"}, {"instruction": "Create a Fortran pure function named step that takes an integer*16 input and returns an integer*16 output. The function computes the step number based on the input value and returns the result as output.", "input": "", "output": "  pure function step(n)\n    implicit none\n    integer*16, intent(in) :: n\n    integer                :: i, digits\n    real*16                :: temp\n    integer*16             :: step\n\n    temp=n*1.0\n    step=n\n    digits=int(ceiling(log10(temp)))\n    do i=1,digits\n       step=step+mod(n/10_16**(digits-i),10)*(10_16**(i-1))\n    end do\n\n  end function step\n"}, {"instruction": "Create a Fortran function named stdiag to generate a structured diagonal matrix based on the given stencil vector and dimension. The function takes 3 input parameters: an integer n, a real array s, and an integer err. It returns a real array stdiag of dimensions n x n as output.", "input": "", "output": "        function stdiag(n, s, err)\n            implicit none\n            ! dimension of returned stdiag\n            integer(4), intent(in) :: n\n            ! stencil vector\n            real(8), dimension(:), intent(in) :: s\n            ! errornumber\n            integer(4), intent(out) :: err\n\n            ! result\n            real(8), dimension(n, n) :: stdiag\n            real(8), dimension(n*n) :: tmp\n            ! size of s, middle index, size of tmp\n            integer(4) :: l, m, nn\n            ! loop indices\n            integer(4) :: i, k\n\n            stdiag = 0\n            l = size(s)\n            ! checking conditions\n            if (mod(l, 2) == 0) then\n                err = -1\n                return\n            else if (n <= l/2) then\n                err = -2\n                return\n            end if\n            err = 0\n            ! if s contains one element, return diag(s(1))\n            if (l == 1) then\n                do i=1, n\n                    stdiag(i, i) = s(1)\n                end do\n                return\n            end if\n\n            tmp = 0\n            nn = size(tmp)\n            m = (l-1) / 2\n            k = 0\n            ! fill upper and lower elements of stdiag with slices of s\n            do i = 1, n*m, n\n                tmp(i : i+m+k) = s(m+1-k : l)           ! upper \n                tmp(nn-i-(m+k) : nn-i) = s(0 : m+1+k)   ! lower\n                k = k + 1       ! extend slice of s by 1 for next iter\n            end do\n            ! fill rest of stdiag with copies of s along the diagonal\n            do i = n*m+1, n*(n-m), n+1\n                tmp(i:i+l) = s\n            end do\n\n            stdiag = reshape(tmp, [n, n])\n        end function stdiag\n"}, {"instruction": "Write a Fortran function named f1 that takes an integer input parameter and returns a character string consisting of 'a' repeated the number of times specified by the input parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(len=n)].", "input": "", "output": "function f1(n) result(r)\ninteger, intent(in) :: n\ncharacter(len=n) :: r\ninteger :: i\ndo i = 1, n\n    r(i:i) = \"a\"\nend do\nend function\n"}, {"instruction": "Write a Fortran function named get_intlength to determine the number of digits in an integer input. The function should take 1 input argument of type integer and return 1 output argument of type integer. The input test_data type is ['integer'] and the output test_data type is ['integer']. Use the imperative tone in your instructions.", "input": "", "output": "function get_intlength(myinteger) result(mylen)\n\ninteger        ::myinteger,mylen\n\nmylen=1\nif(myinteger<10)then\n   mylen=1\nelseif((myinteger>=10).and.(myinteger<100))then\n   mylen=2\nelseif((myinteger>=100).and.(myinteger<1000))then\n   mylen=3\nendif\nreturn\nend function get_intlength\n"}, {"instruction": "Write a Fortran function named hipranddestroygenerator that takes an input parameter of type integer(c_size_t) by value. The function returns an output parameter of type integer(c_int). This function should follow the features of Fortran.", "input": "", "output": "        function hipranddestroygenerator(generator) &\n        bind(c, name=\"hipranddestroygenerator\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hipranddestroygenerator\n            integer(c_size_t), value :: generator\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandsetstream to set the random number generator stream for the HIP platform. The function has 2 input parameters of type integer(c_size_t), passed by value. It returns a single output parameter of type integer(c_int). The function should be called using the bind(C) attribute and the name \"hiprandsetstream\".", "input": "", "output": "        function hiprandsetstream(generator, stream) &\n        bind(c, name=\"hiprandsetstream\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetstream\n            integer(c_size_t), value :: generator\n            integer(c_size_t), value :: stream\n        end function\n"}, {"instruction": "Write a Fortran function named hiprandsetpseudorandomgeneratorseed to set the seed for a pseudorandom number generator. The function should have 2 input parameters of type integer(c_size_t) and integer(kind=8), both passed by value. The function should return an output parameter of type integer(c_int). The name of the function is hiprandsetpseudorandomgeneratorseed.", "input": "", "output": "        function hiprandsetpseudorandomgeneratorseed(generator, seed) &\n        bind(c, name=\"hiprandsetpseudorandomgeneratorseed\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetpseudorandomgeneratorseed\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: seed\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandsetgeneratoroffset to set the offset of a random number generator. The function takes 2 input parameters of type integer(c_size_t) and integer(kind=8) passed by value. It returns an output parameter of type integer(c_int).", "input": "", "output": "        function hiprandsetgeneratoroffset(generator, offset) &\n        bind(c, name=\"hiprandsetgeneratoroffset\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandsetgeneratoroffset\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: offset\n        end function\n"}, {"instruction": "Create a Fortran function named hiprandgetversion to retrieve the version number of the hipRAND library. The function should take 1 input parameter of type integer(c_int) and return 1 output parameter of type integer(c_int). The input parameter represents the version number, and the output parameter will store the retrieved version number. Use the imperative tone to specify these requirements.", "input": "", "output": "        function hiprandgetversion(version) &\n        bind(c, name=\"hiprandgetversion\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hiprandgetversion\n            integer(c_int) :: version\n        end function\n"}, {"instruction": "Create a Fortran function named hipranddestroydistribution to destroy a discrete random number generator distribution. The function takes 1 input parameter of type integer(c_size_t), passed by value. The output is an integer(c_int). The test data types for input and output parameters are ['integer(c_size_t), value'] and ['integer(c_int)'] respectively.", "input": "", "output": "        function hipranddestroydistribution(discrete_distribution) &\n        bind(c, name=\"hipranddestroydistribution\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: hipranddestroydistribution\n            integer(c_size_t), value :: discrete_distribution\n        end function\n"}, {"instruction": "Write a Fortran function named is_in to check if a given character is present in a string. The function should take 2 input parameters of type character(len=1) and character(len=*), and return 1 output parameter of type logical.", "input": "", "output": "function is_in(c, str) result(is)\n    character(len=1), intent(in) :: c\n    character(len=*), intent(in) :: str\n    logical :: is\n\n    integer :: i\n\n    is = .false.\n    do i = 1, len(str)\n        if (c == str(i:i)) then\n            is = .true.\n            exit\n        end if\n    end do\nend function is_in\n"}, {"instruction": "Create a Fortran function named \"gases\" to compute the 2-way gaseous attenuation through a volume in microwave. This function takes 4 input parameters of type real*8: pressure (pres_mb), temperature (t), relative humidity (rh), and frequency (f). It returns 1 output parameter of type real*8, which represents the 2-way gaseous attenuation in decibels per kilometer.", "input": "", "output": "  function gases(pres_mb,t,rh,f)\n  implicit none\n  \n! purpose:\n!   compute 2-way gaseous attenuation through a volume in microwave\n!\n! inputs:\n!   [pres_mb]   pressure (mb) (hpa)\n!   [t]         temperature (k)\n!   [rh]        relative humidity (%)\n!   [f]         frequency (ghz), < 300 ghz\n!\n! returns:\n!   2-way gaseous attenuation (db/km)\n!\n! reference:\n!   uses method of liebe (1985)\n!\n! created:\n!   12/09/05  john haynes (haynes@atmos.colostate.edu)\n! modified:\n!   01/31/06  port from idl to fortran 90\n\n  integer, parameter :: &\n  nbands_o2 = 48 ,&\n  nbands_h2o = 30\n  real*8, intent(in) :: pres_mb, t, rh, f\n  real*8 :: gases, th, e, p, sumo, gm0, a0, ap, term1, term2, term3, &\n            bf, be, term4, npp\n  real*8, dimension(nbands_o2) :: v0, a1, a2, a3, a4, a5, a6\n  real*8, dimension(nbands_h2o) :: v1, b1, b2, b3\n  real*8 :: e_th,one_th,pth3,eth35,aux1,aux2,aux3,aux4\n  real*8 :: gm,delt,x,y,gm2\n  real*8 :: fpp_o2,fpp_h2o,s_o2,s_h2o\n  integer :: i\n  \n! // table1 parameters  v0, a1, a2, a3, a4, a5, a6  \n  data v0/49.4523790,49.9622570,50.4742380,50.9877480,51.5033500, &\n  52.0214090,52.5423930,53.0669060,53.5957480,54.1299999,54.6711570, &\n  55.2213650,55.7838000,56.2647770,56.3378700,56.9681000,57.6124810, &\n  58.3238740,58.4465890,59.1642040,59.5909820,60.3060570,60.4347750, &\n  61.1505580,61.8001520,62.4112120,62.4862530,62.9979740,63.5685150, &\n  64.1277640,64.6789000,65.2240670,65.7647690,66.3020880,66.8368270, &\n  67.3695950,67.9008620,68.4310010,68.9603060,69.4890210,70.0173420, &\n  118.7503410,368.4983500,424.7631200,487.2493700,715.3931500, &\n  773.8387300, 834.1453300/\n  data a1/0.0000001,0.0000003,0.0000009,0.0000025,0.0000061,0.0000141, &\n  0.0000310,0.0000641,0.0001247,0.0002280,0.0003918,0.0006316,0.0009535, &\n  0.0005489,0.0013440,0.0017630,0.0000213,0.0000239,0.0000146,0.0000240, &\n  0.0000211,0.0000212,0.0000246,0.0000250,0.0000230,0.0000193,0.0000152, &\n  0.0000150,0.0000109,0.0007335,0.0004635,0.0002748,0.0001530,0.0000801, &\n  0.0000395,0.0000183,0.0000080,0.0000033,0.0000013,0.0000005,0.0000002, &\n  0.0000094,0.0000679,0.0006380,0.0002350,0.0000996,0.0006710,0.0001800/\n  data a2/11.8300000,10.7200000,9.6900000,8.8900000,7.7400000,6.8400000, &\n  6.0000000,5.2200000,4.4800000,3.8100000,3.1900000,2.6200000,2.1150000, &\n  0.0100000,1.6550000,1.2550000,0.9100000,0.6210000,0.0790000,0.3860000, &\n  0.2070000,0.2070000,0.3860000,0.6210000,0.9100000,1.2550000,0.0780000, &\n  1.6600000,2.1100000,2.6200000,3.1900000,3.8100000,4.4800000,5.2200000, &\n  6.0000000,6.8400000,7.7400000,8.6900000,9.6900000,10.7200000,11.8300000, &\n  0.0000000,0.0200000,0.0110000,0.0110000,0.0890000,0.0790000,0.0790000/\n  data a3/0.0083000,0.0085000,0.0086000,0.0087000,0.0089000,0.0092000, &\n  0.0094000,0.0097000,0.0100000,0.0102000,0.0105000,0.0107900,0.0111000, &\n  0.0164600,0.0114400,0.0118100,0.0122100,0.0126600,0.0144900,0.0131900, &\n  0.0136000,0.0138200,0.0129700,0.0124800,0.0120700,0.0117100,0.0146800, &\n  0.0113900,0.0110800,0.0107800,0.0105000,0.0102000,0.0100000,0.0097000, &\n  0.0094000,0.0092000,0.0089000,0.0087000,0.0086000,0.0085000,0.0084000, &\n  0.0159200,0.0192000,0.0191600,0.0192000,0.0181000,0.0181000,0.0181000/\n  data a4/0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000,0.0000000, &\n  0.0000000,0.6000000,0.6000000,0.6000000,0.6000000,0.6000000,0.6000000/\n  data a5/0.0056000,0.0056000,0.0056000,0.0055000,0.0056000,0.0055000, &\n  0.0057000,0.0053000,0.0054000,0.0048000,0.0048000,0.0041700,0.0037500, &\n  0.0077400,0.0029700,0.0021200,0.0009400,-0.0005500,0.0059700,-0.0024400, &\n  0.0034400,-0.0041300,0.0013200,-0.0003600,-0.0015900,-0.0026600, &\n  -0.0047700,-0.0033400,-0.0041700,-0.0044800,-0.0051000,-0.0051000, &\n  -0.0057000,-0.0055000,-0.0059000,-0.0056000,-0.0058000,-0.0057000, &\n  -0.0056000,-0.0056000,-0.0056000,-0.0004400,0.0000000,0.0000000, &\n  0.0000000,0.0000000,0.0000000,0.0000000/\n  data a6/1.7000000,1.7000000,1.7000000,1.7000000,1.8000000,1.8000000,&\n  1.8000000,1.9000000,1.8000000,2.0000000,1.9000000,2.1000000,2.1000000, &\n  0.9000000,2.3000000,2.5000000,3.7000000,-3.1000000,0.8000000,0.1000000, &\n  0.5000000,0.7000000,-1.0000000,5.8000000,2.9000000,2.3000000,0.9000000, &\n  2.2000000,2.0000000,2.0000000,1.8000000,1.9000000,1.8000000,1.8000000, &\n  1.7000000,1.8000000,1.7000000,1.7000000,1.7000000,1.7000000,1.7000000, &\n  0.9000000,1.0000000,1.0000000,1.0000000,1.0000000,1.0000000,1.0000000/\n\n! // table2 parameters  v1, b1, b2, b3\n  data v1/22.2350800,67.8139600,119.9959400,183.3101170,321.2256440, &\n  325.1529190,336.1870000,380.1973720,390.1345080,437.3466670,439.1508120, &\n  443.0182950,448.0010750,470.8889740,474.6891270,488.4911330,503.5685320, &\n  504.4826920,556.9360020,620.7008070,658.0065000,752.0332270,841.0735950, &\n  859.8650000,899.4070000,902.5550000,906.2055240,916.1715820,970.3150220, &\n  987.9267640/\n  data b1/0.1090000,0.0011000,0.0007000,2.3000000,0.0464000,1.5400000, &\n  0.0010000,11.9000000,0.0044000,0.0637000,0.9210000,0.1940000,10.6000000, &\n  0.3300000,1.2800000,0.2530000,0.0374000,0.0125000,510.0000000,5.0900000, &\n  0.2740000,250.0000000,0.0130000,0.1330000,0.0550000,0.0380000,0.1830000, &\n  8.5600000,9.1600000,138.0000000/\n  data b2/2.1430000,8.7300000,8.3470000,0.6530000,6.1560000,1.5150000, &\n  9.8020000,1.0180000,7.3180000,5.0150000,3.5610000,5.0150000,1.3700000, &\n  3.5610000,2.3420000,2.8140000,6.6930000,6.6930000,0.1140000,2.1500000, &\n  7.7670000,0.3360000,8.1130000,7.9890000,7.8450000,8.3600000,5.0390000, &\n  1.3690000,1.8420000,0.1780000/\n  data b3/0.0278400,0.0276000,0.0270000,0.0283500,0.0214000,0.0270000, &\n  0.0265000,0.0276000,0.0190000,0.0137000,0.0164000,0.0144000,0.0238000, &\n  0.0182000,0.0198000,0.0249000,0.0115000,0.0119000,0.0300000,0.0223000, &\n  0.0300000,0.0286000,0.0141000,0.0286000,0.0286000,0.0264000,0.0234000, &\n  0.0253000,0.0240000,0.0286000/\n  \n! // conversions\n  th = 300./t       ! unitless\n  e = (rh*th**5)/(41.45*10**(9.834*th-10))   ! kpa\n  p = pres_mb/10.-e ! kpa\n  e_th = e*th\n  one_th = 1 - th\n  pth3 = p*th**(3)\n  eth35 = e*th**(3.5)\n\n! // term1\n  sumo = 0.\n  aux1 = 1.1*e_th\n  do i=1,nbands_o2\n    aux2 = f/v0(i)\n    aux3 = v0(i)-f\n    aux4 = v0(i)+f\n    gm = a3(i)*(p*th**(0.8-a4(i))+aux1)\n    gm2 = gm**2\n    delt = a5(i)*p*th**a6(i)\n    x = aux3**2+gm2\n    y = aux4**2+gm2\n    fpp_o2 = (((1./x)+(1./y))*(gm*aux2) - (delt*aux2)*((aux3/(x))-(aux4/(x))))\n    s_o2 = a1(i)*pth3*exp(a2(i)*one_th)\n    sumo = sumo + fpp_o2 * s_o2\n  enddo\n  term1 = sumo\n\n! // term2\n  gm0 = 5.6e-3*(p+1.1*e)*th**(0.8)\n  a0 = 3.07e-4\n  ap = 1.4*(1-1.2*f**(1.5)*1e-5)*1e-10\n  term2 = (2*a0*(gm0*(1+(f/gm0)**2)*(1+(f/60.)**2))**(-1) + ap*p*th**(2.5)) &\n          * f*p*th**2\n\n! // term3\n  sumo = 0.\n  aux1 = 4.8*e_th\n  do i=1,nbands_h2o\n    aux2 = f/v1(i)\n    aux3 = v1(i)-f\n    aux4 = v1(i)+f\n    gm = b3(i)*(p*th**(0.8)+aux1)\n    gm2 = gm**2\n    x = aux3**2+gm2\n    y = aux4**2+gm2\n    !delt = 0.\n    fpp_h2o = ((1./x)+(1./y))*(gm*aux2) ! - (delt*aux2)*((aux3/(x))-(aux4/(x)))\n    s_h2o = b1(i)*eth35*exp(b2(i)*one_th)\n    sumo = sumo + fpp_h2o * s_h2o\n  enddo\n  term3 = sumo\n\n! // term4\n  bf = 1.4e-6\n  be = 5.41e-5\n  term4 = (bf*p+be*e*th**3)*f*e*th**(2.5)\n\n! // summation and result\n  npp = term1 + term2 + term3 + term4\n  gases = 0.182*f*npp\n\n  end function gases\n"}, {"instruction": "Write a Fortran function named clip that takes 4 input parameters of types integer, double precision, double precision, and double precision array of dimension n, and 1 output parameter of type double precision array of dimension n. The function is designed to clip the values of the input array x within the range specified by the inputs a and b, and store the clipped values in the output array y. The function uses a do loop to iterate through the elements of the input array and applies the clipping logic.", "input": "", "output": "        function clip(x, n, a, b) result (y)\r\n            integer, intent(in) :: n\r\n            integer :: k\r\n            double precision, intent(in) :: a, b\r\n            double precision, dimension(n), intent(in) :: x\r\n            double precision, dimension(n) :: y\r\n\r\n            do k=1, n\r\n                if ((a <= x(k)) .and. (x(k) <= b)) then\r\n                    y(k) = x(k)\r\n                else\r\n                    y(k) = dnan\r\n                end if\r\n            end do\r\n            return\r\n        end function\r\n"}, {"instruction": "Write a Fortran function named outer_product to calculate the outer product of two vectors. The number of input parameters is 3, with test_data types ['integer', 'double precision, dimension(n)', 'double precision, dimension(n)']. The number of output parameters is 1, with a test_data type of ['double precision, dimension(n, n)']. Use the imperative tone and ensure the correct understanding and summary of the function.", "input": "", "output": "        function outer_product(x, y, n) result (a)\r\n            implicit none\r\n            integer :: n\r\n            double precision, dimension(n), intent(in) :: x, y\r\n            double precision, dimension(n, n) :: a\r\n            integer :: i, j\r\n            do i=1,n\r\n                do j=1,n\r\n                    a(i, j) = x(i) * y(j)\r\n                end do\r\n            end do\r\n            return\r\n        end function\r\n"}, {"instruction": "Create a Fortran function named det to recursively calculate the determinant of a square matrix. The number of input arguments is 2, with test data types ['integer', 'double precision, dimension(n, n)'], and the number of output arguments is 1 with a test data type ['double precision'].", "input": "", "output": "        recursive function det(a, n) result (d)\r\n            implicit none\r\n            integer :: n\r\n            double precision, dimension(n, n) :: a\r\n            double precision, dimension(n-1, n-1) :: x\r\n            integer :: i\r\n            double precision :: d, s\r\n\r\n            if (n == 1) then\r\n                d = a(1, 1)\r\n                return\r\n            elseif (n == 2) then\r\n                d = a(1, 1) * a(2, 2) - a(1, 2) * a(2, 1)\r\n                return\r\n            else\r\n                d = 0.0d0\r\n                s = 1.0d0\r\n                do i = 1, n\r\n!                   compute submatrix x\r\n                    x(:,  :i-1) = a(2:,    :i-1)\r\n                    x(:, i:   ) = a(2:, i+1:   )\r\n                    d = s * det(x, n-1) * a(1, i) + d\r\n                    s = -s\r\n                end do\r\n            end if\r\n            return\r\n        end function\r\n"}, {"instruction": "Write a Fortran function named floatfac that calculates the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function floatfac(in)\n  implicit none\n  integer,intent(in) :: in\n  integer ::  i\n  real*8 :: floatfac, sum\n  sum=1.d0\n  do i=1,in\n     sum=sum*i\n  enddo\n  floatfac=sum\nend function floatfac\n"}, {"instruction": "Create a Fortran function named myisnan to determine if a given double precision floating point number is NaN (Not a Number). The function should take 1 input argument of type real*8 and return 1 output argument of type logical. The test_data type for input is ['real*8'] and for output is ['logical'].", "input": "", "output": "function myisnan(input)\n  implicit none\n  real*8,intent(in) :: input\n  logical :: myisnan\n  if ((input+1.0d0.eq.input)) then\n     myisnan=.true.\n  else\n     myisnan=.false.\n  endif\nend function myisnan\n"}, {"instruction": "Write a Fortran function named mod97 to calculate the modulo 97 of a given string of integers. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer. The name of the function is mod97.", "input": "", "output": "    function mod97(strint) result(res)\n        character(len=*), intent(in) :: strint\n        integer :: i, num, res\n        res = 0\n        do  i=1, len(trim(strint))\n            read(strint(i:i),*) num\n            res = mod((res*10 + num),97);\n        end do\n    end function mod97\n"}, {"instruction": "Write a Fortran function named sum_ to calculate the sum of all elements in an array. The function takes 1 input parameter of type integer, allocatable, dimension(: ), and returns 1 output parameter of type integer.", "input": "", "output": "    function sum_(x) result(y)\n    integer ,allocatable, dimension(: ), intent(in):: x\n    integer:: y\n    integer:: i\n    integer:: i_cyml0\n    y = 0\n    do i_cyml0 = 1, size(x)\n        i = x(i_cyml0)\n        y = y + i\n    end do\n    end function sum_\n"}, {"instruction": "Write a Fortran function named replace_asterisk_with_step to create a new filename by replacing the asterisk (*) in the input filename with the specified step value. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "        function replace_asterisk_with_step(filename, step) result(new_filename)\n            character(len=*), intent(in) :: filename\n            integer, intent(in) :: step\n            character(len=:), allocatable :: new_filename\n\n            character(len=:), allocatable :: prefix, suffix\n            integer :: new_length, asterisk_location\n\n            asterisk_location = index(filename, \"*\")\n\n            prefix = filename(1:asterisk_location-1)\n            suffix = filename(asterisk_location+1:)\n\n            if (step == 0) then\n                new_length = 1\n            else\n                new_length = floor(log10(1.0d0*step)) + 1\n            end if\n\n            new_length = new_length + len(prefix) + len(suffix)\n\n            allocate(character(len=new_length) :: new_filename)\n\n            write(new_filename, '(a,i0,a)') prefix, step, suffix\n\n        end function\n"}, {"instruction": "Create a Fortran function named local_to_global_param that converts a local parameter to the global domain within the specified range (a <= u <= b).\nThe function takes 3 input parameters of type double precision: a (lower global parameter), b (upper global parameter), and ul (local parameter).\nIt produces 1 output parameter, ug, of type double precision, which represents the global parameter.\nEnsure that the local parameter ul is constrained within the range [0.0, 1.0].", "input": "", "output": "function local_to_global_param(a, b, ul) result(ug)\n    !> convert the local parameter to the global domain\n    !> (a <= u <= b).\n    !> a - lower global parameter.\n    !> b - upper global parameter.\n    !> ul - local parameter.\n    !> ug - global parameter.\n    \n    ! input\n    double precision, intent(in) :: a, b, ul\n    \n    ! output\n    double precision :: ug\n    \n    ! working\n    double precision :: ui\n    \n    ui = ul\n    if (ui .lt. 0.0d0) then\n        ui = 0.0d0\n    else if (ui .gt. 1.0d0) then\n        ui = 1.0d0\n    end if\n    ug = a + ui * (b - a)\n    \nend function local_to_global_param\n"}, {"instruction": "Create a Fortran function named getcodeforcolor to retrieve the ANSI escape code for a given color. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(8). The input arguments should be of test_data type ['character(*)'], and the output should be of test_data type ['character(8)'].", "input": "", "output": "    function getcodeforcolor(color) result(code)\n        character(*)    :: color\n        character(8)    :: code\n        select case (color)\n            case (\"lightblue\")\n                code = \"\\x1b[94m\"\n            case (\"yellow\")\n                code = \"\\x1b[33m\"\n            case (\"green\")\n                code = \"\\x1b[32m\"\n            case default\n                code = \"\"\n        end select\n    end function\n"}, {"instruction": "Create a Fortran function named firstlocation to find the first occurrence of a specified character in a given string. The function takes 3 input parameters: a character, a search string, and an optional logical parameter. The input parameter types are ['character(len=1)', 'character(len=*)', 'logical, optional']. The function has 1 output parameter of type ['integer'].", "input": "", "output": "  function firstlocation(acharacter,searchstring,back) result(location)\n    character(len=1),intent(in)::acharacter\n    character(len=*),intent(in)::searchstring\n    logical,intent(in),optional::back\n    integer::location\n\n    !local variables\n    logical::localback\n    localback=.false.\n    if (present(back)) localback=back\n\n    location=0 !default: 0 means character is not found in the search string \n    location=scan(searchstring,acharacter,back=localback)      \n\n  end function firstlocation\n"}, {"instruction": "Provide a Fortran function named countoccurance to count the occurrences of a specific character within a given string. The function takes 2 input arguments with data types ['character(len=1)', 'character(len=*)'] and 1 output argument with data type ['integer'].", "input": "", "output": "  function countoccurance(acharacter,searchstring) result(numberofoccurance)\n    character(len=1),intent(in)::acharacter\n    character(len=*),intent(in)::searchstring\n    integer::numberofoccurance\n\n    integer::indx\n\n    numberofoccurance=0  !default\n    do indx=1,len(searchstring)\n      if (searchstring(indx:indx).eq.acharacter) numberofoccurance=numberofoccurance+1\n    end do\n    \n  end function countoccurance\n"}, {"instruction": "Provide a Fortran function named texttoint to convert a string of characters representing a number into an integer. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function texttoint(astring) result(number)\n    character(len=*)::astring\n    integer::number\n\n    character(len=10), parameter ::intchar = '0123456789' \n    integer :: k    ! loop counter\n    integer :: loc  ! position in character version of numbers\n    integer :: poweroften\n\n    number=0  !initialize\n    poweroften=0\n\n    do k = len_trim(astring),1,-1      !  to change letters\n      loc = index(intchar,astring (k:k))                   ! locate\n      if (loc.ne.0) then\n        loc=loc-1\n        number = number + loc*(10**poweroften)             ! calculate\n      end if\n      poweroften=poweroften+1\n    end do \n\n  end function texttoint\n"}, {"instruction": "Create a Fortran function named tolerance to calculate the tolerance for comparing two real numbers. The function takes 2 input parameters of type real(8), and returns 1 output parameter of type real(8).", "input": "", "output": "  function tolerance(r1,r2) result(toler)\n    real(8),intent(in)::r1,r2\n    real(8)::toler\n\n    !local variables\n    integer::dg1,dg2,prec1,prec2\n    real(8)::err1,err2,absr1,absr2\n\n    !initialize\n    prec1 = precision(r1)\n    prec2 = precision(r2)\n    absr1 = abs(r1)\n    absr2 = abs(r2)\n\n    !find the number of digits on the left side of decimal point for r1\n    do dg1=prec1,1,-1\n      if (int(absr1/10d0**(dg1-1)) .gt. 0d0) exit\n    end do\n\n    !find the number of digits on the left side of decimal point for r2\n    do dg2=prec2,1,-1\n      if (int(absr2/10d0**(dg2-1)) .gt. 0d0) exit\n    end do\n\n    !tolernace for each number\n    err1 = 10d0**(-(prec1-dg1+1))\n    err2 = 10d0**(-(prec2-dg2+1))\n\n    !final tolerance is the larger of the two tolerances\n    toler = max(err1,err2)\n\n  end function tolerance\n"}, {"instruction": "Create a Fortran function named fun_find_str_i that finds the position of a specified string within an array of strings. The function takes 2 input parameters of type character(len=*) and character(len=*),dimension(:), and returns 1 output parameter of type integer.", "input": "", "output": "  function fun_find_str_i(dum_str,dum_data)\n    ! common blocks\n    implicit none\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    integer::fun_find_str_i\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    character(len=*),intent(in)::dum_str\n    character(len=*),dimension(:),intent(in)::dum_data\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::i,loc_imax\n    ! -------------------------------------------------------- !\n    ! find i\n    ! -------------------------------------------------------- !\n    loc_imax = size(dum_data)\n    i = 0\n    do i=1,loc_imax\n       if (dum_str == dum_data(i)) exit \n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n    fun_find_str_i = i\n    ! -------------------------------------------------------- !\n  end function fun_find_str_i\n"}, {"instruction": "Create a Fortran function named fun_calc_isotope_fractionr to calculate the isotope fraction. It takes 2 input arguments of type real: dum_delta and dum_standard. The output is a single real value. The function returns dum_standard multiplied by (1.0 + dum_delta/1000.0).", "input": "", "output": "  function fun_calc_isotope_fractionr(dum_delta,dum_standard)\n    implicit none\n    ! result variable\n    real::fun_calc_isotope_fractionr\n    ! dummy arguments\n    real,intent(in)::dum_delta,dum_standard\n\n    fun_calc_isotope_fractionr = dum_standard*(1.0 + dum_delta/1000.0)\n  end function fun_calc_isotope_fractionr\n"}, {"instruction": "Create a Fortran function called fun_calc_isotope_abundancer0 to calculate the isotope abundance ratio based on the total abundance and the two isotope ratios. Ensure that the function has 3 input parameters of type real: dum_totabundance, dum_r1, dum_r2, and 1 output parameter of type real.", "input": "", "output": "  function fun_calc_isotope_abundancer0(dum_totabundance,dum_r1,dum_r2)\n    implicit none\n    ! result variable\n    real::fun_calc_isotope_abundancer0\n    ! dummy arguments\n    real,intent(in)::dum_totabundance,dum_r1,dum_r2\n\n    fun_calc_isotope_abundancer0 = dum_totabundance/(1.0 + dum_r1 + dum_r2)\n  end function fun_calc_isotope_abundancer0\n"}, {"instruction": "Create a Fortran function named fun_corr_p to calculate a corrected pressure value based on given input parameters. The function takes 4 input arguments of type real and real, with the last argument being an array of 5 real numbers. The output is a single real value.", "input": "", "output": "  function fun_corr_p(dum_tc,dum_p,dum_rrtimest,dum_dp)\n    ! result variable\n    real::fun_corr_p\n    ! dummy arguments\n    real,intent(in)::dum_tc,dum_p,dum_rrtimest\n    real,intent(in),dimension(5)::dum_dp\n\n    fun_corr_p = &\n         & ( &\n         &   -(dum_dp(1) + dum_dp(2)*dum_tc + dum_dp(3)*dum_tc*dum_tc) + &\n         &   (5.0e-4*(dum_dp(4) + dum_dp(5)*dum_tc))*dum_p &\n         & )*dum_p*dum_rrtimest\n  end function fun_corr_p\n"}, {"instruction": "Create a Fortran function named fun_get_grid_lone that takes an integer input argument. The function returns an array of real numbers with a dimension of 1 to dum_n_i+1.", "input": "", "output": "  function fun_get_grid_lone(dum_n_i)\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    integer,intent(in)::dum_n_i                                  !\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real,dimension(1:dum_n_i+1)::fun_get_grid_lone            !\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::i\n    ! -------------------------------------------------------- !\n    ! calculate and return grid variable\n    ! -------------------------------------------------------- !\n    do i=1,dum_n_i+1\n       fun_get_grid_lone(i) = (360.0/dum_n_i)*real(i-1) + par_grid_lon_offset\n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_get_grid_lone\n"}, {"instruction": "Create a Fortran function named fun_get_grid_z to calculate grid vector for ocean depths. The function takes 2 input arguments of type integer and real, and returns 1 output argument of type real with dimension 1 to dum_n_k.", "input": "", "output": "  function fun_get_grid_z(dum_n_k,dum_dsc)\n    ! -------------------------------------------------------- !\n    ! dummy arguments\n    ! -------------------------------------------------------- !\n    integer,intent(in)::dum_n_k                                !\n    real,intent(in)::dum_dsc                                   ! max ocean depth (m)\n    ! -------------------------------------------------------- !\n    ! result variable\n    ! -------------------------------------------------------- !\n    real,dimension(1:dum_n_k)::fun_get_grid_z                  ! equivalent to goldstein variable zro\n    ! -------------------------------------------------------- !\n    ! define local variables\n    ! -------------------------------------------------------- !\n    integer::k                                                 ! local counting variable\n    real::loc_ez0\n    real::loc_z1\n    real::loc_tv1,loc_tv2,loc_tv3,loc_tv4,loc_tv5\n    real,dimension(1:dum_n_k)::loc_dz,loc_dza\n    ! -------------------------------------------------------- !\n    ! initialize local variables\n    ! -------------------------------------------------------- ! for variable (exponential) dz use ez0 > 0, else use ez0 < 0\n    loc_ez0 = 0.1\n    ! -------------------------------------------------------- !\n    ! calculate and return grid vector\n    ! -------------------------------------------------------- !\n    ! tv3 is the depth of the kth w level from the top\n    ! tv5 is the depth of the k+1th density level from the top\n    loc_z1 = loc_ez0*((1.0 + 1.0/loc_ez0)**(1.0/real(dum_n_k)) - 1.0)\n    loc_tv1 = 0.0\n    loc_tv2 = 0.0\n    loc_tv4 = loc_ez0*((loc_z1/loc_ez0 + 1.0)**0.5 - 1.0)\n    do k=1,dum_n_k\n       if (loc_ez0 > 0.0) then\n          loc_tv3 = loc_ez0*((loc_z1/loc_ez0+1)**real(k) - 1.0)\n          loc_dz(dum_n_k-k+1) = loc_tv3 - loc_tv2\n          loc_tv2 = loc_tv3\n          loc_tv5 = loc_ez0*((loc_z1/loc_ez0+1)**(real(k)+0.5) - 1.0)\n          if(k < dum_n_k) then\n             loc_dza(dum_n_k-k) = loc_tv5 - loc_tv4\n          else\n             loc_dza(k) = loc_dz(dum_n_k)/2.0\n          end if\n          loc_tv4 = loc_tv5\n          loc_tv1 = loc_tv1 + loc_dz(dum_n_k-k+1)\n       else\n          loc_dz(k)  = 1.0/real(dum_n_k)\n          loc_dza(k) = 1.0/real(dum_n_k)\n       endif\n    enddo\n    do k=1,dum_n_k\n       fun_get_grid_z(k) = dum_dsc*sum(loc_dza(k:dum_n_k))\n    end do\n    ! -------------------------------------------------------- !\n    ! end\n    ! -------------------------------------------------------- !\n  end function fun_get_grid_z\n"}, {"instruction": "Create a Fortran function named bar that takes an array of integers as input. The input parameter should be a one-dimensional array of any size. The function should return a two-dimensional array of integers with the first row filled with 1s and the second row containing the elements of the input array.", "input": "", "output": "  function bar(x) result(a)\n    integer, dimension(:), intent(in) :: x\n    integer, dimension(2,size(x)) :: a\n    a(1,:) = 1\n    a(2,:) = x\n  end function\n"}, {"instruction": "Provide a Fortran function named gammln to calculate the natural logarithm of the absolute value of the gamma function. The number of input arguments is 1 and the test_data type is ['real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function gammln(xx)\n!\nimplicit none\n!\n\n!\nreal :: xx\nreal :: gammln\n!\n! local variables\n!\nreal*8,dimension(6) :: cof\nreal*8 :: dble\nreal*8 :: fpf,half,one,ser,stp,tmp,x\ninteger :: j\n!\n!     + + + purpose + + +\n\n!     full accuracy is obtained for xx > 1\n!     for 0 < xx < 1, the reflection formula (6.1.4) can be used first.\n!\n!     based on:\n!     'numerical recipes - the art of scientific computing',\n!     w.h. press, b.p. flannery, s.a. teukolsky, w.t. vetterling\n!     cambridge university press, 1986\n!     pg 157\n!\n!     + + + keywords + + +\n\n!\n!     + + + argument declarations + + +\n!\n!\n!     + + + argument definitions + + +\n!     xx     - real value for values > 0\n!\n!     + + + local variables + + +\n!\ndata cof,stp/76.18009173d0, - 86.50532033d0,24.01409822d0, - 1.231739516d0,     &\n   & 0.120858003d-2, - 0.536382d-5,2.50662827465d0/\ndata half,one,fpf/0.5d0,1.0d0,5.5d0/\n!\n!     + + + end specifications + + +\n!\nx = dble(xx) - one\ntmp = x + fpf\ntmp = (x+half)*log(tmp) - tmp\nser = one\ndo j = 1,6\n  x = x + one\n  ser = ser + cof(j)/x\nend do\n!\ngammln = tmp + log(stp*ser)\n! \nend function gammln\n"}, {"instruction": "Write a Fortran function named int_in_array to check if a given integer is present in an array of integers. The function takes 2 input parameters with test data types ['integer', 'integer, dimension(:)'] and returns 1 output parameter with a test data type of ['logical'].", "input": "", "output": "function int_in_array(number, array) \n integer, intent(in) :: number\n integer, dimension(:), intent(in) :: array\n logical :: int_in_array\n \n integer :: i\n \n int_in_array = .false.\n \n do i=lbound(array,dim=1),ubound(array,dim=1)\n  if(number.eq.array(i)) int_in_array = .true.\n enddo \n \nend function int_in_array\n"}, {"instruction": "Create a Fortran function called derivative2d1 to calculate the first derivative of a 2D array with respect to the first dimension. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). The number of input arguments is 2, and the test_data type is ['real(8), dimension(:,:)', 'real(8), dimension(:)']. The number of output arguments is 1, and the test_data type is ['real(8), dimension(1:size(f,1),1:size(f,2))']. Use the provided backward differences in the input to compute the derivatives.", "input": "", "output": "  function derivative2d1(f,dx1)\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx1    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix2\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d1\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix2=1,lx2\n      derivative2d1(1,ix2)=(f(2,ix2)-f(1,ix2))/dx1(2)\n      derivative2d1(2:lx1-1,ix2)=(f(3:lx1,ix2)-f(1:lx1-2,ix2))/(dx1(3:lx1)+dx1(2:lx1-1))\n      derivative2d1(lx1,ix2)=(f(lx1,ix2)-f(lx1-1,ix2))/dx1(lx1)\n    end do\n  end function derivative2d1\n"}, {"instruction": "Create a Fortran function named derivative2d2 that computes the second derivative of a 2D array with respect to the second dimension using backward differences. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). The function uses parallelization and assumes that ghost cells are not present.", "input": "", "output": "  function derivative2d2(f,dx2)\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx2    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix1\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d2\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix1=1,lx1\n      derivative2d2(ix1,1)=(f(ix1,2)-f(ix1,1))/dx2(2)\n      derivative2d2(ix1,2:lx2-1)=(f(ix1,3:lx2)-f(ix1,1:lx2-2))/(dx2(3:lx2)+dx2(2:lx2-1))\n      derivative2d2(ix1,lx2)=(f(ix1,lx2)-f(ix1,lx2-1))/dx2(lx2)\n    end do\n  end function derivative2d2\n"}, {"instruction": "Create a Fortran function named derivative2d2p that computes the second derivative of a two-dimensional array representing a periodic domain. The function takes two input parameters of type real(8), dimension(:,:) and real(8), dimension(:), and one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)).", "input": "", "output": "  function derivative2d2p(f,dx2)\n\n    !derivative on a periodic domain\n\n    real(8), dimension(:,:), intent(in) :: f    !ghost cells not present...\n    real(8), dimension(:), intent(in) :: dx2    !presumed backward diffs.\n\n    integer :: lx1,lx2,ix1\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: derivative2d2p\n\n    lx1=size(f,1)\n    lx2=size(f,2)\n\n    !$omp parallel do\n    do ix1=1,lx1\n      derivative2d2p(ix1,1)=(f(ix1,2)-f(ix1,lx2))/(dx2(2)+dx2(1))\n      derivative2d2p(ix1,2:lx2-1)=(f(ix1,3:lx2)-f(ix1,1:lx2-2))/(dx2(3:lx2)+dx2(2:lx2-1))\n      derivative2d2p(ix1,lx2)=(f(ix1,1)-f(ix1,lx2-1))/(dx2(1)+dx2(lx2))\n    end do\n\n  end function derivative2d2p\n"}, {"instruction": "Create a Fortran function named integral2d2 to compute a 2-dimensional integral. The function accepts two input parameters of type real(8), dimension(:,:) and real(8), dimension(1:size(f,2)) respectively. It returns one output parameter of type real(8), dimension(1:size(f,1),1:size(f,2)). Make sure that ghost cells have been removed from the input arrays before passing them into this routine. Use backward differences for the second input parameter.", "input": "", "output": "  function integral2d2(f,dx2)\n\n    !------------------------------------------------------------\n    !-------compute an integral along the 2-dim.  it is expected that \n    !-------ghost cells will have been trimmed from arrays before\n    !-------they are passed into this routine\n    !------------------------------------------------------------\n\n    real(8), dimension(:,:), intent(in) :: f\n    real(8), dimension(1:size(f,2)), intent(in) :: dx2  !presumed backward diffs. (1:lx2)\n\n    integer :: ix2,lx2\n    real(8), dimension(1:size(f,1),1:size(f,2)) :: integral2d2\n\n    lx2=size(f,2)\n\n    integral2d2(:,1)=0d0\n    do ix2=2,lx2\n      integral2d2(:,ix2)=integral2d2(:,ix2-1)+0.5d0*(f(:,ix2)+f(:,ix2-1))*dx2(ix2)\n    end do\n\n  end function integral2d2\n"}, {"instruction": "Create a Fortran function named minmod to calculate the minimum of two real(8) numbers. The function takes 2 input arguments of type real(8) and returns 1 output argument of type real(8).", "input": "", "output": "  function minmod(a,b)\n    real(8), intent(in) :: a,b\n    real(8) :: minmod\n\n    if (a*b <= 0.) then\n      minmod=0.\n    else if (abs(a) < abs(b)) then\n      minmod=a\n    else\n      minmod=b\n    end if\n  end function minmod\n"}, {"instruction": "Create a Fortran function named string_in_test to check if the input string matches 'test string'. The function takes 1 input parameter of type character(len=20) and returns a single output parameter of type logical.", "input": "", "output": "  function string_in_test(s) result(t)\n    character(len=20), intent(in) :: s\n    logical :: t\n    if (s == 'test string') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_test\n"}, {"instruction": "Create a Fortran function named string_in_cutoff to determine if the input string matches the value 'test s'. The function takes 1 input parameter of type character(len=6) and returns 1 output parameter of type logical. The function should be called with the input string, and the output will indicate whether the input matches 'test s' as true or false.", "input": "", "output": "  function string_in_cutoff(s) result(t)\n    character(len=6), intent(in) :: s\n    logical :: t\n    if (s == 'test s') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_cutoff\n"}, {"instruction": "Create a Fortran function named string_in_assumed_len. This function takes 3 input arguments of types character(len=*), character(len=*), and integer, and returns 1 output argument of type logical. The function checks if the first input string is 'test string 1' and the second input string is 'string 2', and returns true if both conditions are met; otherwise, it returns false.", "input": "", "output": "  function string_in_assumed_len(s1,x,s2) result(t)\n    character(len=*), intent(in) :: s1, s2\n    integer, intent(in) :: x ! dummy\n    logical :: t\n    if (s1=='test string 1' .and. s2=='string 2') then\n      t = .true.\n    else\n      t = .false.\n    end if\n  end function string_in_assumed_len\n"}, {"instruction": "Create a Fortran function named stat_object to compute statistical properties of a series of real numbers. The function takes 2 input parameters of type real and character(len=*), where the character parameter is optional. The output is a real number. The function utilizes recursion and supports various statistical commands such as \"stddev\", \"variance\", \"count\", \"mean\", and \"reset\" based on the input command.", "input": "", "output": "  recursive function stat_object(a, cmd) result(stddev)\n    real :: stddev\n    real, intent(in) :: a\n    character(len=*), intent(in), optional :: cmd\n\n    real, save :: summa = 0.0, summa2 = 0.0\n    integer, save :: num = 0\n\n    real :: m\n\n    if ( .not. present(cmd) ) then\n       num = num + 1\n       summa = summa + a\n       summa2 = summa2 + a*a\n       stddev = stat_object(0.0, \"stddev\")\n    else\n       select case(cmd)\n       case(\"stddev\")\n          stddev = sqrt(stat_object(0.0, \"variance\"))\n       case(\"variance\")\n          m = stat_object(0.0, \"mean\")\n          if ( num > 0 ) then\n             stddev = summa2/real(num) - m*m\n          else\n             stddev = 0.0\n          end if\n       case(\"count\")\n          stddev = real(num)\n       case(\"mean\")\n          if ( num > 0 ) then\n             stddev = summa/real(num)\n          else\n             stddev = 0.0\n          end if\n       case(\"reset\")\n          summa = 0.0\n          summa2 = 0.0\n          num = 0\n       case default\n          stddev = 0.0\n       end select\n    end if\n\n  end function stat_object\n"}, {"instruction": "Write a Fortran function named vmin to calculate the minimum velocity required for a specified orbit. The function takes 3 input arguments of type double precision (e, a, m_x) and returns 1 output argument of type double precision.", "input": "", "output": "function vmin(e, a, m_x)\n    double precision :: e,a,m_x,vmin\n    !double precision :: hour,julianday\n    \n    double precision :: m_a, mu\n    m_a = a*0.9315\n    mu =  (m_a*m_x)/(m_a+m_x)\n    vmin = 3d5*sqrt((e/1d6)*(m_a)/(2*mu*mu))\nend function vmin\n"}, {"instruction": "Write a Fortran function called reduced_m that takes two double precision input parameters, a and m_x. It calculates the value of m_a as 0.9315 times a, then computes the value of reduced_m using the formula (m_a * m_x)/(m_a + m_x). The function returns a double precision value as the output.", "input": "", "output": "function reduced_m(a, m_x)\n    double precision :: a, m_x, m_a, reduced_m\n    \n    m_a = 0.9315*a\n    reduced_m =  (m_a * m_x)/(m_a + m_x)\nend function reduced_m  \n"}, {"instruction": "Create a Fortran pure function named cpi_t that takes 3 input real numbers and returns 1 real number. The input parameters are k, rtndt, and t. The function uses the parameters to calculate and return the value of cpi_t.", "input": "", "output": "  pure function cpi_t(k, rtndt, t)\n\n    real :: cpi_t\n    real, intent(in) :: k, rtndt, t\n    real, parameter :: ckic = 4.0\n\n    associate( &\n      akic => 19.35+8.335*exp(0.02254*(t-rtndt)), &\n      bkic => 15.61+50.132*exp(0.008*(t-rtndt)) &\n    )\n      cpi_t = merge(0.0,1-exp(-((k-akic)/bkic)**ckic), k < akic)\n    end associate\n\n  end function cpi_t\n"}, {"instruction": "Create a Fortran function named \"bar\" that takes two integer input parameters and returns a single integer output. The input parameters should be of type \"integer\" and passed with the intent \"in.\" The output parameter should also be of type \"integer.\" The function should compute a value based on the input parameters and other local variables.", "input": "", "output": "  function bar (a, b)\n    integer, intent (in) :: a, b\n    integer :: bar\n    common /blk/ q, e\n    integer :: q, r, d, s\n    logical :: e\n    s = 7\n!$omp taskloop lastprivate (s)\n    do d = a, b - 1\n      if (d < 12 .or. d > 17) then\n!$omp atomic write\n        e = .true.\n      end if\n      s = d\n    end do\n!$omp end taskloop\n    bar = s\n  end function bar\n"}, {"instruction": "Create a Fortran function named \"score\" to calculate a score based on an integer input. The function takes 1 input parameter with the test_data type ['integer*8'] and returns 1 output parameter with the test_data type ['integer*8']. The score is computed by multiplying prime numbers based on the digits of the input number.", "input": "", "output": "  pure function score(n)\n    implicit none\n    integer*8, intent(in)             :: n\n    integer*8                         :: temp,score\n    integer, parameter, dimension(10) :: primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]\n\n    score=1\n    temp=n\n    do while (temp > 0)\n       score=score*primes(mod(temp,10)+1)\n       temp=temp/10\n    end do\n    \n  end function score\n"}, {"instruction": "Create a Fortran function named stoch_dist to calculate the stochastic distance based on the input parameters d1, d2, w1, and w2, all of which are of type double precision. The function returns a single double precision value.", "input": "", "output": "function stoch_dist(d1, d2, w1, w2) result(a)\n\n    implicit none\n\n    double precision, intent(in) :: d1\n    double precision, intent(in) :: d2\n    double precision, intent(in) :: w1\n    double precision, intent(in) :: w2\n\n    double precision :: a\n\n    a = w1**2/(w1**2 + d1**2) * w2**2/(w2**2 + d2**2)\n\nend function stoch_dist\n"}, {"instruction": "Write a Fortran function named dist that calculates a distance metric based on the input parameters. The function takes 4 input arguments of type double precision and returns 1 output argument of type double precision. The input parameters are x1, x2, w1, and w2.", "input": "", "output": "function dist(x1, x2, w1, w2) result(a)\n\n    implicit none\n\n    double precision, intent(in) :: x1\n    double precision, intent(in) :: x2\n    double precision, intent(in) :: w1\n    double precision, intent(in) :: w2\n\n    double precision, parameter :: pi = 4.0d0 * atan(1.0d0)\n\n    double precision :: a\n\n    a = exp(-((x1-x2)**2)/(4.0d0*w1**2)) *  (1.0d0 - sin(pi * x1/(2.0d0 * w2))) * &\n        & (1.0d0 - sin(pi * x2/(2.0d0 * w2)))\n\nend function dist\n"}, {"instruction": "Create a Fortran function named \"skalarprodukt\" to calculate the scalar product of two real arrays. The function should have 2 input parameters of type real arrays and 1 output parameter of type real. Use the \"intent(in)\" attribute for the input parameters.", "input": "", "output": "  pure function skalarprodukt(vec_1,vec_2)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    real :: skalarprodukt\n    real :: vec_1(:)\n    real :: vec_2(:)\n    intent(in) :: vec_1,vec_2\n    !--------------------------------------------------------------------------\n    skalarprodukt=sum(vec_1(:)*vec_2(:))\n    !                                                  !\n  end function skalarprodukt\n"}, {"instruction": "Create a Fortran function named determinant2d to calculate the determinant of a 2x2 matrix. The function takes 2 input parameters of type real and returns 1 output parameter of type real. Use the imperative tone and ensure that the number and type of input and output parameters are specified in the instruction.", "input": "", "output": "  pure function determinant2d(a,b)\n    !------------------------------------------------------------------------!\n    implicit none\n    !------------------------------------------------------------------------!\n    real              :: determinant2d\n    real              :: a(2),b(2)\n    !------------------------------------------------------------------------!\n    intent(in)        :: a,b\n    !------------------------------------------------------------------------!\n\n    determinant2d=a(1)*b(2)-a(2)*b(1)\n\n  end function determinant2d\n"}, {"instruction": "Write a pure Fortran function named determinant3d to calculate the determinant of a 3x3 matrix. The function should have 3 input parameters of type real, named a, b, and c. The output should be a single real value representing the determinant of the matrix.", "input": "", "output": "  pure function determinant3d(a,b,c)\n    !------------------------------------------------------------------------!\n    implicit none\n    !------------------------------------------------------------------------!\n    real              :: determinant3d\n    real              :: a(3),b(3),c(3)\n    !------------------------------------------------------------------------!\n    intent(in)        :: a,b,c\n    !------------------------------------------------------------------------!\n    determinant3d=a(1)*b(2)*c(3)-a(1)*b(3)*c(2)+a(2)*b(3)*c(1)-a(2)*b(1)*c(3) &\n                  +a(3)*b(1)*c(2)-a(3)*b(2)*c(1)\n  end function determinant3d\n"}, {"instruction": "Create a Fortran function named morlet to calculate the Morlet wavelet with two input parameters of type real, and one output parameter of type complex. The input parameters are s and fa, and the output parameter is morlet. If fa is equal to 0, set morlet to (0,0); otherwise, calculate morlet using the formula provided. Remember to use the constants pi, w0, and pi14 in the calculation.", "input": "", "output": "  function morlet ( s, fa )\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    real,     parameter  :: pi = 3.14159265359\n    real,     parameter  :: w0 = 6. \n    real, parameter      :: pi14 =  0.7511255444649\n    real,     intent(in) :: s, fa\n    complex              :: morlet\n    !--------------------------------------------------------------------------\n    if (fa == 0.) then \n      morlet = (0.,0.)\n    else\n      morlet = cmplx(pi14*exp( (-(s*2.*pi*fa-w0)**2) / 2.),0.)\n    endif\n\n  end function morlet\n"}, {"instruction": "Create a Fortran function named xyintriangle to determine if a point (x,y) lies within a triangle defined by three vertices. The function takes 5 input parameters of type real and returns 1 output parameter of type logical. The input parameters are x, y, xtri(3), ytri(3), epsilon. The function uses the imperative tone to calculate the volume and check if the point lies within the triangle using the given epsilon tolerance.", "input": "", "output": "  function xyintriangle(x,y,xtri,ytri,epsilon)\n     implicit none\n\n     logical :: xyintriangle\n     real x,y,xtri(3),ytri(3),epsilon\n     real xi, eta\n     real volume\n     intent(in) :: x,y,xtri,ytri,epsilon\n\n     ! compute volume\n     volume = 0.5*( (xtri(2)-xtri(1))*(ytri(3)-ytri(1))-(xtri(3)-xtri(1))*(ytri(2)-ytri(1)) )\n\n     xi  = 0.5/volume*( ( xtri(3)*ytri(1) - xtri(1)*ytri(3) ) + &\n         x*(ytri(3)-ytri(1)) + &\n         y*(xtri(1)-xtri(3)) )\n     eta = 0.5/volume*( ( xtri(1)*ytri(2) - xtri(2)*ytri(1) ) + &\n         x*(ytri(1)-ytri(2)) + &\n         y*(xtri(2)-xtri(1)) )\n\n     ! because of numerical errors, it is possible that a point which lies     !\n     ! exactly on the boundary is considered outside the element               !\n     ! so we set a tolerance value of epsilon which allows points lo lie       !\n     ! slightly out of the element. this is necessary because fluxes are       !\n     ! calculated on boundary points!                                          !\n     ! for epsilon we choose 1e-5                                              !\n\n     if((xi.lt.(0.-epsilon)).or.(eta.lt.(0.-epsilon)).or. &\n         (eta.gt.(1.-xi+epsilon))) then\n         xyintriangle = .false.\n     else\n         xyintriangle = .true.\n     endif\n\n   end function xyintriangle\n"}, {"instruction": "Write a Fortran function named ky that takes an integer dimf and an array lyap of real numbers as input. It returns a real number as output. The number of input parameters is 2, with test_data type ['integer', 'real(kind=8),dimension(dimf)'], and the number of output parameters is 1, with test_data type ['real(kind=8)']. The function calculates the value of ky based on the input parameters and returns the result.", "input": "", "output": "function ky(lyap,dimf)\r\ninteger :: dimf,i\r\nreal(kind=8) :: ky\r\nreal(kind=8),dimension(dimf) :: lyap\r\nky=0.0d0\r\ni=0\r\ndo while (ky.ge.0 .and. i<dimf)\r\n  i=i+1\r\n  ky=ky+lyap(i)\r\nend do\r\nky=i-1+(ky-lyap(i))/(lyap(i))\r\nreturn\r\nend function\r\n"}, {"instruction": "Create a Fortran function named get_ndigit to calculate the number of digits in an integer value. The function takes 1 input argument of type integer(8) and returns 1 output argument of type integer.", "input": "", "output": "  function get_ndigit(value) result(ndigit)\n    implicit none\n\n    integer(8), intent(in) :: value\n    integer :: ndigit\n\n    ndigit = floor(log10(real(value)) + 1)\n  end function get_ndigit\n"}, {"instruction": "Write a Fortran function called in_list to check if a specific string is present in another string. The function takes 3 input arguments of type character(len=*), character(len=*), and character (optional) respectively. The output parameter is of type logical. Ensure that the function is named in_list.", "input": "", "output": "  function in_list(string, search, delim) result(found)\n\n    implicit none\n\n    character(len=*),    intent(in) :: string, search\n    character, optional, intent(in) :: delim\n    logical                         :: found\n\n    character :: c\n    integer   :: i1, i2\n    integer   :: slen\n\n    if (present(delim)) then\n       c = delim\n    else\n       c = ':'\n    end if\n\n    slen = len_trim(string)\n\n    found = .false.\n    i1    = 1\n    i2    = scan(string, c)\n    \n    do while(i2 >= i1)\n       if (trim(adjustl(string(i1:i2-1))) == trim(adjustl(search))) then\n          found = .true.\n          exit\n       end if\n       i1 = i2 + 1\n       i2 = i1 + scan(string(i1:slen), c) - 1\n    end do\n\n    if (trim(adjustl(string(i1:slen))) == trim(adjustl(search))) then\n       found = .true.\n    end if\n\n  end function in_list\n"}, {"instruction": "Create a Fortran function named mnt_regridedges_build to initialize a regridding object. The function takes 4 input parameters of type c_ptr, integer(c_int), real(c_double), and integer(c_int). The function returns an output of type integer(c_int).", "input": "", "output": "    function mnt_regridedges_build(obj, num_cells_per_bucket, periodx, debug) &\r\n                                   bind(c, name='mnt_regridedges_build')\r\n      use, intrinsic :: iso_c_binding, only: c_int, c_double, c_ptr\r\n      implicit none\r\n      type(c_ptr), intent(inout)       :: obj !> void**\r\n      integer(c_int), value            :: num_cells_per_bucket\r\n      real(c_double), value            :: periodx\r\n      integer(c_int), value            :: debug\r\n      integer(c_int)                   :: mnt_regridedges_build\r\n    end function mnt_regridedges_build\r\n"}, {"instruction": "Create a Fortran function named tr_m to calculate the trace of a square matrix. The input parameter is a 2D array of double precision, and the output parameter is a double precision value. The function iterates through the diagonal elements of the input matrix to compute the trace. If the input matrix is not square, an error message is displayed.", "input": "", "output": "function tr_m(a) result (tra)\nimplicit none\n\n      integer i\n      double precision, dimension(:,:), intent (in) :: a\n      double precision :: tra      \n      if(size(a,2).ne.size(a,1))then\n        write(*,*) 'not square matrix in us_trm_f';read(*,*)\n      else\n        tra=0.d0;do i=1,size(a,1);tra=tra+a(i,i);enddo\n      endif \n            \nend function \n"}, {"instruction": "Create a Fortran pure function named ineligible to determine if the sum of the number of digits in two integers and the number of digits in their product is greater than 9. The function takes 2 input arguments of type integer and returns 1 output argument of type logical.", "input": "", "output": "  pure function ineligible(a,b)\n    implicit none\n    integer, intent(in) :: a,b\n    logical             :: ineligible\n\n    ineligible=(digits(a)+digits(b)+digits(a*b) > 9)\n  end function ineligible\n"}, {"instruction": "Create a Fortran function named pandigital that takes two integer input parameters. The test_data type for the input parameters should be ['integer', 'integer']. The function returns a single logical output parameter. The test_data type for the output parameter is ['logical']. The function checks if the concatenation of the input numbers and their product results in a pandigital number (containing all the digits from 1 to 9 exactly once) and returns a logical value accordingly.", "input": "", "output": "  pure function pandigital(a,b)\n    implicit none\n    integer, intent(in)   :: a,b\n    integer               :: i,j,k,temp\n    integer, dimension(9) :: d\n    logical               :: pandigital\n\n    if (digits(a)+digits(b)+digits(a*b) /= 9) then\n       pandigital=.false.\n       go to 1\n    end if\n\n    do i=1,9\n       d(i)=0\n    end do\n\n    i=a\n    j=b\n    k=a*b\n\n    do while (i > 0)\n       temp=mod(i,10)\n       d(temp)=d(temp)+1\n       i=i/10\n    end do\n\n    do while (j > 0)\n       temp=mod(j,10)\n       d(temp)=d(temp)+1\n       j=j/10\n    end do\n\n    do while (k > 0)\n       temp=mod(k,10)\n       d(temp)=d(temp)+1\n       k=k/10\n    end do\n\n    do i=1,9\n       if (d(i) /= 1) then\n          pandigital=.false.\n          go to 1\n       end if\n    end do\n\n    pandigital=.true.\n\n1 end function pandigital\n"}, {"instruction": "Create a Fortran function called randomspin to generate a random integer representing a spin on a lattice. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument, n, represents the number of lattice sites, and the output argument, randomspin, represents the randomly chosen spin.", "input": "", "output": "    function randomspin(n)\n    integer :: n, count, randomspin\n    real :: rand, scaled\n    call random_number(rand)\n    scaled = rand * n !scales to number of sites\n    do count=1,(n+1) !picks spin corresponding to scaled random number\n        if (scaled>=(count-1) .and. scaled<count) randomspin = count\n    end do\n    end function randomspin\n"}, {"instruction": "Write a Fortran function named kd that takes two integer input parameters and returns an integer output. The number of input parameters in this code is 2, and the test_data type is ['integer', 'integer']. The number of output parameters is 1, and the test_data type is ['integer']. This function sets the output integer kd to 1 if the input integers i and j are equal; otherwise, it sets kd to 0.", "input": "", "output": "pure function kd(i,j)\ninteger, intent(in) :: i,j\ninteger :: kd\nkd=0\nif(i.eq.j) then\nkd = 1\nelse \nkd = 0\nend if\nend function kd\n"}, {"instruction": "Create a Fortran function named \"per\" to determine the parity of a permutation based on the input integers i, j, and k. The number of input parameters is 3 with test data type ['integer', 'integer', 'integer'], and the number of output parameters is 1 with test data type ['integer']. If the permutation is even, the function returns 1; if the permutation is odd, the function returns -1; otherwise, it returns 0.", "input": "", "output": "pure function per(i,j,k)\ninteger,intent(in) :: i,j,k\ninteger :: per\nper=0\nif((i.eq.1).and.(j.eq.2).and.(k.eq.3)) then\nper = 1\nelse if((i.eq.2).and.(j.eq.3).and.(k.eq.1)) then\nper = 1\nelse if((i.eq.3).and.(j.eq.1).and.(k.eq.2)) then\nper = 1\nelse if((i.eq.1).and.(j.eq.3).and.(k.eq.2)) then\nper = -1\nelse if((i.eq.2).and.(j.eq.1).and.(k.eq.3)) then\nper = -1\nelse if((i.eq.3).and.(j.eq.2).and.(k.eq.1)) then\nper = -1\nelse\n        per=0\nend if\nend function per\n"}, {"instruction": "Create a Fortran function named chr_lpad that takes a string and a size as input. The input parameters should have the test_data type ['character(len=*)', 'integer']. The function should return a padded string as output with the test_data type ['character(len=:), allocatable'].", "input": "", "output": "function chr_lpad(thestring, thesize) result(retstring)\n  character(len=*), intent(in)  :: thestring\n  integer,          intent(in)  :: thesize\n  character(len=:), allocatable :: retstring\n  integer                       :: insize\n  insize = len(thestring)\n  if(insize > 0 .and. insize < thesize) then\n    retstring = repeat(\" \",thesize-insize)//thestring(1:insize)\n  else\n    retstring = thestring\n  end if\nend function chr_lpad\n"}, {"instruction": "Create a Fortran function named chr_rpad that takes a string and a size as input. The input parameters should be of type character(len=*) and integer, respectively. The function should return a string with a length that is either the length of the input string or the specified size, whichever is larger. The output parameter should be of type character(len=:), allocatable.", "input": "", "output": "function chr_rpad(thestring, thesize) result(retstring)\n  character(len=*), intent(in)  :: thestring\n  integer,          intent(in)  :: thesize\n  character(len=:), allocatable :: retstring\n  integer                       :: insize\n  insize = len(thestring)\n  if(insize > 0 .and. insize < thesize) then\n    retstring = thestring(1:insize)//repeat(\" \",thesize-insize)\n  else\n    retstring = thestring\n  end if\nend function chr_rpad\n"}, {"instruction": "Write a Fortran function named chr_lpadcut to adjust the length of a string by padding or cutting it as needed. The function takes 2 input parameters of type character(len=*) and integer, and returns 1 output parameter of type character(len=thesize). The function uses the imperative tone.", "input": "", "output": "function chr_lpadcut(thestring, thesize) result(retstring)\n  character(len=*), intent(in) :: thestring\n  integer,          intent(in) :: thesize\n  character(len=thesize) :: retstring\n  integer                :: insize\n  insize = len(thestring)\n  if(insize > thesize) then\n    retstring = thestring(1:thesize)\n  elseif(insize > 0) then\n    retstring = repeat(\" \",thesize-insize)//thestring(1:insize)\n  else\n    retstring = repeat(\" \",thesize)\n  end if\nend function chr_lpadcut\n"}, {"instruction": "Write a Fortran function named chr_instr to count the occurrences of a specific character within a given string. The number of input arguments is 2, with test_data types ['character(len=*)', 'character(len=1)']. The number of output arguments is 1, with a test_data type of ['integer'].", "input": "", "output": "function chr_instr(thestring, theneedle) result(nneedle)\n\n  character(len=*), intent(in)  :: thestring\n  character(len=1), intent(in)  :: theneedle\n  integer                       :: nneedle\n\n  integer ch\n\n  nneedle = 0\n  do ch=1, len(thestring)\n    if(thestring(ch:ch) == theneedle) then\n      nneedle = nneedle + 1\n    end if\n  end do\n\nend function chr_instr\n"}, {"instruction": "Write a Fortran function named t2pott to calculate the potential temperature based on the input parameters temperature (real), salinity (real), and pressure (real). The potential temperature is returned as output of type real.", "input": "", "output": "  function t2pott(t, s, p)\n    implicit none\n    real                              :: s        ! [psu]\n    real                              :: p        ! [dbar]\n    real                              :: t        ! [c] temperature\n    real                              :: t2pott   ! [c] potential temperature    \n    real                              :: s_rel\n    real  :: a_a1 = 3.6504e-4, a_a2 = 8.3198e-5, a_a3 = 5.4065e-7, a_a4 = 4.0274e-9\n    real  :: a_b1 = 1.7439e-5, a_b2 = 2.9778e-7\n    real  :: a_c1 = 8.9309e-7, a_c2 = 3.1628e-8, a_c3 = 2.1987e-10\n    real  :: a_d = 4.1057e-9, a_e1 = 1.6056e-10, a_e2 = 5.0484e-12\n    real  :: aa, bb, cc, cc1, dd\n\n    s_rel = s - 35.0;\n\n    aa = (a_a1+ t *(a_a2 - t*(a_a3 - a_a4*t)));\n    bb = s_rel*(a_b1 -a_b2*t)     ;\n    cc = (a_c1 + t*(-a_c2 + a_c3*t));\n    cc1 = a_d*s_rel;\n    dd = (-a_e1 + a_e2*t);\n\n    t2pott = t - p * ( aa + bb + p * (cc - cc1 + p * dd) )\n\n  end function t2pott\n"}, {"instruction": "Write a Fortran function named dist_sq to calculate the squared distance between two line segments. The function takes 5 input parameters of type real: rij_sq, rei, rej, eij, and ell. It returns 1 output parameter of type real: sij_sq.", "input": "", "output": "  function dist_sq ( rij_sq, rei, rej, eij, ell ) result ( sij_sq )\n    implicit none\n    real             :: sij_sq ! returns squared distance between line segments\n    real, intent(in) :: rij_sq ! squared centre-centre distance\n    real, intent(in) :: rei    ! scalar product rij.ei where ei is unit vector along i\n    real, intent(in) :: rej    ! scalar product rij.ej where ej is unit vector along j\n    real, intent(in) :: eij    ! scalar product ei.ej\n    real, intent(in) :: ell    ! line segment length\n\n    real            :: sin_sq, ci, cj, ai, aj, di, dj, ell2\n    real, parameter :: tol = 1.e-6\n\n    sin_sq = 1.0 - eij**2 ! squared sine of angle between line segments\n    ell2   = ell / 2.0    ! half the line segment length\n\n    if ( sin_sq < tol ) then ! guard against nearly-parallel lines\n       ci = -rei\n       cj =  rej\n    else\n       ci = ( - rei + eij * rej ) / sin_sq\n       cj = (   rej - eij * rei ) / sin_sq\n    endif\n\n    ai = abs ( ci )\n    aj = abs ( cj )\n    if ( ai > ell2 ) ci = sign ( ell2, ci )\n    if ( aj > ell2 ) cj = sign ( ell2, cj )\n\n    if ( ai > aj ) then\n       cj =  rej + ci * eij\n    else\n       ci = -rei + cj * eij\n    endif\n\n    ai = abs ( ci )\n    aj = abs ( cj )\n    if ( ai > ell2 ) ci = sign ( ell2, ci )\n    if ( aj > ell2 ) cj = sign ( ell2, cj )\n\n    di =  2.0 * rei + ci - cj * eij\n    dj = -2.0 * rej + cj - ci * eij\n\n    sij_sq = rij_sq + ci * di + cj * dj\n\n  end function dist_sq\n"}, {"instruction": "Write a Fortran function named gaspari_cohn_mid to calculate the Gaspari-Cohn correlation function value based on the input parameters z and c. The function should take 2 input arguments of type real(kind=8) and return 1 output argument of type real(kind=8).", "input": "", "output": "  function gaspari_cohn_mid(z, c) result(f)\n    real(kind=8), intent(in)::z, c\n    real(kind=8)::f\n    f = 1./12*(z/c)**5 - 0.5*(z/c)**4 + 5./8*(z/c)**3 &\n        + 5./3*(z/c)**2 - 5*z/c - 2./3*c/z + 4\n  end function gaspari_cohn_mid\n"}, {"instruction": "Write a Fortran function named rmsd to calculate the Root Mean Square Deviation (RMSD) of an array of double precision numbers. The function takes 2 input parameters: an array of double precision numbers and an integer representing the array size. The output is a single double precision value representing the RMSD.", "input": "", "output": "function rmsd(array, n) result(var)\n\ndouble precision, dimension(:), intent(in) :: array\ninteger, intent(in) :: n\ndouble precision :: var\n\ndouble precision, dimension(n) :: dev\ndouble precision :: mean\n\nmean = sum(array) / n\n\n!allocate(dev(n))\ndev = array - mean\nvar = sqrt(sum(dev*dev) / n)\n!deallocate(dev)\n\nend function\n"}, {"instruction": "Create a Fortran function named fuel to calculate the fuel required based on the mass of an object. The function takes 1 input parameter of type integer, and returns 1 output parameter of type integer. The input parameter is of type ['integer'] and the output parameter is of type ['integer'].", "input": "", "output": "function fuel(mass) result(f)\n    implicit none\n    integer :: f\n    integer, intent(in) :: mass\n    f = 0\n    if (mass.gt.6) then\n        f = int(real(mass) / 3.0 - 2)\n    end if\nend function fuel\n"}, {"instruction": "Write a Fortran function named stringfromint to convert a positive integer to a string. The function takes 1 input parameter of type integer and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function stringfromint(x)\n            !! make a string of \"correct\" length from a positive integer.\n            character(len=:), allocatable :: stringfromint\n                !! string containing the given integer, without spaces.\n            integer, intent(in) :: x\n                !! positive integer to be converted.\n            integer :: numdigits\n\n            numdigits = int(log10(real(x))) + 1\n            allocate(character(len=numdigits) :: stringfromint)\n            write(unit=stringfromint, fmt=\"(i0)\") x\n        end function\n"}, {"instruction": "Create a Fortran function called find_intersection to find the common element in two arrays, given the total number of unique elements. The function takes 3 input parameters of type integer, dimension(:), integer, and returns 1 output parameter of type integer. The test_data type for input parameters is ['integer, dimension(:)', 'integer, dimension(:)', 'integer'], and for the output parameter, it is ['integer'].", "input": "", "output": "        function find_intersection(array1, array2, num_labels) result(intersect_label)\n            !! find the common element in two arrays, given a total of\n            !! **num_labels** unique elements. used by [[find_spanning_cluster]].\n            integer, dimension(:), intent(in) :: array1, array2\n                !! array to analyse.\n            integer, intent(in) :: num_labels\n                !! the known number of unique non-zero elements.\n            integer :: intersect_label\n                !! the first non-zero common element.\n            integer :: l, i\n            logical, dimension(:), allocatable :: label_found\n\n            l = size(array1)\n\n            allocate(label_found(0:num_labels))\n            !/intersectsnippetstart/!\n            label_found(0:num_labels) = .false.\n\n            do i=1,l\n                label_found(array1(i)) = .true.\n            end do\n\n            do i=1,l\n                if(array2(i) /= 0 .and. label_found(array2(i))) then\n                    intersect_label = array2(i)\n                    return\n                end if\n            end do\n            !/intersectsnippetend/!\n\n            intersect_label = -1\n        end function\n"}, {"instruction": "Create a Fortran function named logi that takes an integer input argument and returns a complex number of kind(1d0). The function should convert the input integer to a real number, compute its natural logarithm, and return the result as a complex number. The number of input arguments is 1 and the test_data type is ['integer'], and the number of output arguments is 1 and the test_data type is ['complex(kind(1d0))'].", "input": "", "output": "function logi(x)\r\n  complex(kind(1d0))::logi\r\n  integer,intent(in)::x\r\n  real(kind(1d0))::xx\r\n  xx=x\r\n  logi=dlog(xx)\r\n  return\r\nend function logi\r\n"}, {"instruction": "Write a Fortran function named logr that takes a real number as input and returns the natural logarithm of the input as a complex number. The number of input arguments is 1 and the test_data type is [real(kind(1d0))]. The number of output arguments is 1 and the test_data type is [complex(kind(1d0))].", "input": "", "output": "function logr(x)\r\n  complex(kind(1d0))::logr\r\n  real(kind(1d0)),intent(in)::x\r\n  logr=dlog(x)\r\n  return\r\nend function logr\r\n"}, {"instruction": "Create a Fortran function named logc that takes a single input argument of type complex(kind(1d0)) and returns a single output argument of the same type. The purpose of this function is to compute the complex natural logarithm of the input value.", "input": "", "output": "function logc(x)\r\n  complex(kind(1d0))::logc\r\n  complex(kind(1d0)),intent(in)::x\r\n  logc=cdlog(x)\r\n  return\r\nend function logc\r\n"}, {"instruction": "Write a Fortran function named csqrtr to compute the square root of a real number, returning a complex result. The function should accept 1 input parameter of type real(kind(1d0)) and return 1 output parameter of type complex(kind(1d0)).", "input": "", "output": "function csqrtr(x)\r\n  implicit none\r\n  complex(kind(1d0))::csqrtr\r\n  real(kind(1d0)),intent(in)::x\r\n  complex(kind(1d0))::xx\r\n  if(x.ge.0d0)then\r\n     csqrtr=dcmplx(dsqrt(x))\r\n  else\r\n     xx=x\r\n     csqrtr=cdsqrt(xx)\r\n  endif\r\n  return\r\nend function csqrtr\r\n"}, {"instruction": "Write a Fortran function named csqrtc that computes the square root of a complex number. The function should take 1 input parameter of type complex(kind(1d0)) and return 1 output parameter of the same type.", "input": "", "output": "function csqrtc(x)\r\n  implicit none\r\n  complex(kind(1d0))::csqrtc\r\n  complex(kind(1d0)),intent(in)::x\r\n  csqrtc=cdsqrt(x)\r\n  return\r\nend function csqrtc\r\n"}, {"instruction": "Create a Fortran function named determinant_3x3_real to calculate the determinant of a 3x3 real*8 matrix. The input parameter is a 3x3 real*8 array, and the output parameter is a real*8 value.", "input": "", "output": "  pure function determinant_3x3_real(a) result(det)\n    real*8, dimension(3,3), intent(in) :: a\n    real*8 :: det\n    !\n    det = a(1,1)*(a(2,2)*a(3,3) - a(3,2)*a(2,3)) &\n        + a(1,2)*(a(3,1)*a(2,3) - a(2,1)*a(3,3)) &\n        + a(1,3)*(a(2,1)*a(3,2) - a(3,1)*a(2,2))\n  end function\n"}, {"instruction": "Create a Fortran function named f_enthal that takes two input arguments of type real(kind(0.d0)) and returns one output argument of the same type. The function computes and returns the value of f_enthal based on the input parameters cpinf and cpbw.", "input": "", "output": "  function f_enthal( cpinf,cpbw )\n\n    real(kind(0.d0)), intent(in) :: cpinf\n    real(kind(0.d0)), intent(in) :: cpbw\n    real(kind(0.d0)) :: tmp1, tmp2, tmp3\n    real(kind(0.d0)) :: f_enthal\n\n    tmp1 = ( n_tait-1.d0 )/n_tait\n    tmp2 = (  cpbw/(1.d0+b_tait)+1.d0 )**tmp1\n    tmp3 = ( cpinf/(1.d0+b_tait)+1.d0 )**tmp1\n    f_enthal = ( tmp2-tmp3 )*n_tait*( 1.d0+b_tait )/( n_tait-1.d0 )\n\n  end function f_enthal\n"}, {"instruction": "Write a Fortran function named f that takes two input parameters, a real number t and an array of two real numbers x. The function computes two real numbers and returns them as an array. The input parameters are of type real and real, dimension(2), and the output parameter is of type real, dimension(2).", "input": "", "output": "    function f(x, t)\n        implicit none\n        real, intent(in) :: t\n        real, dimension(2), intent(in) :: x\n        real, dimension(2) :: f\n\n        f(1) = x(2) \n        f(2) = -x(1) \n    end function\n"}, {"instruction": "Write a Fortran function called gcd to calculate the greatest common divisor of two integers. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. Use the following signature for the function: \n\n```fortran\nfunction gcd(a, b) result(tempb)\n  implicit none\n  integer, intent(in) :: a, b\n  integer :: tempa, tempb, place_holder\n  ...\nend function gcd\n```", "input": "", "output": "function gcd(a, b) result (tempb)\n    implicit none\n    integer, intent(in) :: a, b\n    integer :: tempa, tempb, place_holder\n    \n    tempa = a\n    tempb = b\n    \n    do while (.not.tempa.eq.0)\n    \n        place_holder = tempa\n    \n        if (tempa.eq.0) then\n            exit\n        end if\n    \n        tempa = mod(tempb,tempa)\n        tempb = place_holder\n    \n    end do\n    \nend function gcd\n"}, {"instruction": "Write a Fortran function named all_caps to convert a given input string to all uppercase letters. The function takes 1 input parameter of type character(len=*), and returns 1 output parameter of type character(len=len(string)).", "input": "", "output": "function all_caps( string ) result(caps)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: caps\n\n    character(len=1)             :: ch\n    integer                      :: i\n\n    integer, parameter :: shift = iachar('a') - iachar('a')\n\n    do i = 1,len(string)\n        ch = string(i:i)\n        if ( iachar(ch) >= iachar('a') .and. iachar(ch) <= iachar('z') ) then\n            caps(i:i) = achar(iachar(ch)+shift)\n        else\n            caps(i:i) = ch\n        endif\n    enddo\nend function all_caps\n"}, {"instruction": "Create a Fortran function named leapy to determine if a given year is a leap year. The function takes 1 input parameter of type real, representing the year. It returns 1 output parameter of type logical, indicating whether the year is a leap year or not.", "input": "", "output": "function leapy(yr)\n  implicit none\n  logical           :: leapy\n  real, intent(in)  :: yr\n\n  if (mod(yr, 4.0) .ne. 0) then\n     leapy = .false.\n  elseif(mod(yr, 25.0) .ne. 0) then\n     leapy = .true.\n  elseif(mod(yr, 16.0) .ne. 0) then\n     leapy = .false.\n  else\n     leapy = .true.\n  endif\n\nend function leapy\n"}, {"instruction": "Write a Fortran function named cut_function that takes 3 input parameters of type double precision: r, cut_start, and cut_distance. The function returns a single output parameter of type double precision. The function computes a damping factor based on the input parameters, where the damping factor is 1.0 when r is less than the product of cut_start and cut_distance, 0.0 when r is greater than cut_distance, and a smoothly varying function of r between these limits.", "input": "", "output": "pure function cut_function(r, cut_start, cut_distance) result(f)\n\n    implicit none\n\n    ! distance\n    double precision, intent(in) :: r\n\n    ! lower limit of damping\n    double precision, intent(in) :: cut_start\n\n    ! upper limit of damping\n    double precision, intent(in) :: cut_distance\n\n    ! intermediate variables\n    double precision :: x\n    double precision :: rl\n    double precision :: ru\n\n    double precision :: f\n\n    ru = cut_distance\n    rl = cut_start * cut_distance\n\n    if (r > ru) then\n\n        f = 0.0d0\n\n    else if (r < rl) then\n\n        f = 1.0d0\n\n    else\n\n        x = (ru - r) / (ru - rl)\n        f = (10.0d0 * x**3) - (15.0d0 * x**4) + (6.0d0 * x**5)\n\n    endif\n\nend function cut_function\n"}, {"instruction": "Create a Fortran function named var_kind that takes one integer input argument and returns an integer output argument. The input argument's data type should be 'integer', and the output argument's data type should also be 'integer'. This function determines the kind of a variable based on the input kind value and returns the appropriate kind value.", "input": "", "output": "  function var_kind(vkind) result(varkind)\n    integer:: vkind\n    integer:: varkind\n    if(vkind<=pm_null) then\n       varkind=pm_pointer\n    else  if(vkind>=pm_string) then\n       varkind=pm_pointer\n    else\n       varkind=vkind\n    endif\n  end function var_kind\n"}, {"instruction": "Create a Fortran function named \"ufn\" to calculate the value of \"ufn\" using the input parameters \"gammz\", \"z1\", and \"z2\", which are real(8) data types. The output parameter \"ufn\" is also of type real(8).", "input": "", "output": " function ufn(gammz,z1,z2)\n\n\t \n implicit none\n\n real(8), intent(in) :: gammz, z1, z2\n real(8) :: ufn\n \n ufn = ( ( (3.0+gammz**2)*z1 + 2.0*gammz*z2 ) / &\n       gammz**2 / (1.0-gammz**2) )\n  \n return\n\n end function\n"}, {"instruction": "Create a Fortran function named compute_pi to estimate the value of pi using the Monte Carlo method. The function has 1 input parameter of type integer. The output parameter is 1, of type real(kind=8).", "input": "", "output": "function compute_pi(n) result(pi)\n    integer, intent(in) :: n\n    real(kind=8) :: pi, x, y\n    integer :: i\n\n    do i = 1, n\n        call random_number(x)\n        call random_number(y)\n        if (x**2.0d00 + y**2.0d00 <= 1.0d00) then\n            pi = pi + 1.0d00\n        end if\n    end do\n    pi = 4.0d00*pi/n\nend function compute_pi\n"}, {"instruction": "Write a Fortran function named stringcompare to compare two strings of characters up to a specified length. The number of input arguments is 3, and the test_data type is ['character*80', 'character*80', 'integer']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "function stringcompare(string1,string2,len)\n  implicit none\n  character*80 :: string1,string2\n  integer :: len\n  integer :: i\n  logical :: stringcompare\n  !\n  if(len > 80) stop\n  if(len <= 0) then\n     stringcompare=.false.\n     return\n  endif\n  stringcompare=.true.\n  do i=1,len\n     if(string1(i:i) /= string2(i:i)) stringcompare=.false.\n  enddo\n  return\nend function stringcompare\n"}, {"instruction": "Create a Fortran function named interp3 to perform trilinear interpolation. The function takes 7 input parameters of real(kind = 8) type, which are x, y, z, v, xq, yq, and zq. The output parameter is a real(kind = 8) type.", "input": "", "output": "  function interp3(x, y, z, v, xq, yq, zq) result(vq)\n    real(kind = 8) :: vq\n    real(kind = 8), intent(in) :: xq, yq, zq\n    real(kind = 8), dimension(:), intent(in) :: x, y, z\n    real(kind = 8), dimension(:,:,:), intent(in) :: v\n    integer(kind = 4) :: nx, ny, nz, i1, i2, j1, j2, k1, k2\n    real(kind = 8) :: x1, x2, y1, y2, z1, z2, v111, v211, v121, v221, &\n      v112, v212, v122, v222\n    real(kind = 8) :: n(8), ax(8), ay(8), az(8), av(8)\n\n    nx = size(v, 1)\n    ny = size(v, 2)\n    nz = size(v, 3)\n    i1 = minloc(xq - x, dim = 1, mask = xq .ge. x)\n    j1 = minloc(yq - y, dim = 1, mask = yq .ge. y)\n    k1 = minloc(zq - z, dim = 1, mask = zq .ge. z)\n    i2 = i1 + 1\n    j2 = j1 + 1\n    k2 = k1 + 1\n\n    if ( i1 .eq. nx .and. j1 .ne. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = v(i1,j2,k1)\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = 0.d0\n      v122 = v(i1,j2,k2)\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = v(i2,j1,k2)\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .ne. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = v(i1,j2,k1)\n      v221 = v(i2,j2,k1)\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny .and. k1 .ne. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = v(i1,j1,k2)\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .ne. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = v(i1,j2,k1)\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .ne. nx .and. j1 .eq. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else if ( i1 .eq. nx .and. j1 .eq. ny .and. k1 .eq. nz ) then\n      x1 = x(i1)\n      x2 = 2.d0 * x1 - x(nx-1)\n      y1 = y(j1)\n      y2 = 2.d0 * y1 - y(ny-1)\n      z1 = z(k1)\n      z2 = 2.d0 * z1 - z(nz-1)\n      v111 = v(i1,j1,k1)\n      v211 = 0.d0\n      v121 = 0.d0\n      v221 = 0.d0\n      v112 = 0.d0\n      v212 = 0.d0\n      v122 = 0.d0\n      v222 = 0.d0\n    else\n      x1 = x(i1)\n      x2 = x(i2)\n      y1 = y(j1)\n      y2 = y(j2)\n      z1 = z(k1)\n      z2 = z(k2)\n      v111 = v(i1,j1,k1)\n      v211 = v(i2,j1,k1)\n      v121 = v(i1,j2,k1)\n      v221 = v(i2,j2,k1)\n      v112 = v(i1,j1,k2)\n      v212 = v(i2,j1,k2)\n      v122 = v(i1,j2,k2)\n      v222 = v(i2,j2,k2)\n    end if\n\n    ax = [ x2, x1, x2, x1, x2, x1, x2, x1 ]\n    ay = [ y2, y2, y1, y1, y2, y2, y1, y1 ]\n    az = [ z2, z2, z2, z2, z1, z1, z1, z1 ]\n    av = [ v111, v211, v121, v221, v112, v212, v212, v222 ]\n    n = dabs( (ax - xq) * (ay - yq) * (az - zq) ) / dabs( (x2 - x1) * (y2 - y1) * (z2 -z1) )\n    vq = dot_product(av, n)\n    return\n  end function interp3\n"}, {"instruction": "Provide a Fortran function named f5 that takes a single character input and returns a character string. The input parameter should have a length of 1 to 8 characters. The output parameter should have a length specified by the result of the scan function. Use a do loop to assign characters to the output string based on the position of the characters in the input string.", "input": "", "output": "  function f5 (c)\r\n    character(len=1_8) :: c\r\n    character(len=scan('123456789', c)) :: f5\r\n    integer :: i\r\n    do i = 1, len (f5)\r\n       f5(i:i) = char (i+96)\r\n    end do\r\n  end function f5\r\n"}, {"instruction": "Create a Fortran function named sigmav_ion that calculates the ionization rate coefficient (sigmav_ion) based on the input electron temperature (te). The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision']. Use the provided code as the function definition.", "input": "", "output": "function sigmav_ion(te)\n  implicit none\n  double precision, parameter :: tm=2.d0 !ev\n  double precision :: sigmav_ion, te, x,y\n  if(te .lt. tm) then\n     sigmav_ion = 0.d0\n     return\n  endif\n  x = log(te)\n  y=-3.271396786375d+01+x*(1.353655609057d+01+x*(-5.739328757388d+00            &\n    +x*(1.563154982022d+00+x*(-2.877056004391d-01+x*(3.482559773737d-02         &\n    +x*(-2.631976175590d-03+x*(1.119543953861d-04+x*(-2.039149852002d-06))))))))\n  sigmav_ion = exp(y)\n return\nend function sigmav_ion\n"}, {"instruction": "Write a Fortran function named lnsig that calculates the length of a string excluding trailing whitespace characters. The input parameter is a character string, and the output parameter is an integer representing the length of the string.", "input": "", "output": "function lnsig(title)\n  implicit none\n  character(len=*) :: title\n  integer :: lnsig, ilen, i\n\n  ilen = len(title)\n  do i = ilen, 1, -1\n     if (title(i:i) /= ' ') exit\n  end do\n  lnsig = i\n  if (i > 0) then\n     if (ichar(title(i:i)) == 0) lnsig = i - 1\n  end if\nend function lnsig\n"}, {"instruction": "Write a Fortran function named lnsig1 to calculate the length of a character string excluding trailing and leading blank spaces. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function lnsig1(text)\n  implicit none\n  integer :: lnsig1, ilen, ii, iend, ibeg, iii\n  character(len=*) :: text\n\n  ilen = len(text)\n  do ii = ilen, 1, -1\n     if (text(ii:ii) /= ' ') exit\n  end do\n  if (ii > 0) then\n     if (ichar(text(ii:ii)) == 0) ii = ii - 1\n  end if\n\n  iend = ii\n  if (iend /= 0) then\n     do ii = 1, iend\n        if (text(ii:ii) /= ' ') exit\n     end do\n     ibeg = ii\n     text(1:iend-ibeg+1) = text(ibeg:iend)\n     if (iend-ibeg+1 /= ilen) then\n        do iii = iend-ibeg+2, ilen\n           text(iii:iii) = ' '\n        end do\n     end if\n     lnsig1 = iend-ibeg+1\n  else\n     lnsig1 = 1\n  end if\nend function lnsig1\n"}, {"instruction": "Create a Fortran function named does_start_with to check if a given string starts with a specified pattern. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type logical. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1 and the test_data type is ['logical'].", "input": "", "output": "  function does_start_with(str,pattern) result (r)\n\n    character(len=*), intent(in) :: str\n    character(len=*), intent(in) :: pattern\n    logical :: r\n\n    if (len(str)<len(pattern)) then       ! if str is shorter than pattern\n      r = .false.  \n    else    \n      r = (str(1:len(pattern))==pattern)  ! otherwise, compare \n    end if\n \n  end function does_start_with\n"}, {"instruction": "Create a Fortran function called normalize to calculate the normalized form of a given vector. The function takes 1 input parameter of type real*8, dimension(:), and intent(in), and returns 1 output parameter of type real*8, dimension(1:size(vector)).", "input": "", "output": "   function normalize( vector )\n   real*8, dimension(:), intent(in) :: vector\n   real*8, dimension(1:size(vector)) :: normalize\n   integer :: n\n   real*8 :: fact\n\n   n = size( vector )\n   fact = sqrt( dot_product( vector(1:n), vector(1:n) ) )\n   if ( fact > 0.0d0 ) normalize = vector / fact\n   end function normalize\n"}, {"instruction": "Create a Fortran function named random_vector that generates an array of random double-precision floating-point numbers. The function takes 1 input argument of type integer, and the test_data type is ['integer']. It returns an array of random double-precision floating-point numbers with a dimension of 1 to n, where n is the input argument. The output test_data type is ['real*8, dimension(1:n)'].", "input": "", "output": "   function random_vector( n )\n   integer, intent(in) :: n\n   real*8, dimension(1:n) :: random_vector\n   integer :: i\n\n   call random_seed\n   do i = 1, n\n       call random_number( random_vector(i) )\n   end do\n   end function random_vector\n"}, {"instruction": "Provide a Fortran function named find_match. The function takes 3 input parameters of type real, real array, and optional integer, and returns 1 output parameter of type real array of size 2. The function searches for a match in the sorted array z for the given value zin and returns the indices where the match is found or the closest indices if no match is found.", "input": "", "output": "    function find_match(zin,z,guess)\n\n        implicit none\n        real, intent(in) :: zin\n        real, intent(in),dimension(:) :: z\n        integer, optional, intent(inout)::guess\n        real,dimension(2) :: find_match\n        integer::n,i,endpt\n\n        n=size(z)\n        find_match(1)=-1\n\n        if (.not.present(guess)) then\n            guess=n/2\n        endif\n\n        if (z(guess)>=zin) then\n            ! then we should search downward from z(guess)\n            endpt=1\n            i=guess\n            do while ((i>=endpt).and.(find_match(1)==-1))\n                if (z(i)<=zin) then\n                    find_match(1)=i\n                    if (i==n) then\n                        ! should only happen if z(i)=zin\n                        find_match(2)=i\n                    else\n                        find_match(2)=i+1\n                    endif\n                endif\n                i=i-1\n            end do\n        else\n            ! then we should search upward from z(guess)\n            endpt=n\n            i=guess\n            do while ((i<=endpt).and.(find_match(1)==-1))\n                if (z(i)>zin) then\n                    find_match(1)=i-1\n                    find_match(2)=i\n                endif\n                i=i+1\n            end do\n\n            if (find_match(1)==-1) then\n                find_match(1)=-2\n            endif\n        endif\n\n    end function find_match\n"}, {"instruction": "Create a Fortran function named map_set_random_seed to set the random seed for the random number generator. The function takes 1 input parameter of type integer. The output is also an integer. Use the imperative tone to indicate the action to be performed.", "input": "", "output": "function map_set_random_seed(rs) result(ret)\n  integer :: rs,ret\n  randomseed=rs\n  ret=0\nend function \n"}, {"instruction": "Write a Fortran function named crossprod that calculates the cross product of two three-dimensional vectors. The function takes 2 input parameters of type real(8), dimension(3) and returns 1 output parameter of type real(8), dimension(3).", "input": "", "output": "   function crossprod(u,v) result (w)\n     implicit none\n\n     type(real(8)), dimension(3), intent(in) :: u, v\n     type(real(8)), dimension(3) :: w\n\n     w(1) = u(2)*v(3)-u(3)*v(2)\n     w(2) = u(3)*v(1)-u(1)*v(3)\n     w(3) = u(1)*v(2)-u(2)*v(1)\n\n   end function\n"}, {"instruction": "Create a Fortran function named mappbc that takes in 4 input parameters of type real(8) with dimensions of 3. The input parameters are labeled as p, n, xa, and a. The output parameter is a single parameter of type real(8) with dimensions of 3, labeled as pmap. This function computes pmap based on the conditional logic inside the function. Use the dot_product and dsqrt functions to perform the necessary calculations.", "input": "", "output": "   function mappbc(p,n,xa,a) result(pmap)\n     type(real(8)),dimension(3), intent(in) :: p, n, xa,a\n     type(real(8)), dimension(3) :: pmap\n     integer i\n\n     if( ((dot_product(xa-p,n)/dabs(dot_product(xa-p,n)) ) .ge. 0.d0) .and. ( dsqrt(dot_product(xa-p,xa-p)).gt.0.d-10 )) then\n        pmap = xa + a\n     else\n        pmap = xa\n     end if\n   end function\n"}, {"instruction": "Write a Fortran function named fun to calculate the value of a mathematical function. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The input parameter is denoted by intent(in) and named x. The function returns the negation of the product of x and the cosine of x squared. The function name is fun.", "input": "", "output": "    function fun(x) result(f)\r\n\n        ! the unique global minimum is at x = 4.691893 \r\n        ! variables\r\n        real(8), intent(in) :: x\r\n        real(8) :: f\r\n        ! body of fun\r\n        f = x*cos(x*x)\r\n        \r\n        f = -f\r\n        \r\n    end function fun\r\n"}, {"instruction": "Provide a Fortran function named gcd to calculate the greatest common divisor of two 64-bit integer numbers. The function takes 2 input arguments of type integer(8) and returns 1 output argument of type integer(8).", "input": "", "output": "  recursive function gcd(x,y) result(z)\n    implicit none\n    integer(8), intent(in) :: x, y\n    integer(8) :: z\n    if (x.lt.y) then\n      z = gcd(y,x)\n      return\n    end if\n    z = x\n    if (y.eq.0_8) return\n    z = gcd(y,mod(x,y))\n    return\n  end function gcd\n"}, {"instruction": "Write a recursive Fortran function named common_factor to find the greatest common factor of two integers. The function takes 3 input arguments of type integer and returns 1 output argument of type integer. The input arguments are n, m, and ifact, while the output argument is val.", "input": "", "output": "      recursive function common_factor(n,m,ifact) result(val)\n      implicit none\n      integer, intent(in) :: n\n      integer, intent(in) :: m\n      integer, intent(in) :: ifact\n      integer:: val\n\n      val = 0\n      if (mod(n,m)==0) then\n         val = m\n      else\n         val = common_factor(n,m+ifact,ifact)\n      end if\n\n      end function common_factor\n"}, {"instruction": "Write a Fortran function named decibel to calculate the decibel value of a complex number. The function takes 1 input argument of type complex (kind = 8) and returns 1 output argument of type real (kind = 8). The input parameter should be named x, and the output parameter should be named res. Ensure the input argument is declared with the \"intent(in)\" attribute.", "input": "", "output": "function decibel(x) result(res)\nimplicit none\ncomplex (kind = 8), intent(in) :: x\nreal    (kind = 8) :: res, tmp\ntmp = max(1.0d-20, abs(x))\nres = 20.0d0 * log10(tmp)\nreturn\nend function decibel\n"}, {"instruction": "Create a Fortran function named get_var to retrieve the value of an environment variable or return a default value if the environment variable is not set. The function has 2 input arguments of type character (len=*) and 1 output argument of type character (len=:), allocatable.", "input": "", "output": "        function get_var(var, dflt) result(l)\n            character (len=*), intent(in):: var\n            character (len=*), intent(in):: dflt\n            character (len=:), allocatable:: l\n\n            character (len=1000):: raw\n            integer:: n, s\n\n            call get_environment_variable(name=var, value=raw, & \n                                          length=n, status=s)\n            if (s .eq. 0) then\n                ! value var exists and either has no value or its value is \n                ! assigned to raw\n                if (n .gt. 0) then \n                    allocate(character (len=n):: l)\n                    l = trim(raw)\n                    return\n                end if\n            end if\n            ! in case the env.var not set or empty, return its default value\n            n = len(dflt)\n            allocate(character (len=n):: l)\n            l = dflt\n            return\n        end function get_var\n"}, {"instruction": "Create a Fortran function named cross that calculates the cross product of two 3-dimensional real arrays. The function should take 2 input arguments of type real, dimension(3) and return 1 output argument of type real, dimension(3).", "input": "", "output": "    pure function cross(a, b)\n      real, dimension(3), intent(in) :: a,b\n      real, dimension(3) :: cross\n\n     cross = (/ a(2) * b(3) - a(3) * b(2), &\n           a(3) * b(1) - a(1) * b(3), &\n           a(1) * b(2) - a(2) * b(1) /)\n    end function cross\n"}, {"instruction": "Create a Fortran function named \"zfnc\" to calculate the value of a function. The function takes 2 input parameters of type real, named \"enrgy\" and \"enrgymax\". It returns 1 output parameter of type real. The function calculates the value of 2 times the square root of \"enrgy\" divided by \"enrgymax\" minus 1.", "input": "", "output": "  function zfnc (enrgy, enrgymax)\n    \n    implicit none\n    \n    real, intent(in) :: enrgy, enrgymax\n    real :: zfnc\n    \n    zfnc = 2.*sqrt(enrgy/enrgymax)-1.\n    \n    return\n    \n  end function zfnc\n"}, {"instruction": "Create a Fortran function named rootlay to determine the layer in which a root is located based on the root depth, layer thickness, and number of layers. The number of input arguments is 3 and the test_data type is [integer,real,real,dimension(nlay)]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function rootlay(rtdepth,lthick,nlay)\n!\nimplicit none\n!\n\n!\ninteger :: nlay\nreal :: rtdepth\nreal,dimension(nlay) :: lthick\ninteger :: rootlay\n!\n! local variables\n!\nreal :: d\ninteger :: i\n!\nif ((rtdepth*1000.0).lt.lthick(1)) then\n  rootlay = 1\n  go to 99999\nend if\nd = lthick(1)\ndo i = 2,nlay\n  d = d + lthick(i)\n  if ((rtdepth*1000.0).lt.d) then\n     if ((d-(rtdepth*1000.)).lt.((rtdepth*1000.)-(d-lthick(i)))) then\n        rootlay = i\n     else\n        rootlay = i - 1\n     end if\n     go to 99999\n  end if\n  rootlay = nlay\nend do\n!\n99999 end function rootlay\n"}, {"instruction": "Create a Fortran function named str2int to convert a given character string to an integer. The function should accept 1 input argument of type character(len=*) and return 1 output argument of type integer. Ensure that the input string represents a valid integer within 9 digits. If the string is longer than 9 digits, the function should print an error message and stop.", "input": "", "output": "function str2int(str) result(intv)\n\ncharacter(len=*), intent(in) :: str\n\ninteger :: strlength\ninteger :: intv\n\nstrlength = len_trim(adjustl(str))\nif (strlength > 9) then\n   print *,'error: integer string length is greater than 9 digits long.'\n   stop\nend if \n\nread(str,*) intv\n\nend function str2int\n"}, {"instruction": "Write a Fortran function named bc_get_u that calculates the velocity component u at a given position. The function takes 3 input parameters of type real, dimension(3) and returns one output parameter of type real.", "input": "", "output": "function bc_get_u(x0, x1, um)\n\timplicit none\n\treal\t\t\t\t\t:: bc_get_u\n\treal, dimension(3)\t:: x0\n\treal, dimension(3)\t:: x1\n\treal\t\t\t\t\t:: rx, ry, rz, r2, r\n\treal\t\t\t\t\t:: um\n\treal\t\t\t\t\t:: u\n\tbc_get_u = 0.0\n\n! for poiseuille.conf\n!\tx1 = x0\n!\ty1 = 0.0\n!\tz1 = 0.0\n\n! for elbow-6a.conf\n!\tx1 = x0\n!\ty1 = 0.0\n!\tz1 = -3.0\n\n\trx = x0(1) - x0(1)\n\try = x0(2) - x1(2)\n\trz = x0(3) - x1(3)\n\tr2 = rx*rx + ry*ry + rz*rz\n\tr = sqrt(r2)\n\n\tu = um*2.0*(1.0 - r*r/(0.5*0.5))\n\tif( r > 0.5 ) then\n\t\tu = 0.0\n\tend if\n\n\tbc_get_u = u\n\treturn\nend function bc_get_u\n"}, {"instruction": "Create a Fortran function named bjoin that takes 2 input arguments, where the first argument is an integer and the second argument is an array of integers of size ntot. The function returns a single integer as the output. This function is designed to perform a binary join operation on the input array to compute a decimal value based on the binary representation of the array elements.", "input": "", "output": "  function bjoin(ib,ntot) result(i)\n    integer                 :: ntot\n    integer,dimension(ntot) :: ib\n    integer                 :: i,j\n    i=0\n    do j=0,ntot-1\n       i=i+ib(j+1)*2**j\n    enddo\n  end function bjoin\n"}, {"instruction": "Write a Fortran function named tcl_get_var to retrieve the value of a Tcl variable. The function takes 3 input parameters of type c_ptr (pass-by-value), c_ptr (pass-by-value), and c_int (pass-by-value). The output parameter is a single c_ptr.", "input": "", "output": "     function tcl_get_var(interp, name, flags) &\n          bind(c, name=\"tcl_getvar\")\n       use iso_c_binding, only: c_int, c_ptr\n       type(c_ptr), value :: interp, name\n       integer(c_int), value :: flags\n       type(c_ptr) :: tcl_get_var\n     end function tcl_get_var\n"}, {"instruction": "Write a Fortran function named ispalindrome to determine whether a given string is a palindrome. The function takes 1 input parameter of type character(len=16) and returns 1 output parameter of type logical.", "input": "", "output": "    function ispalindrome(str) result(r)\n        character(len=16) :: str\n        logical :: r\n        integer :: left\n        integer :: right\n        integer :: strlen\n        integer :: halflen\n        character :: leftch, rightch\n        \n        strlen = len_trim(str)\n        halflen = strlen / 2\n        \n        do left=1, halflen\n            right = strlen - left + 1\n            leftch = str(left:left+1)\n            rightch = str(right:right+1)\n            if (leftch .ne. rightch) then\n                r = .false.\n                return\n            end if\n        end do\n        \n        r = .true.\n        \n    end function ispalindrome\n"}, {"instruction": "Create a Fortran function named hui_hii_recombb that computes the recombination coefficient for hydrogen and ionized helium. The function takes 1 input argument of type real. The output is a single real value.", "input": "", "output": "  function hui_hii_recombb(t)\n    real :: t\n    real :: hui_hii_recombb, lambda\n    real, parameter :: t_hi=1.57807d5\n\n    lambda = 2.d0 * t_hi / t\n    hui_hii_recombb = 2.753d-14 * lambda**1.500d0 / &\n         ( 1.d0 + (lambda/2.740d0)**0.407d0 )**2.242d0\n\n  end function hui_hii_recombb\n"}, {"instruction": "Write a Fortran function named tolower to convert the input string to lowercase. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type character(len=len(string)). The input string is converted to lowercase, and the result is returned.", "input": "", "output": "function tolower(string)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: tolower\n\n    integer                      :: i\n    integer                      :: ch\n\n    tolower = string\n    do i = 1,len(string)\n        ch = iachar(string(i:i))\n        if ( ch >= 65 .and. ch <= 90 ) then\n            tolower(i:i) = achar(ch + 32)\n        endif\n    enddo\nend function tolower\n"}, {"instruction": "Create a Fortran function named toupper to convert all lowercase characters in the input string to uppercase. The function should take 1 input argument of type character(len=*) and produce 1 output argument of type character(len=len(string)).", "input": "", "output": "function toupper(string)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: toupper\n\n    integer                      :: i\n    integer                      :: ch\n\n    toupper = string\n    do i = 1,len(string)\n        ch = iachar(string(i:i))\n        if ( ch >= 97 .and. ch <= 122 ) then\n            toupper(i:i) = achar(ch - 32)\n        endif\n    enddo\nend function toupper\n"}, {"instruction": "Create a Fortran function named j2norm that takes one integer input argument and returns an integer output. The input argument should be declared with the intent(in) attribute. The function should compute the value of the output by adding 1 to the input argument and assigning it to the output.", "input": "", "output": "    function j2norm(two_j)\n        implicit none\n        integer, intent(in) :: two_j\n        integer :: j2norm\n    \n        j2norm = two_j + 1\n    \n    end function j2norm\n"}, {"instruction": "Write a Fortran function named qnorm to calculate the square root of (2 * j + 1) where j is an input integer argument. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "    function qnorm(j)\n        implicit none\n        integer, intent(in) :: j\n        real(kind=8)  :: qnorm\n\n        if (j<0) stop \"qnorm error: negative j\"\n\n        qnorm = sqrt(2d0 * j + 1d0)\n\n    end function qnorm\n"}, {"instruction": "Create a Fortran function named q2norm to calculate the square root of (two_j + 1d0) when given the input parameter two_j of type integer. The output parameter q2norm should be of type real(kind=8). Ensure that q2norm is returned as the result of the computation. If the input parameter two_j is negative, an error message \"qnorm error: negative j\" should be displayed.", "input": "", "output": "    function q2norm(two_j)\n        implicit none\n        integer, intent(in) :: two_j\n        real(kind=8) :: q2norm\n        if (two_j<0) stop \"qnorm error: negative j\"\n\n        q2norm = sqrt(two_j + 1d0)\n    \n    end function q2norm    \n"}, {"instruction": "Write a Fortran function named j that takes one integer input argument and returns one integer output. The input argument is of type integer, and the output is also of type integer. The function selects a value from an array based on the input argument and returns it, or returns 0 if the input argument is out of range.", "input": "", "output": "function j(k)\ninteger :: k\ninteger :: j\ninteger, parameter :: i(2) = (/1,2/)\n\nselect case(k)\ncase (1:size(i))\n    j = i(k)\ncase default\n    j = 0\nend select\nend function\n"}, {"instruction": "Create a Fortran function named golden_number to calculate the golden number based on the given year. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "function golden_number(year)\n\n      implicit none\n\n      integer :: year, golden_number\n\n      golden_number = modulo(year + 1, 19)\n\nend function golden_number\n"}, {"instruction": "Create a Fortran function named cal_vi that calculates the velocity in a specific context. It takes 6 input parameters of type real: l, ks, nu, g, d, and hf1. It returns 1 output parameter of type real.", "input": "", "output": "     function cal_vi(l,ks,nu,g,d,hf1) !velocidad ec 2.3\n         implicit none\n         real :: cal_vi,l,ks,nu,g,d,hf1\n\n         cal_vi = (2.51 * nu * sqrt(l)) / (d * sqrt(2 * g * d * hf1))\n         cal_vi = (ks / (3.7 * d)) + cal_vi\n         cal_vi = (-2 * sqrt(2 * g * d * hf1) / sqrt(l)) * log10(cal_vi)\n\n     end function cal_vi\n"}, {"instruction": "Create a Fortran function named \"cal_hfi_1\" to calculate the value of \"cal_hfi_1\" using the formula: h - zy - sigma_km * ((vi ** 2) / (2 * g)). The function should have 5 input parameters of type real: h, zy, sigma_km, vi, and g. The output parameter should also be of type real.", "input": "", "output": "     function cal_hfi_1(h,zy,sigma_km,vi,g) \n         implicit none\n         real ::cal_hfi_1,h,zy,sigma_km,vi,g\n         cal_hfi_1 = h - zy - sigma_km * ((vi ** 2) / (2 * g))\n     end function cal_hfi_1\n"}, {"instruction": "Create a Fortran function named starts to check if the second input string starts with the first input string. The function takes 2 input parameters of type character(len=*) and returns 1 if the second string starts with the first one; otherwise, it returns 0.", "input": "", "output": "   function  starts(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(1:len(string2))==string2) answer = 1\n   end function starts\n"}, {"instruction": "Create a Fortran function called has to find the first occurrence of one character string within another. The function takes two input arguments of type character(len=*) and returns one output argument of type integer. The number of input arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "   function  has(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      character(len=:),allocatable :: temp\n      integer :: answer, add\n      character(len=*), parameter :: fmt= '(a6,x,i0)'\n      answer = 0\n      add = 0\n      if(len(string2)>len(string1)) return\n      answer = index(string1, string2)\n      if(answer==0) return\n      !     print the location of the match for part 2\n      write(*,fmt) \" at \", answer\n      !     handle multiple occurrences of a string for part 2.\n      add = answer\n      temp = string1(answer+1:)\n      do while(answer>0)\n         answer = index(temp, string2)\n         add = add + answer\n         if(answer>0) write(*,fmt) \" at \", add\n         !          deallocate(temp)\n         temp = string1(add+1:) ! auto reallocation\n      enddo\n      answer = 1\n   end function has\n"}, {"instruction": "Create a Fortran function named \"ends\" to check if one character string ends with another character string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. If the second string is found at the end of the first string, the output is set to 1; otherwise, it is set to 0.", "input": "", "output": "   function  ends(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(len(string1)-len(string2)+1:)==string2) answer = 1\n   end function ends\n"}, {"instruction": "Create a Fortran function named work2 that takes 4 input parameters of type integer, integer, integer, and logical. The function should return a single output parameter of type logical. The function aims to analyze a sequence of digits and determine if they are in decreasing order and contain at most two adjacent identical digits. Use an imperative tone when providing the instructions.", "input": "", "output": "recursive function work2(num, previous,seenpair, seencount) result (result)\n\n  integer, intent(in) :: num, previous, seencount\n  logical , intent(in) :: seenpair\n  logical ::result, digitsdescreasing,seenpairstillvalid\n  integer::digit, newseencount\n\n  seenpairstillvalid = seenpair\n\n  digit = mod(num,10)\n\n  digitsdescreasing = (digit <= previous)\n\n  if (digit == previous)then\n    newseencount = seencount + 1\n  else\n    if (seencount == 2) then\n      seenpairstillvalid = .true.\n    end if\n    newseencount = 1\n  end if\n\n  if (num >= 10) then\n    result = digitsdescreasing .and. work2(int(num / 10), digit, seenpairstillvalid,newseencount )\n  else\n    result = digitsdescreasing .and. (seenpairstillvalid .or.newseencount == 2)\n  end if\nend function work2\n"}, {"instruction": "Create a Fortran function named \"g\" that takes a single real number as input, and returns a real number. The function simply assigns the input to a variable m, then assigns m to a variable n, and finally assigns n to a variable g.", "input": "", "output": "  function g(x)\n    != unit 'b :: x\n    real :: x, n, m, g\n    m = x\n    n = m\n    g = n\n  end function g\n"}, {"instruction": "Write a Fortran function named rand_normal to generate a random number from a normal distribution with the given mean and standard deviation. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "function rand_normal(mean,stdev) result(c)\n  implicit none\n  double precision, parameter :: pi=3.141592653589793238462d0\n  double precision :: mean,stdev,c,temp(2), r, theta\n  if(stdev <= 0.0d0) then\n\n    write(*,*) \"standard deviation must be +ve\"\n  else\n    call random_number(temp)\n    r = (-2.0d0 * log(temp(1)))**5.0d-1\n    theta = 2.0d0*pi*temp(2)\n    c = mean + stdev * r * sin(theta)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named gsumf that calculates the sum of all elements in an array of integers. The function takes 1 input parameter of type integer array and returns 1 output parameter of type integer. The input parameter is of type ['integer, dimension(:)'] and the output parameter is of type ['integer'].", "input": "", "output": "function gsumf(x) result(y)\n    implicit none  \n    integer , dimension(: ), intent(in) :: x\n    integer:: y\n    integer:: i\n    integer:: i_cyml0\n    y = 0\n    do i_cyml0 = 1, size(x)\n        i = x(i_cyml0)\n        y = y + i\n    end do\nend function gsumf\n"}, {"instruction": "Write a Fortran function named roman that takes an integer input and returns a string representing the input value in Roman numerals. The input parameter is 1 of type integer, and the output parameter is 1 of type character (32).", "input": "", "output": "function roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'m ', 'cm', 'd ', 'cd', 'c ', 'xc', 'l ', 'xl', 'x ', 'ix', 'v ', 'iv', 'i '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n"}, {"instruction": "Write a Fortran function named \"csedress\" to calculate the surface erosion rate of cohesive sediment based on different input options. The number of input arguments is 6 and the test_data type is ['integer', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "function csedress(denbulk,wrspo,vdro,vdr,vdrc,iopt)\n\n  ! change record\n\n  ! **  calculates surface erosion rate of cohesive\n\n  ! **  iopt=1  based on\n  ! **\n  ! **  hwang, k. n., and a. j. mehta, 1989: fine sediment erodibility\n  ! **  in lake okeechobee florida. coastal and oceanographic engineering\n  ! **  department, university of florida, gainesville, fl32661\n  ! **  iopt=2  based on j. m. hamrick's modification of\n  ! **\n  ! **  sanford, l.p., and j. p. y. maa, 2001: a unified erosion formulation\n  ! **  for fine sediment, marine geology, 179, 9-23.\n  !\n  ! **  iopt=4 & 5 based on j. m. hamrick's parameterization of sedflume\n  !     test data\n  ! **\n\n  implicit none\n\n  integer :: iopt\n  real :: csedress,denbulk,wrspo,vdro,vdr,vdrc\n  real :: bulkden,tmp,tmpval,factor\n\n  if( iopt == 1 )then\n    bulkden=0.001*denbulk    ! *** to prevent corrupting the denbulk variable\n    if( bulkden <= 1.065 )then\n      csedress=0.62\n    else\n      tmp=0.198/(bulkden-1.0023)\n      tmp=exp(tmp)\n      csedress=6.4e-4*(10.**tmp)\n    endif\n  elseif( iopt == 2 )then\n    csedress=wrspo*(1.+vdro)/(1.+vdr)\n  elseif( iopt == 3 )then\n    csedress=wrspo*(1.+vdro)/(1.+vdrc)\n  elseif( iopt == 4 )then\n    tmpval=(1.+vdro)/(1.+vdr)\n    factor=exp(-tmpval)\n    csedress=factor*wrspo*(1.+vdro)/(1.+vdr)\n  elseif( iopt == 5 )then\n    tmpval=(1.+vdro)/(1.+vdrc)\n    factor=exp(-tmpval)\n    csedress=factor*wrspo*(1.+vdro)/(1.+vdrc)\n  elseif( iopt >= 99 )then\n    csedress=wrspo\n  endif\n\nend function\n"}, {"instruction": "Create a Fortran function named \"get_num_triangles_c\" that takes one input parameter of type \"type(c_ptr), value\" and returns one output parameter of type \"integer(c_int)\".", "input": "", "output": "    function get_num_triangles_c(obj) bind(c, name=\"get_num_triangles\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_num_triangles_c\n        type(c_ptr), value :: obj\n    end function\n"}, {"instruction": "Create a Fortran function named get_2pt_size_c. This function takes 1 input argument of type c_ptr with the value attribute. The output parameter is of type integer(c_int). This function serves to bind to a C function named \"get_2pt_size\".", "input": "", "output": "    function get_2pt_size_c(obj) bind(c, name=\"get_2pt_size\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_2pt_size_c\n        type(c_ptr), value :: obj\n    end function\n"}, {"instruction": "Create a Fortran function named get_2pt_c that accepts two input parameters: a value of type c_ptr and an array of real numbers of type c_double. The function should return an integer value of type c_int.", "input": "", "output": "    function get_2pt_c(obj, twopoint) bind(c, name=\"get_2pt\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_2pt_c\n        type(c_ptr), value :: obj\n        real(c_double), dimension(:) :: twopoint\n    end function\n"}, {"instruction": "Create a Fortran function named get_3pt_c, which binds to C and has the name \"get_3pt\". The function takes 2 input parameters: one of type c_ptr, passed by value, and another of type real(c_double), with an unspecified dimension. The function has 1 output parameter of type integer(c_int).", "input": "", "output": "    function get_3pt_c(obj, threepoint) bind(c, name=\"get_3pt\")\n        use iso_c_binding\n        implicit none\n        integer(c_int) :: get_3pt_c\n        type(c_ptr), value :: obj\n        real(c_double), dimension(:) :: threepoint\n    end function\n"}, {"instruction": "Create a Fortran function named \"simplex_3d\" to convert a 3-dimensional vector into a projection onto a 3-simplex. The input parameter is a real array of size 3, and the output parameter is a real array of size 2. Use the imperative tone to create the function.", "input": "", "output": "  function simplex_3d(x) result(y)\n  ! convert x,y,z into projection onto 3-simplex\n    implicit none\n    real, dimension(3) :: x\n    real, dimension(2) :: y\n    real               :: rac2, rac6\n\n    rac2=sqrt(2.0)\n    rac6=sqrt(6.0)\n\n    y(1)=-(x(1)-1./3.)/rac2+(x(2)-1./3.)/rac2\n    y(2)=-(x(1)-1./3.)/rac6-(x(2)-1./3.)/rac6+2*(x(3)-1./3.)/rac6\n\n  end function simplex_3d\n"}, {"instruction": "Create a Fortran function named f_intrpvalue to calculate an interpolated value based on the input parameters. The function takes 6 input parameters of types integer, real(kind=8), real(kind=8), real(kind=8), real(kind=8), real(kind=8), and returns 1 output parameter of type real(kind=8).", "input": "", "output": "function f_intrpvalue (wvalp0,wvalp1,vlev,vcp0,vcp1,icase)\n\n    implicit none\n\n    integer, intent(in) :: icase\n    real(kind=8), intent(in) :: wvalp0,wvalp1,vlev,vcp0,vcp1\n    real(kind=8) :: f_intrpvalue\n\n    real(kind=8) :: valp0,valp1,rvalue\n    real(kind=8) :: chkdiff\n\n    real(kind=8), parameter :: rgas=287.04d0\n    real(kind=8), parameter :: ussalr=0.0065d0\n    real(kind=8), parameter :: sclht=rgas*256.d0/9.81d0\n\n    valp0 = wvalp0\n    valp1 = wvalp1\n    if ( icase .eq. 2) then  !ght\n       valp0=exp(-wvalp0/sclht)\n       valp1=exp(-wvalp1/sclht)\n    end if\n\n    ! todo:  remove this stop\n    chkdiff = vcp1 - vcp0\n    if(chkdiff .eq. 0) then\n        print *,\"bad difference in vcp's\"\n        stop\n    end if\n\n    rvalue = (vlev-vcp0)*(valp1-valp0)/(vcp1-vcp0)+valp0\n    if (icase .eq. 2) then  !ght\n        f_intrpvalue = -sclht*log(rvalue)\n    else\n        f_intrpvalue = rvalue\n    end if\n\n    return\n\nend function f_intrpvalue\n"}, {"instruction": "Create a Fortran function named accumulate, which takes two integer input parameters and one integer output parameter. The input parameters should be of type integer, and the output parameter should also be of type integer. The function should compute the sum of the two input integers and return the result.", "input": "", "output": "  impure elemental function accumulate (a, s)\n    integer, intent(in) :: a\n    integer, intent(inout) :: s\n    integer :: accumulate\n    \n    s = s + a\n    accumulate = s\n  end function accumulate\n"}, {"instruction": "Write a Fortran function named f_h that takes four real(kind(0d0)) input parameters (fcpbw, fcpinf, fntait, fbtait) and returns one real(kind(0d0)) output parameter. The function computes the value of f_h based on the provided input parameters using a series of calculations.", "input": "", "output": "        function f_h( fcpbw, fcpinf, fntait, fbtait )\n\n            real(kind(0d0)), intent(in) :: fcpbw, fcpinf, fntait, fbtait\n            \n            real(kind(0d0))             :: tmp1,tmp2,tmp3\n            real(kind(0d0))             :: f_h\n            \n            tmp1 = ( fntait-1.d0 )/fntait\n            tmp2 = (  fcpbw/(1.d0+fbtait)+1.d0 )**tmp1\n            tmp3 = ( fcpinf/(1.d0+fbtait)+1.d0 )**tmp1\n            \n            f_h = ( tmp2 - tmp3 )*fntait*( 1.d0+fbtait )/( fntait-1.d0 )\n\n        end function f_h\n"}, {"instruction": "Create a Fortran function named f_rddot_rp to calculate the value of rddot using the given formula rddot = (1/r) * ( -3/2 * rdot^2 + ((r0/r)^3\\gamma - cp)/rho ). The function takes 6 input parameters of type real(kind(0d0)) and returns a single output parameter of the same type. The input parameters are fcp, frho, fr, fv, fr0, and fcpbw, and the output parameter is f_rddot_rp.", "input": "", "output": "        function f_rddot_rp( fcp, frho, fr, fv, fr0, fcpbw )\n\n            real(kind(0d0)), intent(in) :: fcp, frho, fr, fv, fr0, fcpbw\n            real(kind(0d0))             :: f_rddot_rp\n\n            !! rddot = (1/r) (  -3/2 rdot^2 + ((r0/r)^3\\gamma - cp)/rho )\n            !! rddot = (1/r) (  -3/2 rdot^2 + (tmp1 - cp)/rho )\n            !! rddot = (1/r) (  tmp2 )\n\n            f_rddot_rp = (-1.5d0*(fv**2d0) + (fcpbw - fcp)/frho)/fr\n\n            if (re_inv /= dflt_real) f_rddot_rp = f_rddot_rp - 4d0*re_inv*fv/(fr**2d0)/frho\n\n        end function f_rddot_rp\n"}, {"instruction": "Write a Fortran function named f_rddot to calculate the value of f_rddot based on the input parameters fcpbw, fr, fv, fh, fhdot, fcgas, fntait, and fbtait. The input parameters are all of type real(kind(0d0)). The function returns a single real(kind(0d0)) value.", "input": "", "output": "        function f_rddot( fcpbw, fr, fv, fh, fhdot, fcgas, fntait, fbtait )\n\n            real(kind(0d0)), intent(in) :: fcpbw, fr, fv, fh, fhdot\n            real(kind(0d0)), intent(in) :: fcgas, fntait, fbtait\n            \n            real(kind(0d0))             :: tmp1, tmp2, tmp3\n            real(kind(0d0))             :: f_rddot\n\n            tmp1 = fv/fcgas\n            tmp2 = 1.d0 + 4.d0*re_inv/fcgas/fr*( fcpbw/(1.d0+fbtait)+1.d0 ) &\n                        **( -1.d0/fntait )\n            tmp3 = 1.5d0*fv**2d0*( tmp1/3.d0-1.d0 ) + fh*( 1.d0+tmp1 ) &\n                        + fr*fhdot*( 1.d0-tmp1 )/fcgas\n\n            f_rddot = tmp3/( fr*(1.d0-tmp1)*tmp2 )\n\n        end function f_rddot\n"}, {"instruction": "Create a Fortran function named fcgd to calculate a value based on the input argument. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The function involves a computation using the input parameter and several internal real variables. Ensure that the computed value is not less than 0.", "input": "", "output": "    function fcgd(xx)\n    \n      implicit none\n      \n      real :: fcgd          !             |\n      real :: tn            !             |\n      real :: top           !             |\n      real :: tx            !             |\n      real :: qq            !             |\n      real :: xx            !             |\n      \n      tn = -5.\n\t  top = 35.\n      tx = 50.\n      qq = (tn - top)/(top - tx)\n\t  fcgd = ((xx-tn)**qq)*(tx-xx)/(((top-tn)**qq)*(tx-top))\n      if (fcgd < 0.) fcgd = 0.\n    end function\n"}, {"instruction": "Write a Fortran function named distance_between_points to calculate the distance between two 3D points. The function should have 6 input parameters of type double precision representing the coordinates of the two points. The output parameter should also be of type double precision.", "input": "", "output": "function distance_between_points(x0,y0,z0,x1,y1,z1)\n    implicit none\n    double precision :: distance_between_points\n    double precision :: x0,y0,z0,x1,y1,z1\n    double precision :: dx,dy,dz\n    dx = x1 - x0\n    dy = y1 - y0\n    dz = z1 - z0\n    distance_between_points = sqrt(dx * dx  + dy * dy + dz * dz)\nend function\n"}, {"instruction": "Write a Fortran function named is_palindro_r to check if the input string is a palindrome. The function takes 1 input parameter of type character (*) and returns 1 output parameter of type logical. The input parameter should be a string.", "input": "", "output": "  recursive function is_palindro_r (t) result (isp)\n\n    implicit none\n    character (*), intent (in) :: t\n    logical :: isp\n\n    isp = len (t) == 0 .or. t (: 1) == t (len (t) :) .and. is_palindro_r (t (2 : len (t) - 1))\n\n  end function is_palindro_r\n"}, {"instruction": "Create a Fortran function named ydn to perform a calculation on a 3D array. The function takes 1 input parameter of type real with dimensions (:,:,:) and returns 1 output parameter of type real with dimensions size(a,1), size(a,2), size(a,3).", "input": "", "output": "  function ydn(a) result (b)\n    real, dimension(:,:,:):: a\n    real, dimension(size(a,1),size(a,2),size(a,3)):: b\n    do k=1,size(a,3)\n    do j=2,size(a,2)\n    do i=1,size(a,1)\n      b(i,j,k)=half*(a(i,j-1,k)+a(i,j,k))\n    end do\n    end do\n    end do\n    b(:,1,:) = a(:,1,:)\n  end function\n"}, {"instruction": "Write a Fortran function named zdn that takes a 3D array of real numbers as input and computes a new 3D array of real numbers as output. The input parameter should be of type real, dimension(:,:,:), and the output parameter should be of type real, dimension(size(a,1),size(a,2),size(a,3)).", "input": "", "output": "  function zdn(a) result (b)\n    real, dimension(:,:,:):: a\n    real, dimension(size(a,1),size(a,2),size(a,3)):: b\n    do k=2,size(a,3)\n    do j=1,size(a,2)\n    do i=1,size(a,1)\n      b(i,j,k)=half*(a(i,j,k-1)+a(i,j,k))\n    end do\n    end do\n    end do\n    b(:,:,1) = a(:,:,1)\n  end function\n"}, {"instruction": "Create a Fortran function named upper to convert a given string to uppercase. The function takes 1 input argument of type character(*) and returns 1 output argument of type character(len(s1)). The test_data type for the input is ['character(*)'] and for the output is ['character(len(s1))'].", "input": "", "output": "function upper(s1)  result (s2)\n  character(*) :: s1\n  character(len(s1)) :: s2\n  character :: ch\n  integer,parameter :: duc=ichar('a')-ichar('a')\n  integer :: i\n  do i=1,len(s1)\n     ch = s1(i:i)\n     if (ch >= 'a'.and.ch <= 'z') ch = char(ichar(ch)+duc)\n     s2(i:i) = ch\n  end do\nend function upper\n"}, {"instruction": "Create a Fortran function named crheat_f3 that takes a single real input argument and returns a real value. The function computes a specific mathematical expression using the input argument and assigns the result to the output variable. The number of input arguments is 1 and the test_data type is ['real'], while the number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": " function crheat_f3(x) result(f3)\n  real :: x,logx,f3\n  logx=log10(x)\n  f3=-.265*(-2.37+logx)*(4.69+logx)*(15.62+7.21*logx+logx**2)\n end function\n"}, {"instruction": "Write a Fortran function named max_pow_of_2 that takes an integer input and returns the largest power of 2 that is less than the input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function max_pow_of_2(n) result(p)\n    implicit none\n    integer, intent(in) :: n\n    integer :: p\n    p = 1\n    do while (2*p.lt.n)\n      p = 2*p\n    end do\n    return\n  end function max_pow_of_2\n"}, {"instruction": "Create a Fortran function named \"cq\" to perform complex division. The function takes 2 input parameters of type real*8, each with a dimension of 2. The output is a single real*8 parameter with a dimension of 2. The function performs complex division based on the provided inputs and returns the result. Use the imperative tone to create the function.", "input": "", "output": "       function cq( x,y )\n       implicit none\n       real*8, dimension(2) :: cq,z1,z2\n       real*8, intent(in), dimension(2) :: x,y\n       real*8 theta\n       if(x(2).eq.0.d0.and.y(2).eq.0.d0) then\n        cq(1)= x(1)/y(1)\n        cq(2)= 0.d0\n        return\n       endif\n       if(abs(x(2)).eq.1.d0.and.abs(y(2)).eq.1.d0) then\n        cq(1)= x(1)/y(1)\n        cq(2)= 0.d0\n       else\n        if(abs(x(2)).eq.1.d0) then\n         z1(1)= x(1)\n         z1(2)= 0.d0\n         z2(1)= y(1)\n         z2(2)= y(2)         \n        elseif(abs(y(2)).eq.1.d0) then\n         z1(1)= x(1)\n         z1(2)= x(2)\n         z2(1)= y(1)\n         z2(2)= 0.d0         \n        else\n         z1= x\n         z2= y\n        endif\n        if(abs(z2(1)) > abs(z2(2))) then\n         theta= z2(2)/z2(1)\n         cq(1)= (z1(1)+theta*z1(2))/(theta*z2(2)+z2(1))\n         cq(2)= (z1(2)-theta*z1(1))/(theta*z2(2)+z2(1))\n        else\n         theta= z2(1)/z2(2)\n         cq(1)= (theta*z1(1)+z1(2))/(theta*z2(1)+z2(2))\n         cq(2)= (theta*z1(2)-z1(1))/(theta*z2(1)+z2(2)) \n        endif     \n       endif\n       end function cq\n"}, {"instruction": "Write a Fortran function named cr that takes 2 input parameters of type real*8, and returns an array of real*8 values of size 2. If the first input parameter (x) is greater than 0.d0, the function sets the first element of the output array to the square root of x and the second element to 0.d0. If x is less than or equal to 0.d0, the function sets the first element of the output array to 0.d0 and the second element to ep times the square root of the absolute value of x, where ep is the second input parameter.", "input": "", "output": "       function cr(x,ep)\n       implicit none\n       real*8, dimension(2) :: cr\n       real*8, intent(in) :: x,ep\n       if(x > 0.d0) then \n        cr(1)= sqrt(x)\n        cr(2)= 0.d0       \n       else\n        cr(1)= 0.d0\n        cr(2)= ep*sqrt(abs(x))\n       endif\n       end function cr\n"}, {"instruction": "Create a Fortran function named selectindexesbasedonmask to generate a subarray of indexes based on a logical mask. The function takes 1 input argument of type ['logical, dimension(:)'] and returns 1 output argument of type ['integer, dimension(:), allocatable'].", "input": "", "output": "        function selectindexesbasedonmask(mask) result(subarray)\n            implicit none\n            logical, dimension(:) :: mask\n            integer, dimension(:), allocatable :: subarray\n            integer :: nelements, i, index\n            \n            nelements = count(mask)\n            allocate(subarray(nelements))\n            index = 1\n            do i = 1, size(mask)\n                if(mask(i)) then\n                    subarray(index) = i\n                    index = index + 1\n                endif\n            enddo\n        end function\n"}, {"instruction": "Create a Fortran function named predicate to check if a given number is an Armstrong number. The function takes 1 input parameter of type integer. The output is a logical value indicating whether the input number is an Armstrong number.", "input": "", "output": "  pure function predicate(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: current,sum\n    logical             :: predicate\n\n    current=n\n    sum=0\n    do while (current > 0)\n       sum=sum+(mod(current,10)**5)\n       current=current/10\n    end do\n    predicate=(sum == n)\n\n  end function predicate\n"}, {"instruction": "Write a Fortran function named d1_tan to calculate the derivative of the tangent function. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "    pure function d1_tan(x) result(r)\n        real(8) :: r\n        real(8), intent(in) :: x\n        real(8) :: y\n        y = tan(x)\n        r = 1 + y**2\n    end function d1_tan\n"}, {"instruction": "Write a Fortran function named random_int that generates a random integer within a given range. The function takes 2 input parameters of type integer representing the lowest and highest integers in the range. It returns 1 output parameter of type integer representing the randomly generated integer.", "input": "", "output": "function random_int(first,last) result(rand_int)\nuse,intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ninteger,intent(in)   :: first,last ! lowest and highest integer in range of integers to get\ninteger, allocatable :: seed(:)\ninteger              :: n\ninteger              :: rand_int\nreal(kind=dp)        :: rand_val\nlogical,save         :: called=.false.\n   if(.not.called)then\n   ! initialize seed\n      call random_seed(size = n)\n      allocate(seed(n))\n      call random_seed(get=seed)\n      called=.true.\n   endif\n\n   ! to have a discrete uniform distribution on the integers {first, first+1,\n   ! ..., last-1, last} carve the continuous distribution up into last+1-first\n   ! equal sized chunks, mapping each chunk to an integer. one way is:\n   !\n   ! get real number from 0 up to but not including 1 (ie. [0,1)).\n   call random_number(rand_val)\n   ! use random value to choose an integer from first to last\n   rand_int = first + floor((last-first+1)*rand_val)\nend function random_int\n"}, {"instruction": "Create a Fortran function named chi2uniformdistance that takes an array of real numbers as input. The input parameter must be of type real, dimension(:), and it's intended for input. The function must return a single real number. The function calculates the chi-squared uniform distance based on the input array and returns the result.", "input": "", "output": "function chi2uniformdistance(ds)\n  real :: chi2uniformdistance\n  real, dimension(:), intent(in) :: ds\n\n  real :: expected, summa = 0.0\n\n  expected = sum(ds) / size(ds)\n  summa = sum( (ds - expected) ** 2 )\n\n  chi2uniformdistance = summa / expected\nend function chi2uniformdistance\n"}, {"instruction": "Create a Fortran function named \"atlabel\" that takes a single input argument of type character(*) to represent an atomic element symbol. The function should return an integer label corresponding to the input element symbol. The number of input arguments is 1 and the test_data type is ['character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  pure function atlabel(atype) result(lbl)\r\n    character(*), intent(in) :: atype\r\n    integer :: lbl\r\n    \r\n    select case(atype)\r\n      case('h')\r\n        lbl = 1\r\n      case('he')\r\n        lbl = 2\r\n      case('li')\r\n        lbl = 3\r\n      case('be')\r\n        lbl = 4\r\n      case('b')\r\n        lbl = 5\r\n      case('c')\r\n        lbl = 6\r\n      case('n')\r\n        lbl = 7\r\n      case('o')\r\n        lbl = 8\r\n      case('f')\r\n        lbl = 9\r\n      case('ne')\r\n        lbl = 10\r\n      case('na')\r\n        lbl = 11\r\n      case('mg')\r\n        lbl = 12\r\n      case('al')\r\n        lbl = 13\r\n      case('si')\r\n        lbl = 14\r\n      case('p')\r\n        lbl = 15\r\n      case('s')\r\n        lbl = 16\r\n      case('cl')\r\n        lbl = 17\r\n      case('ar')\r\n        lbl = 18\r\n      case default\r\n        lbl = 19\r\n    end select\r\n  end function\r\n"}, {"instruction": "Write a Fortran function named hipmemcpy to perform memory copy operation using the HIP API. The function takes 4 input parameters of types type(c_ptr), value, type(c_ptr), value, integer(c_size_t), value, and integer(c_int), value. It returns 1 output parameter of type integer(c_int). The function is named hipmemcpy.", "input": "", "output": "        function hipmemcpy(dst, src, length, dir) bind(c, name = \"hipmemcpy\")\n            use iso_c_binding\n            implicit none\n            type(c_ptr), value :: dst, src\n            integer(c_size_t), value :: length\n            integer(c_int), value :: dir\n            integer(c_int) :: hipmemcpy\n            end function\n"}, {"instruction": "Create a Fortran function named f that takes two input parameters, a real number theta and an array 'a' of size 3. The function returns an array of size 3. The purpose of this function is to compute the matrix multiplication of the input array 'a' with a 3x3 rotation matrix defined by the angle theta.", "input": "", "output": "      function f(a,theta)\n        implicit none\n          real, intent(in) :: theta\n          real, dimension(1:3) :: a,f\n          real, dimension(1:3,1:3) :: d\n\n          !d = [cos(theta) -sin(theta) 0]\n          !    [sin(theta)  cos(theta  0]\n          !    [    0           0      1]\n\n          d= reshape( (/cos(theta),sin(theta),0.0,-sin(theta),cos(theta),0.0,0.0,0.0,1.0/), (/3,3/) )\n          f=matmul(a,d)\n      end function f\n"}, {"instruction": "Write a Fortran function named g that takes 3 real input parameters and a 1x3 real array as input.The function returns a 1x3 real array as output. The function multiplies the input 1x3 array by a 3x3 matrix and returns the result as the output array.", "input": "", "output": "      function g(i,j,k)\n        implicit none\n          real, intent(in) :: k,j\n          real, dimension(1:3) :: g,i\n          real, dimension(1:3,1:3) :: h\n\n          !h = [ 1 0 j ]\n          !    [ 0 1 k ]\n          !    [ 0 0 1 ]\n\n          h= reshape( (/1.0,0.0,j,0.0,1.0,k,0.0,0.0,1.0/), (/3,3/) )\n          g=matmul(i,h)\n      end function g\n"}, {"instruction": "Write a Fortran function named m2x2det to calculate the determinant of a 2x2 matrix. The function takes 1 input parameter of type real(kind(1d0)), dimension(2,2) and provides 1 output parameter of type real(kind(1d0)).", "input": "", "output": "  function m2x2det(a) result(det)\n    implicit none\n    real(kind(1d0)),dimension(2,2),intent(in)::a\n    real(kind(1d0))::det    \n    det = a(1,1)*a(2,2)-a(1,2)*a(2,1)\n    return\n  end function m2x2det\n"}, {"instruction": "Create a Fortran function named m3x3det to calculate the determinant of a 3x3 matrix. The function takes one input parameter of type real(kind(1d0)), dimension(3,3) and returns one output parameter of type real(kind(1d0)).", "input": "", "output": "  function m3x3det(a) result(det)    \n    implicit none\n    real(kind(1d0)),dimension(3,3),intent(in)::a\n    real(kind(1d0))::det\n    det =  a(1,1)*a(2,2)*a(3,3)  &\n         - a(1,1)*a(2,3)*a(3,2)  &\n         - a(1,2)*a(2,1)*a(3,3)  &\n         + a(1,2)*a(2,3)*a(3,1)  &\n         + a(1,3)*a(2,1)*a(3,2)  &\n         - a(1,3)*a(2,2)*a(3,1)\n    return\n  end function m3x3det\n"}, {"instruction": "Create a Fortran function named m4x4det to calculate the determinant of a 4x4 matrix. The function should accept one input parameter of type real(kind(1d0)), dimension(4,4) and return one output parameter of type real(kind(1d0)). When calling the function, pass a 4x4 matrix as the input argument, and the determinant of the matrix will be returned as the output.", "input": "", "output": "  function m4x4det(a) result(det)    \n    implicit none\n    real(kind(1d0)),dimension(4,4),intent(in)::a\n    real(kind(1d0))::det\n    det =  a(1,1)*(a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)- &\n         a(3,3)*a(4,2)))-a(1,2)*(a(2,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+ &\n         a(2,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1)))+a(1,3)*(a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)- &\n         a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))-a(1,4)*(a(2,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+ &\n         a(2,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(2,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))    \n    return\n  end function m4x4det\n"}, {"instruction": "Create a Fortran function named m6x6det to calculate the determinant of a 6x6 matrix. The input parameter is a 6x6 real(kind(1d0)) array, and the output parameter is a real(kind(1d0)).", "input": "", "output": "  function m6x6det(a) result(det)\n    implicit none\n    real(kind(1d0)),dimension(6,6),intent(in)::a\n    real(kind(1d0)):: det, a11, a12, a13, a14, a15, a16, a21, a22, a23, a24, &\n         a25, a26, a31, a32, a33, a34, a35, a36, a41, a42, a43, a44, a45, a46,   &\n         a51, a52, a53, a54, a55, a56, a61, a62, a63, a64, a65, a66\n    \n    a11=a(1,1); a12=a(1,2); a13=a(1,3); a14=a(1,4); a15=a(1,5); a16=a(1,6)\n    a21=a(2,1); a22=a(2,2); a23=a(2,3); a24=a(2,4); a25=a(2,5); a26=a(2,6)\n    a31=a(3,1); a32=a(3,2); a33=a(3,3); a34=a(3,4); a35=a(3,5); a36=a(3,6)\n    a41=a(4,1); a42=a(4,2); a43=a(4,3); a44=a(4,4); a45=a(4,5); a46=a(4,6)\n    a51=a(5,1); a52=a(5,2); a53=a(5,3); a54=a(5,4); a55=a(5,5); a56=a(5,6)\n    a61=a(6,1); a62=a(6,2); a63=a(6,3); a64=a(6,4); a65=a(6,5); a66=a(6,6)\n\n    det = -(a16*a25*a34*a43*a52-a15*a26*a34*a43*a52-a16*a24*a35*a43*             &\n         a52+a14*a26*a35*a43*a52+a15*a24*a36*a43*a52-a14*a25*a36*a43*a52-a16*a25*  &\n         a33*a44*a52+a15*a26*a33*a44*a52+a16*a23*a35*a44*a52-a13*a26*a35*a44*      &\n         a52-a15*a23*a36*a44*a52+a13*a25*a36*a44*a52+a16*a24*a33*a45*a52-a14*a26*  &\n         a33*a45*a52-a16*a23*a34*a45*a52+a13*a26*a34*a45*a52+a14*a23*a36*a45*      &\n         a52-a13*a24*a36*a45*a52-a15*a24*a33*a46*a52+a14*a25*a33*a46*a52+a15*a23*  &\n         a34*a46*a52-a13*a25*a34*a46*a52-a14*a23*a35*a46*a52+a13*a24*a35*a46*      &\n         a52-a16*a25*a34*a42*a53+a15*a26*a34*a42*a53+a16*a24*a35*a42*a53-a14*a26*  &\n         a35*a42*a53-a15*a24*a36*a42*a53+a14*a25*a36*a42*a53+a16*a25*a32*a44*      &\n         a53-a15*a26*a32*a44*a53-a16*a22*a35*a44*a53+a12*a26*a35*a44*a53+a15*a22*  &\n         a36*a44*a53-a12*a25*a36*a44*a53-a16*a24*a32*a45*a53+a14*a26*a32*a45*      &\n         a53+a16*a22*a34*a45*a53-a12*a26*a34*a45*a53-a14*a22*a36*a45*a53+a12*a24*  &\n         a36*a45*a53+a15*a24*a32*a46*a53-a14*a25*a32*a46*a53-a15*a22*a34*a46*      &\n         a53+a12*a25*a34*a46*a53+a14*a22*a35*a46*a53-a12*a24*a35*a46*a53+a16*a25*  &\n         a33*a42*a54-a15*a26*a33*a42*a54-a16*a23*a35*a42*a54+a13*a26*a35*a42*      &\n         a54+a15*a23*a36*a42*a54-a13*a25*a36*a42*a54-a16*a25*a32*a43*a54+a15*a26*  &\n         a32*a43*a54+a16*a22*a35*a43*a54-a12*a26*a35*a43*a54-a15*a22*a36*a43*      &\n         a54+a12*a25*a36*a43*a54+a16*a23*a32*a45*a54-a13*a26*a32*a45*a54-a16*a22*  &\n         a33*a45*a54+a12*a26*a33*a45*a54+a13*a22*a36*a45*a54-a12*a23*a36*a45*      &\n         a54-a15*a23*a32*a46*a54+a13*a25*a32*a46*a54+a15*a22*a33*a46*a54-a12*a25*  &\n         a33*a46*a54-a13*a22*a35*a46*a54+a12*a23*a35*a46*a54-a16*a24*a33*a42*      &\n         a55+a14*a26*a33*a42*a55+a16*a23*a34*a42*a55-a13*a26*a34*a42*a55-a14*a23*  &\n         a36*a42*a55+a13*a24*a36*a42*a55+a16*a24*a32*a43*a55-a14*a26*a32*a43*      &\n         a55-a16*a22*a34*a43*a55+a12*a26*a34*a43*a55+a14*a22*a36*a43*a55-a12*a24*  &\n         a36*a43*a55-a16*a23*a32*a44*a55+a13*a26*a32*a44*a55+a16*a22*a33*a44*      &\n         a55-a12*a26*a33*a44*a55-a13*a22*a36*a44*a55+a12*a23*a36*a44*a55+a14*a23*  &\n         a32*a46*a55-a13*a24*a32*a46*a55-a14*a22*a33*a46*a55+a12*a24*a33*a46*      &\n         a55+a13*a22*a34*a46*a55-a12*a23*a34*a46*a55+a15*a24*a33*a42*a56-a14*a25*  &\n         a33*a42*a56-a15*a23*a34*a42*a56+a13*a25*a34*a42*a56+a14*a23*a35*a42*      &\n         a56-a13*a24*a35*a42*a56-a15*a24*a32*a43*a56+a14*a25*a32*a43*a56+a15*a22*  &\n         a34*a43*a56-a12*a25*a34*a43*a56-a14*a22*a35*a43*a56+a12*a24*a35*a43*      &\n         a56+a15*a23*a32*a44*a56-a13*a25*a32*a44*a56-a15*a22*a33*a44*a56+a12*a25*  &\n         a33*a44*a56+a13*a22*a35*a44*a56-a12*a23*a35*a44*a56-a14*a23*a32*a45*      &\n         a56+a13*a24*a32*a45*a56+a14*a22*a33*a45*a56-a12*a24*a33*a45*a56-a13*a22*  &\n         a34*a45*a56+a12*a23*a34*a45*a56)*a61+(a16*a25*a34*a43*a51-a15*a26*a34*    &\n         a43*a51-a16*a24*a35*a43*a51+a14*a26*a35*a43*a51+a15*a24*a36*a43*a51-a14*  &\n         a25*a36*a43*a51-a16*a25*a33*a44*a51+a15*a26*a33*a44*a51+a16*a23*a35*a44*  &\n         a51-a13*a26*a35*a44*a51-a15*a23*a36*a44*a51+a13*a25*a36*a44*a51+a16*a24*  &\n         a33*a45*a51-a14*a26*a33*a45*a51-a16*a23*a34*a45*a51+a13*a26*a34*a45*      &\n         a51+a14*a23*a36*a45*a51-a13*a24*a36*a45*a51-a15*a24*a33*a46*a51+a14*a25*  &\n         a33*a46*a51+a15*a23*a34*a46*a51-a13*a25*a34*a46*a51-a14*a23*a35*a46*      &\n         a51+a13*a24*a35*a46*a51-a16*a25*a34*a41*a53+a15*a26*a34*a41*a53+a16*a24*  &\n         a35*a41*a53-a14*a26*a35*a41*a53-a15*a24*a36*a41*a53+a14*a25*a36*a41*      &\n         a53+a16*a25*a31*a44*a53-a15*a26*a31*a44*a53-a16*a21*a35*a44*a53+a11*a26*  &\n         a35*a44*a53+a15*a21*a36*a44*a53-a11*a25*a36*a44*a53-a16*a24*a31*a45*      &\n         a53+a14*a26*a31*a45*a53+a16*a21*a34*a45*a53-a11*a26*a34*a45*a53-a14*a21*  &\n         a36*a45*a53+a11*a24*a36*a45*a53+a15*a24*a31*a46*a53-a14*a25*a31*a46*      &\n         a53-a15*a21*a34*a46*a53+a11*a25*a34*a46*a53+a14*a21*a35*a46*a53-a11*a24*  &\n         a35*a46*a53+a16*a25*a33*a41*a54-a15*a26*a33*a41*a54-a16*a23*a35*a41*      &\n         a54+a13*a26*a35*a41*a54+a15*a23*a36*a41*a54-a13*a25*a36*a41*a54-a16*a25*  &\n         a31*a43*a54+a15*a26*a31*a43*a54+a16*a21*a35*a43*a54-a11*a26*a35*a43*      &\n         a54-a15*a21*a36*a43*a54+a11*a25*a36*a43*a54+a16*a23*a31*a45*a54-a13*a26*  &\n         a31*a45*a54-a16*a21*a33*a45*a54+a11*a26*a33*a45*a54+a13*a21*a36*a45*      &\n         a54-a11*a23*a36*a45*a54-a15*a23*a31*a46*a54+a13*a25*a31*a46*a54+a15*a21*  &\n         a33*a46*a54-a11*a25*a33*a46*a54-a13*a21*a35*a46*a54+a11*a23*a35*a46*      &\n         a54-a16*a24*a33*a41*a55+a14*a26*a33*a41*a55+a16*a23*a34*a41*a55-a13*a26*  &\n         a34*a41*a55-a14*a23*a36*a41*a55+a13*a24*a36*a41*a55+a16*a24*a31*a43*      &\n         a55-a14*a26*a31*a43*a55-a16*a21*a34*a43*a55+a11*a26*a34*a43*a55+a14*a21*  &\n         a36*a43*a55-a11*a24*a36*a43*a55-a16*a23*a31*a44*a55+a13*a26*a31*a44*      &\n         a55+a16*a21*a33*a44*a55-a11*a26*a33*a44*a55-a13*a21*a36*a44*a55+a11*a23*  &\n         a36*a44*a55+a14*a23*a31*a46*a55-a13*a24*a31*a46*a55-a14*a21*a33*a46*      &\n         a55+a11*a24*a33*a46*a55+a13*a21*a34*a46*a55-a11*a23*a34*a46*a55+a15*a24*  &\n         a33*a41*a56-a14*a25*a33*a41*a56-a15*a23*a34*a41*a56+a13*a25*a34*a41*      &\n         a56+a14*a23*a35*a41*a56-a13*a24*a35*a41*a56-a15*a24*a31*a43*a56+a14*a25*  &\n         a31*a43*a56+a15*a21*a34*a43*a56-a11*a25*a34*a43*a56-a14*a21*a35*a43*      &\n         a56+a11*a24*a35*a43*a56+a15*a23*a31*a44*a56-a13*a25*a31*a44*a56-a15*a21*  &\n         a33*a44*a56+a11*a25*a33*a44*a56+a13*a21*a35*a44*a56-a11*a23*a35*a44*      &\n         a56-a14*a23*a31*a45*a56+a13*a24*a31*a45*a56+a14*a21*a33*a45*a56-a11*a24*  &\n         a33*a45*a56-a13*a21*a34*a45*a56+a11*a23*a34*a45*a56)*a62-(a16*a25*a34*    &\n         a42*a51-a15*a26*a34*a42*a51-a16*a24*a35*a42*a51+a14*a26*a35*a42*a51+a15*  &\n         a24*a36*a42*a51-a14*a25*a36*a42*a51-a16*a25*a32*a44*a51+a15*a26*a32*a44*  &\n         a51+a16*a22*a35*a44*a51-a12*a26*a35*a44*a51-a15*a22*a36*a44*a51+a12*a25*  &\n         a36*a44*a51+a16*a24*a32*a45*a51-a14*a26*a32*a45*a51-a16*a22*a34*a45*      &\n         a51+a12*a26*a34*a45*a51+a14*a22*a36*a45*a51-a12*a24*a36*a45*a51-a15*a24*  &\n         a32*a46*a51+a14*a25*a32*a46*a51+a15*a22*a34*a46*a51-a12*a25*a34*a46*      &\n         a51-a14*a22*a35*a46*a51+a12*a24*a35*a46*a51-a16*a25*a34*a41*a52+a15*a26*  &\n         a34*a41*a52+a16*a24*a35*a41*a52-a14*a26*a35*a41*a52-a15*a24*a36*a41*      &\n         a52+a14*a25*a36*a41*a52+a16*a25*a31*a44*a52-a15*a26*a31*a44*a52-a16*a21*  &\n         a35*a44*a52+a11*a26*a35*a44*a52+a15*a21*a36*a44*a52-a11*a25*a36*a44*      &\n         a52-a16*a24*a31*a45*a52+a14*a26*a31*a45*a52+a16*a21*a34*a45*a52-a11*a26*  &\n         a34*a45*a52-a14*a21*a36*a45*a52+a11*a24*a36*a45*a52+a15*a24*a31*a46*      &\n         a52-a14*a25*a31*a46*a52-a15*a21*a34*a46*a52+a11*a25*a34*a46*a52+a14*a21*  &\n         a35*a46*a52-a11*a24*a35*a46*a52+a16*a25*a32*a41*a54-a15*a26*a32*a41*      &\n         a54-a16*a22*a35*a41*a54+a12*a26*a35*a41*a54+a15*a22*a36*a41*a54-a12*a25*  &\n         a36*a41*a54-a16*a25*a31*a42*a54+a15*a26*a31*a42*a54+a16*a21*a35*a42*      &\n         a54-a11*a26*a35*a42*a54-a15*a21*a36*a42*a54+a11*a25*a36*a42*a54+a16*a22*  &\n         a31*a45*a54-a12*a26*a31*a45*a54-a16*a21*a32*a45*a54+a11*a26*a32*a45*      &\n         a54+a12*a21*a36*a45*a54-a11*a22*a36*a45*a54-a15*a22*a31*a46*a54+a12*a25*  &\n         a31*a46*a54+a15*a21*a32*a46*a54-a11*a25*a32*a46*a54-a12*a21*a35*a46*      &\n         a54+a11*a22*a35*a46*a54-a16*a24*a32*a41*a55+a14*a26*a32*a41*a55+a16*a22*  &\n         a34*a41*a55-a12*a26*a34*a41*a55-a14*a22*a36*a41*a55+a12*a24*a36*a41*      &\n         a55+a16*a24*a31*a42*a55-a14*a26*a31*a42*a55-a16*a21*a34*a42*a55+a11*a26*  &\n         a34*a42*a55+a14*a21*a36*a42*a55-a11*a24*a36*a42*a55-a16*a22*a31*a44*      &\n         a55+a12*a26*a31*a44*a55+a16*a21*a32*a44*a55-a11*a26*a32*a44*a55-a12*a21*  &\n         a36*a44*a55+a11*a22*a36*a44*a55+a14*a22*a31*a46*a55-a12*a24*a31*a46*      &\n         a55-a14*a21*a32*a46*a55+a11*a24*a32*a46*a55+a12*a21*a34*a46*a55-a11*a22*  &\n         a34*a46*a55+a15*a24*a32*a41*a56-a14*a25*a32*a41*a56-a15*a22*a34*a41*      &\n         a56+a12*a25*a34*a41*a56+a14*a22*a35*a41*a56-a12*a24*a35*a41*a56-a15*a24*  &\n         a31*a42*a56+a14*a25*a31*a42*a56+a15*a21*a34*a42*a56-a11*a25*a34*a42*      &\n         a56-a14*a21*a35*a42*a56+a11*a24*a35*a42*a56+a15*a22*a31*a44*a56-a12*a25*  &\n         a31*a44*a56-a15*a21*a32*a44*a56+a11*a25*a32*a44*a56+a12*a21*a35*a44*      &\n         a56-a11*a22*a35*a44*a56-a14*a22*a31*a45*a56+a12*a24*a31*a45*a56+a14*a21*  &\n         a32*a45*a56-a11*a24*a32*a45*a56-a12*a21*a34*a45*a56+a11*a22*a34*a45*a56)* &\n         a63+(a16*a25*a33*a42*a51-a15*a26*a33*a42*a51-a16*a23*a35*a42*a51+a13*a26* &\n         a35*a42*a51+a15*a23*a36*a42*a51-a13*a25*a36*a42*a51-a16*a25*a32*a43*      &\n         a51+a15*a26*a32*a43*a51+a16*a22*a35*a43*a51-a12*a26*a35*a43*a51-a15*a22*  &\n         a36*a43*a51+a12*a25*a36*a43*a51+a16*a23*a32*a45*a51-a13*a26*a32*a45*      &\n         a51-a16*a22*a33*a45*a51+a12*a26*a33*a45*a51+a13*a22*a36*a45*a51-a12*a23*  &\n         a36*a45*a51-a15*a23*a32*a46*a51+a13*a25*a32*a46*a51+a15*a22*a33*a46*      &\n         a51-a12*a25*a33*a46*a51-a13*a22*a35*a46*a51+a12*a23*a35*a46*a51-a16*a25*  &\n         a33*a41*a52+a15*a26*a33*a41*a52+a16*a23*a35*a41*a52-a13*a26*a35*a41*      &\n         a52-a15*a23*a36*a41*a52+a13*a25*a36*a41*a52+a16*a25*a31*a43*a52-a15*a26*  &\n         a31*a43*a52-a16*a21*a35*a43*a52+a11*a26*a35*a43*a52+a15*a21*a36*a43*      &\n         a52-a11*a25*a36*a43*a52-a16*a23*a31*a45*a52+a13*a26*a31*a45*a52+a16*a21*  &\n         a33*a45*a52-a11*a26*a33*a45*a52-a13*a21*a36*a45*a52+a11*a23*a36*a45*      &\n         a52+a15*a23*a31*a46*a52-a13*a25*a31*a46*a52-a15*a21*a33*a46*a52+a11*a25*  &\n         a33*a46*a52+a13*a21*a35*a46*a52-a11*a23*a35*a46*a52+a16*a25*a32*a41*      &\n         a53-a15*a26*a32*a41*a53-a16*a22*a35*a41*a53+a12*a26*a35*a41*a53+a15*a22*  &\n         a36*a41*a53-a12*a25*a36*a41*a53-a16*a25*a31*a42*a53+a15*a26*a31*a42*      &\n         a53+a16*a21*a35*a42*a53-a11*a26*a35*a42*a53-a15*a21*a36*a42*a53+a11*a25*  &\n         a36*a42*a53+a16*a22*a31*a45*a53-a12*a26*a31*a45*a53-a16*a21*a32*a45*      &\n         a53+a11*a26*a32*a45*a53+a12*a21*a36*a45*a53-a11*a22*a36*a45*a53-a15*a22*  &\n         a31*a46*a53+a12*a25*a31*a46*a53+a15*a21*a32*a46*a53-a11*a25*a32*a46*      &\n         a53-a12*a21*a35*a46*a53+a11*a22*a35*a46*a53-a16*a23*a32*a41*a55+a13*a26*  &\n         a32*a41*a55+a16*a22*a33*a41*a55-a12*a26*a33*a41*a55-a13*a22*a36*a41*      &\n         a55+a12*a23*a36*a41*a55+a16*a23*a31*a42*a55-a13*a26*a31*a42*a55-a16*a21*  &\n         a33*a42*a55+a11*a26*a33*a42*a55+a13*a21*a36*a42*a55-a11*a23*a36*a42*      &\n         a55-a16*a22*a31*a43*a55+a12*a26*a31*a43*a55+a16*a21*a32*a43*a55-a11*a26*  &\n         a32*a43*a55-a12*a21*a36*a43*a55+a11*a22*a36*a43*a55+a13*a22*a31*a46*      &\n         a55-a12*a23*a31*a46*a55-a13*a21*a32*a46*a55+a11*a23*a32*a46*a55+a12*a21*  &\n         a33*a46*a55-a11*a22*a33*a46*a55+a15*a23*a32*a41*a56-a13*a25*a32*a41*      &\n         a56-a15*a22*a33*a41*a56+a12*a25*a33*a41*a56+a13*a22*a35*a41*a56-a12*a23*  &\n         a35*a41*a56-a15*a23*a31*a42*a56+a13*a25*a31*a42*a56+a15*a21*a33*a42*      &\n         a56-a11*a25*a33*a42*a56-a13*a21*a35*a42*a56+a11*a23*a35*a42*a56+a15*a22*  &\n         a31*a43*a56-a12*a25*a31*a43*a56-a15*a21*a32*a43*a56+a11*a25*a32*a43*      &\n         a56+a12*a21*a35*a43*a56-a11*a22*a35*a43*a56-a13*a22*a31*a45*a56+a12*a23*  &\n         a31*a45*a56+a13*a21*a32*a45*a56-a11*a23*a32*a45*a56-a12*a21*a33*a45*      &\n         a56+a11*a22*a33*a45*a56)*a64-(a16*a24*a33*a42*a51-a14*a26*a33*a42*        &\n         a51-a16*a23*a34*a42*a51+a13*a26*a34*a42*a51+a14*a23*a36*a42*a51-a13*a24*  &\n         a36*a42*a51-a16*a24*a32*a43*a51+a14*a26*a32*a43*a51+a16*a22*a34*a43*      &\n         a51-a12*a26*a34*a43*a51-a14*a22*a36*a43*a51+a12*a24*a36*a43*a51+a16*a23*  &\n         a32*a44*a51-a13*a26*a32*a44*a51-a16*a22*a33*a44*a51+a12*a26*a33*a44*      &\n         a51+a13*a22*a36*a44*a51-a12*a23*a36*a44*a51-a14*a23*a32*a46*a51+a13*a24*  &\n         a32*a46*a51+a14*a22*a33*a46*a51-a12*a24*a33*a46*a51-a13*a22*a34*a46*      &\n         a51+a12*a23*a34*a46*a51-a16*a24*a33*a41*a52+a14*a26*a33*a41*a52+a16*a23*  &\n         a34*a41*a52-a13*a26*a34*a41*a52-a14*a23*a36*a41*a52+a13*a24*a36*a41*      &\n         a52+a16*a24*a31*a43*a52-a14*a26*a31*a43*a52-a16*a21*a34*a43*a52+a11*a26*  &\n         a34*a43*a52+a14*a21*a36*a43*a52-a11*a24*a36*a43*a52-a16*a23*a31*a44*      &\n         a52+a13*a26*a31*a44*a52+a16*a21*a33*a44*a52-a11*a26*a33*a44*a52-a13*a21*  &\n         a36*a44*a52+a11*a23*a36*a44*a52+a14*a23*a31*a46*a52-a13*a24*a31*a46*      &\n         a52-a14*a21*a33*a46*a52+a11*a24*a33*a46*a52+a13*a21*a34*a46*a52-a11*a23*  &\n         a34*a46*a52+a16*a24*a32*a41*a53-a14*a26*a32*a41*a53-a16*a22*a34*a41*      &\n         a53+a12*a26*a34*a41*a53+a14*a22*a36*a41*a53-a12*a24*a36*a41*a53-a16*a24*  &\n         a31*a42*a53+a14*a26*a31*a42*a53+a16*a21*a34*a42*a53-a11*a26*a34*a42*      &\n         a53-a14*a21*a36*a42*a53+a11*a24*a36*a42*a53+a16*a22*a31*a44*a53-a12*a26*  &\n         a31*a44*a53-a16*a21*a32*a44*a53+a11*a26*a32*a44*a53+a12*a21*a36*a44*      &\n         a53-a11*a22*a36*a44*a53-a14*a22*a31*a46*a53+a12*a24*a31*a46*a53+a14*a21*  &\n         a32*a46*a53-a11*a24*a32*a46*a53-a12*a21*a34*a46*a53+a11*a22*a34*a46*      &\n         a53-a16*a23*a32*a41*a54+a13*a26*a32*a41*a54+a16*a22*a33*a41*a54-a12*a26*  &\n         a33*a41*a54-a13*a22*a36*a41*a54+a12*a23*a36*a41*a54+a16*a23*a31*a42*      &\n         a54-a13*a26*a31*a42*a54-a16*a21*a33*a42*a54+a11*a26*a33*a42*a54+a13*a21*  &\n         a36*a42*a54-a11*a23*a36*a42*a54-a16*a22*a31*a43*a54+a12*a26*a31*a43*      &\n         a54+a16*a21*a32*a43*a54-a11*a26*a32*a43*a54-a12*a21*a36*a43*a54+a11*a22*  &\n         a36*a43*a54+a13*a22*a31*a46*a54-a12*a23*a31*a46*a54-a13*a21*a32*a46*      &\n         a54+a11*a23*a32*a46*a54+a12*a21*a33*a46*a54-a11*a22*a33*a46*a54+a14*a23*  &\n         a32*a41*a56-a13*a24*a32*a41*a56-a14*a22*a33*a41*a56+a12*a24*a33*a41*      &\n         a56+a13*a22*a34*a41*a56-a12*a23*a34*a41*a56-a14*a23*a31*a42*a56+a13*a24*  &\n         a31*a42*a56+a14*a21*a33*a42*a56-a11*a24*a33*a42*a56-a13*a21*a34*a42*      &\n         a56+a11*a23*a34*a42*a56+a14*a22*a31*a43*a56-a12*a24*a31*a43*a56-a14*a21*  &\n         a32*a43*a56+a11*a24*a32*a43*a56+a12*a21*a34*a43*a56-a11*a22*a34*a43*      &\n         a56-a13*a22*a31*a44*a56+a12*a23*a31*a44*a56+a13*a21*a32*a44*a56-a11*a23*  &\n         a32*a44*a56-a12*a21*a33*a44*a56+a11*a22*a33*a44*a56)*a65+(a15*a24*a33*    &\n         a42*a51-a14*a25*a33*a42*a51-a15*a23*a34*a42*a51+a13*a25*a34*a42*a51+a14*  &\n         a23*a35*a42*a51-a13*a24*a35*a42*a51-a15*a24*a32*a43*a51+a14*a25*a32*a43*  &\n         a51+a15*a22*a34*a43*a51-a12*a25*a34*a43*a51-a14*a22*a35*a43*a51+a12*a24*  &\n         a35*a43*a51+a15*a23*a32*a44*a51-a13*a25*a32*a44*a51-a15*a22*a33*a44*      &\n         a51+a12*a25*a33*a44*a51+a13*a22*a35*a44*a51-a12*a23*a35*a44*a51-a14*a23*  &\n         a32*a45*a51+a13*a24*a32*a45*a51+a14*a22*a33*a45*a51-a12*a24*a33*a45*      &\n         a51-a13*a22*a34*a45*a51+a12*a23*a34*a45*a51-a15*a24*a33*a41*a52+a14*a25*  &\n         a33*a41*a52+a15*a23*a34*a41*a52-a13*a25*a34*a41*a52-a14*a23*a35*a41*      &\n         a52+a13*a24*a35*a41*a52+a15*a24*a31*a43*a52-a14*a25*a31*a43*a52-a15*a21*  &\n         a34*a43*a52+a11*a25*a34*a43*a52+a14*a21*a35*a43*a52-a11*a24*a35*a43*      &\n         a52-a15*a23*a31*a44*a52+a13*a25*a31*a44*a52+a15*a21*a33*a44*a52-a11*a25*  &\n         a33*a44*a52-a13*a21*a35*a44*a52+a11*a23*a35*a44*a52+a14*a23*a31*a45*      &\n         a52-a13*a24*a31*a45*a52-a14*a21*a33*a45*a52+a11*a24*a33*a45*a52+a13*a21*  &\n         a34*a45*a52-a11*a23*a34*a45*a52+a15*a24*a32*a41*a53-a14*a25*a32*a41*      &\n         a53-a15*a22*a34*a41*a53+a12*a25*a34*a41*a53+a14*a22*a35*a41*a53-a12*a24*  &\n         a35*a41*a53-a15*a24*a31*a42*a53+a14*a25*a31*a42*a53+a15*a21*a34*a42*      &\n         a53-a11*a25*a34*a42*a53-a14*a21*a35*a42*a53+a11*a24*a35*a42*a53+a15*a22*  &\n         a31*a44*a53-a12*a25*a31*a44*a53-a15*a21*a32*a44*a53+a11*a25*a32*a44*      &\n         a53+a12*a21*a35*a44*a53-a11*a22*a35*a44*a53-a14*a22*a31*a45*a53+a12*a24*  &\n         a31*a45*a53+a14*a21*a32*a45*a53-a11*a24*a32*a45*a53-a12*a21*a34*a45*      &\n         a53+a11*a22*a34*a45*a53-a15*a23*a32*a41*a54+a13*a25*a32*a41*a54+a15*a22*  &\n         a33*a41*a54-a12*a25*a33*a41*a54-a13*a22*a35*a41*a54+a12*a23*a35*a41*      &\n         a54+a15*a23*a31*a42*a54-a13*a25*a31*a42*a54-a15*a21*a33*a42*a54+a11*a25*  &\n         a33*a42*a54+a13*a21*a35*a42*a54-a11*a23*a35*a42*a54-a15*a22*a31*a43*      &\n         a54+a12*a25*a31*a43*a54+a15*a21*a32*a43*a54-a11*a25*a32*a43*a54-a12*a21*  &\n         a35*a43*a54+a11*a22*a35*a43*a54+a13*a22*a31*a45*a54-a12*a23*a31*a45*      &\n         a54-a13*a21*a32*a45*a54+a11*a23*a32*a45*a54+a12*a21*a33*a45*a54-a11*a22*  &\n         a33*a45*a54+a14*a23*a32*a41*a55-a13*a24*a32*a41*a55-a14*a22*a33*a41*      &\n         a55+a12*a24*a33*a41*a55+a13*a22*a34*a41*a55-a12*a23*a34*a41*a55-a14*a23*  &\n         a31*a42*a55+a13*a24*a31*a42*a55+a14*a21*a33*a42*a55-a11*a24*a33*a42*      &\n         a55-a13*a21*a34*a42*a55+a11*a23*a34*a42*a55+a14*a22*a31*a43*a55-a12*a24*  &\n         a31*a43*a55-a14*a21*a32*a43*a55+a11*a24*a32*a43*a55+a12*a21*a34*a43*      &\n         a55-a11*a22*a34*a43*a55-a13*a22*a31*a44*a55+a12*a23*a31*a44*a55+a13*a21*  &\n         a32*a44*a55-a11*a23*a32*a44*a55-a12*a21*a33*a44*a55+a11*a22*a33*a44*a55)* &\n         a66\n      return\n    end function m6x6det\n"}, {"instruction": "Create a Fortran function named minor to extract a minor matrix from a given matrix based on the specified row and column indices. The function should take 4 input arguments of type integer, integer, integer, and real(kind(1d0)),dimension(n,n), and return 1 output argument of type real(kind(1d0)),dimension(n-1,n-1).", "input": "", "output": "    function minor(n,a,i,j)\n      implicit none\n      integer,intent(in)::n,i,j\n      real(kind(1d0)),dimension(n,n),intent(in)::a\n      real(kind(1d0)),dimension(n-1,n-1)::minor\n      integer::k1,k2,i0,j0\n      i0=1\n      do k1=1,n\n         if(k1.eq.i)cycle\n         j0=1\n         do k2=1,n\n            if(k2.eq.j)cycle\n            minor(i0,j0)=a(k1,k2)\n            j0=j0+1\n         enddo\n         i0=i0+1\n      enddo\n      return\n    end function minor\n"}, {"instruction": "Write a Fortran function named ldot, which calculates the linear dot product of two given arrays. The function should accept four input parameters: two integers n1 and n2, a 2D real array a of size n1 by n2, and a 1D real array b of size n1. The output should be a 1D real array ldot of size n2.", "input": "", "output": "    function ldot(n1,n2,a,b)\n      ! b.a \n      implicit none\n      integer,intent(in)::n1,n2\n      real(kind(1d0)),dimension(n1,n2),intent(in)::a\n      real(kind(1d0)),dimension(n1),intent(in)::b\n      real(kind(1d0)),dimension(n2)::ldot\n      integer::i,j\n      do i=1,n2\n         ldot(i)=0d0\n          do j=1,n1\n            ldot(i)=ldot(i)+a(j,i)*b(j)\n         enddo\n      enddo\n      return\n    end function ldot\n"}, {"instruction": "Write a Fortran function named hdeltabar that checks if an array element at index j is non-zero. The number of input parameters is 3 with test_data type ['integer', 'integer', 'integer,dimension(n)'], and the number of output parameters is 1 with test_data type ['integer'].", "input": "", "output": "    function hdeltabar(n,x,j)\n      implicit none\n      integer,intent(in)::n,j\n      integer,dimension(n),intent(in)::x\n      integer::hdeltabar\n      integer::i\n      do i=1,n\n         if(x(i).ne.0.and.i.eq.j)then\n            hdeltabar=0\n            return\n         endif\n      enddo\n      hdeltabar=1\n      return\n    end function hdeltabar\n"}, {"instruction": "Create a Fortran function named \"chap\" that calculates the Chapman function value based on a real input parameter. The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "      function chap(zeta)\n        real :: zeta\n        real :: rm\n        integer :: i\n        real :: y(22)\n        real :: chap\n        data (y(i),i=1,22)/3.800, 4.055, 4.348, 4.687, 5.083, 5.551, 6.113, &\n          6.799, 7.650, 8.732, 10.144, 12.051, 14.730, 18.686, 24.905, 35.466, &\n          55.211, 96.753, 197., 485., 1476., 9999./\n        do 10 i = 75, 96\n          rm = i\n          if (zeta<rm) go to 20\n10 continue\n20 chap = y(i-75) + (y(i-74)-y(i-75))*(zeta-(rm-1.))\n      end function chap\n"}, {"instruction": "Create a Fortran function named split_string to split a string based on a specified separator character. The function takes 2 input arguments with the test_data type ['character(len=*)', 'character(1)'] and returns 1 output parameter with the test_data type ['character(len=len(string)), dimension(:), allocatable'].", "input": "", "output": "    function split_string(string,separator)\n        implicit none\n        character(len=*),intent(in) :: string\n        character(1),intent(in) :: separator\n        character(len=len(string)), dimension(:), allocatable :: split_string\n\n        character(len=len(string)), dimension(:), allocatable :: temp_split_string\n\n        integer :: i,j,k\n\n\n        allocate(split_string(0))\n        temp_split_string = split_string\n        i = 0\n        k = 0\n        do \n            j = index(string(i+1:),separator)\n            if(trim(adjustl(string(i+1:i+j)))=='') exit\n\n            k = k+1 \n            deallocate(split_string)\n            allocate(split_string(k))\n            split_string(:k-1) = temp_split_string\n            deallocate(temp_split_string)\n            split_string(k) = trim(adjustl(string(i+1:i+j))) \n            temp_split_string = split_string\n\n            i = i+j\n        end do\n\n    end function split_string\n"}, {"instruction": "Write a Fortran function named interp_gxp that performs interpolation. This function has 6 input parameters of types real(kind=8), dimension(:), real(kind=8), dimension(:), real(kind=8), dimension(:), real(kind=8), dimension(:), integer, dimension(:), and integer, dimension(:). It has 1 output parameter of type real(kind=8), dimension(size(x)). This function performs interpolation using the input data and returns the interpolated values in the output parameter.", "input": "", "output": "      function interp_gxp(x,p,ix,iy,xv,yv) result(yy)\n          real(kind=8), dimension(:), intent(in) :: x,p,xv\n          real(kind=8), dimension(:), intent(in) :: yv\n          integer, dimension(:), intent(in) :: ix,iy\n          integer, dimension(size(ix)) :: indx\n          real(kind=8), dimension(size(x)) :: yy,slope,yix,xix,yix1,xix1,xx\n          xx=log(x); \n\n          indx=iy*size(xv)+ix\n          ! then interpolate between these to choose appropriate p:\n          yix=yv(indx) ; yix1=yv(indx+1) ; \n          xix=xv(ix) ; xix1=xv(ix+1)\n          slope=(yix1-yix)/(xix1-xix)\n          yy=yix+slope*(xx-xix)\n          yy=exp(yy)\n      end function interp_gxp\n"}, {"instruction": "Create a Fortran function named eval_a that takes two input parameters of type integer. Calculate a real*8 result using the formula eval_a = 1.d0 / (0.5d0 * ((di + dj) * (di + dj + 1.d0)) + di + 1.d0), where di and dj are the real*8 representations of the input integers i and j. The function returns a single real*8 result.", "input": "", "output": "pure function eval_a(i, j)\nreal*8 :: eval_a\ninteger, intent(in) :: i, j\nreal*8 :: di, dj\ninteger :: d\ndi = real(i,8)\ndj = real(j,8)\neval_a = 1.d0 / (0.5d0 * ((di + dj) * (di + dj + 1.d0)) + di + 1.d0)\nend function\n"}, {"instruction": "Create a Fortran function named qconj to calculate the conjugate of a quaternion represented by a 4-element real array. The function should take 1 input argument of type real, dimension(0:3) and return 1 output argument of type real, dimension(0:3).", "input": "", "output": " pure function qconj(qs)\n  implicit none      \n  real, intent(in), dimension(0:3) :: qs      \n  real, dimension(0:3) :: qconj\n  \n  qconj(0) = qs(0)\n  qconj(1:3) = -qs(1:3)\n end function qconj\n"}, {"instruction": "Write a Fortran function called dimenumb that calculates the number of digits in a given integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": " function dimenumb(inum)\n  implicit none\n  integer,intent(in) :: inum\n  integer :: dimenumb, i\n  real :: tmp\n\n  i=1\n  tmp = real(inum)\n  do\n    if (tmp<10.0) exit\n    i = i+1\n    tmp = tmp / 10.0\n  enddo\n\n  dimenumb = i\n end function dimenumb\n"}, {"instruction": "Create a Fortran function named compare to compare two integer values. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type is ['integer', 'integer'] for input and ['integer'] for output.", "input": "", "output": "    function compare(f,g)\n      implicit none\n      integer               :: f,g\n      integer               :: compare\n      if(f<g) then\n         compare=-1\n      else\n         compare=1\n      endif\n    end function compare\n"}, {"instruction": "Create a Fortran function named sub2ind that calculates the linear index of a multidimensional array given its dimensions and subscripts. The function takes 2 input parameters of type 'integer, dimension(:)' representing the dimensions of the array and the subscripts, and returns 1 output parameter of type 'integer' representing the linear index.", "input": "", "output": "function sub2ind(dims, subs) result (ind)\n    !+ calculates the linear index of an array with dimensions `dims` and\n    !+ subcripts `subs`\n    integer, dimension(:), intent(in) :: dims\n        !+ dimension of array\n    integer, dimension(:), intent(in) :: subs\n        !+ subscripts to convert\n    integer :: ind\n        !+ linear index\n\n    integer :: k, l, p\n\n    ind = subs(1)\n    do k=2,size(dims)\n        p = dims(1)\n        do l=2, k-1\n            p = p*dims(l)\n        enddo\n        ind = ind + p*(subs(k)-1)\n    enddo\n\nend function sub2ind\n"}, {"instruction": "Create a Fortran function named get_index_of_first_particle, which takes an integer input parameter and returns an integer output. The function's purpose is to return the index of the first particle.", "input": "", "output": "function get_index_of_first_particle(index_of_the_particle)\n  implicit none\n  integer :: get_index_of_first_particle\n  integer :: index_of_the_particle\n  get_index_of_first_particle=0\nend function\n"}, {"instruction": "Create a Fortran function named get_total_radius that takes a double precision input parameter named radius. The function returns an integer value.", "input": "", "output": "function get_total_radius(radius)\n  implicit none\n  integer :: get_total_radius\n  double precision :: radius\n  get_total_radius=0\nend function\n"}, {"instruction": "Write a Fortran function named get_potential_at_point to calculate the potential at a given point. The function takes 5 input parameters of type double precision: eps, x, y, z, and phi. It returns 1 output parameter of type integer.", "input": "", "output": "function get_potential_at_point(eps, x, y, z, phi)\n  implicit none\n  integer :: get_potential_at_point\n  double precision :: eps, x, y, z, phi\n  get_potential_at_point=0\nend function\n"}, {"instruction": "Create a Fortran function named set_eps2 that takes a double precision input parameter to set the value of epsilon squared. The function returns an integer value indicating the success of the operation. The number of input parameters is 1 with a test_data type of ['double precision'], and the number of output parameters is 1 with a test_data type of ['integer'].", "input": "", "output": "function set_eps2(epsilon_squared)\n  implicit none\n  integer :: set_eps2\n  double precision :: epsilon_squared\n  set_eps2=0\nend function\n"}, {"instruction": "Write a Fortran function named get_eps2 that takes a double precision input argument and returns an integer. The input argument type is ['double precision'] and the output argument type is ['integer'].", "input": "", "output": "function get_eps2(epsilon_squared)\n  implicit none\n  integer :: get_eps2\n  double precision :: epsilon_squared\n  get_eps2=0\nend function\n"}, {"instruction": "Create a Fortran function named get_potential to retrieve the potential for a particle based on its index. This function takes 2 input parameters of type integer and double precision. The output is a single integer.", "input": "", "output": "function get_potential(index_of_the_particle, potential)\n  implicit none\n  integer ::get_potential\n  integer :: index_of_the_particle\n  double precision :: potential\n  get_potential=0\nend function\n"}, {"instruction": "Create a Fortran function named set_acceleration to set the acceleration components for a particle. The function takes 4 input parameters: index_of_the_particle (integer), ax (double precision), ay (double precision), and az (double precision). It returns a single output parameter of type integer.", "input": "", "output": "function set_acceleration(index_of_the_particle, ax, ay, az)\n  implicit none\n  integer :: set_acceleration\n  integer :: index_of_the_particle\n  double precision :: ax, ay, az\n  set_acceleration=0\nend function\n"}, {"instruction": "Create a Fortran function named get_center_of_mass_position to calculate the center of mass position in three-dimensional space. The function takes 3 input parameters of type double precision representing the x, y, and z coordinates, and returns an output value of type integer.", "input": "", "output": "function get_center_of_mass_position(x, y, z)\n  implicit none\n  integer :: get_center_of_mass_position\n  double precision :: x, y, z\n  get_center_of_mass_position=0\nend function\n"}, {"instruction": "Create a Fortran function named get_center_of_mass_velocity to calculate the center of mass velocity components in three dimensions. Accept 3 input parameters of type double precision (vx, vy, vz) and return 1 output parameter of type integer. The test_data type for input is ['double precision', 'double precision', 'double precision'] and for the output is ['integer'].", "input": "", "output": "function get_center_of_mass_velocity(vx, vy, vz)\n  implicit none\n  integer :: get_center_of_mass_velocity\n  double precision :: vx, vy, vz\n  get_center_of_mass_velocity=0\nend function\n"}, {"instruction": "Create a Fortran function named get_acceleration to retrieve the acceleration components (ax, ay, az) of a particle specified by its index. The function takes 4 input parameters of type integer, double precision, double precision, and double precision respectively. The output is an integer indicating the status of the function.", "input": "", "output": "function get_acceleration(index_of_the_particle, ax, ay, az)\n  implicit none\n  integer :: get_acceleration\n  integer :: index_of_the_particle\n  double precision :: ax, ay, az\n  get_acceleration=0\nend function\n"}, {"instruction": "Create a Fortran function named pm_spectrum that calculates the Pierson-Moskowitz spectrum for a given frequency, significant wave height, and peak period. The function should have 3 input parameters of type real(kind=long) representing the frequency, significant wave height, and peak period, and 1 output parameter of type real(kind=long) representing the Pierson-Moskowitz spectrum.", "input": "", "output": " function pm_spectrum(freq, hs, tp)\n!\n\n! for the frequency freq, significant wave height hs, and peak period\n! tp.\n\n   implicit none\n   integer, parameter :: long=selected_real_kind(12,99)\n   real(kind=long) :: pm_spectrum, hs, tp, a, b, freq, t02,   &\n        four=4._long, pi, zero=0._long, one=1._long\n   pi = acos (-one)\n\n   t02=.71*tp\n   a = hs*hs/(four*pi*t02**4)\n   b = one/(pi*t02**4)\n   if (freq.le.zero) then\n      pm_spectrum = zero\n   else\n      pm_spectrum = a/freq**5 * exp (-b/freq**4)\n   endif\n   return\n end function pm_spectrum\n"}, {"instruction": "Create a Fortran function named char2int that converts a character string to an integer. The function takes 1 input parameter of type character (*) and returns 1 output parameter of type integer. The function should use the \"intent (in)\" attribute for the input parameter.", "input": "", "output": "   function char2int(c) result (i)\n      implicit none\n      character (*), intent (in) :: c\n      integer :: i\n      character (20) :: ifmt\n      write (ifmt,'(\"(i\",i0,\")\")') len_trim(c)\n      read (c,fmt=ifmt) i\n   end function char2int\n"}, {"instruction": "Create a Fortran function called neighbors to determine if two arrays of integers, knn1 and knn2, share any common elements. The function should return a logical value indicating whether there are any common elements in the arrays. The input parameters include two integer arrays, knn1 and knn2, both of which are of unspecified size. The output parameter is a single logical value.", "input": "", "output": "    function neighbors(knn1,knn2) result(same_list)\n        implicit none\n        integer,intent(in), dimension(:) :: knn1\n        integer,intent(in), dimension(:) :: knn2 \n\n        logical :: same_list\n\n        ! check to see if they're in each others neighbors lists\n        same_list= any(knn1==knn2(1)) .or. any(knn2==knn1(1))\n\n    end function neighbors\n"}, {"instruction": "Create a Fortran function named matches to compare two integer arrays and count the number of matching elements. The function takes 2 input parameters of type integer arrays with unspecified dimension and returns 1 output parameter of type integer.", "input": "", "output": "    function matches(knn1,knn2)\n        implicit none\n        integer,intent(in), dimension(:) :: knn1\n        integer,intent(in), dimension(:) :: knn2 \n\n        integer :: matches\n\n        integer i,j\n\n        matches = count( [( [( knn1(i)==knn2(j), i=1,size(knn1) )], j=1,size(knn2) )] )\n\n    end function matches\n"}, {"instruction": "Write a Fortran function named cbrt that calculates the cube root of an integer input. The number of input parameters is 1 and the test_data type is ['integer(4)']. The number of output parameters is 1 and the test_data type is ['real(8)'].", "input": "", "output": "function cbrt(mant)\n    implicit none\n\n    integer(4), intent(in) :: mant\n    real(8) :: expo,cbrt\n\n    expo=1./3.\n    cbrt=mant**expo\n    return\nend function cbrt\n"}, {"instruction": "Write a Fortran function named bias to generate a random number between 0 and 1. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used to determine the bias of the random number generation. If the random number is greater than 1 divided by the input integer, the output is 0; otherwise, it is 1.", "input": "", "output": "function bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named fprobdep to calculate the probability of deposition using a probability integral. The function takes 2 input parameters of type real, and returns 1 output parameter of type real. The inputs are tauddd and taubbb, and the output is fprobdep.", "input": "", "output": "function fprobdep(tauddd,taubbb)\n\n  !**********************************************************************c\n  !\n  ! **  fprobdep calculates probability of deposition using probability\n  ! **  integral\n  !\n  ! **  this subroutine is part of  efdc-full version 1.0a\n  !\n  ! **  last modified by john hamrick on 1 november 2001\n  !\n  !----------------------------------------------------------------------c\n  !\n  ! change record\n  ! date modified     by                 date approved    by\n  !\n  !----------------------------------------------------------------------c\n  !\n  !**********************************************************************c\n  !\n\n  implicit none\n\n  integer :: ineg\n  real   :: fprobdep,yval,xval,polyx,expy,funy,tmpval\n  real, intent(in) :: tauddd,taubbb\n\n\n  ! *** evaluation assumes taubbb > tauddd\n  yval=2.04*log(0.25*((taubbb/tauddd)-1.)*exp(1.27*tauddd))\n  ineg=0\n  if( yval < 0.0 )then\n    ineg=1\n    yval=abs(yval)\n  endif\n  xval=1.0/(1.0+0.3327*yval)\n  polyx=xval*(0.4632-0.1202*xval+0.9373*xval*xval)\n  expy=-0.5*yval*yval\n  funy=0.3989*exp(expy)\n  tmpval=1.0-funy*polyx\n  if( ineg == 1 ) tmpval=1.0-tmpval\n  fprobdep=1.0-tmpval\n\n  ! **  notes\n  !     0.3989=1/sqrt(2*pi)\n\nend function\n"}, {"instruction": "Create a Fortran function named quantile that takes two input arguments: an integer k and a one-dimensional real array a. The output is a single real value. The function computes the quantile of the input array a at the specified position k and returns the corresponding value.", "input": "", "output": "    pure recursive function quantile(k, a) result(value)\n        integer, intent(in)  :: k          ! position in array\n        real, dimension(:), intent(in)  :: a\n\n        real                              :: value      ! output value of quantile\n        integer                           :: j\n        real                              :: ak\n\n        ak = a(k)\n        j = count(a < ak)                              ! how many a(:) < ak\n\n        if (j .ge. k) then\n            value = quantile(k, pack(a, a < ak))\n        else\n            j = count(a > ak) + k - size(a)\n\n            if (j .gt. 0) then\n                value = quantile(j, pack(a, a > ak))\n            else\n                value = ak\n            end if\n        end if\n    end function quantile\n"}, {"instruction": "Create a Fortran function named rev_order to reverse the order of elements in an integer array. The number of input arguments is 1 with the test_data type ['integer,dimension(:)'], and the number of output arguments is 1 with the test_data type ['integer,dimension(size(v1))'].", "input": "", "output": "function rev_order(v1) result(v)\n  integer,dimension(:),intent(in)::v1\n  integer,dimension(size(v1))::v\n  integer::i,j\n  j=0\n  do i=size(v1),1,-1\n    j=j+1\n    v(i)=v1(j)\n  end do\nend function\n"}, {"instruction": "Create a Fortran function named ifthenelse_s that returns a character pointer based on a logical condition. The function takes 3 input parameters: a logical flag, and two target character strings. The output is a pointer to a character string. The number of input arguments is 3 and the test_data type is ['logical', 'character(len=*), target', 'character(len=*), target']. The number of output arguments is 1 and the test_data type is ['character(len=:), pointer'].", "input": "", "output": "    function ifthenelse_s(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    character(len=:), pointer :: ifthenelse\n    character(len=*), target :: either, or\n\n    if (flag) then\n        ifthenelse => either\n    else\n        ifthenelse => or\n    end if\n\n    end function\n"}, {"instruction": "Write a Fortran function named ifthenelse_l to evaluate a conditional expression based on the value of a logical flag. The function should accept 3 input arguments of type logical and return 1 output argument of type logical. The test_data type for input arguments is ['logical', 'logical', 'logical'], and for the output argument is ['logical'].", "input": "", "output": "    function ifthenelse_l(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    logical :: ifthenelse, either, or\n\n    if (flag) then\n        ifthenelse = either\n    else\n        ifthenelse = or\n    end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named ifthenelse_r that returns a real number based on a logical flag and two real numbers. The number of input arguments is 3 with test_data types ['logical', 'real', 'real'], and the number of output arguments is 1 with a test_data type of ['real'].", "input": "", "output": "    function ifthenelse_r(flag, either, or) result(ifthenelse)\n    logical, intent(in) :: flag\n    real :: ifthenelse, either, or\n\n    if (flag) then\n        ifthenelse = either\n    else\n        ifthenelse = or\n    end if\n\n    end function\n"}, {"instruction": "Create a Fortran function named fast_exp to efficiently compute the exponentiation of an array of double precision numbers. The function should take 4 input arguments of types double precision array, integer, integer, and double precision. The output is a double precision array. The function utilizes the \"where\" construct to ensure convergence and a do loop to iterate the exponentiation.", "input": "", "output": "function fast_exp(x, n, m, k) result(val)\n    double precision, dimension(n), intent(in) :: x\n    integer, intent(in) :: n\n    integer, intent(in) :: m\n    double precision, intent(in) :: k\n\n    integer :: i\n    double precision, dimension(n) :: val\n\n    val = (1.0d0+k*x)\n\n    ! makes sure the expression converges\n    where (val < 0.0d0) val = 0.0d0\n\n    do i=2, m\n        val = val * val\n    enddo\n\n    ! exact\n    !val = exp(x)\n\n\nend function fast_exp\n"}, {"instruction": "Create a Fortran function named nr_change_coins to calculate the minimum number of coins needed to make change for a given amount. The function takes 2 input parameters with test_data type ['integer, value', 'integer, dimension(:)'] and returns 1 output parameter with test_data type ['integer'].", "input": "", "output": "    function nr_change_coins(amount, coins) result(nr_coins)\n        implicit none\n        integer, value :: amount\n        integer, dimension(:), intent(in) :: coins\n        integer :: nr_coins\n        integer :: coin_nr, coin\n\n        nr_coins = 0\n        do coin_nr = size(coins), 1, -1\n            coin = coins(coin_nr)\n            nr_coins = nr_coins + amount/coin\n            amount = mod(amount, coin)\n        end do\n    end function nr_change_coins\n"}, {"instruction": "Create a Fortran function named getvarbymode to retrieve a value based on a specified mode. The function takes 3 input arguments of type integer: mode, num, and mem (an array). It returns a single output argument of type integer. If the mode is 1, the output is the value of num; otherwise, it retrieves the value from the mem array using the index num + 1.", "input": "", "output": "  function getvarbymode(mem, mode, num) result(r)\n    integer, intent(in) :: mode, num\n    integer :: r\n    integer, dimension(:), intent(in) :: mem\n    if(mode == 1) then\n        r = num\n    else\n        r = mem(num + 1)\n    end if\n    return\n  end function\n"}, {"instruction": "Create a Fortran function named gettriplepointpropindex that takes a single input argument of type character(len=*) and returns an integer index. The function maps the input to a specific index based on the value of the input parameter using a select case construct.", "input": "", "output": "  function gettriplepointpropindex(comid) result(index)\n    implicit none\n    character(len=*), intent(in) :: comid\n    integer :: index\n    select case (comid)\n    case(\"c1\")\n       index = 1\n    case(\"c2\")\n       index = 2\n    case(\"c3\")\n       index = 3\n    case(\"o2\")\n       index = 4\n    case(\"n2\")\n       index = 5\n    case(\"r152a\")\n       index = 6\n    case(\"h2o\")\n       index = 7\n    case(\"nc7\")\n       index = 8\n    case(\"nh3\")\n       index = 9\n    case(\"f2\")\n       index = 10\n    case(\"he\")\n       index = 11\n    case(\"r134a\")\n       index = 12\n    case default\n       index = 0\n    end select\n  end function gettriplepointpropindex\n"}, {"instruction": "Create a Fortran function named gcd that calculates the greatest common divisor (GCD) of two integer values. The function should take 2 input arguments of type integer and return 1 output argument of type integer. The input arguments should be passed using the \"intent(in)\" attribute.", "input": "", "output": "function gcd(v, t)\n  integer :: gcd\n  integer, intent(in) :: v, t\n  integer :: c, b, a\n\n  b = t\n  a = v\n  do\n     c = mod(a, b)\n     if ( c == 0) exit\n     a = b\n     b = c\n  end do\n  gcd = b ! abs(b)\nend function gcd\n"}, {"instruction": "Write a Fortran function named foo that takes a string as input and returns a modified string. The input parameter should be of type character(*) and intent(in), and the output parameter should be of type character(len=len(string)+2). If the input string contains double quotes, the function should add single quotes around the string and return the modified string.", "input": "", "output": "    function foo(string)\n    character(*), intent(in) :: string\n    character(len=len(string)+2) :: foo\n    if (index(trim(string), '\"').ne.0) then\n      foo = \"'\" // trim(string) // \"'\"\n    end if\n  end function foo\n"}, {"instruction": "Create a Fortran function named \"get_file_length\" with one input parameter of type \"character(len=*)\" to represent the file name. The output parameter, \"lines,\" is of type \"integer.\" This function is designed to determine the number of lines in a specified file by reading the file line by line until the end is reached, excluding empty lines and lines that start with '#'. Make sure to include the necessary error handling for cases where the file cannot be read.", "input": "", "output": "  function get_file_length(file) result(lines)\n    integer           :: lines\n    character(len=*)  :: file\n    integer           :: ifile,ierr,pos\n    logical           :: iofile,bool,bool1,bool2\n    character(len=256)::buffer\n    inquire(file=trim(file),exist=iofile)\n    lines=0\n    if(.not.iofile)then\n       write(*,*) 'cannot read +'//trim(file)//'. skip file_size'\n       return\n    endif\n    open(99,file=trim(file))\n    ierr=0\n    do while(ierr==0)\n       lines=lines+1\n       read(99,*,iostat=ierr)buffer\n       bool1=scan(buffer,\"#\").ne.0\n       bool2=len_trim(buffer).eq.0       \n       if(bool1 .or. bool2)lines=lines-1\n    enddo\n    lines=lines-1\n    rewind(99)\n    close(99)\n  end function get_file_length\n"}, {"instruction": "Write a Fortran function called blocks_to_matrix that takes 3 input parameters: vblocks of type complex(8) and dimension (nlat, nso, nso), nlat of type integer, and nso of type integer, and returns 1 output parameter matrix of type complex(8) and dimension (nlat*nso, nlat*nso). The function's purpose is to convert a set of blocks into a matrix. Use the imperative tone in the instructions.", "input": "", "output": "  function blocks_to_matrix(vblocks,nlat,nso) result(matrix)\n    complex(8),dimension(nlat,nso,nso)      :: vblocks\n    integer                                 :: nlat,nso\n    complex(8),dimension(nlat*nso,nlat*nso) :: matrix\n    integer                                 :: i,j,ip\n    matrix=zero\n    do ip=1,nlat\n       i = 1 + (ip-1)*nso\n       j = ip*nso\n       matrix(i:j,i:j) =  vblocks(ip,:,:)\n    enddo\n  end function blocks_to_matrix\n"}, {"instruction": "Create a Fortran function named gf_funca that takes a single real*8 input argument. The function should calculate a value using a series of algebraic operations and return a single real*8 output. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [real*8].", "input": "", "output": "function gf_funca(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\ta0,a1,a2,a3,a4\n\treal*8\t\t\t\t\t::\ta5,a6,a7,a8,a9\n\treal*8\t\t\t\t\t::\tgf_funca\n\n\tdata\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9\t\t\t&\n\t\t/\t+1.21d0,\t-13.328d0,\t+215.896d0,\t\t&\n\t\t\t-1763.96d0,\t+8418.94d0,\t-24314.21d0,\t&\n\t\t\t+42002.57d0,-41592.9d0,\t21859.0d0,\t\t&\n\t\t\t-4838.6d0\t/\n\n\tgf_funca\t=\t(a8+a9*tt)*tt\n\tgf_funca\t=\t(a7+gf_funca)*tt\n\tgf_funca\t=\t(a6+gf_funca)*tt\n\tgf_funca\t=\t(a5+gf_funca)*tt\n\tgf_funca\t=\t(a4+gf_funca)*tt\n\tgf_funca\t=\t(a3+gf_funca)*tt\n\tgf_funca\t=\t(a2+gf_funca)*tt\n\tgf_funca\t=\t(a1+gf_funca)*tt\n\tgf_funca\t=\ta0+gf_funca\n\n\treturn\nend function gf_funca\n"}, {"instruction": "Create a Fortran function named gf_funcb that takes a single real*8 input parameter. The input parameter is of type real*8. The function should return a single real*8 output parameter. The function computes a complex mathematical expression based on the input parameter.", "input": "", "output": "function gf_funcb(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tb0,b1,b2,b3,b4\n\treal*8\t\t\t\t\t::\tb5,b6,b7,b8,b9\n\treal*8\t\t\t\t\t::\tgf_funcb\n\n\tdata\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9\t\t\t&\n\t\t/\t+0.938d0,\t+5.373d0,\t-67.92d0,\t\t&\n\t\t\t+796.534d0,\t-4780.77d0,\t+17137.74d0,\t&\n\t\t\t-36618.81d0,+44894.06d0,-29030.24d0,\t&\n\t\t\t+7671.22d0\t/\n\n\tgf_funcb\t=\t(b8+b9*tt)*tt\n\tgf_funcb\t=\t(b7+gf_funcb)*tt\n\tgf_funcb\t=\t(b6+gf_funcb)*tt\n\tgf_funcb\t=\t(b5+gf_funcb)*tt\n\tgf_funcb\t=\t(b4+gf_funcb)*tt\n\tgf_funcb\t=\t(b3+gf_funcb)*tt\n\tgf_funcb\t=\t(b2+gf_funcb)*tt\n\tgf_funcb\t=\t(b1+gf_funcb)*tt\n\tgf_funcb\t=\tb0+gf_funcb\n\n\treturn\nend function gf_funcb\n"}, {"instruction": "Write a Fortran function named gf_funcc to calculate a specific mathematical function based on the given input value. The input argument is of type real*8. The function returns a result of type real*8.", "input": "", "output": "function gf_funcc(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tc0,c1,c2,c3,c4\n\treal*8\t\t\t\t\t::\tc5,c6,c7\n\treal*8\t\t\t\t\t::\tgf_funcc\n\n\tdata\tc0,c1,c2,c3,c4,c5,c6,c7\t\t\t\t\t&\n\t\t/\t+1.268d0,\t-9.747d0,\t+209.653d0,\t\t&\n\t\t\t-1397.89d0,\t+5155.67d0,\t-9844.35d0,\t\t&\n\t\t\t+9136.4d0,\t-3272.62d0\t\t/\n\n\tgf_funcc\t=\t(c6+c7*tt)*tt\n\tgf_funcc\t=\t(c5+gf_funcc)*tt\n\tgf_funcc\t=\t(c4+gf_funcc)*tt\n\tgf_funcc\t=\t(c3+gf_funcc)*tt\n\tgf_funcc\t=\t(c2+gf_funcc)*tt\n\tgf_funcc\t=\t(c1+gf_funcc)*tt\n\tgf_funcc\t=\tc0+gf_funcc\n\n\treturn\nend function gf_funcc\n"}, {"instruction": "Write a Fortran function named gf_funcd that takes a real*8 input parameter tt and returns a real*8 output parameter.", "input": "", "output": "function gf_funcd(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\td0,d1,d2,d3,d4\n\treal*8\t\t\t\t\t::\td5,d6,d7,d8,d9\n\treal*8\t\t\t\t\t::\tgf_funcd\n\t\t\t\n\tdata\td0,d1,d2,d3,d4,d5,d6,d7,d8,d9\t\t\t&\n\t\t/\t+0.632d0,\t-40.97d0,\t+667.16d0,\t\t&\n\t\t\t-6072.07d0,\t+31127.39d0,-96293.05d0,\t&\n\t\t\t+181856.75d0,\t\t\t-205690.43d0,\t&\n\t\t\t+128170.2d0,-33744.6d0\t/\n    \n\tgf_funcd\t=\t(d8+d9*tt)*tt\n\tgf_funcd\t=\t(d7+gf_funcd)*tt\n\tgf_funcd\t=\t(d6+gf_funcd)*tt\n\tgf_funcd\t=\t(d5+gf_funcd)*tt\n\tgf_funcd\t=\t(d4+gf_funcd)*tt\n\tgf_funcd\t=\t(d3+gf_funcd)*tt\n\tgf_funcd\t=\t(d2+gf_funcd)*tt\n\tgf_funcd\t=\t(d1+gf_funcd)*tt\n\tgf_funcd\t=\td0+gf_funcd\n\n\treturn\nend function gf_funcd\n"}, {"instruction": "Create a Fortran function named gf_dfunca that takes a single real*8 input parameter and returns a real*8 output. The function computes a polynomial expression using the input parameter and pre-defined coefficients, and then returns the result.", "input": "", "output": "function gf_dfunca(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\ta0,a1,a2,a3,a4\n\treal*8\t\t\t\t\t::\ta5,a6,a7,a8,a9\n\treal*8\t\t\t\t\t::\tgf_dfunca\n\t\t\t\n\tdata\ta0,a1,a2,a3,a4,a5,a6,a7,a8,a9\t\t\t&\n\t\t/\t+2.948d0,\t-24.53d0,\t+249.69d0,\t\t&\n\t\t\t-754.85d0,\t-1187.71d0,\t+16370.75d0,\t&\n\t\t\t-48811.41d0,+68220.87d0,-46688.0d0,\t\t&\n\t\t\t+12622.25d0\t/\n\n\tgf_dfunca\t=\t(a8+a9*tt)*tt\n\tgf_dfunca\t=\t(a7+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a6+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a5+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a4+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a3+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a2+gf_dfunca)*tt\n\tgf_dfunca\t=\t(a1+gf_dfunca)*tt\n\tgf_dfunca\t=\ta0+gf_dfunca\n\n\treturn\nend function gf_dfunca\n"}, {"instruction": "Provide a Fortran function named gf_dfuncb that takes one 64-bit real number as input. The function calculates a value using a series of mathematical operations. The number of input arguments is 1 and the test_data type is ['real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function gf_dfuncb(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tb0,b1,b2,b3,b4\n\treal*8\t\t\t\t\t::\tb5,b6,b7,b8,b9\n\treal*8\t\t\t\t\t::\tgf_dfuncb\n\t\t\t\n\tdata\tb0,b1,b2,b3,b4,b5,b6,b7,b8,b9\t\t\t&\n\t\t/\t+1.11d0,\t+2.894d0,\t-76.765d0,\t\t&\n\t\t\t+1565.35d0,\t-11336.19d0,+44270.15d0,\t&\n\t\t\t-97014.11d0,+118879.26d0,-76209.82d0,\t&\n\t\t\t+19923.28d0\t/\n    \n\tgf_dfuncb\t=\t(b8+b9*tt)*tt\n\tgf_dfuncb\t=\t(b7+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b6+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b5+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b4+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b3+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b2+gf_dfuncb)*tt\n\tgf_dfuncb\t=\t(b1+gf_dfuncb)*tt\n\tgf_dfuncb\t=\tb0+gf_dfuncb\n\n\treturn\nend function gf_dfuncb\n"}, {"instruction": "Create a Fortran function named gf_dfuncc to calculate a specific mathematical function. The function takes 1 input parameter of type real*8. The output is also a real*8 value. Use the imperative tone to define the function and specify the input and output parameters.", "input": "", "output": "function gf_dfuncc(tt)\n\n\timplicit none\n\n! --- variables -------------------------------------------\n\treal*8,intent(in)\t\t::\ttt\n\n! --- local variables -------------------------------------\n\treal*8\t\t\t\t\t::\tc0,c1,c2,c3,c4,c5\n\treal*8\t\t\t\t\t::\tgf_dfuncc\n\t\t\t\n\tdata\tc0,c1,c2,c3,c4,c5\t\t\t\t\t\t&\n\t\t/\t+14.19d0,\t-148.24d0,\t+847.8d0,\t\t&\n\t\t\t-2318.58d0,\t+3168.35d0,\t-1590.27d0\t\t/\n    \n\tgf_dfuncc\t=\t(c4+c5*tt)*tt\n\tgf_dfuncc\t=\t(c3+gf_dfuncc)*tt\n\tgf_dfuncc\t=\t(c2+gf_dfuncc)*tt\n\tgf_dfuncc\t=\t(c1+gf_dfuncc)*tt\n\tgf_dfuncc\t=\tc0+gf_dfuncc\n\n\treturn\nend function gf_dfuncc\n"}, {"instruction": "Create a Fortran function named \"pythag\" that takes two real(8) input parameters and returns a real(8) output. This function calculates the hypotenuse of a right-angled triangle using the input parameters as the lengths of the two shorter sides.", "input": "", "output": "  function pythag ( a, b )\n    implicit none\n    real(8) :: a\n    real(8) :: b\n    real(8) :: p\n    real(8) :: pythag\n    real(8) :: r\n    real(8) :: s\n    real(8) :: t\n    real(8) :: u\n    p = max ( abs ( a ), abs ( b ) )\n    if ( p /= 0.0d+00 ) then\n       r = ( min ( abs ( a ), abs ( b ) ) / p )**2\n       do\n          t = 4.0d+00 + r\n          if ( t == 4.0d+00 ) then\n             exit\n          end if\n          s = r / t\n          u = 1.0d+00 + 2.0d+00 * s\n          p = u * p\n          r = ( s / u )**2 * r\n       end do\n    end if\n    pythag = p\n    return\n  end function pythag\n"}, {"instruction": "Create a Fortran function named fibonacciiterate to calculate the Fibonacci number at a specific position using an iterative approach. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "    function fibonacciiterate(position) result(fibonacci)\r\n        integer, intent(in) :: position\r\n        integer :: fibonacci\r\n\r\n        integer, dimension(10), save :: buffer\r\n        integer, save                :: index  = 3\r\n        buffer(1) = 1\r\n        buffer(2) = 1\r\n\r\n        if (buffer(position) == 0) then\r\n            do index = index, position\r\n                buffer(index) = buffer(index - 1) + buffer(index - 2)\r\n            end do\r\n        end if\r\n\r\n        fibonacci = buffer(position)\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named get_grid_dims to retrieve the grid dimensions from the environment variable 'gocean_omp_grid'. The function takes 2 input arguments of type integer and returns a logical output. The input parameters should be of type ['integer', 'integer'], and the output parameter should be of type ['logical'].", "input": "", "output": "  function get_grid_dims(nx, ny) result(success)\n    implicit none\n    integer, intent(inout) :: nx, ny\n    logical :: success\n    character(len=20) :: lstr\n    integer :: idx, ierr\n\n    success = .false.\n\n    call get_environment_variable(name='gocean_omp_grid', value=lstr, &\n                                  status=ierr)\n\n    if(ierr /= 0)return\n\n    ! we expect the string to have the format 'axb' where a and b are\n    ! integers.\n    idx = index(lstr, 'x')\n    if(idx == 0)then\n       write (*,\"(/'shallow_omp_mod::get_grid_dims: failed to parse ' &\n                 &  'gocean_omp_grid string: ',(a))\") trim(lstr)\n       write (*,\"('   -  will use defaults for dimensions of tiling grid')\")\n       return\n    endif\n\n    read(lstr(1:idx-1),*,iostat=ierr) nx\n    if(ierr /= 0)return\n\n    read(lstr(idx+1:),*,iostat=ierr) ny\n    if(ierr == 0)success = .true.\n\n  end function get_grid_dims\n"}, {"instruction": "Create a Fortran function named is_palindrome to determine whether a given phrase is a palindrome. The function should have 1 input parameter of type character(len=*) and 1 output parameter of type logical. The input parameter represents the phrase to be checked. The output parameter will be true if the phrase is a palindrome, and false otherwise.", "input": "", "output": "    function is_palindrome(phrase) result(palindrome)\n        implicit none\n        character(len=*), intent(in) :: phrase\n        logical :: palindrome\n        integer :: i, n\n\n        n = len_trim(phrase)\n        palindrome = .true.\n        do i = 1, n/2\n            if (phrase(i:i) /= phrase(n-i+1:n-i+1)) then\n                palindrome = .false.\n                exit\n            end if\n        end do\n    end function is_palindrome\n"}, {"instruction": "Create a Fortran function named c_connect with 8 input parameters and 1 output parameter. The input parameters are of the types type(c_ptr), character(c_char) arrays, integer(c_int), and type(c_ptr). The output parameter is of the type type(c_ptr). This function is bound to the C function \"mysql_real_connect\" and is used for connecting to a MySQL database using the provided connection details.", "input": "", "output": "    function c_connect (mysql, host, user, pwd, db, port, socket, flags) &\n    bind(c, name='mysql_real_connect')\n      use iso_c_binding\n      implicit none\n      type(c_ptr) :: c_connect\n      type(c_ptr), value :: mysql\n      character(c_char), dimension(*) :: host, user, pwd, db\n      integer(c_int), value :: port\n      type(c_ptr), value :: socket\n      integer(c_int), value :: flags\n    end function c_connect\n"}, {"instruction": "Create a Fortran function named c_init_mysql, which will initialize a MySQL data structure. The function should take 1 input parameter of type c_ptr with value attribute, and it should return 1 output parameter of type c_ptr. The function should be declared with the bind attribute \"bind(c, name='mysql_init')\" and should specify the calling convention using attributes stdcall for both gcc and dec compilers.", "input": "", "output": "    function c_init_mysql (mysql) &\n    bind(c, name='mysql_init')\n      use iso_c_binding\n      implicit none\n      type(c_ptr) :: c_init_mysql\n      type(c_ptr), value :: mysql\n      !gcc$ attributes stdcall:: c_init_mysql\n      !dec$ attributes stdcall:: mysql_init\n    end function c_init_mysql\n"}, {"instruction": "Create a Fortran function named c_fetch_row, which binds to the C function mysql_fetch_row. The function takes 1 input parameter of type c_ptr with the attribute value. It returns 1 output parameter of type c_ptr.", "input": "", "output": "    function c_fetch_row (res) &\n    bind(c, name='mysql_fetch_row')\n      use iso_c_binding\n      implicit none\n      type(c_ptr), value :: res\n      type(c_ptr) :: c_fetch_row\n    end function c_fetch_row\n"}, {"instruction": "Create a Fortran function named adjustc that centers a text string within a specified length. The function takes 2 input parameters: a character string and an optional integer specifying the length of the centered text. The output is a dynamically allocated character string of the specified length.", "input": "", "output": "pure function adjustc(string,length)\n\n!character(len=*),parameter::ident_32=\"@(#)m_strings::adjustc(3f): center text\"\n\n!>\n!! procedure   adjustc(3f)\n!! description center text using implicit or explicit length\n!!##version     2.0, 20160711\n!! author      john s. urban\n!===================================================================================================================================\n!-----------------------------------------------------------------------------------------------------------------------------------\ncharacter(len=*),intent(in)  :: string         ! input string to trim and center\ninteger,intent(in),optional  :: length         ! line length to center text in\ncharacter(len=:),allocatable :: adjustc        ! output string\ninteger                      :: inlen\ninteger                      :: ileft          ! left edge of string if it is centered\n!-----------------------------------------------------------------------------------------------------------------------------------\n   if(present(length))then                     ! optional length\n      inlen=length                             ! length will be requested length\n      if(inlen.le.0)then                       ! bad input length\n         inlen=len(string)                     ! could not use input value, fall back to length of input string\n      endif\n   else                                        ! output length was not explicitly specified, use input string length\n      inlen=len(string)\n   endif\n   allocate(character(len=inlen):: adjustc)    ! create output at requested length\n   adjustc(1:inlen)=' '                        ! initialize output string to all blanks\n!-----------------------------------------------------------------------------------------------------------------------------------\n   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it\n   if(ileft.gt.0)then                          ! if string will fit centered in output\n      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string\n   else                                        ! input string will not fit centered in output string\n      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can\n   endif\nend function adjustc\n"}, {"instruction": "Create a Fortran function named expint_1 that calculates the exponential integral function. It takes 2 input parameters of type integer and real(8), and returns 1 output parameter of type real(8). Ensure the input integer parameter is non-negative and the real parameter is non-negative if the integer parameter is greater than 1. The function implements the exponential integral function using a combination of continued fraction and series methods.", "input": "", "output": "  function expint_1(n,x) result(expint)\n    implicit none\n    integer,intent(in) :: n\n    real(8),intent(in) :: x\n    real(8) :: expint\n    integer,parameter :: maxit=200\n    real(8),parameter :: esp=1.d-12, big=huge(x)*esp\n    real(8),parameter :: euler=0.577215664901532860606512d0\n    integer :: i,nm1,j\n    real(8) :: a,b,c,d,del,fact,h,arsum\n \n    if ( .not.(n>=0.and.x>=0.d0.and.(x>0.d0.or.n>1)) ) then\n       write(*,*) 'bad arguments in expint.f'\n       stop\n    end if\n \n    if ( n==0 ) then\n       expint=exp(-x)/x\n       return\n    end if\n    nm1=n-1\n    if ( x==0.d0 ) then\n       expint=1.d0/nm1\n    else if ( x>1.d0 ) then\n       b=x+n\n       c=big\n       d=1.d0/b\n       h=d\n       do i=1,maxit\n          a=-i*(nm1+i)\n          b=b+2.d0\n          d=1.d0/(a*d+b)\n          c=b+a/c\n          del=c*d\n          h=h*del\n          if ( abs(del-1.d0)<=esp ) exit\n       end do\n       if ( i>maxit ) then\n          write(*,*) 'continued fraction failed in expint.f'\n          stop\n       end if\n       expint=h*exp(-x)\n    else\n       if ( nm1/=0 ) then\n          expint=1.d0/nm1\n       else\n          expint=-log(x)-euler\n       end if\n       fact=1.d0\n       do i=1,maxit\n          fact=-fact*x/i\n          if ( i/=nm1 ) then\n             del=-fact/(i-nm1)\n          else\n             arsum = 0.d0\n             do j=1,nm1\n                arsum = arsum + 1.d0/j\n             end do\n             del = fact*(-log(x)-euler+arsum)\n          end if\n          expint=expint+del\n          if ( abs(del)<abs(expint)*esp ) exit\n       end do\n       if ( i>maxit ) then\n          write(*,*) 'series failed in expint.f'\n          stop\n       end if\n    end if\n\n  end function expint_1\n"}, {"instruction": "Create a Fortran function named det to compute the determinant or permanent of a square matrix. The function takes 3 input parameters: a real matrix of dimension n x n, an integer n, and an integer permanent. The output is a real value. The input parameter \"permanent\" determines whether the function computes the determinant (set to -1) or the permanent (set to 1).", "input": "", "output": "  recursive function det(a,n,permanent) result(accumulation)\n    ! setting permanent to 1 computes the permanent.\n    ! setting permanent to -1 computes the determinant.\n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n"}, {"instruction": "Write a Fortran function named grayencode that takes an integer as input and returns the Gray code equivalent. The function should have 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "  function grayencode(i)\n    implicit none\n    ! passed variables\n    integer, intent(in) :: i\n    ! return value\n    integer :: grayencode\n    grayencode = ieor(i, ishft(i,-1))\n  end function grayencode\n"}, {"instruction": "Write a Fortran function named graydecode that takes an integer as input and returns another integer as output. The function should decode a Gray code to its binary equivalent. The input parameter should be of type integer and intent(in), while the output parameter should also be of type integer.", "input": "", "output": "  function graydecode(gn)\n    implicit none\n    ! passed variables\n    integer, intent(in) :: gn\n    ! return value\n    integer :: graydecode\n    ! local variables\n    integer :: bn, ii\n    bn = gn\n    ii = 1\n    do while (ishft(gn, -ii) > 0)\n       bn = ieor(bn, ishft(gn, -ii))\n       ii = ii + 1\n    end do\n    graydecode = bn\n  end function graydecode\n"}, {"instruction": "Create a Fortran function named \"minlen\" to calculate the minimum length of a number when expressed in a given base. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters are \"n\" and \"base,\" and the output parameter is \"minlen.\"", "input": "", "output": "  function minlen(n, base)\n    implicit none\n    ! passed parameters\n    integer, intent(in) :: n, base\n    ! returned value\n    integer :: minlen\n    ! local variable\n    integer :: num\n    num = n\n    minlen = 1\n    do while (num >= base)\n       num = num / base\n       minlen = minlen + 1\n    end do\n  end function minlen\n"}, {"instruction": "Create a Fortran function named evaluatefirst to process the input string and integer, and return a real number. The function accepts 2 input parameters with test_data types ['character(len =*)', 'integer,optional'], and returns 1 output parameter with test_data type ['real'].", "input": "", "output": "        function evaluatefirst(s,n)result(number)\n          implicit none\n          character(len =*), intent(inout) :: s\n          integer,optional                 :: n\n          real                             :: number\n          number = 1.1\n        end function\n"}, {"instruction": "Write a Fortran function named sum_string to calculate the sum of ASCII values of all characters in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "  elemental function sum_string(str) result(sig)\n    character(len=*), intent(in)   :: str\n    integer                        :: sig\n    character, dimension(len(str)) :: tmp\n    integer :: i\n\n    forall (i=1:len(str))\n       tmp(i) = str(i:i)\n    end forall\n    sig = sum(ichar(tmp))\n  end function sum_string\n"}, {"instruction": "Create a Fortran function called distance that calculates the distance between two points in a 2D plane. The function takes 4 input arguments of type real (ax, ay, bx, by) and returns 1 output argument of type real.", "input": "", "output": "function distance(ax, ay, bx, by)\n    implicit none\n    real :: ax\n    real :: ay\n    real :: bx\n    real :: by\n    real :: distance\n    distance = ((bx - ax) ** 2 + (by - ay) ** 2) ** 0.5\n    return\nend function\n"}, {"instruction": "Create a Fortran function named get_lower_case to convert a given character string to lowercase. The function takes 2 input parameters: an integer representing the character string length and a character string to convert. The output is a character string of the same length as the input.", "input": "", "output": "  function get_lower_case(length,inputstr) result (lowcasestring)\r\n    \r\n    !argument declarations\r\n    integer, intent(in) :: length  !<character string length\r\n    character(len=length), intent(in) :: inputstr  !<character string to convert\r\n    character(len=length) :: lowcasestring  !<lower case string\r\n    \r\n    !local variables\r\n    integer i\r\n\r\n    lowcasestring = inputstr\r\n    do i=1,length\r\n      if(ichar(lowcasestring(i:i)).ge.65 .and. ichar(lowcasestring(i:i)).le.90)then\r\n        lowcasestring(i:i)=char(ichar(lowcasestring(i:i))+32)\r\n      endif\r\n    enddo\r\n    \r\n  end function get_lower_case\r\n"}, {"instruction": "Create a Fortran function named trim to remove trailing spaces from a character string. The function should have 1 input parameter of type character(len=*), and 1 output parameter of type character(len=len_trim(x)).", "input": "", "output": "function trim(x) result(r)\ncharacter(len=*),intent(in) :: x\ncharacter(len=len_trim(x)) :: r\n! this does not work yet in lfortran:\n!r = x(1:len(r))\n! so we do this workaroud that works:\ninteger :: i\ndo i = 1, len(r)\n    r(i:i) = x(i:i)\nend do\nend function\n"}, {"instruction": "Create a Fortran function named unique to return only the unique values from the input integer array. The function should have 1 input parameter of type integer array and intent(in), and 1 output parameter of type integer array with allocatable dimension.", "input": "", "output": "function unique(vec) result(vec_unique)\n! return only the unique values from vec.\n\nimplicit none\n\ninteger,dimension(:),intent(in) :: vec\ninteger,dimension(:),allocatable :: vec_unique\n\ninteger :: i,num\nlogical,dimension(size(vec)) :: mask\n\nmask = .false.\n\ndo i=1,size(vec)\n\n    !count the number of occurrences of this element:\n    num = count( vec(i)==vec )\n\n    if (num==1) then\n        !there is only one, flag it:\n        mask(i) = .true.\n    else\n        !flag this value only if it hasn't already been flagged:\n        if (.not. any(vec(i)==vec .and. mask) ) mask(i) = .true.\n    end if\n\nend do\n\n!return only flagged elements:\nallocate( vec_unique(count(mask)) )\nvec_unique = pack( vec, mask )\n\n!if you also need it sorted, then do so.\n! for example, with slatec routine:\n!call isort (vec_unique, [0], size(vec_unique), 1)\n\nend function unique\n"}, {"instruction": "Create a Fortran function named f to determine the value of a real number based on the input integer value. The function takes 1 input parameter of type integer and returns 1 output parameter of type real. The input test_data type is ['integer'], and the output test_data type is ['real'].", "input": "", "output": "function f(n)\n  integer, intent(in) :: n\n  real                :: f\n\n  select case (n)\n    case (:-1); f = -1.0\n    case (0);   f =  0.0\n    case (1:);  f =  1.0\n  end select\nend function\n"}, {"instruction": "Create a Fortran function named pder to estimate pressure derivatives. It takes 2 input parameters of type real, dimension(:,:,:), and real. It returns 1 output parameter of type real, dimension(:,:,:), allocatable. The function uses one-sided derivatives at the top and bottom levels with second and fourth-order accuracy.", "input": "", "output": "  function pder(f,dp) result (dfdp)\n    !   estimation of pressure derivatives.\n    !   one-sided derivatives are used at top and bottom levels\n    !   accuracy=1 means second-order accuracy\n    !   accuracy=2 fourth-order accuracy\n    implicit none\n\n    real,dimension(:,:,:),intent(in) :: f\n    real,                 intent(in) :: dp\n    real,dimension(:,:,:),allocatable :: dfdp\n    real :: inv_dp\n    integer :: nlon,nlat,nlev,accuracy,k\n\n    nlon=size(f,1); nlat=size(f,2); nlev=size(f,3)\n    allocate(dfdp(nlon,nlat,nlev))\n    inv_dp = 1.0 / (2.*dp)\n    accuracy=1\n    select case (accuracy)\n\n    case(1)\n       dfdp(:,:,2:nlev-1)=f(:,:,3:nlev)-f(:,:,1:nlev-2)\n       dfdp(:,:,2:nlev-1)=dfdp(:,:,2:nlev-1)*inv_dp\n\n       dfdp(:,:,1)=(f(:,:,2)-f(:,:,1))/dp\n       dfdp(:,:,nlev)=(f(:,:,nlev)-f(:,:,nlev-1))/dp\n    case(2)\n       do k=3,nlev-2\n          dfdp(:,:,k)=f(:,:,k-2)-8.*f(:,:,k-1)+8.*f(:,:,k+1) &\n               -f(:,:,k+2)\n          dfdp(:,:,k)=dfdp(:,:,k)/(12.*dp)\n       enddo\n       dfdp(:,:,2)=(dfdp(:,:,3)-dfdp(:,:,1))/(2.*dp)\n       dfdp(:,:,nlev-1)=(dfdp(:,:,nlev)-dfdp(:,:,nlev-2))/(2.*dp)\n       dfdp(:,:,1)=(f(:,:,2)-f(:,:,1))/dp\n       dfdp(:,:,nlev)=(f(:,:,nlev)-f(:,:,nlev-1))/dp\n\n    end select\n\n  end function pder\n"}, {"instruction": "Create a Fortran function named factorial to compute the factorial of an integer input. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Ensure the function checks for errors when the input is less than 0 or greater than 12.", "input": "", "output": "  recursive function factorial(i) result(fac)\n    implicit none\n    integer::fac\n    integer,intent(in)::i\n    integer::init=0,j\n    logical,dimension(12)::lfacsave\n    integer,dimension(12)::facsave\n    save facsave,init,lfacsave\n    if(init.eq.0)then\n       lfacsave(1:12)=.false.\n       init=1\n    endif\n    if(i.lt.0)then\n       write(*,*)\"error: i<0 in factorial with i=\",i\n       stop\n    endif\n    if(i.gt.12)then\n       write(*,*)\"error: i > 12, please take long type (kind=lint) integer\"\n       stop\n    endif\n    if(i.eq.0)then\n       fac=1\n    else\n       if(lfacsave(i))then\n          fac=facsave(i)\n       else\n          fac=i*factorial(i-1)\n          facsave(i)=fac\n          lfacsave(i)=.true.\n       endif\n    endif\n  end function factorial\n"}, {"instruction": "Create a Fortran function named number_coefs_for_rank to calculate the total number of coefficients for a given rank. The function takes 1 input argument of type integer. The output is also of type integer.", "input": "", "output": "  function number_coefs_for_rank(rank) result(res)\n    implicit none\n    integer,intent(in)::rank\n    integer::res,i\n    if(rank.lt.0)res=0\n    res=0\n    do i=0,rank\n       res=res+((3+i)*(2+i)*(1+i))/6\n    enddo\n    return\n  end function number_coefs_for_rank\n"}, {"instruction": "Create a Fortran function named mirror_about_plane that takes a 3D vector and an integer representing a plane index as input. The function returns a 3D vector that is the mirror image of the input vector about the specified plane. The number of input arguments is 2 and the test_data type is ['real,dimension(3)', 'integer']. The number of output arguments is 1 and the test_data type is ['real,dimension(3)'].", "input": "", "output": "    function mirror_about_plane(vec, plane) result(mirrored_vec)\n        ! returns a version of the given vector mirrored about the given plane\n        ! the plane number is the component index which is normal to the plane (i.e. 1: yz plane, etc.)\n\n        implicit none\n\n        real,dimension(3),intent(in) :: vec\n        integer,intent(in) :: plane\n        real,dimension(3) :: mirrored_vec\n\n        mirrored_vec = vec\n        mirrored_vec(plane) = -vec(plane)\n        \n    end function mirror_about_plane\n"}, {"instruction": "Create a Fortran function named smt_get that takes an array of characters as input and returns a character array of the same size. The input parameter should be of type character and have a dimension of (:), while the output parameter should be of type character with a size equal to the input array. Use a do loop to populate the output array with the elements of the input array, and return the result.", "input": "", "output": "     function smt_get( array )\n\n!  dummy arguments\n\n     character, dimension( : ) :: array\n     character( size( array ) ) :: smt_get\n\n!  local variables\n\n     integer :: i\n\n     do i = 1, size( array )\n        smt_get( i : i ) = array( i )\n     end do\n\n     return\n\n\n     end function smt_get\n"}, {"instruction": "Create a Fortran function named compute_pi to calculate an approximate value of pi using the Leibniz formula. The function takes 1 input parameter of type integer. The output is a real*8 value.", "input": "", "output": "function compute_pi(segments)\n  implicit none\n\n  integer, intent(in) :: segments\n  real*8 :: compute_pi\n\n  real*8 :: polygon_edge_length_squared\n  integer :: polygon_sides\n  integer :: i\n\n  polygon_edge_length_squared = 2.0\n  polygon_sides = 2\n  do i = 1, segments\n    polygon_edge_length_squared = -sqrt(1 - polygon_edge_length_squared / 4) * 2 + 2\n    polygon_sides = polygon_sides * 2\n  end do\n  compute_pi = sqrt(polygon_edge_length_squared) * polygon_sides\n  return\nend function\n"}, {"instruction": "Create a Fortran function named fl5_qe1 to calculate the result of a mathematical function. The function takes 1 input argument of type double precision and returns 1 output argument of type double precision. The function computes the result using the formula y = x ** 3 + dexp(-x).", "input": "", "output": "    function fl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** 3 + dexp(-x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named dfl5_qe1 to calculate the value of a quadratic equation, Y = 3 * X^2 - dexp(-X). The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "    function dfl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 3 * x ** 2 - dexp(-x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function called \"fl5_qe2\" that takes a double precision input parameter and returns a double precision output parameter. The function computes the result by raising the input to the power of 1/3 and adding the natural logarithm of the input.", "input": "", "output": "    function fl5_qe2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** (1.0d0/3.0d0) + dlog(x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function called dfl5_qe2 to compute the value of a mathematical expression. The function takes 1 input parameter of type double precision. The output is also a double precision value. The function computes the expression 1 / (3 * x ** (2.0d0/3.0d0)) + (1 / x) and returns the result.", "input": "", "output": "    function dfl5_qe2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 1 / (3 * x ** (2.0d0/3.0d0)) + (1 / x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named fl5_qe3 that takes a double precision input argument and returns a double precision output. The function computes the value of y using the formula y = 1 - dexp(-(x ** 2) / 25).", "input": "", "output": "    function fl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 1 - dexp(-(x ** 2) / 25)\r\n        return\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named dfl5_qe3 that takes a double precision input parameter and returns a double precision result. The function computes the value of y using the formula y = (2 * x) / (25 * dexp((x ** 2) / 25)).", "input": "", "output": "    function dfl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = (2 * x) / (25 * dexp((x ** 2) / 25))\r\n        return\r\n    end function\r\n"}, {"instruction": "Write a Fortran function named f2 that takes a double precision input argument and returns a double precision output. The function computes the value of 4 times the cosine of the input minus the exponential function raised to the power of 2 times the input. The number of input arguments is 1 and the test_data type is ['double precision'], and the number of output arguments is 1 with the test_data type ['double precision']. Use the \"return\" statement to return the result.", "input": "", "output": "    function f2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 4 * dcos(x) - dexp(2 * x)\r\n        return\r\n    end function\r\n"}, {"instruction": "Write a Fortran elemental function named last_character_c to return the last character of the input string. The number of input arguments is 1 of type character(len=*), and the number of output arguments is 1 of type character(len=1).", "input": "", "output": "    elemental function last_character_c(string) result(char_)\n        character(len=*), intent(in) :: string\n        character(len=1) :: char_\n\n        integer :: length\n\n        length = len(string)\n        char_ = string(length:length)\n    end function\n"}, {"instruction": "Create a Fortran function named \"ring\" that calculates the sum of a sequence of numbers in a ring pattern. The function should take 2 input parameters of type integer and return 1 output parameter of type integer. The input parameters should be named \"start\" and \"k,\" and the output parameter should be named \"ring.\"", "input": "", "output": "  pure function ring(start,k)\n    implicit none\n    integer, intent(in) :: start,k\n    integer             :: i,j\n    integer             :: ring\n\n    j=0\n    ring=0\n    do i=start+k+k+(k-2)+(k-2)-1,start,-1\n       if (mod(j,k-1) == 0) then\n          ring=ring+i\n       end if\n       j=j+1\n    end do\n  end function ring\n"}, {"instruction": "Create a Fortran function named to_string that takes two integer input parameters and returns a character string of specified length. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [character(len=length)].", "input": "", "output": "    function to_string(int, length) result(str)\n        integer, intent(in) :: int\n        integer, intent(in) :: length\n        character(len=length) :: str\n        character(len=13) :: fmt\n        write(fmt, \"(a,i10,a)\") \"(i\", length, \")\"\n        write(str, fmt) int\n        return\n    end function to_string\n"}, {"instruction": "Create a Fortran function named get_unit that assigns an unused I/O unit number to the variable get_unit. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used for dummy purposes and the output argument stores the assigned I/O unit number.", "input": "", "output": "function get_unit(dummy)\n  integer :: get_unit,dummy\n\n  integer :: u\n  logical :: used\n\n  do u=7,99\n    inquire(unit=u,opened=used)\n    if(.not.used)then\n      exit\n    endif\n  enddo\n\n  get_unit=u\n\nend function get_unit\n"}, {"instruction": "Create a Fortran function named djscaled to calculate the scaled value of a given real*8 input parameter. The number of input arguments is 1 with a test_data type of ['real*8'], and the number of output arguments is 1 with a test_data type of ['real*8'].", "input": "", "output": "function djscaled(xval)\n  implicit none\n  real*8 :: djscaled,xval,pixval\n  real*8, parameter :: pi = 3.14159265358979323844d0 !!temp\n\n  if (xval.lt.0d0.or.xval.gt.1d0) then\n     print *, \"scalederr f\",xval; stop\n  endif\n  pixval=pi*xval\n  djscaled = 0.75d0 * pi * sin(pixval)**3 \n\nend function djscaled\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor of two integers.The number of input arguments is 2 and the test_data type is [integer, integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n"}, {"instruction": "Create a Fortran function named tridiag_solve that solves a tridiagonal linear system of equations. The function should have 5 input parameters of types integer, real array of dimension n, real, real, and real, and 1 output parameter of type real array of dimension n. The function should calculate the solution for the tridiagonal system and store the result in the output array.", "input": "", "output": "function tridiag_solve(l, d, r, b, n)\n    implicit none\n    integer, intent(in) :: n\n    ! input array\n    real,  dimension(n), intent(in) :: b\n    real, intent(in) :: l, d, r\n    ! return value will be stored in this array\n    real, dimension(n) :: tridiag_solve\n\n    real,  dimension(n) :: bhat, rhat\n    integer :: i\n\n    rhat(1) = r / d\n    bhat(1) = b(1) / d\n    do i=2,n\n        rhat(i) = r / (d - l * rhat(i - 1))\n        bhat(i) = (b(i) - l * bhat(i-1)) / (d - l * rhat(i-1))\n    enddo\n\n    ! compute the solution, starting from n, then n-1, n-2, ...\n    tridiag_solve(n) = bhat(n)\n    do i=1,n-1\n        tridiag_solve(n - i) = bhat(n - i) - rhat(n - i) * tridiag_solve(n - i + 1)\n    end do\n\nend function\n"}, {"instruction": "Create a Fortran function named int2str to convert an integer to a string. The function takes 3 input parameters: n (integer), nc (integer), myform (character string). It returns a single output parameter int2str (character string) of length nc. Use the imperative tone when providing the instruction for this function.", "input": "", "output": "  function int2str(n,nc,myform)\r\n    implicit none\r\n    integer :: n,nc\r\n    character(len=nc)::int2str\r\n    character(len=*)::myform\r\n    write(int2str,myform)n\r\n  end function int2str\r\n"}, {"instruction": "Create a Fortran function named func0 that takes an integer input argument and returns a double precision result. The function computes the value of 2 times the input integer plus 2, and assigns the result to the function name. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "  function func0(i)\n    implicit none\n    double precision :: func0\n    integer, intent(in) :: i\n    func0 = dble(2*(i+1))\n  end function func0\n"}, {"instruction": "Create a Fortran function named inc_cptr that accepts a pointer of type c_ptr and an offset in bytes as input arguments. The number of input arguments is 2 and the test_data type is ['type(c_ptr),value', 'integer(c_size_t),value']. The function returns a new pointer of type c_ptr as the output. The number of output arguments is 1 and the test_data type is ['type(c_ptr)'].", "input": "", "output": "    function inc_cptr(ptr,offset_bytes) bind(c,name=\"inc_cptr\")\n      use iso_c_binding\n      implicit none\n      type(c_ptr),intent(in),value :: ptr\n      integer(c_size_t),value      :: offset_bytes\n      !\n      type(c_ptr) :: inc_cptr\n    end function\n"}, {"instruction": "Create a Fortran function called myiter to calculate the iteration for the Poisson solver. The function takes two input parameters: a real, two-dimensional array p and a real value h. It returns a two-dimensional real array of the same size as p.", "input": "", "output": "    function myiter(p,h)\n    ! calculate the iteration for the poisson solver. note that this is exactly\n    ! the same as the laplacian, but without the final -4*u term, and\n    ! non-periodic boundaries on the left and right (it uses neumann bcs\n    ! instead)\n\n        real, dimension(:,:), intent(in) :: p\n        real, intent(in) :: h\n        real, dimension(size(p,1),size(p,2)) :: myiter\n        integer :: nnx\n\n        nnx = size(p,1)\n\n        myiter = (cshift(p,shift=+1, dim=2) &\n             +cshift(p,shift=-1,dim=2) &\n             +cshift(p,shift=+1,dim=1) &\n             +cshift(p,shift=-1,dim=1))\n        myiter(1,:) = myiter(1,:)-p(nnx,:)\n        myiter(nnx,:) = myiter(nnx,:)-p(1,:)\n    end function\n"}, {"instruction": "Create a Fortran function named norm2_c that calculates the 2-norm of a complex vector. The function takes one input parameter of type complex(8) and dimension(:), and returns one output parameter of type real(8).", "input": "", "output": "function norm2_c(val)\n  character(len=*),parameter :: this_sub_name = 'norm2'\n\n  complex(8),dimension(:),intent(in) :: val\n\n  real(8) :: norm_real\n  real(8) :: norm_complex\n\n  real(8) :: norm2_c\n\n  norm_real = norm2(real(val))\n  norm_complex = norm2(aimag(val))\n\n  norm2_c = (norm_real**2 + norm_complex**2)**(0.5)\nend function norm2_c\n"}, {"instruction": "Write a Fortran function named dot_product_c that computes the dot product of two complex arrays. The function takes 2 input parameters of type complex(8) arrays and returns 1 output parameter of type complex(8).", "input": "", "output": "function dot_product_c(val1,val2)\n  character(len=*),parameter :: this_sub_name = 'dot_product_c'\n\n  complex(8),dimension(:),intent(in) :: val1\n  complex(8),dimension(:),intent(in) :: val2\n\n  complex(8) :: dot_product_c\n\n  integer :: n_elem_1\n  integer :: n_elem_2\n  integer :: ielem\n\n  n_elem_1 = size(val1)\n  n_elem_2 = size(val2)\n\n  dot_product_c = 0\n\n  do ielem = 1,n_elem_1\n    dot_product_c = dot_product_c + val1(ielem)*val2(ielem)\n  enddo\nend function dot_product_c\n"}, {"instruction": "Create a Fortran function named multiply_two_numbers to calculate the product of two real numbers. Define 2 input parameters of type real and labeled as intent(in). The output parameter should also be of type real. The number of input parameters is 2 with test_data type ['real', 'real'], and the number of output parameters is 1 with test_data type ['real'].", "input": "", "output": "  function multiply_two_numbers(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a * b\n    return\n  end function multiply_two_numbers\n"}, {"instruction": "Create a Fortran function named dist that computes the Cartesian distance between two 3-dimensional points. The function has 2 input parameters of type real, dimension(3) and the test_data type is ['real,dimension(3)', 'real,dimension(3)']. It also has 1 output parameter of type real and the test_data type is ['real'].", "input": "", "output": "function dist(a, b) result(c)\r\n  ! calculates the cartesian distance between 2 points\r\n\r\n    implicit none\r\n\r\n    real,dimension(3),intent(in) :: a, b\r\n    real :: c\r\n\r\n    c = sqrt(sum((a-b)**2))\r\n\r\nend function dist\r\n"}, {"instruction": "Create a Fortran function named inner that computes the 3D Euclidean inner product of two input vectors. The input parameters consist of two 3-dimensional real arrays. The output parameter is a single real value.", "input": "", "output": "function inner(a, b) result(c)\r\n  ! calculates the 3d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(3) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)+a(3)*b(3)\r\n\r\nend function inner\r\n"}, {"instruction": "Create a Fortran function named inner2 to compute the 2D Euclidean inner product. The function takes 2 input parameters of type real, dimension(2) and returns 1 output parameter of type real. The name of the function is inner2.", "input": "", "output": "function inner2(a, b) result(c)\r\n  ! calculates the 2d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(2) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)\r\n\r\nend function inner2\r\n"}, {"instruction": "Create a Fortran function called outer to compute the outer product of two 3-dimensional real arrays. This function takes 2 input parameters of type real, dimension(3) and the test_data type is [real,dimension(3)', 'real,dimension(3)']. It returns 1 output parameter of type real, dimension(3,3) and the test_data type is ['real,dimension(3,3)'].", "input": "", "output": "function outer(a, b) result(c)\r\n  ! calculates the outer product of two vectors\r\n\r\n  implicit none\r\n\r\n  real,dimension(3) :: a, b\r\n  real,dimension(3,3) :: c\r\n\r\n  integer :: i\r\n\r\n  c = 0.\r\n\r\n  do i=1,3\r\n    c(i,:) = a(i)*b(:)\r\n  end do\r\n\r\nend function\r\n"}, {"instruction": "Create a Fortran function named det3 to calculate the determinant of a 3x3 matrix. The function takes 1 input parameter of type real, dimension(3,3), and returns 1 output parameter of type real.", "input": "", "output": "function det3(a) result(c)\r\n  ! calculates the determinant of a 3x3 matrix\r\n\r\n  implicit none\r\n\r\n  real,dimension(3,3) :: a\r\n  real :: c\r\n\r\n  c = a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))\r\n  c = c - a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\r\n  c = c + a(1,3)*(a(2,1)*a(3,2)-a(3,1)*a(2,2))\r\n\r\nend function det3\r\n"}, {"instruction": "Write a Fortran function named dot to compute the dot product of two 3-dimensional real arrays. The function should have 2 input parameters of type real (kind=8), dimension(3) and 1 output parameter of type real (kind=8). The function must return the dot product of the two input arrays.", "input": "", "output": "    function dot(v1, v2)\n      real (kind=8), intent(in), dimension(3) :: v1, v2\n      integer(kind=4) :: i, length\n      real (kind=8) :: cp, dot\n    \t\n      length = size(v1)\n      cp = 0.0;\n    \t\n      do i=1,length\n        cp = cp + v1(i)*v2(i)\n      enddo\n    \t\n      dot = cp\n      return\n    end function dot\n"}, {"instruction": "Create a Fortran function named cross that calculates the cross product of two 3-dimensional vectors. The function takes 2 input parameters of type real (kind=8), dimension(3) and returns 1 output parameter of type real (kind=8), dimension(3).", "input": "", "output": "    function cross(v1, v2)\n      real (kind=8), intent(in), dimension(3) :: v1, v2\n      real (kind=8), dimension(3) :: cross\n\t\t\n      cross(1) = v1(2)*v2(3)-v1(3)*v2(2)\n      cross(2) = v1(3)*v2(1)-v1(1)*v2(3)\n      cross(3) = v1(1)*v2(2)-v1(2)*v2(1)\n    \t\n      return\n    end function cross\n"}, {"instruction": "Write a Fortran function named scalevec to scale a vector by a scalar value. The function takes 2 input parameters: an array of real numbers with kind=8 and dimension(:), and a single real number with kind=8. The output is an allocatable array of real numbers with kind=8 and dimension(:).", "input": "", "output": "    function scalevec(sc, v1)\n      real (kind=8), intent(in), dimension(:) :: v1\n      real (kind=8), intent(in) :: sc\n      integer(kind=4) :: i, length\n      real (kind=8), allocatable, dimension(:) :: scalevec\n      length = size(v1)\n     \n      allocate(scalevec(length))\n      scalevec(1:length) = sc*v1(1:length)\n        \n      return\n    end function scalevec\n"}, {"instruction": "Create a Fortran function named file_name that extracts the file name from a given path. The function takes 2 input parameters of type character(*) and character(1), the second one being optional. The output is 1 parameter of type character(:), allocatable.", "input": "", "output": "pure function file_name(instr, filesep)\n\ncharacter(*), intent(in) :: instr\ncharacter(1), intent(in), optional :: filesep\ncharacter(:), allocatable :: file_name\n\ncharacter(1) :: sep\ninteger :: i\n\nsep = '/'\nif(present(filesep)) sep = filesep\n\ni = scan(instr, sep, back=.true.)\nfile_name = instr(i+1:len(instr))\n\nend function file_name\n"}, {"instruction": "Write a Fortran function named rerf to compute the relative error function (rerf) for a given real number. The function takes 1 input argument of type real and returns 1 output argument of type real.", "input": "", "output": "function rerf(y)\n!\nimplicit none\n!\n\n!\nreal :: y\nreal :: rerf\n!\n! local variables\n!\nreal :: a,a1,a2,alogy,b,b1,b2,base,c,c1,c2,d,d1,e,er1,er2,f,g,h,i,j,sqy,y2,y3,  &\n      & y4,y5,z\nreal :: alog\n!\n!**********************************************************************\n!     + + +  purpose + + +\n\n\n!     written by l. hagen and coded by i. elmanyawi\n \n!     + + +  argument declarations + + +\n \n!     + + + local variables + + +\n!     + + + end specifications + + +\n!\na = 0.000009477\nb = -2.76913995\nc = 0.88589485\nd = 2.30199509\ne = -2.44996884\nf = -0.14332263\ng = 2.246990417\nh = -0.54046067\ni = -0.68292239\nj = 0.15092933\nz = y\ny = abs(y)\n!\na1 = 2857.5463\nb1 = -0.00016423\nc1 = -5717.0696\nd1 = -2857.5783\na2 = 69161.649\nb2 = -277330.28\nc2 = 208168.95\n!\nsqy = sqrt(y)\nalogy = alog(y)\ny2 = y*y\ny3 = y2*y\ny4 = y3*y\ny5 = y4*y\n!\nbase = (a+c*y+e*y2+g*y3+i*y4)/(1.000000+b*y+d*y2+f*y3+h*y4+j*y5)\n!\nif (y.le.0.966105) then\n  rerf = base\nelse if (y.gt.0.999311) then\n!\n  er2 = a2 + b2*y*sqy + c2*y2\n  rerf = base - er2\nelse\n!\n  er1 = a1 + b1/alogy + c1*alogy/y + d1/y2\n  rerf = base - er1\nend if\nrerf = rerf*z/y\nend function rerf\n"}, {"instruction": "Create a Fortran function named predicate that takes an integer input argument and returns a logical value. The input argument should be of type integer, and the output should be of type logical. The function computes whether the square root of the input number is a whole number and returns true if it is, and false if it is not. Use the imperative tone to instruct the creation of a Fortran function with the mentioned specifications.", "input": "", "output": "  pure function predicate(n)\n    implicit none\n    integer, intent(in) :: n\n    logical             :: predicate\n\n    predicate=mod(sqrt(dble(n)),1.0)/=0.0\n\n  end function predicate\n"}, {"instruction": "Create a Fortran function named quote that takes in a string and an optional quote character. The input parameters are of type 'character(len=*)' and 'character(len=*), optional'. The function returns a single output parameter of type 'character(len=:), allocatable'. The function concatenates the input string with the specified quote character and returns the result.", "input": "", "output": "        function quote(s, q) result (r)\n            character(len=*), intent(in) :: s\n            character(len=*), optional, intent(in) :: q\n            character(len=:), allocatable :: t_q\n            character(len=:), allocatable :: r\n\n            if (.not. present(q)) then\n                t_q = '\"'\n            else\n                t_q = q\n            end if\n\n            r = t_q//s//t_q\n        end function\n"}, {"instruction": "Write a Fortran function named dlog2 to calculate the base-2 logarithm of a double precision number. The function should have 1 input parameter of type double precision and 1 output parameter of type double precision. The input parameter should be declared with the intent(in) attribute.", "input": "", "output": "        function dlog2(x) result (y)\n            implicit none\n            double precision, intent(in) :: x\n            double precision :: y\n\n            y = dlog(x) / dlog(2.0d0)\n            return\n        end function\n"}, {"instruction": "Create a Fortran function named drand to generate a random double precision number within the specified range. The function takes 2 input arguments of type double precision and returns 1 output argument of type double precision. The input arguments are the lower and upper bounds of the range.", "input": "", "output": "        function drand(a, b) result (y)\n            implicit none\n            double precision :: a, b, x, y\n            ! x in [0, 1)            \n            call random_number(x)\n            y = (x * (b - a)) + a\n            return\n        end function\n"}, {"instruction": "Create a Fortran function called \"str\" to convert an integer to a string. The function should have 1 input parameter of type integer and 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function str(k) result (t)\n!       \"convert an integer to string.\"\n            integer, intent(in) :: k\n            character(len=128) :: s\n            character(len=:), allocatable :: t\n            write(s, *) k\n            t = trim(adjustl(s))\n            return\n            return\n        end function\n"}, {"instruction": "Write a Fortran function named dstr that converts a double precision number to a string representation. The function takes 1 input parameter of type double precision and returns 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "        function dstr(x) result (q)\n            integer :: j, k\n            double precision, intent(in) :: x\n            character(len=64) :: s\n            character(len=:), allocatable :: p, q\n            \n            if (isnan(x)) then\n                q = '?'\n                return\n            else if (x == dinf) then\n                q = '\u221e'\n                return\n            else if (x == dninf) then\n                q = '-\u221e'\n                return\n            end if\n\n            write(s, *) x\n            p = trim(adjustl(s))\n            do j=len(p), 1, -1\n                if (p(j:j) == '0') then\n                    continue\n                else if (p(j:j) == '.') then\n                    k = j - 1\n                    exit\n                else \n                    k = j\n                    exit\n                end if\n            end do\n            q = p(:k)\n            return\n        end function\n"}, {"instruction": "Create a Fortran function named get_col_totals that calculates the sum of each column in a 2D array. The function requires three input parameters: the number of rows (integer), the number of columns (integer), and the array itself (real, dimension(r, c)). The function returns an array (real, dimension(c)) containing the column totals.", "input": "", "output": "function get_col_totals(r, c, arr)\n  integer, intent(in) :: r, c\n  real, dimension(r, c), intent(in) :: arr\n  real, dimension(c) :: totals\n  real, dimension(c) :: get_col_totals\n  totals = 1\n  get_col_totals = totals\nend function get_col_totals\n"}, {"instruction": "Write a Fortran function code named qaverage0 that calculates the average of two quantities, mya and myb, raised to the power of their respective densities, rhoa and rhob. The number of input parameters is 4 and the test_data types are ['real*8', 'real*8', 'real*8', 'real*8']. The number of output parameters is 1 and the test_data type is ['real*8'].", "input": "", "output": " pure function qaverage0(rhoa,rhob,mya,myb)\n  \n  implicit none\n  \n  real*8, intent(in) :: rhoa,rhob,mya,myb\n  \n  real*8 :: qaverage0,rhosum\n  \n  rhosum=rhoa+rhob\n  \n  qaverage0=(mya**(rhoa)+myb**(rhob))**(1.d0/rhosum)\n  \n  return\n  \n end function\n"}, {"instruction": "Write a Fortran function named remove_spaces to remove whitespace from a given string. The function takes one input argument of type 'character(len=*)' and returns one output argument of type 'character(len=:), allocatable'.", "input": "", "output": "    pure function remove_spaces(str) result(res)\n        !! remove whitespace in the given string.\n\n        character(len=*), intent(in) :: str\n            !! the string.\n        character(len=:), allocatable :: res\n            !! the string without spaces.\n\n        character(len=len_trim(str)) :: tmp\n        integer :: i, j, c\n\n        tmp = adjustl(str)\n\n        j = 0\n\n        do i = 1, len_trim(tmp)\n            c = iachar(tmp(i:i))\n            if ((c == int(z'20')) .or. (c >= int(z'09') .and. c <= int(z'0d'))) then\n                cycle\n            end if\n            j = j + 1\n            tmp(j:j) = tmp(i:i)\n        end do\n\n        if (j == 0) then\n            res = ''\n        else\n            res = tmp(1:j)\n        end if\n    end function remove_spaces\n"}, {"instruction": "Provide a Fortran function called to_upper that converts a given string into uppercase characters. The function takes one input argument of type 'character(len=*)' and returns one output argument of type 'character(len=len(str))'.", "input": "", "output": "    pure function to_upper(str) result(res)\n        !! convert a string into uppercase.\n\n        character(len=*), intent(in) :: str\n            !! the string to be converted.\n        character(len=len(str)) :: res\n            !! the converted uppercase string.\n\n        integer :: i, c\n\n        res = str\n\n        do i = 1, len_trim(res)\n            c = iachar(res(i:i))\n            select case (c)\n            case (97:122)\n                res(i:i) = achar(c - 32)\n            end select\n        end do\n    end function to_upper\n"}, {"instruction": "Write a Fortran function named b32 that takes in a single double precision floating-point number as input. The input argument should be declared as real(8) and have the intent \"in\". The function calculates a result based on the input value and returns a double precision floating-point number as the output. The output result should also be declared as real(8). The function uses a mathematical formula to compute the result. The number of input arguments is 1 and the test_data type is ['real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)'].", "input": "", "output": "function b32(xx)\n\timplicit none\n\treal(8), intent(in) :: xx\n\treal(8) :: b32\n\t\tb32 = ((-2.d0 * xx +2.d0) * xx +1.d0) / 2.d0\n\treturn\nend function\n"}, {"instruction": "Write a Fortran function named b42 that takes in a single input argument of type real(8) and returns a single output argument of type real(8). The function calculates a mathematical expression ((-3 * xx + 3) * xx + 3) * xx + 1 and divides the result by 6.0.", "input": "", "output": "function b42(xx)\n\timplicit none\n\treal(8), intent(in) :: xx\n\treal(8) :: b42\n\t\tb42 = (((-3.d0 * xx + 3.d0) * xx + 3.d0) * xx + 1.d0) / 6.0d0\n\treturn\nend function\n"}, {"instruction": "Write a Fortran function named boundary_func that calculates the value of a mathematical function for given input values. The function takes two input arguments of type real(kind = 8) and returns one output argument of the same type. The input parameters are denoted as x and y. The function computes the value of the function sin(pi*x)*exp(-pi*y), where pi is a predefined constant.", "input": "", "output": "function boundary_func(x,y)\n        implicit none \n        real(kind = 8) :: boundary_func, x, y, pi\n        pi = 4.d0*atan(1.d0)\n        boundary_func = sin(pi*x)*exp(-pi*y)\nend function\n"}, {"instruction": "Create a Fortran function named atan4 that calculates the four-argument arctangent. The function takes 4 input arguments of type real(kind=8) and returns a single output of the same type. The input arguments are a, b, c, and d.", "input": "", "output": "   function atan4(a,b,c,d)\r\n    implicit none\r\n    real(kind=8) :: atan4\r\n    real(kind=8), intent(in) :: a,b,c,d\r\n    real (kind=8),parameter :: twopi=6.283185307179586d0, &\r\n                                  pi=3.141592553589793d0\r\n      atan4 = atan2(a,b) - c\r\n      !  limit angle change to pi (180 degrees)\r\n      if( atan4-d > pi  )then\r\n        atan4 = atan4 - twopi\r\n      else if( atan4-d < -pi )then\r\n        atan4 = atan4 + twopi\r\n      end if\r\n    end function\r\n"}, {"instruction": "Create a Fortran function named getcolorgradvect to calculate the color gradient vector based on the input values and exponent. The function takes 2 input parameters of type real(8), dimension(:) and real(8), and returns 1 output parameter of type integer, dimension(size(value)).", "input": "", "output": "    function getcolorgradvect(value,valueexp) result(res)\n        \n        real(8), dimension(:) :: value\n        integer, dimension(size(value)) :: red, green, blue\n        integer, dimension(size(value)) :: res\n        real(8) :: valueexp\n        \n        value = value**valueexp\n        \n        red   = (br - ar) * value + ar      ! evaluated as -255*value + 255.\n        green = (bg - ag) * value + ag      ! evaluates as 0.\n        blue  = (bb - ab) * value + ab      ! evaluates as 255*value + 0.\n        \n        res = red + 256*green + 65536*blue\n        \n    end function getcolorgradvect\n"}, {"instruction": "Create a Fortran function named set_begin_time that takes a double precision input argument. This function returns an integer output. The number of input arguments is 1 with the test_data type ['double precision'], and the number of output arguments is 1 with the test_data type ['integer']. The function sets the begin time and returns -1.", "input": "", "output": "function set_begin_time(time)\n  implicit none\n  double precision :: time\n  integer :: set_begin_time\n  set_begin_time=-1\nend function\n"}, {"instruction": "Create a Fortran function named get_gravity_at_point to calculate the gravitational force at a specific point. The function takes 8 input parameters of types integer, double precision, and calculates the gravitational force at the specified point. The function returns an output parameter of type integer.", "input": "", "output": "function get_gravity_at_point(eps, x, y, z, ax, ay, az, npoints)\n  implicit none\n  integer :: npoints\n  double precision :: eps, x, y, z, ax, ay, az\n  integer :: get_gravity_at_point\n  get_gravity_at_point=-1\nend function\n"}, {"instruction": "Create a Fortran function named sum_8bit that takes two 8-bit integer input parameters and returns their sum as an 8-bit integer output parameter. The number of input arguments is 2 and the test_data type is [integer(1), integer(1)]. The number of output arguments is 1 and the test_data type is [integer(1)].", "input": "", "output": "function sum_8bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_8bit' :: sum_8bit\n    implicit none\n    integer(1) :: a, b, value\n    value = a + b\nend function sum_8bit\n"}, {"instruction": "Create a Fortran function named sum_16bit to calculate the sum of two 16-bit integers. The function should take 2 input arguments of type integer(2) and return 1 output argument of type integer(2).", "input": "", "output": "function sum_16bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_16bit' :: sum_16bit\n    implicit none\n    integer(2) :: a, b, value\n    value = a + b\nend function sum_16bit\n"}, {"instruction": "Create a Fortran function named sum_32bit to calculate the sum of two 32-bit integers. The function takes 2 input parameters of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "function sum_32bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_32bit' :: sum_32bit\n    implicit none\n    integer(4) :: a, b, value\n    value = a + b\nend function sum_32bit\n"}, {"instruction": "Please create a Fortran function named sum_64bit that calculates the sum of two 64-bit integer numbers. The function should have 2 input parameters of type integer(8) and 1 output parameter of type integer(8).", "input": "", "output": "function sum_64bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_64bit' :: sum_64bit\n    implicit none\n    integer(8) :: a, b, value\n    value = a + b\nend function sum_64bit\n"}, {"instruction": "Write a Fortran function code named multiply_float32 that multiplies two 32-bit floating-point numbers. The number of input arguments is 2 and the data type of each argument is real(4). The number of output arguments is 1 and the data type of the output is also real(4).", "input": "", "output": "function multiply_float32(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float32' :: multiply_float32\n    implicit none\n    real(4) :: a, b, value\n    value = a * b\nend function multiply_float32\n"}, {"instruction": "Write a Fortran function named multiply_float64 that calculates the product of two double precision floating-point numbers. The function should have two input parameters of type real(8) and the test_data type should be ['real(8)', 'real(8)']. The function should return a single output value of type real(8) and the test_data type should be ['real(8)'].", "input": "", "output": "function multiply_float64(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float64' :: multiply_float64\n    implicit none\n    real(8) :: a, b, value\n    value = a * b\nend function multiply_float64\n"}, {"instruction": "Please provide a Fortran function named upcase that converts all lowercase characters in a given string to uppercase. The function takes one input argument of type character(kind=c_char,len=*) and one output argument of type character(kind=c_char,len=len(s)).", "input": "", "output": "  function upcase(s) result(ss)\n    use iso_c_binding\n    implicit none\n    character(kind=c_char,len=*), intent(in) :: s\n    character(kind=c_char,len=len(s)) :: ss\n    integer :: n, i\n    character(*), parameter :: uc = \"abcdefghijklmnopqrstuvwxyz\"\n    character(*), parameter :: lc = \"abcdefghijklmnopqrstuvwxyz\"\n    ss = s\n    do i = 1, len_trim(s)\n       n = index(lc, s(i:i))\n       if (n /= 0) ss(i:i) = uc(n:n)\n    end do\n  end function upcase\n"}, {"instruction": "Write a Fortran function named sum_digits_squared that computes the sum of the squares of the individual digits of an input integer number. The function takes one input parameter of type integer and returns one output parameter of type integer.", "input": "", "output": "  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n"}, {"instruction": "Write a Fortran function code named spring_1 that calculates the quantum spring energy for a given atom. The function takes 4 input arguments: rik (coordinates of the atom of interest), ril (coordinates of the other atom of interest), box (simulation box length), and k_spring (spring potential constant). The input arguments have the data types: ['real, dimension(3)', 'real, dimension(3)', 'real', 'real'].\n\nThe function calculates the spring potential between the atom of interest and its neighbor in the same polymer ring. The coordinates are adjusted for periodic boundaries using the anint function. The squared distance between the atoms is calculated and multiplied by the spring potential constant. Finally, the calculated partial potential is returned as the output argument.\n\nThe function has 1 output argument with the data type 'real'.", "input": "", "output": "  function spring_1 ( rik, ril, box, k_spring ) result ( partial_pot )\n    implicit none\n    real                           :: partial_pot ! returns quantum potential for given atom\n    real, dimension(3), intent(in) :: rik         ! coordinates of atom of interest\n    real, dimension(3), intent(in) :: ril         ! coordinates of other atom of interest\n    real,               intent(in) :: box         ! simulation box length\n    real,               intent(in) :: k_spring    ! spring potential constant\n\n    ! partial_pot is the quantum spring energy of atom (i,k) in rik for polymer bead k\n    ! with its neighbour (i,l) in the same polymer ring\n    ! the coordinates in rik are not necessarily identical with those in r(:,i,k)\n    ! the partner atom index is always the same as i\n\n    ! it is assumed that r has been divided by box\n    ! results are in lj units where sigma = 1, epsilon = 1\n\n    real               :: r_ik_il_sq\n    real, dimension(3) :: r_ik_il\n\n    r_ik_il(:)  = rik(:) - ril(:)\n    r_ik_il(:)  = r_ik_il(:) - anint ( r_ik_il(:) ) ! periodic boundaries in box=1 units\n    r_ik_il_sq  = sum ( r_ik_il**2 ) *  box**2      ! squared distance in sigma=1 units\n    partial_pot = 0.5 * k_spring * r_ik_il_sq       ! spring potential\n\n  end function spring_1\n"}, {"instruction": "Create a Fortran function named indexof that takes an integer element and a one-dimensional integer array as input. The function returns the index of the element in the array if found, otherwise, it returns -1. The number of input arguments is 2 and the test_data type is ['integer', 'integer, dimension(:)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function indexof(element, array)\n    ! please note that array has to be sorted\n    integer :: indexof\n    integer, intent(in) :: element\n    integer, intent(in), dimension(:) :: array\n\n    integer :: left, right, middle\n    left = lbound(array, 1)\n    right = ubound(array, 1)\n    middle = (left + right) / 2\n\n    indexof = -1\n\n    if (array(left) > element .or. array(right) < element) then\n       return\n    end if\n    do while (element /= array(middle))\n       if (left > right) then\n          return\n       end if\n\n       if (element > array(middle)) then\n          left = middle + 1\n       else if (element < array(middle)) then\n          right = middle - 1\n       end if\n       middle = (left + right) / 2\n\n    end do\n\n    indexof = middle\n\n  end function indexof\n"}, {"instruction": "Write a Fortran function named tmpedge2localedge to compute the local edge index given the temporary edge index. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is iedge, and the output parameter is ilocaledge.", "input": "", "output": "function tmpedge2localedge(iedge) result(ilocaledge)\nimplicit none\n    integer, intent(in) :: iedge\n    integer :: ilocaledge\n\n    ilocaledge = mod(iedge+2,3)+1\n    return\nend function tmpedge2localedge\n"}, {"instruction": "Write a Fortran function named rot_rx to calculate the 3x3 rotation matrix for a given angle in radians. The input parameter is a real number representing the angle (test_data type is ['real']), and the output parameter is a 3x3 real matrix representing the rotation matrix (test_data type is ['real, dimension(3,3)']).", "input": "", "output": "      function rot_rx ( theta )\n\n      implicit none\n\n      real, intent ( in ) :: theta\n\n      real, dimension ( 3 , 3 ) :: rot_rx\n\n      rot_rx ( 1 , 1 ) = 1.0\n      rot_rx ( 2 , 1 ) = 0.0\n      rot_rx ( 3 , 1 ) = 0.0\n      rot_rx ( 1 , 2 ) = 0.0\n      rot_rx ( 2 , 2 ) = cos ( theta )\n      rot_rx ( 3 , 2 ) = sin ( theta )\n      rot_rx ( 1 , 3 ) = 0.0 \n      rot_rx ( 2 , 3 ) = -sin ( theta )\n      rot_rx ( 3 , 3 ) = cos ( theta )\n\n      return\n\n      end function\n"}, {"instruction": "Write a Fortran function named sgn to determine the sign of a real number. The number of input arguments is 1 and the test_data type is [real(4)]. The number of output arguments is 1 and the test_data type is [real(4)].", "input": "", "output": "    function sgn(x)\n        real(4)::sgn\n        real(4)::x\n        if (x==0) sgn = 0\n        if (x>0)  sgn = 1\n        if (x<0)  sgn = -1\n    end function\n"}, {"instruction": "Create a Fortran function named get_len that calculates the length of a string and returns the result as an integer. The function has 1 input parameter of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    integer::k\n    get_len = len(string)\n    k = 0\n    do while (k<get_len)\n      if (string(k+1:k+1)/=' ') then\n        k = k+1\n      else\n        get_len = k\n      end if\n    end do\n  end function\n"}, {"instruction": "Write a Fortran function named zeros to create a 2D array of zeros with dimensions x and y. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer, dimension(x,y)].", "input": "", "output": "  function zeros(x,y) result(result)\n    integer:: x,y\n    integer, dimension(x,y) :: result\n\n    do i_x=1,x\n       do i_y=1,y\n          result(i_x, i_y) = 0\n       end do\n    end do\n  end function\n"}, {"instruction": "Write a Fortran function named fact to calculate the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "function fact(n)    !computing factorial\r\n    implicit none\r\n    integer::f,n,i    !local variables\r\n    integer::fact   !dummy variable\r\n    f=1\r\n    do i=1,n\r\n        f=f*i\r\n    end do\r\n    fact=f\r\nend function\r\n"}, {"instruction": "Create a Fortran function named strmerge to merge two input strings to the same length based on a logical expression. The function takes 3 input parameters of type ['character(len=*)', 'character(len=*)', 'logical'] and returns 1 output parameter of type ['character(len=max(len(str1), len(str2)))'].", "input": "", "output": "elemental function strmerge(str1,str2,expr) result(strout)\n!$@(#) m_strings::strmerge(3f): pads first and second arguments to merge(3f) to same length\ncharacter(len=*),intent(in)              :: str1\ncharacter(len=*),intent(in)              :: str2\nlogical,intent(in)                       :: expr\ncharacter(len=max(len(str1), len(str2))) :: strout\n   if(expr)then\n      strout=str1\n   else\n      strout=str2\n   endif\nend function strmerge\n"}, {"instruction": "Write a Fortran function named atleast that returns a string padded to at least a specified length. The function should have 3 input parameters with test_data types ['character(len=*)', 'integer', 'character(len=*), optional'], and 1 output parameter with a test_data type of ['character(len=max(length,len(trim(line))))']. Use the imperative tone in your instructions.", "input": "", "output": "function atleast(line,length,pattern) result(strout)\n\n!$@(#) m_overload::atleast(3f): return string padded to at least specified length\n\ncharacter(len=*),intent(in)                :: line\ninteger,intent(in)                         :: length\ncharacter(len=*),intent(in),optional       :: pattern\ncharacter(len=max(length,len(trim(line)))) :: strout\nif(present(pattern))then\n   strout=line//repeat(pattern,len(strout)/len(pattern)+1)\nelse\n   strout=line\nendif\nend function atleast\n"}, {"instruction": "Create a Fortran function named \"latlon_local_min\" to determine if the center value of a given array is the minimum value within the array. The function should take 1 input argument of type real*8, with dimension(1:9). The output should be a single real*8 value.", "input": "", "output": "function latlon_local_min(orog_section) result(is_minimum)\n\n\nreal*8, intent(in), dimension(1:9) :: orog_section\n\n!local variables\ninteger :: i\nreal*8 :: centre_value\nreal*8 :: is_minimum\n\n    is_minimum = 1.0\n    do i = 1,9\n        if (i == 5) cycle\n        centre_value = orog_section(5)\n        if (orog_section(i) < centre_value) is_minimum = 0.0\n    end do\n\nend function latlon_local_min\n"}, {"instruction": "Write a Fortran function named fibonacci to calculate the Fibonacci number for a given input integer.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "recursive function fibonacci (n) result (fnum)\n     integer, intent(in) :: n\n     integer :: fnum\n\n    !  handle exit conditions\n    if (n<2) then\n        fnum = n\n    \n    !  handle normal conditions\n    else\n        fnum = fibonacci(n-1) + fibonacci(n-2)\n\n    endif\nend function fibonacci\n"}, {"instruction": "Create a Fortran function named fjson_convert_str_to_value that converts a character string to a JSON string. The function takes 1 input argument with the test data type ['character(len=*)'] and returns 1 output argument with the test data type ['character(len=:), allocatable'].", "input": "", "output": "   function fjson_convert_str_to_value(var) result(val_string)\n\n      implicit none\n\n      !> variable to be converted\n      character(len=*), intent(in) :: var\n\n      !> json string\n      character(len=:), allocatable :: val_string\n\n      character(len=:), allocatable :: str_string\n\n      character(len=*), parameter :: caller = \"fjson_convert_str_to_value\"\n\n      str_string = '\"' // var // '\"'\n      val_string = trim(adjustl(str_string))\n\n   end function\n"}, {"instruction": "Write a Fortran function named rand_exponential to generate a random number from an exponential distribution with the specified mean. The number of input arguments is 1 and the test_data type is ['double precision']. The number of output arguments is 1 and the test_data type is ['double precision']. If the mean is not positive, the function will display a message stating that the mean must be positive.", "input": "", "output": "      function rand_exponential(mean) result(c)\n      double precision :: mean,c,temp\n      if (mean <= 0.0d0) then\n\n        write(*,*) \"mean must be positive\"\n      else\n       call random_number(temp)\n       c=-mean*log(temp)\n      end if\n      end function\n"}, {"instruction": "Create a Fortran function named csv_record that takes in 4 input parameters of types ['character (len=*)', 'character', 'real, dimension(nostats)', 'integer'], and returns 1 output parameter of type 'character (len=256)'. The function should process the input data and generate a CSV record, which combines the state, party, and fields, separated by commas. The CSV record will be stored in the output parameter \"record\".", "input": "", "output": "function csv_record(state, party, fields, nostats) result(record)\n   implicit none\n   ! dummy arguments\n   character (len=*), intent(in) :: state\n   character, intent(in) :: party\n   real, intent(in), dimension(nostats) :: fields\n   integer, intent(in) :: nostats\n\n   character (len=256) :: record\n   ! local data\n   integer :: i\n   character (len=25) :: str\n   ! processing\n   record=trim(state)//','//trim(party)\n   do i = 1, nostats\n      write (str,*) fields(i)\n      record=trim(record)//','//trim(adjustl(str))\n   end do\nend function csv_record\n"}, {"instruction": "Write a Fortran function named fibonacci to compute the nth Fibonacci number. The function accepts 1 input parameter of type integer(kind=4) and returns 1 output parameter of type integer(kind=4). The name of the function is fibonacci.", "input": "", "output": "recursive function fibonacci(n) result(item)\n    integer(kind=4) :: item\n    integer(kind=4), intent(in) :: n\n    select case (n)\n        case (0:1)\n            item = n\n        case default\n            item = fibonacci(n-1) + fibonacci(n-2)\n    end select\nend function\n"}, {"instruction": "Create a Fortran function named func_normal_cdf to calculate the cumulative distribution function (CDF) of a normal distribution. The function takes 3 input parameters of type real(kind = real64) representing x, mean, and standard deviation. It returns 1 output parameter of type real(kind = real64) representing the CDF value.", "input": "", "output": "elemental function func_normal_cdf(x, mean, stddev) result(ans)\n    ! note: see https://en.wikipedia.org/wiki/normal_distribution\n\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare inputs/outputs ...\n    real(kind = real64)                                                         :: ans\n    real(kind = real64), intent(in)                                             :: mean\n    real(kind = real64), intent(in)                                             :: stddev\n    real(kind = real64), intent(in)                                             :: x\n\n    ! declare internal variables ...\n    real(kind = real64)                                                         :: tmp\n\n    ! calculate short-hand ...\n    tmp = (x - mean) / (stddev * sqrt(2.0e0_real64))\n\n    ! calculate cdf ...\n    ans = 0.5e0_real64 * (1.0e0_real64 + erf(tmp))\nend function func_normal_cdf\n"}, {"instruction": "Create a Fortran function called get_counter that retrieves the value of a variable counter and assigns it to the input parameter c. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_counter(c) result (ret)\n  integer :: ret,c\n  c=counter\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named set_time that takes a single input parameter of type real(8) and returns an output parameter of type integer. The function sets the value of a global variable t_curr to the input parameter tnow and assigns 0 to the output parameter ret.", "input": "", "output": "function set_time(tnow) result (ret)\n  integer :: ret\n  real(8) :: tnow\n  t_curr=tnow\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function named get_wind_sigma to return an integer value. It takes a real(8) input parameter and returns an integer output. The input parameter has the test_data type ['real(8)'], and the output parameter has the test_data type ['integer'].", "input": "", "output": "function get_wind_sigma(t) result (ret)\n  integer :: ret\n  real(8) :: t\n  t=wind_sigma\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_ra_alpha that takes in one real(8) input parameter. The function returns an integer output. The function assigns the value of the input parameter to a variable t, and then sets the return value to 0.", "input": "", "output": "function get_ra_alpha(t) result (ret)\n  integer :: ret\n  real(8) :: t\n  t=ra_alpha\n  ret=0\nend function\n"}, {"instruction": "Write a Fortran function named get_lx that takes a real(8) input argument and returns an integer output. The input parameter has a test_data type of ['real(8)'], and the output parameter has a test_data type of ['integer'].", "input": "", "output": "function get_lx(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  x=lx\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named set_dx that takes a single real(8) input argument and returns an integer output. The input argument type is real(8), and the output type is integer. This function sets the value of a variable dx to the input argument x and returns 0.", "input": "", "output": "function set_dx(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  dx=x\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_h that takes a real(8) input argument and returns an integer. The function sets the input value x to h and assigns 0 to the return value ret.", "input": "", "output": "function get_h(x) result (ret)\n  integer :: ret\n  real(8) :: x\n  x=h\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function called set_savecounter to assign a value to a saved variable. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument is used to set the value of the saved variable savecounter, and the output argument is set to 0.", "input": "", "output": "function set_savecounter(x) result (ret)\n  integer :: ret,x\n  savecounter=x\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_max_it that takes an integer input argument and returns an integer output. The input parameter is of type integer, and the output parameter is also of type integer. This function retrieves the maximum value from the input argument and assigns it to the output parameter.", "input": "", "output": "function get_max_it(x) result (ret)\n  integer :: ret,x\n  x=max_it\n  ret=0\nend function\n"}, {"instruction": "Provide a Fortran function named get_ny that takes one integer input argument and returns an integer value. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "function get_ny(x) result (ret)\n  integer :: ret\n  integer :: x\n  x=ny\n  ret=0\nend function\n"}, {"instruction": "Write a Fortran function called listcontains to check if a given integer is present in a list of integers. The function takes 2 input parameters with test_data type ['integer, dimension(1:)', 'integer'], and returns 1 output parameter with test_data type ['logical'].", "input": "", "output": "        function listcontains(list, x) result(r)\n            integer, dimension(1:), intent(in) :: list\n            integer, intent(in) :: x\n            logical :: r\n            integer :: i\n        \n            do i=1,size(list)\n                if (list(i) == x) then\n                    r = .true.\n                    return\n                end if\n            end do\n        \n            r = .false.\n    \n        end function listcontains    \n"}, {"instruction": "Create a Fortran function called sanitize to process a double-precision floating-point number. The function takes 1 input parameter of type double precision and returns 1 output parameter of type double precision, as ['double precision'] and ['double precision'] respectively. The function checks if the absolute value of the input is less than 1.0d-99, and if so, sets the output to 0.0d0; otherwise, it returns the input value.", "input": "", "output": "  function sanitize(val) result (new_val)\n\n    implicit none\n\n    double precision, intent(in) :: val\n    double precision :: new_val\n\n    if (abs(val) < 1.d-99) then\n       new_val = 0.0d0\n    else\n       new_val = val\n    endif\n\n  end function sanitize\n"}, {"instruction": "Create a Fortran function named count_lines that takes a file name as input and returns the number of lines in the file, excluding lines starting with a '#' symbol. The number of input arguments is 1, and the test_data type is ['character(len=*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function count_lines(fname)\n    character(len=*) :: fname\n    integer :: count_lines\n\t\n    character(100) :: tmp\n    \n    count_lines = 0 \n    open (90, file = fname) \n    do \n        read (90,*, end=10) tmp\n        if (.not.(tmp(1:1) == '#')) then \n            count_lines = count_lines + 1 \n        end if\n    end do \n    10 close (90)\n\t\nend function count_lines\n"}, {"instruction": "Write a Fortran function named select that takes three input arguments of types logical, integer, and integer, and returns one output argument of type integer. This function selects and returns either the second or third input argument based on the value of the first input argument. If the first argument is true, the function returns the second argument; otherwise, it returns the third argument.", "input": "", "output": "pure function select (selector, iftrue, iffalse)\n  logical, intent (in) :: selector\n  integer, intent (in) :: iftrue, iffalse\n  integer :: select\n\n  if (selector) then\n    select = iftrue\n  else\n    select = iffalse\n  end if\nend function select\n"}, {"instruction": "Write a Fortran function called zfftf_size that takes an integer size as input and returns an integer zfftf_size.", "input": "", "output": "  function zfftf_size(size)\n    implicit none\n    integer,intent(in) :: size\n    integer :: zfftf_size\n    zfftf_size = size;\n  end function zfftf_size\n"}, {"instruction": "Create a Fortran function named cross that takes two real arrays of size 3 as input parameters. The function calculates the cross product of the two input arrays and stores the result in another real array of size 3. The number of input arguments is 2, and the test_data type is ['real(kind=8), dimension(3)', 'real(kind=8), dimension(3)']. The number of output arguments is 1, and the test_data type is ['real(kind=8), dimension(3)'].", "input": "", "output": "function cross (a, b)\n   real(kind=8), dimension(3), intent(in) :: a, b\n   real(kind=8), dimension(3) :: cross\n   integer :: i\n\n   cross(1) = a(2)*b(3) - a(3)*b(2)\n   cross(2) = a(3)*b(1) - a(1)*b(3)\n   cross(3) = a(1)*b(2) - a(2)*b(1)\n\nend function cross\n"}, {"instruction": "Create a Fortran function named create_block_matrix that takes two input arguments of type integer with the values matrix_size and block_size. The function returns one output argument of type integer array with dynamic dimensions. The function allocates memory for a matrix of size matrix_size by matrix_size and initializes it with block patterns, where each block has a size of block_size and contains ones.", "input": "", "output": "    function create_block_matrix(matrix_size, block_size) result(b)\n        use, intrinsic :: iso_fortran_env, only : error_unit\n        implicit none\n        integer, value :: matrix_size, block_size\n        integer, dimension(:, :), allocatable :: b\n        integer :: i, j, k, status\n\n        allocate (b(matrix_size, matrix_size), stat=status)\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2a)') &\n                'error: can not allocate matrix'\n            stop 2\n        end if\n        b = 0\n        forall (i = 1:size(b, 1):block_size, &\n                j = 0:block_size - 1, &\n                k = 0:block_size - 1, &\n                i + j <= size(b, 1) .and. i + k <= size(b, 2))\n            b(i + j, i + k) = 1\n        end forall\n    end function create_block_matrix\n"}, {"instruction": "Create a Fortran function named utrue that calculates the true solution for comparison, if known. The function should take 2 input arguments of type real(kind=8) and return 1 output argument of type real(kind=8). The input arguments are of type ['real(kind=8)', 'real(kind=8)'] and the output argument is of type ['real(kind=8)'].", "input": "", "output": "function utrue(x, y)\n\n    ! true solution for comparison, if known.\n\n    implicit none\n    real(kind=8), intent(in) :: x,y\n    real(kind=8) :: utrue\n\n    utrue = x**2 - y**2\n\nend function utrue\n"}, {"instruction": "Create a Fortran function named \"fak\" to calculate the factorial of a given integer. The function should take 1 input argument of type integer and return 1 output argument of type integer. The input parameter should be declared with the \"intent(in)\" attribute.", "input": "", "output": "function fak(k) result(fakultaet)\n    implicit none\n    integer, intent(in) :: k\n    integer :: fakultaet\n    integer :: m\n    fakultaet = 1\n    do m=1,k\n        fakultaet = fakultaet*m\n    end do\nend function\n"}, {"instruction": "Create a Fortran function named ret_arr that takes two integer input parameters. The test_data type for the input parameters is ['integer', 'integer']. The function returns an integer array of the dimension specified by the input parameters. The test_data type for the output parameter is ['integer, dimension(a, b)']. Initialize the array with the value 100 and set the first row to 0.", "input": "", "output": "      function ret_arr(a, b)\n        implicit none\n        integer, intent(in) :: a, b\n        integer, dimension(a, b) :: ret_arr\n\n        ret_arr = 100\n        ret_arr(1,:) = 0\n\n      end function ret_arr\n"}, {"instruction": "Create a Fortran function named replace_single to replace a single occurrence or all occurrences of a substring within a given input string. The function takes 4 input parameters of type character(len=*) and an optional integer parameter. The output parameter is a character array of allocatable length.", "input": "", "output": "function replace_single( input, substring, replacement, mode )\r\n    character(len=*), intent(in)  :: input\r\n    character(len=*), intent(in)  :: substring\r\n    character(len=*), intent(in)  :: replacement\r\n    integer, intent(in), optional :: mode\r\n\r\n    character(len=:), allocatable :: replace_single\r\n\r\n    integer                       :: k, pos, mode_\r\n    logical                       :: back\r\n\r\n    ! careful with zero-length substrings\r\n    if ( substring == '' ) then\r\n        replace_single = input\r\n        return\r\n    endif\r\n\r\n    mode_ = replace_all\r\n    if ( present(mode) ) then\r\n        mode_ = mode\r\n    endif\r\n\r\n    back = ( mode_ == last_only )\r\n\r\n    !\r\n    ! find the substring\r\n    !\r\n    pos            = 1\r\n    replace_single = ''\r\n\r\n    do\r\n         k = index( input(pos:), substring, back )\r\n         !write(*,*) 'k = ', k\r\n\r\n         if ( k >= 1 ) then\r\n             replace_single = replace_single // input(pos:pos+k-2) // replacement\r\n             pos = pos + k + len(substring) - 1\r\n         else\r\n             exit\r\n         endif\r\n\r\n         if ( mode_ /= replace_all ) then\r\n             exit\r\n         endif\r\n    enddo\r\n\r\n    replace_single = replace_single // input(pos:)\r\n\r\nend function replace_single\r\n"}, {"instruction": "Create a Fortran function named insert that inserts a string into another string at a specified position. The function takes 3 input parameters: input (character), pos (integer), and string (character). It returns 1 output parameter insert (character) which is allocatable.", "input": "", "output": "function insert( input, pos, string )\r\n    character(len=*), intent(in)         :: input\r\n    integer, intent(in)                  :: pos\r\n    character(len=*), intent(in)         :: string\r\n\r\n    character(len=:), allocatable        :: insert\r\n\r\n    ! check the position - in this order\r\n    if ( pos >= len(input) .or. pos == append ) then\r\n        insert = input // string\r\n        return\r\n    endif\r\n    if ( pos < 1 .or. pos == prepend ) then\r\n        insert = string // input\r\n        return\r\n    endif\r\n\r\n    ! position within the string\r\n    insert = input(1:pos) // string // input(pos+1:)\r\n\r\nend function insert\r\n"}, {"instruction": "Write a Fortran function named delete that takes three input parameters: input (character array), pos (integer), and length (integer), and returns one output parameter, delete (character array). The function deletes a specified portion of the input string based on the position and length provided.", "input": "", "output": "function delete( input, pos, length )\r\n    character(len=*), intent(in)         :: input\r\n    integer, intent(in)                  :: pos\r\n    integer, intent(in)                  :: length\r\n\r\n    character(len=:), allocatable        :: delete\r\n    integer                              :: startpos, endpos\r\n\r\n    ! check the position\r\n    startpos = pos\r\n    endpos   = min( startpos + length - 1, len(input) )\r\n    if ( pos < 1 ) then\r\n        startpos = 1\r\n        endpos   = min( startpos + length - 1, len(input) )\r\n    endif\r\n\r\n    if ( startpos == 1 ) then\r\n        delete = input(endpos+1:)\r\n    else\r\n        delete = input(1:startpos-1) // input(endpos+1:)\r\n    endif\r\n\r\nend function delete\r\n"}, {"instruction": "Create a Fortran function named toupper that takes a string as input and returns a new string with all alphabetic characters converted to uppercase. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=len(input))'].", "input": "", "output": "function toupper( input )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=len(input))            :: toupper\r\n\r\n    integer                              :: i\r\n    integer                              :: ach\r\n    integer, parameter                   :: ascii_a         = iachar('a')\r\n    integer, parameter                   :: ascii_z         = iachar('z')\r\n    integer, parameter                   :: ascii_capital_a = iachar('a')\r\n    integer, parameter                   :: offset          = ascii_a - ascii_capital_a\r\n\r\n    toupper = input\r\n\r\n    do i = 1,len(input)\r\n        ach = iachar(toupper(i:i))\r\n        if ( ach >= ascii_a .and. ach <= ascii_z ) then\r\n            toupper(i:i) = achar(ach - offset)\r\n        endif\r\n    enddo\r\n\r\nend function toupper\r\n"}, {"instruction": "Create a Fortran function called trimx, which trims the input string based on the characters provided in the set string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=:), which is allocatable. The name of the function is \"trimx\".", "input": "", "output": "function trimx( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimx\r\n\r\n    integer                              :: start, stop\r\n\r\n    start = verify( input, set )\r\n    stop  = verify( input, set, .true. )\r\n\r\n    trimx = input(start:stop)\r\n\r\nend function trimx\r\n"}, {"instruction": "Create a Fortran function named trimxleft that takes two input arguments of type character with variable length. The function returns one output argument of type character with allocatable length. This function trims characters from the left side of the input string based on the set of characters specified in the 'set' argument. Use the imperative tone to describe the instructions for the function.", "input": "", "output": "function trimxleft( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimxleft\r\n\r\n    integer                              :: start\r\n\r\n    start = verify( input, set )\r\n\r\n    trimxleft = input(start:)\r\n\r\nend function trimxleft\r\n"}, {"instruction": "Create a Fortran function named trimxright to remove trailing characters from the input string based on the specified set of characters. The number of input arguments is 2, and the test_data type is ['character(len=*)', 'character(len=*)']. The number of output arguments is 1, and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "function trimxright( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimxright\r\n\r\n    integer                              :: stop\r\n\r\n    stop  = verify( input, set, .true. )\r\n\r\n    trimxright = input(:stop)\r\n\r\nend function trimxright\r\n"}, {"instruction": "Create a Fortran function named int_to_str that converts an integer to a string. It takes 1 input parameter of type integer. The output is a character string that is allocated dynamically.", "input": "", "output": "  function int_to_str(i) result(s)\n    implicit none\n    \n    character(:), allocatable :: s\n    integer, intent(in) :: i\n    character(range(i)+2) :: scratch\n\n    write(scratch,'(i0)') i\n    s = trim(scratch)\n  end function int_to_str\n"}, {"instruction": "Create a Fortran function named deboor to implement the De Boor algorithm for computing the value of a B-spline basis function at a given point. The function takes 4 input parameters of types integer, integer, real, and real array. The output is a real value.", "input": "", "output": "  recursive function deboor(i, k, x, t) result(db)\n    real :: db\n    integer, intent(in) :: i, k\n    real, intent(in) :: x\n    real, dimension(:), intent(in) :: t\n    real :: a1, a2\n\n    if ( k .eq. 1 ) then\n      if ( x .ne. t(size(t)) ) then\n        if ( ( x .ge. t(i) ) .and. ( x .lt. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      else\n        if ( ( x .ge. t(i) ) .and. ( x .le. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      end if\n    else\n      if ( t(i+k-1) - t(i) .ne. 0. ) then\n        a1 = ( x - t(i) ) / ( t(i+k-1) - t(i) )\n      else\n        a1 = 0.\n      end if\n      if ( t(i+k) - t(i+1) .ne. 0. ) then\n        a2 = ( t(i+k) - x ) / ( t(i+k) - t(i+1) )\n      else\n        a2 = 0.\n      end if\n      db = a1 * deboor(i, k-1, x, t) + a2 * deboor(i+1, k-1, x, t)\n    end if\n    return\n  end function deboor\n"}, {"instruction": "Write a Fortran function named checkfilesexist to check the existence of two files. The number of input arguments is 2, and the test_data type is ['character*180', 'character*180']. The number of output arguments is 1, and the test_data type is ['logical'].", "input": "", "output": "  function checkfilesexist(filename_v_nsh, filename_v_vns) result(exist)\n    character*180, intent(in)  :: filename_v_nsh\n    character*180, intent(in)  :: filename_v_vns\n    logical :: exist\n    ! locals\n    integer :: ios\n    open(9902, file=filename_v_nsh, status='old', err=88)\n    read(9902,'(//)',iostat=ios)\n    close(9902)\n    if (ios.ne.0) goto 88\n    open(9919, file=filename_v_vns, status='old', err=88)\n    read(9919,'(//)',iostat=ios)\n    close(9919)\n    if (ios.ne.0) goto 88\n    exist=.true.\n    return\n88  continue\n    exist=.false.\n    return \n  end function checkfilesexist\n"}, {"instruction": "Create a Fortran function named checkfileexists to determine if a file with a given filename exists. The function takes 1 input parameter of type character*180. The output is a logical value indicating the existence of the file. If the file exists, the output is .true.; otherwise, it is .false.", "input": "", "output": "  function checkfileexists(filename_v_vns) result(exist)\n    character*180, intent(in)  :: filename_v_vns\n    logical :: exist\n    ! locals\n    integer :: ios\n    open(9919, file=filename_v_vns, status='old', err=88)\n    read(9919,'(//)',iostat=ios)\n    close(9919)\n    if (ios.ne.0) goto 88\n    exist=.true.\n    return\n88  continue\n    exist=.false.\n    return \n  end function checkfileexists\n"}, {"instruction": "Write a Fortran function named fib to compute the Fibonacci number at position n. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "recursive function fib(n) result(f)\n  implicit none\n  integer :: f, n\n  if (n == 0) then\n    f = 0\n  else if (n < 3) then\n    f = 1\n  else\n    f = fib(n-1) + fib(n-2)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named lin_scale that takes 3 double precision input parameters (val, val_max, val_min) and returns a single double precision output. The function scales the input value val to a range between val_min and val_max using linear scaling.", "input": "", "output": "    function lin_scale(val, val_max, val_min)\n    implicit none\n        double precision    :: val, val_max, val_min\n        double precision    :: lin_scale\n        \n        lin_scale = (val-val_min)/(val_max-val_min)\n    end function\n"}, {"instruction": "Write a Fortran function named lin_scale_back that takes 3 input arguments of type double precision and returns 1 output argument of type double precision. The function's purpose is to perform linear scaling back operation, where the scaled value is rescaled to the original range using the provided maximum and minimum values.", "input": "", "output": "    function lin_scale_back(val_scaled, val_max, val_min) result(val)\n    implicit none\n        double precision    :: val_scaled, val_max, val_min\n        double precision    :: val\n        \n        val = (val_max-val_min)*val_scaled + val_min\n    end function\n"}, {"instruction": "Create a Fortran function named checkdigit to calculate a check digit for a given 6-character string. The function takes 1 input parameter of type character(6) and returns 1 output parameter of type character.", "input": "", "output": "  function checkdigit(c)\n    character :: checkdigit\n    character(6), intent(in) :: c\n    character(36) :: alpha = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n    integer, dimension(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    integer :: i, n\n\n    do i = 1, 6\n      temp(i) = index(alpha, c(i:i)) - 1\n    end do\n    temp = temp * weights\n    n = mod(10 - (mod(sum(temp), 10)), 10)\n    checkdigit = achar(n + 48)\n  end function checkdigit\n"}, {"instruction": "Write a Fortran function named compasspoint to convert a given angle in degrees to the corresponding compass point. The function takes 1 input parameter of type real. The output parameter is of type character(18).", "input": "", "output": "function compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"north             \", \"north by east     \", \"north-northeast   \", &\n             \"northeast by north\", \"northeast         \", \"northeast by east \", \"east-northeast    \", &\n             \"east by north     \", \"east              \", \"east by south     \", \"east-southeast    \", &\n             \"southeast by east \", \"southeast         \", \"southeast by south\", \"south-southeast   \", &\n             \"south by east     \", \"south             \", \"south by west     \", \"south-southwest   \", &\n             \"southwest by south\", \"southwest         \", \"southwest by west \", \"west-southwest    \", &\n             \"west by south     \", \"west              \", \"west by north     \", \"west-northwest    \", &\n             \"northwest by west \", \"northwest         \", \"northwest by north\", \"north-northwest   \", &\n             \"north by west     \"  /)\n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\n"}, {"instruction": "Create a Fortran function named clampint that takes a single input argument of type real(8). The input argument should be passed by value using the \"intent(in)\" attribute. The function should return a single output argument of type integer(1). The purpose of the function is to clamp the input real number to the range of 0 to 255. If the input is greater than 255, it should be set to 255, and if it is less than 0, it should be set to 0. The clamped value should then be converted to an integer of kind=1 and returned as the output of the function.", "input": "", "output": "    pure function clampint(color)\n        real(8), intent(in) :: color\n        integer :: v\n        integer(1) :: clampint\n\n        v = int(color*255.0d+0)\n\n        if (v > 255) then\n            v = 255\n        else if (v < 0) then\n            v = 0\n        endif\n\n        clampint = int(v, kind=1)\n    end function\n"}, {"instruction": "Create a Fortran function named imaxval that takes a three-dimensional array of double precision numbers as input. The input parameter should be declared with the intent(in) attribute. The function should return a single double precision value as the maximum value found in the input array. Use the imperative tone to provide these instructions.", "input": "", "output": "   function imaxval(var)\n     implicit none\n     double precision, dimension(:,:,:), intent(in) :: var\n     double precision :: imaxval\n     integer :: ifunr,jfunr,kfunr\n     imaxval = -1.0d100\n     !$omp target teams distribute parallel do collapse(3) reduction(max:imaxval)\n     do kfunr=1,size(var,3)\n        do jfunr=1,size(var,2)\n           do ifunr=1,size(var,1)\n              imaxval = max(imaxval, var(ifunr,jfunr,kfunr) )\n           end do\n        end do\n     end do\n     !$omp end target teams distribute parallel do     \n   end function imaxval\n"}, {"instruction": "Create a Fortran function named indx that takes three integer input parameters (ii, jj, np) and returns one integer output parameter (indx). The function computes the 'lower triangular' index for an np x np array. The test_data type is ['integer', 'integer', 'integer'] for input parameters and ['integer'] for the output parameter.", "input": "", "output": "function indx(ii,jj,np)\n  ! returns the 'lower triangular' index for an np x np array.\n  !\n  ! indx is equivalent to:\n  ! indx=0\n  ! do jj=1,np\n  !   do ii=jj,np\n  !     indx=indx+1\n  !     <some code>\n  !   enddo\n  ! enddo\n  integer :: ii,jj\n  integer :: np\n  integer :: indx\n  if (jj>ii) then\n     ! this swaps ii and jj variables without a temporary variable.\n     ii=ii+jj\n     jj=ii-jj\n     ii=ii-jj\n  endif\n  indx=(jj-1)*np+ii-(jj*(jj-1))/2\n  return\nend function indx\n"}, {"instruction": "Write a Fortran pure function named step to calculate the sum of squares of digits in an integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  pure function step(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: step,remaining\n\n    step=0\n    remaining=n\n    do while (remaining>0)\n       step=step+mod(remaining,10)**2\n       remaining=remaining/10\n    end do\n    \n  end function step\n"}, {"instruction": "Write a Fortran function named numbersonline that calculates the number of non-empty lines in the input character string. The number of input arguments is 1, and the test_data type is ['character(*)']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "function numbersonline(rec       )\n    implicit none\n!\n! global variables\n!\n    integer         :: numbersonline\n    character(*)    :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n    integer                        :: istarti\n    integer                        :: leeg\n    integer                        :: lend\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    numbersonline = 0\n    leeg = 1\n    lend = len_trim(rec)\n    do i = 1, lend\n       if (index(rec(i:i), ' ')==0) then\n          !           hier staat iets\n          if (leeg==1) then\n             leeg = 0\n             istarti = i\n             numbersonline = numbersonline + 1\n          endif\n       else\n          leeg = 1\n       endif\n    enddo\nend function numbersonline\n"}, {"instruction": "Write a Fortran function called trimtext to determine the last non-blank character in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function trimtext (string)\nimplicit none\ninteger::i,size,last\ninteger::len,trimtext\ncharacter(len=1)::char\ncharacter(len=1)::null\ncharacter(len=*)::string\n!\n!     move forward through the string, one character\n!     at a time, looking for first null character\n!\ntrimtext = 0\nsize = len(string)\nnull = char(0)\nlast = size\ndo i = 1, size\n   if (string(i:i) .eq. null) then\n      last = i - 1\n      exit\n   end if\nend do\n!\n!     move backward through the string, one character\n!     at a time, looking for first non-blank character\n!\ndo i = last, 1, -1\n   if (string(i:i) .gt. ' ') then\n      trimtext = i\n      exit\n   end if\nend do\n\nreturn\nend function trimtext\n"}, {"instruction": "Create a Fortran function named get_env to retrieve the value of an environment variable. The function takes 2 input parameters of type character(len=*) and character(len=*),optional, and returns 1 output parameter of type character(len=:),allocatable. The function retrieves the value of the specified environment variable and provides a default value if the variable is undefined or blank.", "input": "", "output": "    function get_env(name,default) result(value)\n    implicit none\n    !> name of environment variable to get the value of\n    character(len=*),intent(in)          :: name\n    !> default value to return if the requested value is undefined or blank\n    character(len=*),intent(in),optional :: default\n    !> the returned value\n    character(len=:),allocatable         :: value\n    integer                              :: howbig\n    integer                              :: stat\n    integer                              :: length\n        ! get length required to hold value\n        length=0\n        if(name.ne.'')then\n           call get_environment_variable(name, length=howbig,status=stat,trim_name=.true.)\n           select case (stat)\n           case (1)\n               !*!print *, name, \" is not defined in the environment. strange...\"\n               value=''\n           case (2)\n               !*!print *, \"this processor doesn't support environment variables. boooh!\"\n               value=''\n           case default\n               ! make string to hold value of sufficient size\n               allocate(character(len=max(howbig,1)) :: value)\n               ! get value\n               call get_environment_variable(name,value,status=stat,trim_name=.true.)\n               if(stat.ne.0)value=''\n           end select\n        else\n           value=''\n        endif\n        if(value.eq.''.and.present(default))value=default\n     end function get_env\n"}, {"instruction": "Write a Fortran function named hash_index to calculate the hash index for a given key and table size. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The test_data type for input arguments is ['integer', 'integer'], and for the output argument is ['integer'].", "input": "", "output": "function hash_index(key,n) result(indx)\n  integer::key\n  integer::n\n  integer::indx\n\n  indx = mod(key,n)\n  indx = max(indx,1)\nend function\n"}, {"instruction": "Create a Fortran function named prod to calculate the product of a series of real numbers starting from a specified value and ending at a specified integer value. The number of input arguments is 2, and the test_data type is [real, integer]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "function prod(a,b)\n  implicit none\n  real :: a,prod\n  integer :: b,i\n  prod = 1.\n  do i = 0,b-1\n     prod = prod*(a+i)\n  end do\n  return\nend function prod\n"}, {"instruction": "Write a Fortran function named a_dagger_int that takes two input parameters: an integer \"k\" and an array of integers \"state\". The output is a double precision array with the same size as \"state\".", "input": "", "output": "    function a_dagger_int(k,state) result(new_state)\n\n    \n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n    \n        !write(*,*) k,new_state\n        new_state    = state \n        new_state(k) = new_state(k) + 1\n        new_state    = sqrt(1.0*new_state(k))*new_state\n               !write(*,*) k,new_state\n    end function a_dagger_int\n"}, {"instruction": "Create a Fortran function named norm2 that calculates the Euclidean norm of a vector. There are 2 input parameters with test_data types ['integer', 'double precision, dimension(n)'], and 1 output parameter with test_data type ['double precision'].", "input": "", "output": "  function norm2 (n,x )\n    ! description :\n    ! calcul de la norme euclidienne d'un vecteur.\n    implicit none\n    ! inputs :\n    integer, intent(in)                                     :: n\n    double precision, dimension(n), intent(in)              :: x\n    ! outputs :                                           \n    double precision                                        :: norm2\n                                                            \n    ! variables :                                           \n    integer                                                 :: i\n    \n    ! calcul de la norme euclidienne\n    norm2 = 0.0d0\n    do i = 1, n\n      norm2 = norm2 + x(i)*x(i)\n    enddo\n    norm2 = sqrt(norm2)/dble(n)\n    \n    return\n  end function norm2 \n"}, {"instruction": "Create a Fortran function named t0 to calculate the reciprocal of the distance between two points in 3D space. The function takes 2 input arguments of type double precision, dimension(3), and returns 1 output argument of type double precision.", "input": "", "output": "function t0(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision :: var\n\n  double precision :: r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  var = 1.0d0 / sqrt(r2)\n\nend function t0\n"}, {"instruction": "Create a Fortran function named t1 that calculates a vector quantity based on the input vectors r_a and r_b. The number of input parameters is 2, and their test_data type is ['double precision, dimension(3)', 'double precision, dimension(3)']. The number of output parameters is 1, and the test_data type is ['double precision, dimension(3)'].", "input": "", "output": "function t1(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(3) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n  var = dr / (r*r2)\n\nend function t1\n"}, {"instruction": "Create a Fortran function named t2 to calculate the transformation matrix based on the input vectors r_a and r_b. The function takes 2 input arguments of type double precision, each with a dimension of 3. It returns 1 output argument of type double precision with a dimension of 6.", "input": "", "output": "function t2(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(6) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n\n  var(1) = 3 * dr(1) * dr(1) - r2   ! xx\n  var(2) = 3 * dr(1) * dr(2)        ! xy\n  var(3) = 3 * dr(1) * dr(3)        ! xz\n  var(4) = 3 * dr(2) * dr(2) - r2   ! yy\n  var(5) = 3 * dr(2) * dr(3)        ! yz\n  var(6) = 3 * dr(3) * dr(3) - r2   ! zz\n\n  var = var / (r*r2*r2)\n\nend function t2\n"}, {"instruction": "Write a Fortran function named foldindex that takes two integer input parameters ind and nitems. It returns an integer value as the result. This function computes the folded index, which ensures that the index is within the range of 1 to nitems by wrapping around if the index is negative or exceeds nitems.", "input": "", "output": "  function foldindex(ind, nitems) result(folded)\n    integer, intent(in) :: ind, nitems\n    integer :: folded\n\n    if (ind > 0) then\n      folded = modulo(ind - 1, nitems) + 1\n    else if (ind < 0) then\n      folded = modulo(ind, nitems) + 1\n    else\n      stop 'invalid index value'\n    end if\n    \n  end function foldindex\n"}, {"instruction": "Create a Fortran function called pr_findtimeindex to find the index in the timeseriespoints array of the next stopping time after the currenttime value. The function takes 4 input parameters of type integer, double precision array, double precision, and double precision, and returns 1 output parameter of type integer. If the stopping time is found within the specified range, it returns the index; otherwise, it returns -1.", "input": "", "output": "function pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount) result(index)\n!***************************************************************************************************************\n! find the index in the timeseriespoints array of the next stopping time after the currenttime value. \n! return -1 if none is found or if maximumtime is less than the stopping time found in the timeseriespoints \n! array.\n!***************************************************************************************************************\n!\n! specifications\n!---------------------------------------------------------------------------------------------------------------\n  implicit none\n  integer,intent(in) :: timepointscount\n  doubleprecision,dimension(timepointscount),intent(in) :: timeseriespoints\n  doubleprecision,intent(in) :: currenttime, maximumtime\n  integer :: index, n\n  doubleprecision :: t\n!---------------------------------------------------------------------------------------------------------------\n  index = -1\n  \n  if(timepointscount .lt. 1) return\n  do n = 1, timepointscount\n      if((timeseriespoints(n) .gt. currenttime) .and. (timeseriespoints(n) .le. maximumtime)) then\n          index = n\n          return\n      end if\n  end do\n\nend function pr_findtimeindex\n"}, {"instruction": "Create a Fortran function named outer3d that calculates the outer product of two 3D vectors. The function should have 2 input parameters of type double precision, dimension(3) and intent(in). The output should be a 3x3 matrix of type double precision.", "input": "", "output": "function outer3d(ri, rj)\n\n    implicit none\n\n    double precision, dimension(3), intent(in) :: ri, rj\n    double precision, dimension(3,3) :: outer3d\n\n    !write (*,*) \"ri\", ri(:3)\n    ! write (*,*) \"rj\", rj(:3)\n\n    outer3d(:3,:3) = spread(ri(:3), dim=2, ncopies=3) * spread(rj(:3), dim=1, ncopies=3)\n    ! write (*,*) \"outer[0,:3] = \", outer3d(1,1), outer3d(1,2), outer3d(1,3)\n    ! write (*,*) \"outer[1,:3] = \", outer3d(2,1), outer3d(2,2), outer3d(2,3)\n    ! write (*,*) \"outer[2,:3] = \", outer3d(3,1), outer3d(3,2), outer3d(3,3)\n\nend function outer3d\n"}, {"instruction": "Write a Fortran function named periodic_distance to calculate the distance between two points in a periodic system. The function takes 4 input parameters: two integer arrays of size 2, and two double precision values. The output is a single double precision value.", "input": "", "output": "function periodic_distance(zi, zj, r_width, c_width)\n\n    implicit none\n\n    integer, dimension(2), intent(in) :: zi\n    integer, dimension(2), intent(in) :: zj\n    double precision, intent(in) :: c_width\n    double precision, intent(in) :: r_width\n    double precision :: periodic_distance\n\n    double precision  :: dr, dc\n\n    ! row-distance\n    dr = exp(-dble(abs(zi(1) - zj(1)))/r_width)\n\n    ! column-distance\n    dc = exp(-dble(abs(zi(2) - zj(2)))/c_width)\n\n    periodic_distance = dr * dc\n\nend function periodic_distance\n"}, {"instruction": "Create a Fortran recursive function named factorial to calculate the factorial of a given integer. The function should take 1 input argument with the test_data type ['integer*8'] and return 1 output argument with the test_data type ['integer*8'].", "input": "", "output": "recursive function factorial(n)  result(fact)\n\nimplicit none\ninteger*8 :: fact\ninteger*8, intent(in) :: n\n\nif (n == 0) then\n   fact = 1\nelse\n   fact = n * factorial(n-1)\nend if\n\nend function factorial\n"}, {"instruction": "Write a Fortran function named cscalarprod to calculate the scalar product of two complex vectors. The number of input arguments is 2 and the test_data type is ['complex(kind(1d0)),dimension(0:3)', 'complex(kind(1d0)),dimension(0:3)']. The number of output arguments is 1 and the test_data type is ['complex(kind(1d0))'].", "input": "", "output": "  function cscalarprod(p1,p2)\n    implicit none\n    complex(kind(1d0))::cscalarprod\n    complex(kind(1d0)),dimension(0:3),intent(in)::p1,p2\n!    real(kind(1d0)),parameter::eps2=1d-6\n!    real(kind(1d0))::max\n    cscalarprod=p1(0)*p2(0)-p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)\n!    max=abs(p1(0)*p2(0))+abs(p1(1)*p2(1))+abs(p1(2)*p2(2))+abs(p1(3)*p2(3))\n!    if(abs(cscalarprod/max).lt.eps2)cscalarprod=dcmplx(0d0)\n  end function cscalarprod\n"}, {"instruction": "Create a Fortran function named bincount to count the occurrences of each unique element in an input integer array. The function takes 1 input parameter of type integer array with unknown size and returns 1 output parameter of type integer array with dynamic allocation.", "input": "", "output": "  function bincount(x)\r\n    integer, dimension(:), intent(in) :: x\r\n    integer, dimension(:), allocatable :: bincount\r\n\r\n    integer :: i, k\r\n\r\n    allocate(bincount(maxval(x)))\r\n    bincount = 0\r\n\r\n    do i = 1, size(x)\r\n       k = x(i)\r\n       bincount(k) = bincount(k) + 1\r\n    end do\r\n  end function bincount\r\n"}, {"instruction": "Create a Fortran function named cumsum_i to calculate the cumulative sum of an array of integers. The function takes 1 input parameter of type integer array with unspecified size, and returns 1 output parameter of type integer array with the size equal to the input array.", "input": "", "output": "  function cumsum_i(x) result (cumsum)\r\n    integer, dimension(:), intent(in) :: x\r\n    integer, dimension(size(x)) :: cumsum\r\n\r\n    integer :: i\r\n\r\n    cumsum(1) = x(1)\r\n    do i = 2, size(x)\r\n       cumsum(i) = cumsum(i - 1) + x(i)\r\n    end do\r\n  end function cumsum_i\r\n"}, {"instruction": "Create a Fortran function named l to find the index of the first positive integer in an array up to a specified position. The function takes 2 input arguments of type 'integer, dimension(:)' and 'integer'. The output is a single integer.", "input": "", "output": "function l(a,j)\n  implicit none\n\n  integer, dimension(:), intent(in) :: a\n  integer :: l,j,i,k\n\n  do i=1,j\n    k=a(i)\n    if (k>0) exit\n  end do\nl=i\nend function l\n"}, {"instruction": "Create a Fortran function named get_len that takes a single input argument of type character(len=*) and returns an integer. This function calculates the length of the input string and returns the result as an integer.", "input": "", "output": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    get_len = 0\n    do while (string(get_len+1:get_len+1)/=' ')\n      get_len = get_len+1\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named equalto to compare two double precision floating-point numbers for approximate equality. The function takes 3 input parameters of type double precision, where the third parameter is optional. The output is a logical value indicating whether the two numbers are approximately equal.", "input": "", "output": "function equalto(a, b, abs_tol) result(equal_to)\n    !> check if two floats are almost equal.\n    !> a - first float.\n    !> b - other float.\n    !> abs_tol - absolute toleranace.\n    \n    ! input\n    double precision, intent(in) :: a, b\n    double precision, intent(in), optional :: abs_tol\n    \n    ! output\n    logical :: equal_to\n    \n    ! working\n    double precision :: atol, diff\n    \n    ! in case they are exact.\n    if (a .eq. b) then\n        equal_to = .true.\n        return\n    end if\n    \n    ! set defaults.\n    atol = 1.0d-8\n    if (present(abs_tol)) then\n        atol = abs_tol\n    end if\n    \n    diff = dabs(b - a)\n    ! absolute comparison.\n    if (diff .le. atol) then\n        equal_to = .true.\n        return\n    end if\n    equal_to = .false.\nend function equalto\n"}, {"instruction": "Create a Fortran function named replace_text to replace all occurrences of a specified text within a string with another text. The function takes 3 input arguments of type character(*), representing the original string, the text to be replaced, and the replacement text. It returns 1 output argument of type character(len=len(str)) which holds the modified string.", "input": "", "output": "   function replace_text(str, text, rep) result(outs)\n      character(*) :: str, text, rep\n      character(len=len(str)) :: outs\n      integer :: i, nt, nr\n\n      outs = str\n      nt = len_trim(text)\n      nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt))\n         if (i == 0) exit\n         outs = outs(:i-1) // rep(:nr) // outs(i+nt:)\n      end do\n   end function replace_text\n"}, {"instruction": "Create a Fortran function called smoothstep1 that takes a single real input argument. The function returns a single real output, computed as x*x*(3-2*x). The number of input arguments is 1, and the test_data type is ['real']. The number of output arguments is 1, and the test_data type is ['real'].", "input": "", "output": "  pure function smoothstep1 (x)\n    implicit none\n    real :: smoothstep1\n    real, intent (in) :: x\n    smoothstep1 = x*x*(3-2*x)\n  end function smoothstep1\n"}, {"instruction": "Create a Fortran function named pascaltriangle that calculates a specific value in Pascal's triangle based on the provided inputs. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  pure function pascaltriangle (a,b)\n    implicit none\n    integer :: pascaltriangle\n    integer, intent (in) :: a,b\n    integer i\n    pascaltriangle = 1\n    do i = 0, b-1\n      pascaltriangle = pascaltriangle*(a-i)/(i+1)\n    end do\n  end function pascaltriangle\n"}, {"instruction": "Create a Fortran function named random_int to generate a random integer within a specified range. The function should have 2 input parameters of type integer, value, and the test_data type is ['integer ,value', 'integer ,value']. The function should have 1 output parameter of type integer, and the test_data type is ['integer'].", "input": "", "output": "    function random_int(from_val, to_val) result(r_int)\n        implicit none\n        integer ,value :: from_val, to_val\n        integer ::  r_int\n        real :: r\n        \n        call random_number(r)\n        r_int = int(from_val + r*(to_val - from_val))\n    end function random_int\n"}, {"instruction": "Create a Fortran function named notinlist to determine if an integer value is not present in an array of integers. The function takes 3 input parameters: two integers and an array of integers with dimension n. The output parameter is a logical value. If the integer is not found in the array, the logical value is set to true; otherwise, it is set to false.", "input": "", "output": "  function notinlist(l,p,n) result(notinit)\r\n    integer  :: l,n\r\n    integer, dimension(n) :: p\r\n\r\n    logical  :: notinit\r\n\r\n    integer  :: i\r\n\r\n    notinit = .true.\r\n    if (n.eq.0) then\r\n        notinit = .true.\r\n    else\r\n        do i = 1,n\r\n            if (p(i).eq.l) notinit = .false.\r\n        end do\r\n    end if\r\n\r\n  end function notinlist\r\n"}, {"instruction": "Create a Fortran function named io_str_get_num_tokens to count the number of tokens in a given string. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type integer.", "input": "", "output": "function io_str_get_num_tokens(str)\n  implicit none\n\n  integer                       ::  io_str_get_num_tokens\n  character(len=*), intent(in)  ::  str\n\n  character(len=1), parameter ::  space = ' '\n  integer ::  i, j, strlen\n\n  ! if we assume that we have used str_shrink before then we can just count the spaces..\n  strlen = len_trim(str)\n  io_str_get_num_tokens = 1 ! always n-1 spaces to n tokens\n  i = 1 ! get into loop\n  j = 1\n  do while (i .gt. 0)\n    i = index(str(j:strlen), space)\n    j = j+i\n    if (i .gt. 0) io_str_get_num_tokens = io_str_get_num_tokens + 1\n  end do\nend function io_str_get_num_tokens\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_animation_new_from_stream to create a new animation from a stream. The function takes 3 input parameters of type 'type(c_ptr), value' for the stream, cancellable, and error. It returns 1 output parameter of type 'type(c_ptr)'.", "input": "", "output": "function gdk_pixbuf_animation_new_from_stream(stream, cancellable, error) bind(&\n&c) \n  use iso_c_binding, only: c_ptr\n  type(c_ptr) :: gdk_pixbuf_animation_new_from_stream\n  type(c_ptr), value :: stream\n  type(c_ptr), value :: cancellable\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_scale_simple that takes 4 input parameters of type c_ptr, integer(c_int), integer(c_int), and integer(c_int) as values. The function returns a single output parameter of type c_ptr. This function is intended to scale a GDK Pixbuf image to the specified width and height using the specified interpolation type.", "input": "", "output": "function gdk_pixbuf_scale_simple(src, dest_width, dest_height, interp_type) bin&\n&d(c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: gdk_pixbuf_scale_simple\n  type(c_ptr), value :: src\n  integer(c_int), value :: dest_width\n  integer(c_int), value :: dest_height\n  integer(c_int), value :: interp_type\nend function\n"}, {"instruction": "Create a Fortran function named gdk_pixbuf_new_from_inline to interface with C code. The function takes 4 input parameters of types integer(c_int), type(c_ptr), integer(c_int), and type(c_ptr) as specified. The output is a single parameter of type type(c_ptr).", "input": "", "output": "function gdk_pixbuf_new_from_inline(data_length, data, copy_pixels, error) bind&\n&(c) \n  use iso_c_binding, only: c_ptr, c_int\n  type(c_ptr) :: gdk_pixbuf_new_from_inline\n  integer(c_int), value :: data_length\n  type(c_ptr), value :: data\n  integer(c_int), value :: copy_pixels\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named toupper, which converts all lowercase letters in a given string to uppercase. The function takes 1 input parameter of type character(*) and returns 1 output parameter of type character(len(str)).", "input": "", "output": "elemental function toupper(str)\n!! ascii letters to uppercase\ncharacter(*), intent(in) :: str\ncharacter(len(str)) :: toupper\ncharacter(*), parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\", &\n                            upper=\"abcdefghijklmnopqrstuvwxyz\"\ninteger :: i,j\n\ntoupper = str\n\n!do concurrent (i = 1:len(str))  ! fixme: flang\ndo i = 1,len(str)\n  j = index(lower,str(i:i))\n  if (j > 0) toupper(i:i) = upper(j:j)\nend do\n\nend function toupper\n"}, {"instruction": "Create a Fortran function named cyc to determine if the iterator is a multiple of the cycle_size. The function should take 2 input arguments of type integer, and the test_data type should be ['integer', 'integer']. It should return 1 output argument of type logical, and the test_data type should be ['logical'].", "input": "", "output": "    function cyc(iterator,cycle_size)\n        implicit none\n        integer, intent(in) :: iterator\n        integer, intent(in) :: cycle_size\n        logical :: cyc\n\n        if(cycle_size<=0) then\n            cyc = .false.\n        else\n            cyc = mod(iterator,cycle_size)==0\n        end if\n\n    end function cyc\n"}, {"instruction": "Create a Fortran function named func to increment the input integer by one. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The function should be used with the imperative tone.", "input": "", "output": "    function func (n) result (rc)\n    !$acc routine\n    integer, intent (in) :: n\n    integer :: rc\n\n    rc = n\n    rc = rc + 1\n\n    end function\n"}, {"instruction": "Create a Fortran function named curl_easy_perform to execute a single transfer with the given handle. The function takes 1 input parameter of type c_ptr and returns 1 output parameter of type integer(c_int).", "input": "", "output": "     function curl_easy_perform(handle) &\n          bind(c, name=\"curl_easy_perform\")\n       use iso_c_binding, only: c_int, c_ptr\n       type(c_ptr), value :: handle\n       integer(c_int) :: curl_easy_perform\n     end function curl_easy_perform\n"}, {"instruction": "Create a Fortran function named lacz_gamma to calculate the gamma function of a given real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    ! these precomputed values are taken by the sample code in wikipedia,\n    ! and the sample itself takes them from the gnu scientific library\n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n"}, {"instruction": "Write a Fortran function named strcmp that compares two strings and returns an integer value. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  function strcmp(string1, string2)\n    !\n    ! compares two strings, a-la c\n    !\n    integer :: strcmp\n    character(*) :: string1\n    character(*) :: string2\n\n    if (lgt(trim(string1), trim(string2))) then\n       strcmp = 1\n    else if (lgt(trim(string2), trim(string1))) then\n       strcmp = -1\n    else\n       strcmp = 0\n    end if\n  end function strcmp\n"}, {"instruction": "Create a Fortran function called true2 that takes in 4 input parameters of type double precision, double precision, integer, and integer. The function should return a single output of type double precision. The function computes the value of (1-x)^5 + y^5 and assigns it to the output variable true2.", "input": "", "output": "function true2(x,y,comp,eigen)\nimplicit none\ndouble precision, intent(in) :: x,y\ninteger, intent(in) :: comp,eigen\ndouble precision :: true2\ntrue2 = (1-x)**5 + y**5\nend function true2\n"}, {"instruction": "Write a recursive Fortran function named ackermann to calculate the Ackermann function. The function takes 2 input parameters, both of type integer, and returns 1 output parameter of type integer. The input test_data type is ['integer', 'integer'], and the output test_data type is ['integer'].", "input": "", "output": "  recursive function ackermann(m, n) result(ack)\n    integer :: ack, m, n\n\n    if (m == 0) then\n      ack = n + 1\n    else if (n == 0) then\n      ack = ackermann(m - 1, 1)\n    else\n      ack = ackermann(m - 1, ackermann(m, n - 1))\n    end if\n  end function ackermann\n"}, {"instruction": "Write a Fortran function named \"wr\" to calculate the value of \"wr\" based on the input parameter \"nr\", which is of type real(8). The function should return a real(8) value.", "input": "", "output": "pure function wr(nr)\n    real(8), intent(in) :: nr\n    real(8) :: wr\n    wr = 0.0\n    if (nr <= 1.0) then\n        wr = 1.0 - nr\n    endif\nend function\n"}, {"instruction": "Create a Fortran function named freefall to calculate the velocity of an object in free fall from a given height. The function should take 1 input parameter of type real and return 1 output parameter of type real. The input parameter represents the height from which the object is falling, and the output parameter represents the velocity of the object in free fall. Use the formula: velocity = square root of (2 * g * height), where g is the gravitational acceleration. Remember to use the \"return\" statement to return the computed velocity.", "input": "", "output": "function freefall(high)\r\n\timplicit none\r\n\treal,parameter :: g = 9.80665\r\n    real :: high\r\n\treal :: freefall\r\n\tfreefall = (2 * g * high) ** 0.5\r\n\treturn\r\nend function\r\n"}, {"instruction": "Create a Fortran function named circarea to calculate the area of a circle based on the provided radius. The function takes 1 input parameter of type real and returns 1 output parameter of type real. Use the formula area = pi * radius * radius to calculate the area.", "input": "", "output": "  function circarea(radius) result(area)\n    real,intent(in)::radius\n    real::area\n    \n    area = pi * radius * radius\n    return\n  end function circarea\n"}, {"instruction": "Create a Fortran function named circperi to calculate the circumference of a circle. The function takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter represents the radius of the circle, and the output parameter stores the calculated circumference.", "input": "", "output": "  function circperi(radius) result(circumference)\n    real,intent(in)::radius\n    real::circumference\n    \n    circumference = 2 * pi * radius\n    return\n  end function circperi\n"}, {"instruction": "Create a Fortran function named trs2a2 that takes in 5 input parameters: two real matrices of dimensions 1:m, an integer j, an integer k, and an integer m. The function returns a real matrix of dimensions 1:m. The function calculates an intermediate transition matrix starting from k without descending below j, using the formula r = iju(i-ik)dij, with ii = deltajj, where j >= i. The function uses nested loops to perform the computation and assigns the result to the output matrix trs2a2.", "input": "", "output": "      function trs2a2 (j, k, u, d, m)\n!      matrice de transition intermediaire, partant de k sans descendre\n!      sous j. r = iju(i-ik)dij, avec ii = deltajj, j >= i.\n!      alternative: trs2a2 = 0\n!                   trs2a2 (j:k-1, j:k-1) = matmul (utrsft (j:k-1,j:k-1),\n!                                                   dtrsft (j:k-1,j:k-1))\n!\n      real, dimension (1:m,1:m) :: trs2a2  ! resultat\n      real, dimension (1:m,1:m) :: u, d    ! matrices utrsft, dtrsft\n      integer, intent (in)      :: j, k, m ! niveaux vallee pic\n!\n!##### following line replaced by prentice to make less system dependent\n!      real (kind = kind (1.0d0)) :: dtmp\n      real (kind = selected_real_kind (10,50)) :: dtmp\n!\n      trs2a2 = 0.0\n      do iclw1 = j, k - 1\n         do iclw2 = j, k - 1\n            dtmp = 0.0d0\n            do iclww = j, k - 1\n               dtmp = dtmp + u (iclw1, iclww) * d (iclww, iclw2)\n            enddo\n            trs2a2 (iclw1, iclw2) = dtmp\n         enddo\n      enddo\n      return\n      end function trs2a2\n"}, {"instruction": "Create a Fortran function named is_leap_year to determine if a given year is a leap year. The function takes 2 input parameters, an integer \"year\" and an optional logical \"has_error\". The output is a logical value indicating whether the input year is a leap year.", "input": "", "output": "    function is_leap_year(year, has_error) result(is_leap)\n        implicit none\n        integer, intent(in) :: year\n        logical, optional, intent(out) :: has_error\n        logical :: is_leap\n\n        if (present(has_error)) then\n            has_error = year <= 1582\n        end if\n        if (mod(year, 4) == 0) then\n            if (mod(year, 100) == 0) then\n                if (mod(year, 400) == 0) then\n                    is_leap = .false.\n                else\n                    is_leap = .true.\n                end if\n            else\n                is_leap = .true.\n            end if\n        else\n            is_leap = .false.\n        end if\n    end function is_leap_year\n"}, {"instruction": "Create a Fortran function named aave to calculate the area mean of a two-dimensional real array in Cartesian coordinates. This function should have 1 input parameter of type real, dimension(:,:), and intent(in), and 1 output parameter of type real.", "input": "", "output": "function aave(f) result(res)\n  !   calculation of area mean (res) of field f in cartesian coordinates.\n  !   simplest possible way.\n  !\n  real,dimension(:,:),intent(in) :: f\n  real :: res,sum,wsum\n  integer :: i,j,nlon,nlat\n  nlon=size(f,1)\n  nlat=size(f,2)\n\n  sum=0\n  wsum=0\n  do j=1,nlat\n     do i=1,nlon\n        sum=sum+f(i,j)\n        wsum=wsum+1.\n     enddo\n  enddo\n  res=sum/wsum\n\nend function aave\n"}, {"instruction": "Write a Fortran function named p2der that estimates the second pressure derivatives of a three-dimensional real array at different levels. The function takes 2 input parameters of type real, dimension(:,:,:), and real, and returns 1 output parameter of type real, dimension(:,:,:), allocatable.", "input": "", "output": "function p2der(f,dp) result(df2dp2)\n  !   estimation of second pressure derivatives.\n  !   at top and bottom levels, these are set to zero\n  !\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),allocatable :: df2dp2\n  real,intent(in) :: dp\n  integer :: nlon,nlat,nlev,c,k\n\n  nlon=size(f,1)\n  nlat=size(f,2)\n  nlev=size(f,3)\n  allocate(df2dp2(nlon,nlat,nlev))\n  c=1\n  select case(c)\n\n  case(1)\n     df2dp2(:,:,2:nlev-1)=(f(:,:,3:nlev)+f(:,:,1:nlev-2) &\n          -2*f(:,:,2:nlev-1))/(dp*dp)\n     df2dp2(:,:,1)=0.\n     df2dp2(:,:,nlev)=0.\n  case(2)\n     do k=3,nlev-2\n        df2dp2(:,:,k)=(-1./12.)*f(:,:,k-2)+(4./3.)*f(:,:,k-1)&\n             -(5./2.)*f(:,:,k)+(4./3.)*f(:,:,k+1)-(1./12.)*f(:,:,k+2)\n        df2dp2(:,:,k)=df2dp2(:,:,k)/(dp*dp)\n     enddo\n     df2dp2(:,:,2)=(f(:,:,3)+f(:,:,1)-2.*f(:,:,2))/(dp*dp)\n     df2dp2(:,:,nlev-1)=(f(:,:,nlev)+f(:,:,nlev-2)-2.*f(:,:,nlev-1))/(dp*dp)\n     df2dp2(:,:,1)=0.\n     df2dp2(:,:,nlev)=0.\n  end select\nend function p2der\n"}, {"instruction": "Create a Fortran function named binomial to calculate the binomial coefficient using the given input parameters. The number of input arguments is 2, and the test_data type is ['integer(kind=16)', 'integer(kind=16)']. The number of output arguments is 1, and the test_data type is ['integer(kind=16)'].", "input": "", "output": "  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n"}, {"instruction": "Create a Fortran function named nextdiffid that takes 3 input parameters: an integer, an array of real numbers with dimension n, and a logical array with dimension n. The function returns an integer representing the position of the minimum value in the input array, excluding the elements marked as 'true' in the logical array.", "input": "", "output": "function nextdiffid(dist,n,checksecondary)\n! find the minimum value in dist skipping the vertex checked yet and returns\n! its position (id)\n\n  integer :: nextdiffid,n\n  real, dimension(n) :: dist\n  logical, dimension(n) :: checksecondary\n\n  integer :: i\n  real :: vmin\n\n  nextdiffid=0\n  vmin=infinity\n  do i=1,n\n     if (checksecondary(i)) cycle\n     if (dist(i) < vmin) then\n        vmin=dist(i)\n        nextdiffid=i\n     endif\n  enddo\n  return\nend function nextdiffid\n"}, {"instruction": "Create a Fortran function named dplane that computes the position of a point in a plane based on geometric calculations. The function takes 5 input parameters of type real: d12, d13, d23, r1, r2, and returns 1 output parameter of type real.", "input": "", "output": "function dplane(d12,d13,d23,r1,r2)\n\n  real :: dplane,d12,d13,d23,r1,r2\n\n  real :: x,y,xc,yc\n  real :: dr,xn,yn,dn,d13n,d23n\n\n! position of v3\n  x=(d12**2-d23**2+d13**2)/(2*d12)\n  y=sqrt(max(d13**2-x**2,0.))\n! difference of distance at the base\n  dr=abs(r1-r2)\n! computation of the new base length\n  dn=sqrt(d12**2.-dr**2.)\n  if (r1 < r2) then\n! case where v2 remains and v1 is changed\n     xn=(d12**2-dn**2+dr**2)/(2*d12)\n     yn=(sqrt(max(dr**2-xn**2,0.)))\n     d13n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23**2+d13n**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13n**2-x**2,0.))\n        dplane=r2+y\n     else\n        dplane=infinity\n     endif\n  else\n! case where v1 remains and v2 is changed\n     xn=(d12**2-dr**2+dn**2)/(2*d12)\n     yn=(sqrt(max(dn**2-xn**2,0.)))\n     d23n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23n**2+d13**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13**2-x**2,0.))\n        dplane=r1+y\n     else\n        dplane=infinity\n     endif\n  endif\nend function dplane\n"}, {"instruction": "Create a Fortran function named strip_comments that takes two input arguments of type character(len=*) and character(len=1) and returns one output argument of type character(len=len(str)). The function removes any comments indicated by the specified comment character from the input string and returns the modified string.", "input": "", "output": "\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c !comment character\n\t character(len=len(str)) :: str2\n\t\n\t integer :: i\n\t\n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t\n\t end function strip_comments\n"}, {"instruction": "Create a Fortran function named std that calculates the standard deviation for each row of a 2D array of real(8) numbers. The function takes 2 input parameters: a 2D array of real(8) numbers with unspecified dimensions and an integer representing the number of columns. It returns 1 output parameter, a 1D array of real(8) numbers with a size equal to the number of rows in the input array.", "input": "", "output": "    function std(x, n)\n        real(8), dimension(:,:), intent(in) :: x\n        integer, intent(in) :: n\n        real(8), dimension(n) :: std\n        real(8), dimension(n) :: mean\n        integer :: s, i\n        s = size(x, 2)\n        do i=1,n\n            mean(i) = sum(x(i,:)) / s\n            std(i) = sqrt(sum((x(i,:) - mean(i))**2)) / s\n        end do\n    end function std\n"}, {"instruction": "Create a Fortran function named arg that takes an integer input argument and returns an allocatable character string. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable']. This function retrieves a command line argument based on the input integer index and assigns it to the allocatable character string.", "input": "", "output": "    function arg(i)\n        integer, intent(in) :: i\n        character(len=:), allocatable :: arg\n        integer :: len\n\n        call get_command_argument(i, arg, len)\n        allocate(character(len=len) :: arg)\n        call get_command_argument(i, arg, len)\n    end function\n"}, {"instruction": "Create a Fortran function named findface to determine the face of a unit cube that a given point (x, y, z) lies on. The function takes 3 input arguments of type double precision (x, y, z) and returns 1 output argument of type integer (face) indicating the face of the cube that the point lies on.", "input": "", "output": "  function findface(x, y, z) result(face)\r\n  implicit none\r\n  doubleprecision,intent(in) :: x, y, z\r\n  integer :: face\r\n  \r\n  face = 0\r\n  if(x .eq. 0.0d0) then\r\n      face = 1\r\n  else if(x .eq. 1.0d0) then\r\n      face = 2\r\n  else if(y .eq. 0.0d0) then\r\n      face = 3\r\n  else if(y .eq. 1.0d0) then\r\n      face =4\r\n  else if(z .eq. 0.0d0) then\r\n      face = 5\r\n  else if(z .eq. 1.0d0) then\r\n      face = 6\r\n  end if\r\n  \r\n  end function findface\r\n"}, {"instruction": "Create a Fortran function named area to calculate the area of a triangle using the given three sides. The function should have 3 input parameters of type real, and the test_data type is ['real', 'real', 'real']. It should have 1 output parameter of type real, and the test_data type is ['real'].", "input": "", "output": "function area(x, y, z) result(res)\n    implicit none\n    real :: res\n    real, intent(in) :: x, y, z\n    real :: theta, height\n    theta = acos((x**2 + y**2 - z**2)/(2.0*x*y))\n    height = x*sin(theta)\n    res = 0.5*y*height\nend function area\n"}, {"instruction": "Write a Fortran function named frind that takes 3 integer arguments as input, denoted as i, j, and n. The function calculates a result of type integer and returns it. The input arguments are of type integer, and the output parameter is also of type integer.", "input": "", "output": "function frind(j,i,n) result(res)\n  implicit none\n\n  integer, intent(in) :: i,j,n\n  integer :: res\n\n  res = i + (j-1)*(2*n - j)/2\n\nend function frind\n"}, {"instruction": "Write a Fortran function named dot_product_arr to calculate the dot product of two arrays of double-precision real numbers. The function takes 2 input arguments of type real(kind=8), dimension(:,:), and returns 1 output argument of type real(kind=8), dimension(size(a,1)).", "input": "", "output": "       pure function dot_product_arr(a,b) result(dot)\n       real(kind=8), dimension(:,:), intent(in) :: a,b\n       real(kind=8), dimension(size(a,1)) :: dot\n       integer :: i\n       dot=0d0\n       do i=1,size(a,2); dot=dot+a(:,i)*b(:,i); enddo\n       end function dot_product_arr\n"}, {"instruction": "Create a Fortran function named cum_sum to calculate the cumulative sum of an array up to a specified index. The function takes 2 input parameters of type real(kind=8), dimension(:) and integer, and returns 1 output parameter of type real(kind=8), dimension(size(x)).", "input": "", "output": "       function cum_sum(x,cumu)\n       real(kind=8), intent(in), dimension(:) :: x\n       real(kind=8), dimension(size(x)) :: cum_sum\n       integer :: i\n       integer, intent(in) :: cumu\n       do i=1,size(x)\n         cum_sum(i)=sum(x(1:i))\n       enddo\n       end function cum_sum\n"}, {"instruction": "Create a Fortran function named std to calculate the standard deviation of a list of real numbers. The function should take 2 input parameters, where the first parameter is an integer and the second parameter is an array of real numbers. The output should be a single real number representing the standard deviation. Remember to use real,dimension(n) to indicate that the second input parameter is an array of real numbers with a length specified by the first input parameter.", "input": "", "output": "function std(list,n)\nimplicit none\n!--\ninteger               :: n\nreal,dimension(n)     :: list\n!--\ninteger               :: i\nreal                  :: var,std,mean\n!--\nvar=0.0d0\nmean=sum(list)/(real(n)+1.0e-20)\n!--\ndo i=1, n\n    var=var+(list(i)-mean)**2\nend do\n!--\nstd=sqrt((var)/(real(n)+1.0e-20))\n!--\nreturn\nend function\n"}, {"instruction": "Write a Fortran function named cov to calculate the covariance between two sets of data. The function takes 3 input parameters: an integer n, and two arrays of real numbers x and y, both of size n. The function returns a single real number as the output, representing the covariance. Remember to use the imperative tone for the instructions.", "input": "", "output": "function cov(x,y,n)\nimplicit none\n!--\ninteger                :: n\nreal,dimension(n)      :: x,y\nreal                   :: cov\n!--\nreal                   :: x_mean,y_mean\nreal                   :: c\ninteger                :: i\n!--\nx_mean=sum(x)/(real(n)+1.0e-20)\ny_mean=sum(y)/(real(n)+1.0e-20)\n!--\nc=0.0d0\n!--\ndo i=1,n\n    c=c+(x(i)-x_mean)*(y(i)-y_mean)\nend do\ncov=c/((n-1)+1.0e-20)\n!--\nreturn\n!--\nend function cov\n"}, {"instruction": "Create a Fortran function named predicate to determine if a triangle with side lengths represented by integer inputs is a Pythagorean triple. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 1 and the test_data type is [logical].", "input": "", "output": "  pure function predicate(a,b,c)\n    implicit none\n    integer, intent(in) :: a,b,c\n    real*16             :: path1,path2,path3,best_path\n    logical             :: predicate\n\n    path1=sqrt(dble((a+b)**2 + c**2))\n    path2=sqrt(dble((a+c)**2 + b**2))\n    path3=sqrt(dble((b+c)**2 + a**2))\n    best_path=min(path1,min(path2,path3))\n\n    predicate=(mod(best_path,1.0)==0.0)\n    \n  end function predicate\n"}, {"instruction": "Create a Fortran function named foo that takes an integer input argument. The function should return an array of integers of the same length as the input argument. The input argument type should be integer(4), and the output argument type should be integer(4), allocatable, dimension(:).", "input": "", "output": "  function foo (n) result(res)\n    integer(4), allocatable, dimension(:) :: res\n    integer(4) :: n\n    allocate (res(n))\n    res = [((i + 15), i = 1, n)]\n  end function foo\n"}, {"instruction": "Write a Fortran function named fomp_get_ancestor_thread_num that takes one integer input parameter. The function returns an integer value and is intended to obtain the thread number of the ancestor at a specified level.", "input": "", "output": "function fomp_get_ancestor_thread_num(level)\n\n    implicit none\n\n    !f2py threadsafe\n\n    integer, intent(in) :: level\n    integer :: fomp_get_ancestor_thread_num\n    if (.false.) print *, level\n\n    fomp_get_ancestor_thread_num = -1\n\nend function fomp_get_ancestor_thread_num\n"}, {"instruction": "Create a Fortran function named dot that calculates the dot product of two vectors. The function takes 3 input parameters: an integer*4, an array of real*8 with dimension n, and another array of real*8 with dimension n. The output parameter is a real*8.", "input": "", "output": "function dot(a,b,n)\n  ! compute the dot product of a and b\n    implicit none\n    real*8 :: dot ! return  value\n  !-----------------------------------------------\n\n    integer*4              , intent(in)    :: n\n    real*8   , dimension(n), intent(in)    :: a,b\n  !-----------------------------------------------\n  ! declare local variables\n    integer*4 :: i\n  !-----------------------------------------------'\n    dot = 0.\n    do i=1,n\n        dot = dot + a(i) * b(i)\n    end do\nend function dot\n"}, {"instruction": "Create a Fortran function named sameedgedifferentpolygon to compare edges of different polygons. The function takes 4 input parameters of types integer, integer, real(kind(0d0)),dimension(0:3,3,96), and real(kind(0d0)),dimension(0:3,3,96). The output parameter is of type logical. The function checks if the edges of two polygons are the same and returns a logical value.", "input": "", "output": "   function sameedgedifferentpolygon(j,i,edge,edge2) result (sedp)\n\n     implicit none\n     logical :: sedp\n     integer :: j,i\n     real(kind(0d0)),dimension(0:3,3,96) :: edge, edge2\n\n     sedp = all(edge(:,1:2,j).eq.edge2(:,1:2,i)).or.     &\n            (all(edge(:,1,j).eq.edge2(:,2,i)).and.         &\n             all(edge(:,2,j).eq.edge2(:,1,i)))\n\n   end function sameedgedifferentpolygon\n"}, {"instruction": "Write a Fortran function named nextedgesamepolygon to compare two sets of edges from polygons. The function takes 4 input parameters of type integer, integer, real(kind(0d0)),dimension(0:3,3,96), and real(kind(0d0)),dimension(0:3,3,96). The output is a single logical value.", "input": "", "output": "   function nextedgesamepolygon(j,i,edge,edge2) result (nesp)\n\n     implicit none\n     logical :: nesp\n     integer :: j,i\n     real(kind(0d0)),dimension(0:3,3,96) :: edge, edge2\n\n     nesp = ((all(edge(:,1,j).eq.edge2(:,1,i)).or.       &\n              all(edge(:,1,j).eq.edge2(:,2,i))).and.       &\n             all(edge(:,3,j).eq.edge2(:,3,i)))\n\n   end function nextedgesamepolygon\n"}, {"instruction": "Write a Fortran function named \"istep\" to compute the Heaviside step function for a given real(8) input value. The number of input arguments is 1, and the test_data type is [real(8)]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "  elemental function istep(x) result(out)\n    real(8),intent(in) :: x\n    real(8)            :: out\n    if(x < 0.d0) then\n       out = 1.0d0\n    elseif(x==0.d0)then\n       out = 0.50d0\n    else\n       out = 0.0d0\n    endif\n  end function istep\n"}, {"instruction": "Create a Fortran function called random_normal that generates a random number from a normal distribution with a given mean and standard deviation. The function should have 2 input parameters of type real(8) for mean and standard deviation, and 1 output parameter of type real(8) for the generated random number.", "input": "", "output": "  function random_normal(mean,stdev) result(c)\n\n    real(8), intent(in) :: mean,stdev\n    real(8)             :: c, r, theta\n    real(8)             :: temp(2)\n    real(8), parameter  :: pi = 4.d0*datan(1.d0)\n\n    call random_number(temp)\n\n    r = (-2.0d0*log(temp(1)))**0.5    \n    theta = 2.0d0*pi*temp(2)\n\n    c = mean+stdev*r*sin(theta)\n\n  end function random_normal\n"}, {"instruction": "Create a Fortran function named generate_rand_int that returns a random integer within a specified range. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The input argument specifies the upper limit of the range from which the random integer will be generated.", "input": "", "output": "  function generate_rand_int(out_of)\n\n    implicit none\n    integer, parameter :: dp=selected_real_kind(15,300)\n    real(kind=dp) :: rand\n    integer :: generate_rand_int\n    integer :: out_of\n\n    call random_number(rand)\n    generate_rand_int=ceiling(real(out_of,dp)*rand)\n\n  end function generate_rand_int\n"}, {"instruction": "Create a Fortran function named map2d that takes an integer and an array of real(8) numbers as input. The number of input arguments is 2 and the test_data type is ['integer', 'real(8), dimension(:)']. The function should output a 3x3 array of real(8) numbers. The number of output arguments is 1 and the test_data type is ['real(8), dimension(1:3,1:3)']. The function reshapes the input array and populates the 3x3 array based on specific calculations.", "input": "", "output": "      function map2d(a,ntens)\n        implicit none\n        real(8),  dimension(1:3,1:3) :: map2d\n        integer, intent(in) :: ntens\n        real(8), intent(in), dimension(:) :: a\n        real(8),dimension(1:6) :: b = 0\n        b(1:ntens) = a(1:ntens)\n        map2d = reshape( [b(1), b(4)/2, b(5)/2, &\n               b(4)/2,b(2),b(6)/2, b(5)/2,b(6)/2, b(3)],[3,3] )\n      end function map2d\n"}, {"instruction": "Create a Fortran function named map2stress that takes a 3x3 array of real(8) numbers and an integer as input. The number of input arguments is 2, and the test_data type is ['real(8), dimension(1:3,1:3)', 'integer']. The function returns a 1D array of real(8) numbers with a length specified by the input integer. The number of output arguments is 1, and the test_data type is ['real(8), dimension(1:ntens)']. The function calculates the stress components from the input 3x3 array and returns the specified number of stress components.", "input": "", "output": "      function map2stress(a,ntens)\n        implicit none\n        real(8), intent(in), dimension(1:3,1:3) :: a\n        integer, intent(in) :: ntens\n        real(8),  dimension(1:ntens) :: map2stress\n        real(8), dimension(1:6) :: b\n        b = [a(1,1),a(2,2),a(3,3),a(1,2),a(1,3),a(2,3)]\n        map2stress = b(1:ntens)\n      end function map2stress\n"}, {"instruction": "Create a Fortran function named map2t that takes an integer and an array of real(8) as input, and returns a 3x3 array of real(8). The input parameters should be of type integer and real(8) array, while the output parameter should be a 3x3 array of real(8). The function should reshape the input array and assign specific elements of it to a new array, which is then reshaped into a 3x3 array and returned.", "input": "", "output": "      function map2t(a,ntens)\n        implicit none\n        real(8),  dimension(1:3,1:3) :: map2t\n        integer, intent(in) :: ntens\n        real(8), intent(in), dimension(:) :: a\n        real(8), dimension(1:6) :: b= 0\n        b(1:ntens) = a(1:ntens)\n        map2t = reshape( [b(1),b(4),b(5), &\n            b(4),b(2),b(6),  b(5),b(6),b(3) ],[3,3] )\n      end function map2t\n"}, {"instruction": "Write a Fortran function named inv33 to calculate the inverse of a 3x3 matrix. The function should take one input parameter of type real(8), dimension(3,3) and return one output parameter of type real(8), dimension(3,3).", "input": "", "output": "      function inv33( a )  !==================contained in get_increment\n      implicit none\n      real(8), dimension(3,3), intent(in) :: a\n      real(8), dimension(3,3) :: b\n      real(8), dimension(3,3) :: inv33\n      real(8) :: det\n      det = - a(1,3)*a(2,2)*a(3,1) + a(1,2)*a(2,3)*a(3,1) + &\n               a(1,3)*a(2,1)*a(3,2) - a(1,1)*a(2,3)*a(3,2) - &\n               a(1,2)*a(2,1)*a(3,3) + a(1,1)*a(2,2)*a(3,3)\n      b= reshape( &\n         [-a(2,3)*a(3,2)+ a(2,2)*a(3,3), a(1,3)*a(3,2)-a(1,2)*a(3,3), &\n        -a(1,3)*a(2,2) + a(1,2)*a(2,3),  a(2,3)*a(3,1)- a(2,1)*a(3,3), &\n        -a(1,3)*a(3,1) + a(1,1)*a(3,3),  a(1,3)*a(2,1)- a(1,1)*a(2,3), &\n        -a(2,2)*a(3,1)  + a(2,1)*a(3,2), a(1,2)*a(3,1)- a(1,1)*a(3,2), &\n       -a(1,2)*a(2,1) + a(1,1)*a(2,2)]    ,[3,3]    )\n      inv33 = transpose(b)/det\n      end function inv33\n"}, {"instruction": "Write a Fortran function named cross_product that takes two 3-dimensional arrays of double precision numbers as input and returns a 3-dimensional array of double precision numbers as output. The input parameters should have the \"intent(in)\" attribute. The function calculates the cross product of the two input arrays and stores the result in the output array.", "input": "", "output": "\tpure function cross_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3) :: cross_product\n\t\t\n\t\tcross_product(1) = a(2) * b(3) - a(3) * b(2)\n\t\tcross_product(2) = a(3) * b(1) - a(1) * b(3)\n\t\tcross_product(3) = a(1) * b(2) - a(2) * b(1)\n\t\t\n\tend function cross_product\n"}, {"instruction": "Create a Fortran function named tensor_product to calculate the tensor product of two input arrays. The function takes 2 input parameters of type double precision, dimension (3) and returns 1 output parameter of type double precision, dimension (3, 3).", "input": "", "output": "\tpure function tensor_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3, 3) :: tensor_product\n\t\tinteger :: i, j\n\t\t\n\t\tdo i = 1, 3\n\t\t\tdo j = 1, 3\n\t\t\t\ttensor_product (i, j) = a (i) * b (j)\n\t\t\tend do\n\t\tend do\n\t\t\n\tend function tensor_product\n"}, {"instruction": "Create a Fortran function named skew that takes in a 3-element array of double precision as input. The function should return a 3x3 array of double precision. The purpose of this function is to generate a skew-symmetric matrix based on the input array.", "input": "", "output": "\tpure function skew (r)\n\t\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: r\n\t\tdouble precision, dimension (3, 3) :: skew\n\t\t\n\t\tskew (1, 1) = 0.0d0\n\t\tskew (1, 2) = - r (3)\n\t\tskew (1, 3) = r (2)\n\t\tskew (2, 1) = r (3)\n\t\tskew (2, 2) = 0.0d0\n\t\tskew (2, 3) = - r (1)\n\t\tskew (3, 1) = - r (2)\n\t\tskew (3, 2) = r (1)\n\t\tskew (3, 3) = 0.0d0\n\t\t\n\tend function skew\n"}, {"instruction": "Create a Fortran function named skew2 to generate a 3x3 skew-symmetric matrix based on the input 3-element vector. The input parameter is of type double precision, dimension(3), and the output parameter is of type double precision, dimension(3, 3).", "input": "", "output": "\tpure function skew2 (r)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: r\n\t\tdouble precision, dimension (3, 3) :: skew2\n\t\t\n\t\tskew2 (1, 1) = - (r (2) ** 2 + r (3) ** 2)\n\t\tskew2 (1, 2) = r (1) * r (2)\n\t\tskew2 (1, 3) = r (1) * r (3)\n\t\tskew2 (2, 1) = r (1) * r (2)\n\t\tskew2 (2, 2) = - (r (1) ** 2 + r (3) ** 2)\n\t\tskew2 (2, 3) = r (2) * r (3)\n\t\tskew2 (3, 1) = r (1) * r (3)\n\t\tskew2 (3, 2) = r (2) * r (3)\n\t\tskew2 (3, 3) = - (r (1) ** 2 + r (2) ** 2)\n\t\t\n\tend function skew2\n"}, {"instruction": "Create a Fortran function named case2 to generate an array of real numbers based on the input parameters. The number of input arguments is 3 with test data types ['integer', 'integer', 'integer']. The number of output arguments is 1 with a test data type of ['real, dimension(n)']. The function generates an array of real numbers where the elements within the range specified by n_min and n_max are set to 1, and all other elements are set to 0.", "input": "", "output": "    function case2(n, n_min, n_max) result(rvcase2)\n    \n        ! routine arguments\n        integer, intent(in)             :: n\n        integer, intent(in)             :: n_min\n        integer, intent(in)             :: n_max\n        real, dimension(n)              :: rvcase2\n        \n        ! locals\n        integer :: i\n        \n        ! generate the information desired\n        rvcase2 = 0.\n        do i = 1, n\n            if(i >= n_min .and. i <= n_max) then\n                rvcase2(i) = 1.\n            end if\n        end do\n        \n    end function case2\n"}, {"instruction": "Create a Fortran function named nbody_coeffs to calculate the value of a using the input integers k, m, and n. The number of input arguments is 3, and the test_data type is [integer, integer, integer]. The number of output arguments is 1, and the test_data type is [integer]. Use the imperative tone.", "input": "", "output": "function nbody_coeffs(k, m, n) result(a)\n    integer, intent(in) :: k, m, n\n    integer :: a\n\n    integer :: i\n\n    a = 1\n    do i = n-m+1, n-k\n        a = a*i\n    end do\n    do i = 1, m-k\n        a = a/i\n    end do\nend function nbody_coeffs\n"}, {"instruction": "Create a Fortran function named isfinished to determine if a game is finished based on the matrix of game results. The function takes 3 input parameters: nline (integer), ntube (integer), and matrix (integer, dimension(ntube,nline)). It returns 1 output parameter win (logical).", "input": "", "output": "function isfinished(nline, ntube, matrix) result(win)\n  implicit none\n  integer :: nline, ntube\n  integer, dimension(ntube,nline) :: matrix\n  logical :: win\n  integer :: i\n  win = .true.\n  do i = 1, ntube\n     win = win .and. all(matrix(i,:) == matrix(i,1))\n  end do\nend function isfinished\n"}, {"instruction": "Create a Fortran function named \"ph\" to calculate the value of a mathematical function. The function takes 2 input parameters of type integer and returns 1 output parameter of type integer. The test data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "recursive function ph(a, n) result(res)\n  integer, intent(in) :: a, n\n  integer :: res\n  if (n == 0 ) then\n     res = 1\n  else\n     res = a * ph(a + 1, n - 1)\n  end if\nend function\n"}, {"instruction": "Create a Fortran function named number that takes a single input argument of type character(*) and returns an output argument of type integer. The function calculates a numerical value based on the characters in the input string and returns the result.", "input": "", "output": "  pure function number(word)\n    character(*), intent(in) :: word\n    integer                  :: number,i\n\n    number=0\n    do i=1,len_trim(word)\n       number=number+(ichar(word(i:i+1))-ichar('a')+1)\n    end do\n\n  end function number\n"}, {"instruction": "Create a Fortran function named is_triangle that takes an integer input argument and returns a logical output. The input argument is of type integer, and the output is of type logical. The function implements the quadratic formula to determine if the given integer forms a triangular number. Use the imperative tone to create the function-level code.", "input": "", "output": "  pure function is_triangle(n)\n    integer, intent(in) :: n\n    double precision    :: x1,x2\n    logical             :: is_triangle\n\n    ! quadratic formula\n    x1 = (-1 - sqrt(dble(1+8*n))) / 2\n    x2 = (-1 + sqrt(dble(1+8*n))) / 2\n\n    is_triangle=.false.\n    if (x1 > 0 .and. (mod(x1,1.0)==0.0)) is_triangle=.true.\n    if (x2 > 0 .and. (mod(x2,1.0)==0.0)) is_triangle=.true.\n\n  end function is_triangle\n"}, {"instruction": "Create a Fortran function named set_rearth to convert the input real*8 number x from degrees to radians and assign the result to the variable lendeg. The number of input arguments is 1 and the test_data type is [real*8]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "function set_rearth(x) result(ret)\n  integer :: ret\n  real*8 :: x\n  rearth=x\n  lendeg = rearth * pi / 180.\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named bmw_parallel_context_i to calculate the parallel context index using the given index and the total number of parallel contexts. The function should take 2 input arguments of type integer, and the test_data type is ['integer', 'integer']. It should return 1 output argument of type integer, and the test_data type is ['integer'].", "input": "", "output": "      pure function bmw_parallel_context_i(index, num_i)\n\n      implicit none\n\n!  declare arguments\n      integer :: bmw_parallel_context_i\n      integer, intent(in) :: index\n      integer, intent(in) :: num_i\n\n!  start of executable code\n      bmw_parallel_context_i = mod(index - 1, num_i) + 1\n\n      end function\n"}, {"instruction": "Write a Fortran function named scramble that takes an integer number_of_values as input and returns an array of shuffled integers. The input argument is of type integer, while the output argument is an allocatable array of integers.", "input": "", "output": "    function scramble( number_of_values ) result(array)\n        integer, intent(in) :: number_of_values\n        integer, dimension(:), allocatable   :: array\n        integer :: i, j, k, m, n\n        integer :: temp\n        real :: u\n\n        array=[(i,i=1,number_of_values)]\n\n        n=1\n        m=number_of_values\n        do k=1,2\n            do i=1,m\n                call random_number(u)\n                j = n + floor((m+1-n)*u)\n                temp=array(j)\n                array(j)=array(i)\n                array(i)=temp\n            end do\n        end do\n\n    end function scramble\n"}, {"instruction": "Write a Fortran function named \"gdk_pixbuf_new_from_file_at_size_utf8\" that binds to a C function and takes 4 input parameters of types character(kind=c_char) array, integer(c_int), integer(c_int), and type(c_ptr), and returns 1 output parameter of type type(c_ptr). This function is responsible for creating a new GdkPixbuf from a file with the specified width and height, and handles any errors using the error parameter.", "input": "", "output": "function gdk_pixbuf_new_from_file_at_size(filename, width, height, error) bind(&\n&c, name='gdk_pixbuf_new_from_file_at_size_utf8') \n  use iso_c_binding, only: c_ptr, c_char, c_int\n  type(c_ptr) :: gdk_pixbuf_new_from_file_at_size\n  character(kind=c_char), dimension(*) :: filename\n  integer(c_int), value :: width\n  integer(c_int), value :: height\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gtk_ui_manager_add_ui_from_file_utf8 to bind to the C function gtk_ui_manager_add_ui_from_file. It takes 3 input parameters of type c_ptr, value, character(kind=c_char), dimension(*), and type c_ptr, value. It returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gtk_ui_manager_add_ui_from_file(self, filename, error) bind(c, name='g&\n&tk_ui_manager_add_ui_from_file_utf8') \n  use iso_c_binding, only: c_int, c_ptr, c_char\n  integer(c_int) :: gtk_ui_manager_add_ui_from_file\n  type(c_ptr), value :: self\n  character(kind=c_char), dimension(*) :: filename\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Write a Fortran function named gtk_window_set_default_icon_from_file that takes two input parameters of type character(kind=c_char), dimension(*) and type(c_ptr), and one output parameter of type integer(c_int). This function is bound to C with the name 'gtk_window_set_default_icon_from_file_utf8'.", "input": "", "output": "function gtk_window_set_default_icon_from_file(filename, err) bind(c, name='gtk&\n&_window_set_default_icon_from_file_utf8') \n  use iso_c_binding, only: c_int, c_char, c_ptr\n  integer(c_int) :: gtk_window_set_default_icon_from_file\n  character(kind=c_char), dimension(*) :: filename\n  type(c_ptr), value :: err\nend function\n"}, {"instruction": "Create a Fortran function named gtk_file_chooser_add_shortcut_folder_utf8 that binds to C, with the purpose of adding a shortcut folder to a file chooser dialog. The function takes 3 input parameters of type c_ptr, value, character(kind=c_char), dimension(*), and type(c_ptr), value, and returns 1 output parameter of type integer(c_int).", "input": "", "output": "function gtk_file_chooser_add_shortcut_folder(chooser, folder, error) bind(c, n&\n&ame='gtk_file_chooser_add_shortcut_folder_utf8') \n  use iso_c_binding, only: c_int, c_ptr, c_char\n  integer(c_int) :: gtk_file_chooser_add_shortcut_folder\n  type(c_ptr), value :: chooser\n  character(kind=c_char), dimension(*) :: folder\n  type(c_ptr), value :: error\nend function\n"}, {"instruction": "Create a Fortran function named gtk_file_chooser_list_shortcut_folders, which is bound to C and has the name 'gtk_file_chooser_list_shortcut_folders_utf8'. The function takes 1 input parameter of type 'type(c_ptr), value' and returns 1 output parameter of type 'type(c_ptr)'.", "input": "", "output": "function gtk_file_chooser_list_shortcut_folders(chooser) bind(c, name='gtk_file&\n&_chooser_list_shortcut_folders_utf8') \n  use iso_c_binding, only: c_ptr\n  type(c_ptr) :: gtk_file_chooser_list_shortcut_folders\n  type(c_ptr), value :: chooser\nend function\n"}, {"instruction": "Create a Fortran function named julia to calculate the Julia set for a given complex number. The function takes 9 input parameters of types integer, integer, integer, integer, real, real, real, complex, and integer, and returns 1 output parameter of type integer.", "input": "", "output": "    function julia(x, y, width, height, zoom, mx, my, c, max_iter)\n        integer, intent(in) :: x, y, width, height\n        real,    intent(in) :: zoom, mx, my\n        complex, intent(in) :: c\n        integer, intent(in) :: max_iter\n        integer             :: i, julia\n        complex             :: z\n\n        julia = 0\n\n        z = cmplx(1.5 * (x - width / 2) / (0.5 * zoom * width) + mx, &\n                  1.0 * (y - height / 2) / (0.5 * zoom * height) + my)\n\n        do i = 1, max_iter\n            z = z**2 + c\n\n            if (abs(z) > 2) then\n                julia = i\n                exit\n            end if\n        end do\n    end function julia\n"}, {"instruction": "Create a Fortran function named get_model_time to calculate the model time based on the given time value. The function takes 1 input parameter of type real(8) and returns 1 output parameter of type integer. When calling this function, ensure to provide the time value in seconds as the input argument.", "input": "", "output": "function get_model_time(tout) result(ret)\n  integer :: ret\n  real(8) :: tout  \n  tout = statim*86400.d0+dtdp*(itime_bgn-1)\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_timestep that takes in one input parameter of type real(8) and returns an output parameter of type integer. The function sets the value of dtout to the value of dtdp and returns 0 as the result.", "input": "", "output": "function get_timestep(dtout) result(ret)\n  integer :: ret\n  real(8) :: dtout  \n  dtout = dtdp  \n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named get_number_of_nodes to determine the number of nodes. The input argument is an integer, and the output argument is also an integer.", "input": "", "output": "function get_number_of_nodes(nout) result(ret)\n  integer :: ret,nout\n  nout=np\n  ret=0  \nend function\n"}, {"instruction": "Provide a Fortran function named get_number_of_elements to determine the number of elements in an array. The function takes 1 input parameter with the data type integer. It returns 1 output parameter with the data type integer.", "input": "", "output": "function get_number_of_elements(nout) result(ret)\n  integer :: ret,nout\n  nout=ne\n  ret=0  \nend function\n"}, {"instruction": "Create a Fortran function named get_number_of_elevation_boundary_segments to determine the number of elevation boundary segments. The function takes 1 input parameter of type integer. The output is a single integer value. Ensure that the function returns the correct count of elevation boundary segments.", "input": "", "output": "function get_number_of_elevation_boundary_segments(nout) result(ret)\n  integer :: ret, nout\n  nout=nope\n  ret=0\nend function\n"}, {"instruction": "Create a Fortran function named isinmset to determine if a complex number belongs to the Mandelbrot set. The function takes 2 input parameters of type complex and integer, and returns 1 output parameter of type logical. The input parameter test_data type is ['complex', 'integer'], and the output parameter test_data type is ['logical']. Use an imperative tone in the instructions.", "input": "", "output": "pure function isinmset(c, maxiter)\n\n    complex, intent(in) :: c\n    integer, intent(in) :: maxiter\n    integer :: n\n    complex :: z\n    logical :: isinmset\n    \n    z = cmplx(0,0)\n    n = 0\n    if(((abs(c - cmplx(-1,0))) < 0.25) .or. ((abs(1.0 - sqrt(1-(4*c)))) < 1.0)) then\n        isinmset = .true.\n    end if\n\n    do while(abs(z) < 4 .and. (n < maxiter))\n        z = z*z+c\n        n = n+1\n    end do\n\n    if(n >= maxiter) then\n        isinmset = .true.\n    else\n        isinmset = .false.\n    end if    \n\nend function isinmset\n"}, {"instruction": "Write a Fortran pure function named colon to generate an array of consecutive integers between given values inclusive. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer, dimension(1:b-a+1)].", "input": "", "output": "\tpure function colon(a,b)\r\n\t\timplicit none\r\n\t\tinteger, intent(in) :: a,b\r\n\t\tinteger, dimension(1:b-a+1) :: colon\r\n\t\tinteger :: i\r\n\t\tdo i = a,b\r\n\t\t\tcolon(i-a+1) = i\r\n\t\tend do\r\n\tend function colon\r\n"}, {"instruction": "Create a Fortran function named makenumberstring that takes a single real number as input and returns a string of length 20. The function should raise the input number to the power of 2, assign the result to an integer variable, and then assign an empty string to the output.", "input": "", "output": "      function makenumberstring(x)\n      implicit none\n      real, intent(in)     :: x\n      character(len=20)      :: makenumberstring\n      integer             :: xx\n      xx = x**2  ! << ice\n      makenumberstring = ''\n      end function\n"}, {"instruction": "Write a Fortran function named calc_ep to calculate the value of ep based on the given input parameters. The function takes 3 input arguments of type real*8: fx0, ep0, and fx. It returns 1 output argument of type real*8: ep.", "input": "", "output": "function calc_ep(fx0,ep0,fx) result(ep)\n\n      real*8,intent(in) :: fx0,ep0,fx\n      real*8 :: ep\n      real*8 :: a,b,c,d\n      real*8 :: r1,r2,dratio,k\n\n      !ep = 1.d0-(1.d0-fx0)*(1.d0-ep0)/(1.d0-fx)\n      !ep = fx0*(1-ep0)+ep0-fx\n\n      dratio=2.0\n\n      k = (fx0/(1-fx0) + dratio)/(1-ep0)\n\n      a = k;\n      b = -(dratio+k*fx);\n      c = dratio*fx - fx;\n\n      d = b*b - 4.d0*a*c\n\n      r1 = 0.5*(-b + sqrt(d))/a\n      r2 = 0.5*(-b - sqrt(d))/a\n\n      !print *,\"r1,r2:\",r1,r2\n\n      if(r1 > 0) then\n\t      ep=(1-r1)\n      else if(r2 > 0) then\n\t      ep=(1-r2)\n      else\n\t      print *,\"error, r1 and r2:\",r1,r2\n\t      ep=ep0\n      endif\n\n\nend function calc_ep\n"}, {"instruction": "Create a Fortran function named ladjusted_int8 that takes an 8-byte integer as input. The function should return a character string containing the left-aligned representation of the input integer. The number of input arguments is 1 and the test_data type is ['integer(kind=8)']. The number of output arguments is 1 and the test_data type is ['character(len=len_max_int)'].", "input": "", "output": "  function ladjusted_int8(i) result(retchar)\n    integer, parameter :: len_max_int = 20  ! maximum length of chars required for integer*8\n      ! note: if you change this value, make sure to change the value in write() in the code below.\n\n    integer(kind=8), intent(in) :: i  ! integer to be left-adjusted\n\n    character(len=len_max_int) :: chari\n    character(len=len_max_int) :: retchar ! ok up to integer*8\n\n    write(chari, '(i20)') i\n    retchar = trim(adjustl(chari))\n  end function ladjusted_int8\n"}, {"instruction": "Create a Fortran function named dump_int1_binary to convert a 1-byte integer into its binary representation. The function takes 1 input parameter of type integer(kind=1) and returns 1 output parameter of type character(len=8).", "input": "", "output": "  function dump_int1_binary(i1) result(retc)\n    integer(kind=1), intent(in) :: i1\n    character(len=8) :: retc\n    integer :: j, k\n\n    retc(:) = '00000000'\n    do j=0, 7\n      k = 8-j\n      if (btest(i1, j)) retc(k:k) = '1'\n    end do\n  end function dump_int1_binary\n"}, {"instruction": "Create a Fortran function named dump_int2_binary that takes an integer of kind=2 as input and returns a character string of length ikind*8+ikind-1. The function converts the input integer into a binary string and returns it as a character string.", "input": "", "output": "  function dump_int2_binary(i2) result(retc)\n    integer, parameter :: ikind = 2\n    integer(kind=2), intent(in) :: i2\n    character(len=8), dimension(ikind) :: tmpc\n    character(len=ikind*8+ikind-1) :: retc\n    integer :: ir, j, k\n\n    tmpc(:) = '00000000'\n    do ir=1, ikind\n      do j=0, 7\n        k = 8-j\n        if (btest(i2, j+(ir-1)*8)) tmpc(ir)(k:k) = '1'\n      end do\n    end do\n\n    retc = tmpc(ikind)\n    do j = ikind-1, 1, -1\n      retc = trim(retc)//'_'//tmpc(j)\n    end do\n  end function dump_int2_binary\n"}, {"instruction": "Write a Fortran function named norma to calculate the norm of the difference between two double precision arrays. The function should have 2 input parameters of type double precision arrays and 1 output parameter of type double precision. The input parameters should be of dimension (:), and allocatable.", "input": "", "output": "    function norma(vec1,vec2) result(y)\n\n        implicit none\n\n        \n        double precision, dimension(:), allocatable :: vec1, vec2\n        double precision :: y\n\n        \n        y = maxval(abs(vec1 - vec2))\n\n    end function norma \n"}, {"instruction": "Create a Fortran function named get_guess to receive a string input representing a guess. The function takes 1 input parameter of type integer and returns 1 output parameter of type character with a length of 10. When using the function, provide an integer as the input and the function will prompt the user to enter a string of the specified length.", "input": "", "output": "function get_guess(wlen)\n  character(len=10) :: get_guess\n\n  integer, intent(in) :: wlen\n  logical :: valid\n\n  !read guess as a single string\n  write(*, \"(a13,i1,a9)\") \"enter guess (\", wlen, \" letters)\"\n  get_guess = \"\"\n  valid = .false.\n  do while(.true.)\n    read(*, *) get_guess\n    valid = (len(adjustl(trim(get_guess))) == wlen)\n    if(valid) then\n      exit\n    else\n      print*, \"please guess correct number of letters!\"\n    end if\n  end do\n\nend function\n"}, {"instruction": "Create a Fortran function named random_integer to generate a random integer within a specified range. The function has 2 input parameters of type integer, vmin and vmax, and 1 output parameter of type integer. When called, the function will return a random integer value within the range specified by vmin and vmax.", "input": "", "output": "        function random_integer(vmin, vmax) result(val)\n                integer, intent(in)  :: vmin, vmax\n                integer              :: val\n\n                call random_number(random_real)\n                val = vmin + floor( (vmax+1-vmin)*random_real )\n\n        end function random_integer\n"}, {"instruction": "Create a Fortran function called check_uuid to validate whether the input string conforms to the UUID format specified in the RFC. The function takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical. The input parameter represents the UUID string to be validated, and the output parameter returns true if the string adheres to the UUID format defined in the RFC; otherwise, it returns false.", "input": "", "output": "function check_uuid(chars) result(lout)\n\n! return true if the string is permitted by the uuid bfn in rfc\n\ncharacter(len=*) :: chars\ncharacter(len=22), parameter :: hex = '0123456789abcdefabcdef'\nlogical :: lout\n\n   lout = (len_trim(chars) == 36)\n   if (lout) then\n       lout = lout.and.(verify(chars(1:8), hex) == 0)\n       lout = lout.and.(verify(chars(9:9), '-') == 0)\n       lout = lout.and.(verify(chars(10:13), hex) == 0)\n       lout = lout.and.(verify(chars(14:14), '-') == 0)\n       lout = lout.and.(verify(chars(15:18), hex) == 0)\n       lout = lout.and.(verify(chars(19:19), '-') == 0)\n       lout = lout.and.(verify(chars(20:23), hex) == 0)\n       lout = lout.and.(verify(chars(24:24), '-') == 0)\n       lout = lout.and.(verify(chars(25:36), hex) == 0)\n   endif\n\nend function check_uuid\n"}, {"instruction": "Write a Fortran function named rational_abs that takes an array of two integers as input and returns an array of two integers, where each element is the absolute value of the corresponding input element. The number of input arguments is 1 and the test_data type is ['integer,dimension(2)']. The number of output arguments is 1 and the test_data type is ['integer,dimension(2)'].", "input": "", "output": "  function rational_abs(r1)\n    integer,dimension(2) :: rational_abs, r1\n    rational_abs(1) = abs(r1(1))\n    rational_abs(2) = abs(r1(2))\n  end function\n"}, {"instruction": "Write a Fortran function named rational_to_pow that takes two integer arrays of size 2 and an integer exponent as input. The function computes the power of each element in the input array r1 based on the exponent ex and stores the results in the output array rational_to_pow. The number of input arguments is 2 and the test_data type is ['integer,dimension(2)', 'integer']. The number of output arguments is 1 and the test_data type is ['integer,dimension(2)'].", "input": "", "output": "  function rational_to_pow(r1, ex)\n    integer,dimension(2) :: rational_to_pow, r1\n    integer :: ex\n    !(a1 * b2 + a2 * b1) / (b1 * b2)\n    rational_to_pow(1) = r1(1)**ex\n    rational_to_pow(2) = r1(2)**ex\n  end function\n"}, {"instruction": "Create a Fortran function called real_to_rational_pow to calculate the result of raising a real number to a rational power. The function takes 2 input parameters: an integer array of size 2 and a real number. The output consists of 2 parameters: a real number and the result of raising the real number to the rational power. Use the imperative tone to write the instructions.", "input": "", "output": "  function real_to_rational_pow(ex,r1)\n    integer,dimension(2) ::  r1\n    real :: real_to_rational_pow,ex\n    !(a1 * b2 + a2 * b1) / (b1 * b2)\n    if ( r1(1)==0 ) then\n      real_to_rational_pow=0.0\n    else  \n      real_to_rational_pow = ex**(real(r1(1))/real(r1(2)))\n    endif\n  end function\n"}, {"instruction": "Write a Fortran function named gcd to calculate the greatest common divisor (GCD) of two integer numbers. The function takes 2 input arguments of type integer and returns 1 output argument of type integer.", "input": "", "output": "  function gcd(m,n)\n    integer,intent(in)  :: m, n\n    integer :: gcd,irest,ifirst\n    ifirst=abs(m)\n    gcd=abs(n)\n    if(gcd==0)then\n      gcd=ifirst\n    else\n      do\n        irest = mod(ifirst,gcd)\n        if(irest == 0)  exit\n        ifirst = gcd\n        gcd = irest\n      enddo\n      gcd= abs(gcd)\n    endif\n  end function\n"}, {"instruction": "Write a Fortran function named next_ccw to determine the next counterclockwise index in a sequence. The function should take 2 integer input arguments and return 1 integer output argument. The test_data type for input is ['integer', 'integer'], and for output is ['integer'].", "input": "", "output": "function next_ccw( i, n ) result(next)\ninteger :: i,n,next\nnext=mod(i,n)+1\nif( next.le.0 )then\n  next=next+n\nend if\nend function next_ccw\n"}, {"instruction": "Create a Fortran function named capital, which takes one input parameter of type character with a length of 1 and returns one output parameter of the same type and length. This function converts a lowercase character to its uppercase equivalent and returns the result.", "input": "", "output": "function capital( in_char )  \n  !-----------------------------------------------------------------------\n  !\n  ! ... converts character to capital if lowercase\n  ! ... copy character to output in all other cases\n  !\n  implicit none  \n  !\n  character(len=1), intent(in) :: in_char\n  character(len=1)             :: capital\n  character(len=26), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz', &\n                                  upper = 'abcdefghijklmnopqrstuvwxyz'\n  integer                      :: i\n  !\n  !\n  do i=1, 26\n     !\n     if ( in_char == lower(i:i) ) then\n        !\n        capital = upper(i:i)\n        !\n        return\n        !\n     end if\n     !\n  end do\n  !\n  capital = in_char\n  !\n  return \n  !\nend function capital\n"}, {"instruction": "Write a Fortran function named \"toupper\" to convert a given string to uppercase. The function should take 1 input parameter of type character (len=*) and return 1 output parameter of type character (len=len(string)).", "input": "", "output": "function toupper(string) result (toupper_result)\n\n  implicit none\n  character (len=*), intent(in) :: string\n  character (len=len(string)) :: toupper_result\n  integer         :: i,ii\n\n  do i=1,len(string)\n    ii=iachar(string(i:i))\n    select case (ii)\n      case (97:122)\n        toupper_result(i:i)=achar(ii-32)\n      case default\n        toupper_result(i:i)=string(i:i)\n    end select\n  enddo\n\nend function toupper\n"}, {"instruction": "Provide a Fortran function named isitanint to determine if a given input string represents an integer number. The function takes 1 input argument of type character(len=*) and returns 1 output argument of type logical. The input argument represents the string to be checked, and the output argument indicates whether the input string represents an integer.", "input": "", "output": "function isitanint(instring) result(isitanint_result)\n\n  implicit none\n\n  character(len=*), intent(in) :: instring\n  logical :: isitanint_result\n\n  integer         :: i,ii\n\n  isitanint_result=.true.\n\n  do i=1,len(instring)\n    ii=iachar(instring(i:i))\n    select case(ii)\n      case (43,45,48:57)\n        if(i.ne.1) then\n          if(ii.eq.43 .or.ii.eq.45) isitanint_result=.false.\n        endif\n      case default\n        isitanint_result=.false.\n    end select\n  enddo\n\nend function isitanint\n"}, {"instruction": "Write a Fortran function named ran to generate a random number using the linear congruential method. The function takes 1 input argument of type integer and returns 1 output argument of type real.", "input": "", "output": "  function ran(idum)\n  implicit none\n  integer, intent(inout) :: idum\n  integer, parameter     :: k4b=selected_int_kind(9)\n  real                   :: ran\n  integer, parameter     :: ia=16807,im=2147483647,iq=127773,ir=2836\n  real, save             :: am\n  integer(k4b), save     :: ix=-1,iy=-1,k\n  if (idum <= 0 .or. iy < 0) then\n    am=nearest(1.0,-1.0)/im\n    iy=ior(ieor(888889999,abs(idum)),1)\n    ix=ieor(777755555,abs(idum))\n    idum=abs(idum)+1\n  end if\n  ix=ieor(ix,ishft(ix,13))\n  ix=ieor(ix,ishft(ix,-17))\n  ix=ieor(ix,ishft(ix,5))\n  k=iy/iq\n  iy=ia*(iy-k*iq)-ir*k\n  if (iy < 0) iy=iy+im\n  ran=am*ior(iand(im,ieor(ix,iy)),1)\n  end function ran  \n"}, {"instruction": "Create a Fortran function named vtk_areatri that calculates the area of a triangle using the input coordinates of its vertices. The function takes 6 input parameters of type real(8) representing the x and y coordinates of the triangle vertices. It returns 1 output parameter of type real(8) representing the area of the triangle.", "input": "", "output": "      function vtk_areatri(ax,ay,bx,by,cx,cy)\n      implicit none\n      real(8) :: vtk_areatri\n      real(8) :: ax,ay,bx,by,cx,cy\n      real(8) :: tmp\n\n      tmp=ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)\n      vtk_areatri=abs(tmp)*0.5d0\n\n      return\n      end function vtk_areatri\n"}, {"instruction": "Create a Fortran function named gaussian_kernel to calculate the Gaussian kernel value based on the input arrays a and b. The input parameters are two one-dimensional arrays of double precision values. The output parameter is a single double precision value representing the kernel result. The function utilizes the features of Fortran, including array operations and the exp function.", "input": "", "output": "function gaussian_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n    integer :: i\n    double precision :: temp\n    double precision :: sigma\n   \n    kernel = 0.0d0 \n    sigma = 724.0d0\n\n    do i = 1, size(a)\n        temp = a(i) - b(i)\n        kernel = kernel + temp * temp\n    enddo\n\n    kernel = exp(-0.5d0 * sqrt(kernel) / (sigma*sigma))\n\nend function gaussian_kernel\n"}, {"instruction": "Create a Fortran function named laplace_kernel to calculate the Laplace kernel value. The function takes 2 input parameters of type double precision arrays and returns a single output of type double precision. The input parameters are intent(in) and have an undefined size, denoted by dimension(:). The function computes the kernel value using the absolute difference and exponential functions.", "input": "", "output": "function laplace_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n\n    kernel = sum(abs(a(:) - b(:)))\n    kernel = exp(-0.00025118864315095795d0 * kernel)\n\nend function laplace_kernel\n"}, {"instruction": "Create a Fortran function named convert_lower_case to convert a single input character to lower case. The function takes 1 input parameter of type character (len=1) and returns 1 output parameter of type character (len=1).", "input": "", "output": "          function convert_lower_case (input_string) result (output_string)\n!\n          character (len=1) :: input_string, output_string\n          integer :: collating_difference\n!\n          if (ichar(input_string) >= ichar('a') .and. ichar(input_string) <= ichar('z')) then\n              collating_difference = ichar(input_string) - ichar('a')\n              output_string = char(ichar('a') + collating_difference)\n          else\n              output_string = input_string\n          end if\n!\n          end function convert_lower_case\n"}, {"instruction": "Create a Fortran function named factorial that calculates the factorial of a given integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is the number to calculate the factorial of, and the output parameter is the factorial value.", "input": "", "output": "  function factorial(number) result(fact)\n\n    !> number to calculate the factorial of\n    integer, intent(in) :: number\n\n    !> factorial\n    integer :: fact\n\n    integer :: ii\n\n    fact = 1\n    do ii = 2, number\n      fact = fact * ii\n    end do\n\n  end function factorial\n"}, {"instruction": "Create a Fortran function named logequal to generate an array of equally spaced logarithmically distributed values between the given start and end points. The function requires 3 input parameters of types real(kind=8), real(kind=8), and integer(kind=4) representing the start point, end point, and the number of steps respectively. The output is an array of equally spaced logarithmically distributed values of type real(kind=8) with a dimension of steps.", "input": "", "output": "\tpure function logequal(start,fin,steps) result(grid)\n\t\t! data dictionary\n\t\treal(kind=8), intent(in) :: start\n\t\treal(kind=8), intent(in) :: fin\n\t\tinteger(kind=4), intent(in) :: steps\n\t\treal(kind=8),dimension(steps) :: grid\n\t\tinteger(kind=4) :: ii\n\t\treal(kind=8) :: tmp\n\n\t\ttmp = log(start)\n\t\tgrid_loop: do ii = 1, steps\n\t\t\ttmp = (log(fin)-log(start))/steps + tmp\n\t\t\tgrid(ii) = exp(tmp) \n\t\tend do grid_loop\n\t\treturn\n\tend function logequal\n"}, {"instruction": "Create a Fortran function named \"f\" to calculate the exponential of the negative square of a real number. The function takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "function f(x)\n  implicit none\n  real::x, f\n  f=exp(-x**2)\nend function f\n"}, {"instruction": "Write a Fortran function named count_substring to count the occurrences of a substring within a string. The function takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer. The name of the function is count_substring.", "input": "", "output": "function count_substring(string,substring) result(count)\n\n   implicit none\n\n   character(len=*), intent(in) :: string,substring\n   integer :: i,count,position\n\n   count=0\n   if(len(substring).eq.0) return\n\n   i=1\n   do \n      position=index(string(i:),substring)\n      if(position.eq.0) return\n      count=count+1\n      i=i+position+len(substring)\n   end do\n\nend function count_substring\n"}, {"instruction": "Create a Fortran function named integer_to_string that takes an integer as input and returns a string representation of the integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=:), allocatable'].", "input": "", "output": "    pure function integer_to_string(number) result(string)\n        integer, intent(in) :: number\n        character(len=:), allocatable :: string\n\n        character(len=11) :: temp\n\n        write(temp, '(i0)') number\n        string = trim(temp)\n    end function\n"}, {"instruction": "Create a Fortran function named \"contract_i_i\" to calculate the zero-rank contraction of two first-rank tensors. The function takes 2 input parameters of type real, dimension(3) and returns 1 output parameter of type real. The function computes the sum over index i, equivalent to the built-in dot_product, and assigns the result to the output parameter \"c\".", "input": "", "output": "  function contract_i_i ( a, b ) result (c)\n    implicit none\n    real                           :: c ! returns a zero-rank contraction\n    real, dimension(3), intent(in) :: a ! of a first-rank tensor\n    real, dimension(3), intent(in) :: b ! with a first-rank tensor\n\n    ! sum over index i, equivalent to built-in dot_product\n    c = dot_product ( a, b )\n\n  end function contract_i_i\n"}, {"instruction": "Create a Fortran function named contract_ij_ij to calculate the zero-rank contraction of two second-rank tensors. The function should have 2 input parameters of type real, dimension(3,3), and an output parameter of type real.", "input": "", "output": "  function contract_ij_ij ( a, b ) result ( c )\n    implicit none\n    real                              :: c ! returns a zero-rank contraction\n    real, dimension(3,3), intent(in)  :: a ! of a second-rank tensor\n    real, dimension(3,3), intent(in)  :: b ! with another second-rank tensor\n\n    ! sum over indices i, j\n    c = sum ( a * b )\n\n  end function contract_ij_ij\n"}, {"instruction": "Create a Fortran function named contract_ijk_k to perform a contraction operation. The function takes two input parameters of type real, dimension(3,3,3) and real, dimension(3), and returns one output parameter of type real, dimension(3,3).", "input": "", "output": "  function contract_ijk_k ( a, b ) result ( c )\n    implicit none\n    real, dimension(3,3)                :: c ! returns a second-rank contraction of \n    real, dimension(3,3,3), intent(in)  :: a ! a third-rank tensor\n    real, dimension(3),     intent(in)  :: b ! and a first-rank tensor\n\n    integer :: i, j\n\n    ! free indices i, j, sum over index k.\n    do i = 1, 3\n       do j = 1, 3\n          c(i,j) = sum ( a(i,j,:) * b(:) )\n       end do\n    end do\n\n  end function contract_ijk_k\n"}, {"instruction": "Create a Fortran function named skew that takes a 3x3 matrix of real numbers as input and returns a 3-element vector of real numbers as output. The function computes the cross product of the input matrix and returns the resulting vector.", "input": "", "output": "  function skew ( a ) result ( b )\n\n    implicit none\n    real, dimension(3)   :: b ! returns a first-rank tensor by contracting the levi-civita symbol with\n    real, dimension(3,3) :: a ! a second-rank tensor\n\n    b(1) = a(2,3) - a(3,2)\n    b(2) = a(3,1) - a(1,3)\n    b(3) = a(1,2) - a(2,1)\n\n  end function skew\n"}, {"instruction": "Create a Fortran function named cpi_t to calculate the chemical performance index (CPI) at a given temperature and reaction time. The function takes 3 input arguments of type real: k, rtndt, and t. It returns 1 output argument of type real.", "input": "", "output": "    function cpi_t(k, rtndt, t)\n\n        !variables\n        real :: cpi_t\n        real, intent(in) :: k, rtndt, t\n        real :: akic, bkic, ckic\n\n        !calculate akic, bkic, ckic\n        akic = 19.35+8.335*exp(0.02254*(t-rtndt))\n        bkic = 15.61+50.132*exp(0.008*(t-rtndt))\n        ckic = 4.0\n\n        !calculate cpi_t\n        if (k < akic) then\n            cpi_t = 0.0\n        else\n            cpi_t = 1-exp(-((k-akic)/bkic)**ckic)\n        end if\n\n    end function cpi_t\n"}, {"instruction": "Write a Fortran function named dist to calculate the Euclidean distance between two points in a 2D space. The function should take 2 input parameters of type real, dimension(2) and return 1 output parameter of type real. The input parameters will represent the coordinates of the two points, and the output parameter will store the calculated distance.", "input": "", "output": "function dist(pt1,pt2)\n    implicit none\n    real::dist\n    real, dimension(2) :: pt1,pt2\n    dist = sqrt((pt1(1)-pt2(1))**2+(pt1(2)-pt2(2))**2)\nend function dist\n"}, {"instruction": "Create a Fortran function named param_name_string. The function takes 1 input argument with a test_data type of ['character(len=*)']. It returns 1 output argument with a test_data type of ['character(len=strlen)'].", "input": "", "output": "  function param_name_string(name)\n    integer, parameter :: strlen = 30\n    character(len=strlen) :: param_name_string\n    character(len=*), intent(in) :: name\n    integer :: inlen, padl, padr\n    inlen = len_trim(name)\n    padl = 3\n    padr = strlen - inlen - padl ! strlen = padl + inlen + padr\n    if (padr < 0) write(0,'(a,a)') 'len(name) too large in param_name_string, name =',name\n    param_name_string(1:strlen) = repeat(' ',strlen)\n    param_name_string(padl+1:padl+inlen) = trim(name)\n  end function param_name_string\n"}, {"instruction": "Create a Fortran function named icsrcaseb to calculate a value based on the input parameters. The function takes 2 input arguments of type double precision and returns one output argument of type double precision. The function computes a mathematical expression involving the input parameters and assigns the result to the output argument.", "input": "", "output": "           function icsrcaseb(ssh,xk2)\n           implicit none\n           double precision:: ssh,xk2,icsrcaseb\n           double precision:: aa,uuh\n           aa = sqrt(64.0+144.0d0*ssh**2)\n           uuh = (aa+12*ssh)**(1.0d0/3.0d0)-(aa-12*ssh)**(1.0d0/3.0d0)\n           icsrcaseb = xk2*(-4*uuh*(uuh**2+8)/ &\n                    ((uuh**2+4.0d0)*(uuh**2+12.0d0)))\n           end function icsrcaseb\n"}, {"instruction": "Create a Fortran function named icsrcasec that takes four input parameters of type double precision, phimh, xxbarh, ssh, and xk2, and returns a single output parameter of type double precision. The function calculates a complex mathematical expression involving the input parameters and assigns the result to the output parameter.", "input": "", "output": "           function icsrcasec(phimh,xxbarh,ssh,xk2)\n           implicit none\n           double precision:: phimh,xxbarh,ssh,xk2,icsrcasec\n           double precision:: bb,cc,yh,phpxya,phpxyb\n           bb = 2*(phimh+xxbarh)-2*ssh+phimh**3/3+phimh**2*xxbarh\n           cc = (phimh+xxbarh)**2+phimh**2*(phimh**2+4*phimh*xxbarh)/12-&\n                      2*ssh*(phimh+xxbarh)\n           yh = (-bb+sqrt(bb*bb-4*cc))/2\n           phpxya = (phimh+xxbarh+yh)\n           phpxyb = phimh*xxbarh+phimh*phimh/2.d0\n           icsrcasec = xk2*(-2.d0*(phpxya+phimh*phpxyb)/ &\n                          (phpxya**2+phpxyb**2)+1.0d0/ssh)\n           end function icsrcasec\n"}, {"instruction": "Create a Fortran function named atomic_read which reads the value of an integer parameter atomically. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. Ensure that the entire value of the input parameter is read atomically, and no part of it can change during the read operation. Use the imperative tone in the instructions.", "input": "", "output": "       function atomic_read(p)\n       integer :: atomic_read\n       integer, intent(in) :: p\n! guarantee that the entire value of p is read atomically. no part of\n! p can change during the read operation.\n\n!$omp atomic read\n       atomic_read = p\n       return\n       end function atomic_read\n"}, {"instruction": "Create a Fortran function named str2int that takes a string input and converts it to an integer. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "   function str2int(str) result(int)\n      implicit none\n      character(len=*), intent(in) :: str\n      integer                      :: int\n      integer                      :: stat\n\n      read(str, *, iostat=stat) int\n      if(stat /= 0) then\n         write(*, *) \"str reading failed\", str\n         stop 9\n      endif\n   end function str2int\n"}, {"instruction": "Create a Fortran function named replace_text that takes three input parameters of type character(*): s, text, and rep. It returns one output parameter of type character(len(s) + 100). The function replaces occurrences of the string 'text' within the string 's' with the string 'rep', and stores the modified string in 'outs'.", "input": "", "output": "   function replace_text(s, text, rep) result(outs)\n      character(*)           :: s, text, rep\n      character(len(s) + 100) :: outs     ! provide outs with extra 100 char len\n      integer                 :: i, nt, nr\n\n      outs = s; nt = len_trim(text); nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt)); if (i == 0) exit\n         outs = outs(:i - 1)//rep(:nr)//outs(i + nt:)\n      end do\n   end function replace_text\n"}, {"instruction": "Create a Fortran function named modifiedagsupplyreq to calculate the modified agricultural supply requirement. The function takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8). The number of input arguments is 2 and the test_data type is [real(8), real(8)].The number of output arguments is 1 and the test_data type is [real(8)].", "input": "", "output": "  function modifiedagsupplyreq(ragshortprevious,ragsupreq) result(ragsupreqmod)\n    real(8),intent(in) :: ragshortprevious,ragsupreq\n    real(8)            :: ragsupreqmod\n    \n    if (ragshortprevious .le. 0.0) then\n        ragsupreqmod = ragsupreq\n    else\n        if (ragsupreq .gt. ragshortprevious) then\n            ragsupreqmod = ragsupreq - ragshortprevious\n        else\n            ragsupreqmod = ragsupreq\n        end if\n    end if\n    \n  end function modifiedagsupplyreq\n"}, {"instruction": "Create a Fortran function named readfilelist to read a list of file names from a given file. The function takes 2 input parameters of type character(len=256) and character(len=256), dimension(:), allocatable. It returns 1 output parameter of type integer.", "input": "", "output": "    function readfilelist(sfilename, svfiles) result(iretcode)\n    \n        ! routine arguments\n        character(len=256), intent(in)                              :: sfilename\n        character(len=256), dimension(:), allocatable, intent(out)  :: svfiles\n        integer                                                     :: iretcode\n        \n        ! locals\n        integer             :: ilun\n        integer             :: ierrcode\n        integer             :: inumfiles\n        integer             :: ifile\n        character(len=256)  :: sbuffer\n        \n        ! assume success (will falsify on failure)\n        iretcode = 0\n        \n        ! first step: count lines in input file\n        inumfiles = 0\n        open(newunit=ilun, file=sfilename, status='old', action='read', iostat=ierrcode)\n        if(ierrcode /= 0) then\n            iretcode = 1\n            return\n        end if\n        do\n            read(ilun, \"(a)\", iostat=ierrcode) sbuffer\n            if(ierrcode /= 0) exit\n            inumfiles = inumfiles + 1\n        end do\n        if(inumfiles <= 0) then\n            iretcode = 2\n            close(ilun)\n            return\n        end if\n        if(allocated(svfiles)) deallocate(svfiles)\n        allocate(svfiles(inumfiles))\n        \n        ! second step: actual read\n        rewind(ilun)\n        do ifile = 1, inumfiles\n            read(ilun, \"(a)\") svfiles(ifile)\n        end do\n        close(ilun)\n        \n    end function readfilelist\n"}, {"instruction": "Create a Fortran function named basename to extract the base name from a given full path or file name. The function takes 2 input parameters of type character(len=256) and character (optional), and returns 1 output parameter of type character(len=256).", "input": "", "output": "    function basename(sfullname, cseparator) result(sbasename)\n    \n        ! routine arguments\n        character(len=256), intent(in)  :: sfullname\n        character, intent(in), optional :: cseparator\n        character(len=256)              :: sbasename\n        \n        ! local variables\n        integer :: ipos\n        \n        ! locate the last occurrence of path separator character\n        ipos = index(sfullname, cseparator, back=.true.)\n        if(ipos <= 0) then\n            sbasename = sfullname\n        else\n            sbasename = sfullname(ipos+1:)\n        end if\n        \n    end function basename\n"}, {"instruction": "Write a Fortran recursive function named fibr to calculate the Fibonacci number for a given input integer. The function takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input and output parameters should be of type ['integer'].", "input": "", "output": "    recursive function fibr(n) result(fib)\n        integer, intent(in) :: n\n        integer             :: fib\n\n        select case (n)\n            case (:0);      fib = 0\n            case (1);       fib = 1\n            case default;   fib = fibr(n-1) + fibr(n-2)\n        end select\n    end function fibr\n"}, {"instruction": "Create a Fortran function named resolution that takes two double precision input parameters and returns a double precision output parameter. The input parameters should be of type ['double precision', 'double precision'], and the output parameter should be of type ['double precision']. The function computes the resolution based on the input parameters and certain conditions specified in the code.", "input": "", "output": "function resolution(e1,e2)\n    double precision :: e1, e2, resolution\n\n    if ((e1 < 0).or.(e2 < 0).or.((e1-e2)**2 > (nclip*sigma_e)**2)) then\n        resolution = 0\n        return\n    end if\n\n    resolution = exp(-(e1-e2)**2/(2.0*sigma_e**2))/sqrt(2.0*pi*sigma_e**2)\n\n    !clip below zero...\n    !if (resolution < 0) then\n    !    resolution = 0\n    !end if\n\n\nend function resolution\n"}, {"instruction": "Create a Fortran function named biggamma that takes one input parameter of type real*8. The output should also be of type real*8. This function computes the value of biggamma using a series calculation and returns the result. The number of input arguments is 1 and the test_data type is ['real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "function biggamma(tau)\n    implicit none\n    real*8, intent(in) :: tau\n    real*8 :: biggamma\n\n    integer :: order, i\n\n    order = 20\n    biggamma = 0.0d0\n\n    do i=order, 1, -1\n        biggamma = i / (1.0d0 + i / (tau + biggamma))\n    end do \n\n    biggamma = 1.0d0 / (tau + biggamma)\nend function biggamma\n"}, {"instruction": "Write a Fortran function named gfc to calculate a three-element real*8 array based on the input integer parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [real*8, dimension(3)].", "input": "", "output": "      function gfc(n) result(g)\n\n      integer, intent(in) :: n\n\n      real*8, dimension(3) :: g\n\n      if (n .eq. 1) then\n\n         g = (/1.1330d0, -0.4059d0, 0.07014d0/)\n\n      elseif (n .eq. 2) then\n\n         g = (/1.0785d0, -0.2319d0, 0.02947d0/)\n\n      else\n\n         g(1) = 0.9935d0 + 0.2328d0 / n - 0.1296d0 / n / n\n\n         g(2) = (-0.6282d0 + 0.5598d0 / n - 0.5299d0 / n / n) / n\n\n         g(3) = (0.3887d0 - 1.181d0 / n + 1.470d0 / n / n) / n / n\n\n      endif\n\n      return\n\n      end function gfc\n"}, {"instruction": "Write a Fortran function named pbc_d_max_origin to calculate the maximum distance from the origin in a periodic boundary condition system. The function takes 3 input parameters: an integer (natoms), a 3xnatoms double precision array (coo), and a 3x3 double precision array (avec). It returns 1 output parameter of type double precision, representing the maximum distance.", "input": "", "output": "  function pbc_d_max_origin(natoms, coo, avec) result(d_max)\n\n    implicit none\n\n    integer,                                intent(in) :: natoms\n    double precision, dimension(3, natoms), intent(in) :: coo\n    double precision, dimension(3,3),       intent(in) :: avec\n    double precision                                   :: d_max\n    \n    integer                        :: iat\n    double precision, dimension(3) :: cart\n\n    d_max = 0.0d0\n    do iat = 1, natoms\n       cart(1:3) = coo(1,iat)*avec(1:3,1) &\n                 + coo(2,iat)*avec(1:3,2) &\n                 + coo(3,iat)*avec(1:3,3)\n       d_max = max(d_max, sum(cart*cart))\n    end do\n    d_max = sqrt(d_max)\n\n  end function pbc_d_max_origin\n"}, {"instruction": "Create a Fortran function named \"pbc_number_of_tvecs\" to calculate the number of translation vectors within a given cutoff radius. The function takes 3 input parameters of type double precision and dimension(3,3), representing the radial cutoff, maximum distance, and lattice vectors. It returns 1 output parameter of type integer.", "input": "", "output": "  function pbc_number_of_tvecs(r_cut, d_max, avec) result(ntvecs)\n\n    implicit none\n\n    !------------------------------------------------------------------!\n    ! r_cut    : radial cut-off                                        !\n    ! d_max    : max. distance of a point/atom from the origin         !\n    ! avec(i,j): i-th component of the j-th lattice vector             !\n    !------------------------------------------------------------------!\n\n    double precision,                 intent(in) :: r_cut\n    double precision,                 intent(in) :: d_max\n    double precision, dimension(3,3), intent(in) :: avec\n    integer                                      :: ntvecs\n\n    integer                        :: ia, ib, ic\n    logical                        :: lasta, lastb, lastc\n    double precision, dimension(3) :: cart\n    double precision               :: r2, rcut2\n\n    rcut2 = r_cut + 2.0d0*d_max\n    rcut2 = rcut2*rcut2\n\n    ntvecs = 0\n    \n    ic = 0\n    c_do : do\n       lastc = .false.\n       ib = 0\n       b_do : do\n          lastb = .false.\n          ia = 0\n          a_do : do\n             lasta = .false.\n             if ((ic==0) .and. (ib==0) .and. (ia==0)) then\n                ia = ia + 1\n                cycle a_do\n             end if\n             \n             ! (+ia, +ib, +ic)\n             cart(1:3) = dble(ia)*avec(1:3,1) &\n                       + dble(ib)*avec(1:3,2) &\n                       + dble(ic)*avec(1:3,3) \n             r2 = sum(cart*cart)\n             if (r2 <= rcut2) then\n                lasta = .true.\n                ntvecs = ntvecs + 1\n             end if\n\n             if ((ia /= 0) .and. (ib /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n                if (ic /= 0) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n                   ! (-ia, -ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(-ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n\n                end if ! c /= 0\n\n             else if ((ia /= 0) .and. (ic /= 0)) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n             else if ((ib /= 0) .and. (ic /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n             end if\n\n             if (.not. lasta) exit a_do\n             lastb = .true.\n             ia = ia + 1\n          end do a_do\n          if (.not. lastb) exit b_do\n          lastc = .true.\n          ib = ib + 1\n       end do b_do\n       if (.not. lastc) exit c_do\n       ic = ic + 1\n    end do c_do\n  \n  end function pbc_number_of_tvecs\n"}, {"instruction": "Create a Fortran function named eta to calculate the value of eta based on the given input parameters. The function takes 5 input arguments with the test_data type ['real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)'] and outputs a single value of type real(8).", "input": "", "output": "function eta(x,eta0,etainf,tau,r)\n    implicit none\n    real(8):: eta,eta0,etainf,tau,r,x\n\n    eta = eta0-(eta0-etainf)*(1.0e0-exp(-((x/tau)**r)))\n\nend function eta\n"}, {"instruction": "Create a Fortran function named distance, which takes a single real input argument and returns an integer output. The function computes the distance of the input number from the nearest perfect square, and then returns the distance as the output.", "input": "", "output": "function distance(i) result(j)\n    real, intent(in) :: i ! input\n    integer :: j ! output\n\n    integer :: num\n    integer :: offset\n\n    num = floor(real(ceiling(sqrt(i))) / 2)\n    offset = mod(int(i - ((2 * num - 1) ** 2)), 2 * num)\n\n    j = num + abs(offset - num)\n end function distance\n"}, {"instruction": "Create a Fortran function named get_random_double_precision_with_range to generate a random double precision number within a specified range. The function has 2 input parameters with the test_data type ['double precision', 'double precision'], and 1 output parameter with the test_data type ['double precision'].", "input": "", "output": "    function get_random_double_precision_with_range(start, end_) result(random_double)\n        double precision, intent(in) :: start\n        double precision, intent(in) :: end_\n        double precision :: random_double\n\n        call random_number(random_double)\n        random_double = start + (end_ - start) * random_double\n    end function\n"}, {"instruction": "Create a Fortran function named get_random_integer_with_range to generate a random integer within a specified range. The function takes 2 input arguments of type integer and returns 1 output argument of type integer. The input arguments should be named start and end_, and the output argument should be named random_integer.", "input": "", "output": "    function get_random_integer_with_range(start, end_) result(random_integer)\n        integer, intent(in) :: start\n        integer, intent(in) :: end_\n        integer :: random_integer\n\n        double precision :: random_real\n\n        call random_number(random_real)\n        random_integer = start + floor((end_ + 1 - start) * random_real)\n    end function\n"}, {"instruction": "Write a Fortran function named count_non_empty to calculate the number of non-empty elements in a 2D integer array. The function should take 1 input argument of type integer, dimension(:, :), and return 1 output argument of type integer.", "input": "", "output": "    function count_non_empty(counts) result(nr_non_empty)\n        implicit none\n        integer, dimension(:, :), intent(in) :: counts\n        integer :: nr_non_empty\n\n        nr_non_empty = size(counts) - count(counts == 0)\n    end function count_non_empty\n"}, {"instruction": "Write a Fortran function named pi to estimate the value of pi using a Monte Carlo method. The function takes 1 input parameter of type integer and returns 1 output parameter of type real(8). The input parameter n specifies the number of random points to be generated for the estimation. Use the random points to calculate the value of pi and return the result.", "input": "", "output": "        function  pi(n)\n        integer :: n\n        real(8) :: x(2,n),pi\n        call random_number(x)\n        pi = 4.d0 * dble( count( hypot(x(1,:),x(2,:)) <= 1.d0 ) ) / n\n        end function\n"}, {"instruction": "Create a Fortran function named mod2pi that takes a single real number as input and returns the value of the input number modulo 2\u03c0. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "   function mod2pi(theta)\n\n      real, intent(in) :: theta\n      real :: pi, th, mod2pi\n      real, parameter :: theta_tol = 1.e-6\n      logical :: out\n\n      pi = 2.*acos(0.)\n\n      if (theta <= pi .and. theta >= -pi) then\n         mod2pi = theta\n         return\n      end if\n\n      if (theta - theta_tol <= pi .and. theta >= -pi) then\n         mod2pi = pi\n         return\n      end if\n\n      if (theta <= pi .and. theta + theta_tol >= -pi) then\n         mod2pi = -pi\n         return\n      end if\n\n      th = theta\n      out = .true.\n      do while (out)\n         if (th > pi) th = th - 2.*pi\n         if (th < -pi) th = th + 2.*pi\n         if (th <= pi .and. th >= -pi) out = .false.\n      end do\n      mod2pi = th\n\n   end function mod2pi\n"}, {"instruction": "Create a Fortran function named downcase, which takes a character string as input and returns a new string with all alphabetic characters converted to lowercase. The number of input arguments is 1, with the test_data type being ['character(*)'], and the number of output arguments is 1, with the test_data type being ['character(len(string))'].", "input": "", "output": "  function downcase(string)\n\n    character(*), intent(in) :: string\n    character(len(string))   :: downcase\n\n    character(1) :: c\n    integer      :: i\n\n    continue\n\n    downcase = string\n\n    do i = 1,len(string)\n      c = string(i:i)\n      if ( c >= 'a' .and. c <= 'z') downcase(i:i) = achar(iachar(c) + 32)\n    end do\n\n  end function downcase\n"}, {"instruction": "Write a Fortran function named rocrand_set_stream to set the stream for a ROCRAND generator. The function takes 2 input parameters of type integer(c_size_t) with the value attribute. The output is a single integer(c_int) value.", "input": "", "output": "        function rocrand_set_stream(generator, stream) &\n        bind(c, name=\"rocrand_set_stream\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_set_stream\n            integer(c_size_t), value :: generator\n            integer(c_size_t), value :: stream\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_set_seed to set the seed for a random number generator. The function takes 2 input parameters of type integer and outputs an integer value. The number of input arguments is 2 and the test_data type is ['integer(c_size_t), value', 'integer(kind=8), value']. The number of output arguments is 1 and the test_data type is ['integer(c_int)'].", "input": "", "output": "        function rocrand_set_seed(generator, seed) &\n        bind(c, name=\"rocrand_set_seed\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_set_seed\n            integer(c_size_t), value :: generator\n            integer(kind =8), value :: seed\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_get_version to retrieve the version of the ROC-RNG library. The function must have 1 input parameter of type integer(c_int) and 1 output parameter of type integer(c_int). The input parameter stores the version number, and the output parameter retrieves the version information from the library. Use the imperative tone to define the function and its parameters.", "input": "", "output": "        function rocrand_get_version(version) &\n        bind(c, name=\"rocrand_get_version\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_get_version\n            integer(c_int) :: version\n        end function\n"}, {"instruction": "Create a Fortran function named rocrand_destroy_discrete_distribution, which is used to destroy a discrete distribution. The function takes 1 input parameter of type integer(c_size_t) by value. It returns 1 output parameter of type integer(c_int). Use the bind(c, name=\"rocrand_destroy_discrete_distribution\") to ensure compatibility with C.", "input": "", "output": "        function rocrand_destroy_discrete_distribution(discrete_distribution) &\n        bind(c, name=\"rocrand_destroy_discrete_distribution\")\n            use iso_c_binding\n            implicit none\n            integer(c_int) :: rocrand_destroy_discrete_distribution\n            integer(c_size_t), value :: discrete_distribution\n        end function\n"}, {"instruction": "Create a Fortran function named f to compute the derivatives of a given vector y with respect to time t. The function takes 2 input parameters of type ['complex*16, dimension(:)', 'double precision'] and returns 1 output parameter of type ['complex*16, dimension(size(y))'].", "input": "", "output": "  function f(t,y) result(k)\n    !use interaction_interface\n    \n    implicit none\n    complex*16,       dimension(:), intent(in) :: y\n    !double precision, dimension(:), intent(in) :: beta_ijkl\n    !double precision, dimension(:), intent(in) :: beta_ijkl_map\n    double precision,               intent(in) ::  t\n    complex*16,       dimension(size(y))       :: k    \n    \n    !k(1) =  y(2) \n    !k(2) = -y(1)!-0.25*y(2)  \n    \n    k(1) = -2.0*y(2)!4.0-y(1)*y(1)-4*y(2)*y(2)\n    k(2) = 0.4 + y(1) + 0.3*y(1)*y(1) - 0.6*y(2)*y(2)!y(2)*y(2) - y(1)*y(1) + 1.0\n\n\n    !k(1) = dcmplx(0.0,-1.0)*(0.5*y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(2) + y(1))\n    !k(2) = dcmplx(0.0,-1.0)*(sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(1))\n    !k(3) = dcmplx(0.0,-1.0)*(-y(3)+sqrt(2.0)*exp(-t*t/5.0)*cos(t)*y(2)+0.5*y(1))\n    !call interactionterm(size(y), y, k, beta_ijkl,beta_ijkl_map)    \n    !write(*,*) k(2)\n    \n  end function f\n"}, {"instruction": "Write a Fortran function named number_of_occupied_adjacent_sets to calculate the number of occupied adjacent sets in a 2D integer array. The function takes 3 input parameters with test_data types ['integer', 'integer', 'integer,dimension(:,:)'] and returns 1 output parameter with a test_data type of ['integer'].", "input": "", "output": "    function number_of_occupied_adjacent_sets(i, j, iarray) result(n_occupied)\n    !! for part 1\n    implicit none\n    integer,intent(in) :: i, j !! index to check\n    integer,dimension(:,:),intent(in) :: iarray\n    integer :: n_occupied, ii, jj\n\n    integer :: n, m\n\n    n = size(iarray,1)\n    m = size(iarray,2)\n\n    n_occupied = 0\n\n    ! ###\n    ! #x#\n    ! ###\n\n    do ii = i-1, i+1\n        do jj = j-1, j+1\n            if (ii==i .and. jj==j) cycle\n            if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n                if (iarray(ii,jj)==1) n_occupied = n_occupied + 1\n            end if\n        end do\n    end do\n\n    end function number_of_occupied_adjacent_sets\n"}, {"instruction": "Create a Fortran function named number_of_occupied_adjacent_sets_2 to calculate the number of occupied adjacent sets surrounding a specified index in a two-dimensional integer array. The function takes 3 input parameters of type integer, integer, and integer array, and returns 1 output parameter of type integer.", "input": "", "output": "    function number_of_occupied_adjacent_sets_2(i, j, iarray) result(n_occupied)\n    !! for part 2\n\n    implicit none\n\n    integer,intent(in) :: i, j !! index to check\n    integer,dimension(:,:),intent(in) :: iarray\n\n    integer :: n_occupied, ii, jj, k\n    integer :: n, m\n\n    n = size(iarray,1)\n    m = size(iarray,2)\n\n    n_occupied = 0\n\n    ! ###\n    ! #x#\n    ! ###\n\n    do ii = i-1, 1, -1\n        select case (iarray(ii,j))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! up\n    do ii = i+1, n\n        select case (iarray(ii,j))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! down\n    do jj = j-1, 1, -1\n        select case (iarray(i,jj))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! left\n    do jj = j+1, m\n        select case (iarray(i,jj))\n        case(1)\n            n_occupied = n_occupied + 1\n            exit\n        case(0)\n            exit\n        end select\n    end do ! right\n\n    ! up->left\n    do k = 1, max(i-1,j-1)\n        ii = i - k\n        jj = j - k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! up->right\n    do k = 1, max(i-1,m-j)\n        ii = i - k\n        jj = j + k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! down->left\n    do k = 1, max(n-i,j-1)\n        ii = i + k\n        jj = j - k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n    ! down->right\n    do k = 1, max(n-i,m-j)\n        ii = i + k\n        jj = j + k\n        if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n            select case (iarray(ii,jj))\n            case(1)\n                n_occupied = n_occupied + 1\n                exit\n            case(0)\n                exit\n            end select\n        end if\n    end do\n\n    end function number_of_occupied_adjacent_sets_2\n"}, {"instruction": "Create a Fortran pure recursive function called indent_newlines that takes two input parameters: a character string (chars) and an integer (n). The function returns one output parameter, an allocatable character string (indented). The function's purpose is to add indentation to each newline character found in the input string based on the value of the integer parameter. If no newline character is found, the original string is returned.", "input": "", "output": "    recursive pure function indent_newlines(chars, n) result(indented)\n        character(len=*), intent(in) :: chars\n        integer, intent(in) :: n\n        character(len=:), allocatable :: indented\n\n        integer :: idx\n\n        idx = index(chars, new_line('c'))\n        if (idx <= 0) then\n            indented = chars\n        else\n            indented = chars(1:idx)    &\n                // repeat(' ', n) // indent_newlines(chars(idx + 1:), n)\n        end if\n    end function\n"}, {"instruction": "Create a Fortran subroutine named core_guess to generate an initial guess for the Fock operator based on the core Hamiltonian. The subroutine takes 2 input parameters: an integer kf representing the basis set size, and a real*8 2D array hc representing the core Hamiltonian. It also has 1 output parameter: a real*8 2D array f representing the initial guess for the Fock operator.", "input": "", "output": "    subroutine core_guess(kf,hc,f)\n        ! ----------------------------\n        ! core hamiltonian\n        ! ----------------------------\n        !\n        ! source:\n        !   a. szabo and n. s. ostlund\n        !   modern quantum chemistry\n        !   dover\n        !   1996\n        !\n        !-----------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                   ! basis set size\n        real*8, dimension(kf,kf), intent(in) :: hc  ! core hamiltonian\n\n        ! output\n        real*8, dimension(kf,kf), intent(out) :: f   ! initial guess for the fock operator\n\n        ! initial guess: core hamiltonian\n        f = hc\n\n    end subroutine core_guess\n"}, {"instruction": "Write a Fortran subroutine named trisolve to solve a constant coefficient, periodic domain, tridiagonal linear system. The subroutine takes 5 input parameters: n (integer), a (real*8 array), b (real*8 array), c (real*8 array), and r (real*8 array). It also has 1 output parameter: x (real*8 array). \n\nThe subroutine uses forward and backward elimination sweeps to solve the tridiagonal linear system. It performs computations based on the values of a, b, c, and r arrays. The final solution is stored in the x array.\n\nYour task is to provide the implementation of the trisolve subroutine by filling in the necessary calculations and assignments.", "input": "", "output": "subroutine trisolve(x,a,b,c,r,n)\n\n  ! to solve the constant coefficient, periodic domain,\n  ! tridiagonal linear system\n  ! ax = r\n  ! where a is the value below the diagonal of a,\n  ! b is the value on the diagonal of a,\n  ! c is the value above the diagonal of a,\n  ! and r is the known vector right hand side.\n\n  implicit none\n\n  integer,intent(in) :: n\n  real*8, intent(in) :: a(n), b(n), c(n), r(n)\n  real*8, intent(out) :: x(n)\n  integer :: j\n  real*8 :: q(n), s(n), rmx, p\n\n\n  rmx=r(n)\n\n  ! forward elimination sweep\n  q(1) = -c(1)/b(1)\n  x(1) = r(1)/b(1)\n  s(1) = -a(1)/b(1)\n  do j = 2, n\n     p = 1.0/(b(j)+a(j)*q(j-1))\n     q(j) = -c(j)*p\n     x(j) = (r(j)-a(j)*x(j-1))*p\n     s(j) = -a(j)*s(j-1)*p\n  enddo\n\n  ! backward pass\n  q(n) = 0.0\n  s(n) = 1.0\n  do j = n-1, 1, -1\n     s(j) = s(j)+q(j)*s(j+1)\n     q(j) = x(j)+q(j)*q(j+1)\n  enddo\n\n  ! final pass\n  x(n) = (rmx-c(n)*q(1)-a(n)*q(n-1))/(c(n)*s(1)+a(n)*s(n-1)+b(n))\n  do j = 1, n-1\n     x(j) = x(n)*s(j)+q(j)\n  enddo\n\n\nend subroutine trisolve\n"}, {"instruction": "Write a Fortran subroutine called lin1db that performs linear interpolation on a one-dimensional bounded domain. The subroutine takes 4 input arguments: n (integer), xg (real*8 array), xd (real*8 array), and q (real*8 array). It also has 1 output argument, qnew (real*8 array).\n\nThe subroutine calculates the interpolation of the quantity q based on the given departure points xd and the grid points xg. It determines the indices of the departure points on the grid and computes the interpolation using the nearby grid points. The interpolated values are stored in the qnew array.\n\nTo use the subroutine, provide the number of grid points (n), the grid points (xg), the departure points (xd), and the quantity values (q). After the subroutine is called, the interpolated values will be stored in the qnew array.\n\nMake sure that the input and output arguments have the correct data types and dimensions to ensure proper execution of the subroutine.", "input": "", "output": "subroutine lin1db(xg,xd,q,qnew,n)\n\n  ! to do 1d linear interpolation to\n  ! advect a quantity q on a one-dimensional bounded\n  ! domain\n\n  implicit none\n\n  integer, intent(in) :: n\n  real*8, intent(in) :: xg(n), xd(n), q(n)\n  real*8, intent(out) :: qnew(n)\n  integer :: i, idx(n), ip, k\n  real*8 :: dx(n - 1), rdx(n - 1), xx(n)\n\n\n\n  ! grid intervals and reciprocals\n  do i = 1, n - 1\n     ip = i + 1\n     dx(i) = xg(ip) - xg(i)\n     rdx(i) = 1.0/dx(i)\n  enddo\n\n  ! find indices to departure points\n  ! and fractions of cells\n  do i = 1, n\n     if (xd(i) .ge. xg(n)) then\n        idx(i) = n - 1\n        xx(i) = 1.0\n     elseif (xd(i) .le. xg(1)) then\n        idx(i) = 1\n        xx(i) = 0.0\n     else\n        k = ceiling((xd(i) - xg(1))/dx(1))\n        k = max(min(k,n-1),1)\n        ! safety check for irregular grid\n        ! ensure xd(i) lies between xg(k) and xg(k+1)\n        do while(xd(i) .lt. xg(k))\n           k = k - 1\n        enddo\n        do while(xd(i) .gt. xg(k+1))\n           k = k + 1\n        enddo\n        idx(i) = k\n        xx(i) = (xd(i) - xg(k))*rdx(k)\n     endif\n  enddo\n\n  ! interpolate\n  do i = 1, n\n     qnew(i) = (1.0 - xx(i))*q(idx(i)) + xx(i)*q(idx(i)+1)\n  enddo\n\n\nend subroutine lin1db\n"}, {"instruction": "Write a Fortran subroutine named residual that calculates the residual for an elliptic problem. \n\nThe subroutine takes 10 input parameters: nx and ny (both integers), nnx and nny (both integers), ff (real*8 array of size nx by ny), rf (real*8 array of size nx by ny), a, b, c, and nu (all real*8). It also has 1 output parameter called resf (real*8 array of size nx by ny).\n\nThe subroutine computes the residual for the elliptic problem using the input parameters and stores the result in the resf array.\n\nTo compute the residual, the subroutine performs calculations for the first row, middle rows, and last row separately, using different formulas based on the values of a, b, c, and nu.\n\nThe subroutine uses loops to iterate over each element of the arrays and perform the necessary calculations.\n\nEnsure that the subroutine is properly implemented and that the indexes of the arrays are handled correctly to avoid out-of-bounds errors.\n\n", "input": "", "output": "subroutine residual(ff,rf,resf,a,b,c,nu,nx,ny,nnx,nny)\n\n  ! calculate residual for elliptic problem\n\n  implicit none\n\n  integer, intent(in) :: nx, ny, nnx, nny\n  real*8, intent(in) :: ff(nx,ny), rf(nx,ny), a(ny), b(ny), c(ny), nu \n  real*8, intent(out) :: resf(nx,ny)\n\n  integer :: i, j, im, jm, ip, jp\n  real*8 :: c0\n\n\n  ! residual in phi equation\n\n  ! first row\n  j = 1\n  jp = modulo(j,nny) + 1\n  c0 = a(j) + 2.0*b(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp)   &\n          + c0*ff(i,j) )\n  enddo\n\n  ! middle rows\n  do j = 2, nny - 1\n     jm = modulo(j - 2,nny) + 1\n     jp = modulo(j,nny) + 1\n     c0 = a(j) + 2.0*b(j) + c(j) + nu\n     do i = 1, nnx\n        im = modulo(i - 2,nnx) + 1\n        ip = modulo(i,nnx) + 1\n        resf(i,j) = ( rf(i,j) &\n             - b(j)*(ff(ip,j) + ff(im,j)) - a(j)*ff(i,jp) - c(j)*ff(i,jm)   &\n             + c0*ff(i,j) )\n     enddo\n  enddo\n\n  ! last row\n  j = nny\n  jm = modulo(j - 2,nny) + 1\n  c0 = 2.0*b(j) + c(j) + nu\n  do i = 1, nnx\n     im = modulo(i - 2,nnx) + 1\n     ip = modulo(i,nnx) + 1\n     resf(i,j) = ( rf(i,j) &\n          - b(j)*(ff(ip,j) + ff(im,j)) - c(j)*ff(i,jm)   &\n          + c0*ff(i,j) )\n  enddo\n\n\nend subroutine residual\n"}, {"instruction": "Write a Fortran subroutine named \"uvatphi\" that averages the values of \"u\" and \"v\" arrays on a C-grid and stores the results in \"up\" and \"vp\" arrays. The subroutine takes 4 input parameters: \"nx\" and \"ny\" of type integer, and \"u\" and \"v\" of type real*8. It also has 2 output parameters: \"up\" and \"vp\" of type real*8. \n\nWithin the subroutine, it is assumed that the polar values of \"v\" have been previously defined by calling a function named \"polar\". \n\nThe subroutine loops over the \"u\" and \"v\" arrays, averaging the values at each point and storing the results in \"up\" and \"vp\" arrays, respectively. \n\nMake sure to include the \"implicit none\" statement at the beginning of the subroutine to enforce explicit declaration of variables.", "input": "", "output": "subroutine uvatphi(nx,ny,u,v,up,vp)\n\n  ! to average u and v to phi points\n  ! on the c-grid\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: u(nx,ny), v(nx,ny+1)\n  real*8, intent(out) :: up(nx,ny), vp(nx,ny)\n\n  integer :: i, ip, j, jp\n\n  ! assume polar values of v have been defined by a previous\n  ! call to polar, e.g. within cgridave\n\n  do j = 1, ny\n     jp = j+1\n     do i = 1, nx\n        ip = i+1\n        if ( i == nx ) ip = 1\n        up(i,j) = 0.5*(u(i,j) + u(ip,j))\n        vp(i,j) = 0.5*(v(i,j) + v(i,jp))\n     enddo\n  enddo\n\nend subroutine uvatphi\n"}, {"instruction": "Write a Fortran subroutine named sph2cart to convert geographical coordinates (latitude and longitude) to Cartesian coordinates. The subroutine takes 2 input parameters of type real (8) representing the latitude and longitude in radians. It also has 3 output parameters of type real (8) representing the Cartesian coordinates (x, y, and z) in the range -1 to 1, where x^2 + y^2 + z^2 = 1. The subroutine uses the cosine and sine functions from the Fortran standard library to perform the conversion.", "input": "", "output": "subroutine sph2cart (lon, lat, x, y, z )\n  !------------------------------------------------------------------------------------\n  ! sph2cart\n  !\n  !     transforms geographical coordinates (lat,lon) to cartesian coordinates.\n  !     similar to stripack's trans\n  !\n  !    input: lat, latitudes of the node in radians [-pi/2,pi/2]\n  !           lon, longitudes of the nodes in radians [-pi,pi]\n  !\n  !    output:  x, y, z, the coordinates in the range -1 to 1.\n  !                    x**2 + y**2 + z**2 = 1\n  !\n  !   p. peixoto 2015\n  !---------------------------------------------------------------------\n  real (8), intent(in) :: lon\n  real (8), intent(in) :: lat\n  real (8), intent(out) :: x\n  real (8), intent(out) :: y\n  real (8), intent(out) :: z\n  real (8):: coslat\n\n  coslat = dcos (lat)\n  x = coslat * dcos (lon)\n  y = coslat * dsin (lon)\n  z = dsin (lat)\n\n  return\nend subroutine sph2cart\n"}, {"instruction": "Create a Fortran subroutine named bondseek to analyze the spatial positions of particles and count the number of bonds within specified distance ranges. The number of input arguments is 4 with test_data types ['integer*4', 'real*8', 'real*8', 'real*8'], and the number of output arguments is 1 with test_data type ['integer*4'].", "input": "", "output": "subroutine bondseek(n,positions,r0,r1,bn)\n\n    implicit none\n\n    integer*4, intent(in)       :: n\n    real*8,    intent(in)       :: r0,r1\n    real*8,    intent(in)       :: positions(n,3)\n\n    integer*4 :: i,j,k\n    integer*4, intent(out) :: bn\n\n    real*8 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n\n    bn = 0\n\n    do i = 1, (n - 1)\n        xi = positions(i,1)\n        yi = positions(i,2)\n        zi = positions(i,3)\n        do j = 1, n\n            if (i .ge. j) cycle\n            xj = positions(j,1)\n            yj = positions(j,2)\n            zj = positions(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = sqrt(dx * dx + dy * dy + dz * dz)\n\n            if (mdl .ge. r0 .and. mdl .le. r1) bn = bn + 1\n\n        end do\n    end do\n    return\nend subroutine bondseek\n"}, {"instruction": "Create a Fortran subroutine named calc_xika to perform complex calculations for a scientific application. The subroutine has 9 input parameters of types ['integer', 'integer', 'integer', 'real(8), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1)', 'real(8), dimension(0:ncomp-1)', 'real(8), dimension(0:ncomp-1,0:nbeads-1)', 'real(8), dimension(0:nbeads-1,0:nsitemax-1)', 'real(8), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1)', 'real(8)'], and 2 output parameters of types ['real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)', 'real(8), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1)']. The subroutine performs a series of nested calculations involving the input arrays and returns the results in the output arrays.", "input": "", "output": "subroutine calc_xika(xika0,xi,rho,nui,nk,delta,obj_func,xika,ncomp,nbeads,nsitemax)\n    implicit none\n    integer,intent(in) :: ncomp, nbeads, nsitemax\n    real(8), intent(in), dimension(0:ncomp-1, 0:nbeads-1, 0:nsitemax-1) :: xika0\n    real(8), intent(in), dimension(0:ncomp-1) :: xi\n    real(8), intent(in), dimension(0:ncomp-1,0:nbeads-1) :: nui\n    real(8), intent(in), dimension(0:nbeads-1,0:nsitemax-1) :: nk\n    real(8), intent(in), dimension(0:ncomp-1,0:ncomp-1,0:nbeads-1,0:nbeads-1,0:nsitemax-1,0:nsitemax-1) :: delta\n    real(8), intent(in) :: rho\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: obj_func\n    real(8), intent(out), dimension(0:ncomp-1,0:nbeads-1,0:nsitemax-1) :: xika\n    integer :: i,k,a,j,l,b\n    \n    !initialize xika to 1.0\n    xika=1.0\n    \n    do i=0, ncomp-1\n        do k=0, nbeads-1\n            do a=0, nsitemax-1\n                do j=0, ncomp-1\n                    do l=0, nbeads-1\n                        do b=0, nsitemax-1\n                            xika(i,k,a)=xika(i,k,a) + (rho * xi(j) * nui(j,l) * nk(l,b) * xika0(j,l,b) * delta(i,j,k,l,a,b))\n                        enddo\n                    enddo\n                enddo\n            enddo\n        enddo\n    enddo\n    xika = (1.0/xika)\n    \n    obj_func = xika - xika0\n    \nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"analyt\" to calculate the seismic wave velocities and density at different depths based on the given medium type and the number of layers. The number of input parameters is 2, of type ['integer', 'integer']. The number of output parameters is 3, of types ['real     (kind=8)', 'complex  (kind=8)', 'complex  (kind=8)'].", "input": "", "output": "subroutine analyt( cp, cs, rho, medium, n1 )\r\n\r\n  !     munk profile\r\n\r\n  !     returns\r\n  !        cs, cp, rho at depths i*h i = 1, n\r\n  !        depths of interfaces\r\n\r\n  implicit none\r\n  integer,           intent(in)  :: medium, n1\r\n  real     (kind=8), intent(out) :: rho( * )\r\n  complex  (kind=8), intent(out) :: cp( * ), cs( * )\r\n  integer                        :: i, n\r\n  real     (kind=8), parameter   :: eps = 0.00737\r\n  real     (kind=8)              :: h, x, z\r\n\r\n  n = n1 - 1\r\n\r\n  select case ( medium )\r\n\r\n  case ( 1 )   ! the ocean\r\n     h = 5000.0 / n\r\n     do i = 1, n1\r\n        z = ( i - 1 ) * h\r\n        x = 2.0 * ( z - 1300.0 ) / 1300.0\r\n        cp(  i ) = 1500.0 * ( 1.0 + eps * ( x - 1.0 + exp( -x ) ) )\r\n        cs(  i ) = 0.0\r\n        rho( i ) = 1.0\r\n     end do\r\n     return\r\n\r\n  case ( 2 )   ! the fluid half-space\r\n     cp(  1 ) = 1551.91\r\n     cs(  1 ) = 0.0\r\n     rho( 1 ) = 1.0e20\r\n     return\r\n\r\n  case( 9 )  ! an elastic layer\r\n     h = 1000.0 / n\r\n     z = 5000.0\r\n\r\n     do i = 1,n+1\r\n        cp( i ) = 4700.0 + ( z - 5000.0 ) / 10.0\r\n        cs( i ) = 2000.0 + ( z - 5000.0 ) / 10.0\r\n        cp( i ) = 4700.0\r\n        cs( i ) = 2000.0\r\n        rho( i ) = 2.0\r\n        z = z + h\r\n     end do\r\n  end select\r\n\r\nend subroutine analyt\r\n"}, {"instruction": "Create a Fortran subroutine named \"insertionsort\" to perform the insertion sort algorithm on an array of integers. The subroutine will take 2 input parameters of type integer array and an additional input parameter of type integer to specify the size of the array. It will also have 1 output parameter of type integer array.", "input": "", "output": "  subroutine insertionsort(inarray,outarray,n)\n\n    implicit none\n    integer,intent(in)  :: n\n    integer,intent(in)  :: inarray(1:n)\n    integer,intent(out) :: outarray(1:n)\n    ! local\n    integer :: i,j\n    integer :: temp\n\n    outarray = inarray\n\n    do i = 2,n\n      j = i\n      do while (j > 1)\n        if (outarray(j - 1) > outarray(j)) then\n          !swap outarray(j) outarray(j-1)\n          temp = outarray(j)\n          outarray(j) = outarray(j - 1)\n          outarray(j - 1) = temp\n          j = j - 1\n        else\n          exit\n        end if\n      end do\n    end do\n\n  end subroutine insertionsort\n"}, {"instruction": "Write a Fortran subroutine named \"blocksplitter\" to split a given number of rows into multiple intervals based on the specified number of threads and interval parameters. The subroutine should take 3 input parameters of type integer (inorows, ithreads, iparam) and 1 output parameter of type integer with the allocatable attribute (oblocks). The inorows is the total number of rows, ithreads is the number of threads, and iparam is the interval parameter. The oblocks array will store the start and end indices of each interval. Use the imperative tone in the instructions.", "input": "", "output": "  subroutine blocksplitter(inorows,ithreads,iparam,oblocks)\r\n    !tue, september 2014\r\n    !splits inorows into ithreads intervals.\r\n    !each interval will have a length of iparam*n, where n is a natural number.\r\n    !the result will be saved in oblocks, where oblocks(i,1) is the start of the i'th interval and oblocks(i,2) is the end of the interval\r\n    !io\r\n    !update 2015 tue\r\n    !fixed the case if inorows < ithreads\r\n    implicit none\r\n    integer,intent(in)                :: inorows,ithreads\r\n    integer,intent(in)                :: iparam\r\n    integer,intent(out),allocatable       :: oblocks(:,:)\r\n    !local vars\r\n    integer                           :: i\r\n    integer                           :: blocksize\r\n    \r\n    blocksize=max(inorows/ithreads,1) \r\n    blocksize =mod(iparam-mod(blocksize,iparam),iparam)+blocksize\r\n    allocate(oblocks(ithreads,2))\r\n    do i=1,ithreads\r\n        oblocks(i,1) = (i-1)*(blocksize)+1\r\n        oblocks(i,2) = min(i*blocksize,inorows)\r\n    end do     \r\n    print*,'blocks',oblocks\r\n  end subroutine blocksplitter  \r\n"}, {"instruction": "Create a Fortran subroutine named \"apply_bprecondition_blut\" to perform forward and backward block solve operations using block LUT matrix. The subroutine takes 5 input parameters: an integer array iblocks, a real*8 array irhs, a real*8 array iluvals, an integer array iluidxs, and an integer array iludiag. It also has 1 output parameter: a real*8 array ox. The subroutine should solve the system using the provided block LU matrix and store the result in the output array ox.", "input": "", "output": "subroutine apply_bprecondition_blut(iblocks, irhs, ox, iluvals, iluidxs, iludiag) \r\n    !tue november 2014\r\n    !this routine does a forward and backward block solve with the block lut matrix\r\n    !\r\n    !io\r\n    !\r\n    !iblocks                 -> the blocksplitting of the matrix\r\n    !irhs                    -> the righthandside we update our solution after\r\n    !ox                      -> the output solution\r\n    !iluvals,iluidxs,iludiag -> the block lu matrix where each block is a separate matrix stored in modfied sparse row format.\r\n\tinteger,intent(in),dimension(:,:) :: iblocks\r\n    real*8,intent(in),dimension(:)    :: irhs\r\n    real*8,intent(out),dimension(:)   ::  ox\r\n    real*8,intent(in),dimension(:,:)  :: iluvals\r\n    integer,intent(in),dimension(:,:) :: iluidxs, iludiag    \r\n    !local variables\r\n    integer             :: i,k,j,threads,m,tmp\r\n    \r\n    \r\n    threads=size(iblocks,1)\r\n!$omp parallel if(startopenmp(2)) default(none)  shared(iblocks,threads,irhs,ox,iluvals,iluidxs,iludiag) private(k,i,j,m,tmp)\r\n!$omp do schedule(static)\r\n    do k=1,threads\r\n        do i = iblocks(k,1),iblocks(k,2)\r\n           ox(i) = irhs(i)\r\n        end do\r\n!\r\n! forward solve (with u^t)\r\n!\r\n       tmp=iblocks(k,1)-1\r\n       m=0\r\n        do i = iblocks(k,1),iblocks(k,2)\r\n           m=m+1\r\n           ox(i) = ox(i) * iluvals(m,k)\r\n           do j=iludiag(m,k),iluidxs(m+1,k)-1\r\n              ox(tmp+iluidxs(j,k)) = ox(tmp+iluidxs(j,k)) - iluvals(j,k)* ox(i)\r\n           end do\r\n        end do\r\n!     \r\n!     backward solve (with l^t)\r\n!    \r\n      do i = iblocks(k,2),iblocks(k,1),-1\r\n       m=i-tmp\r\n\t   do j=iluidxs(m,k),iludiag(m,k)-1\r\n              ox(tmp+iluidxs(j,k)) = ox(tmp+iluidxs(j,k)) - iluvals(j,k)*ox(i)\r\n       end do\r\n      end do\r\n    end do\r\n!$omp end do\r\n!$omp end parallel      \r\nend subroutine apply_bprecondition_blut  \r\n"}, {"instruction": "Create a Fortran subroutine named coordinate3dp to calculate the coordinates of points in a 3D grid. The subroutine takes 3 input parameters of type integer, integer, and real(8) and produces 10 output parameters of type real(8). The input parameters represent the grid dimensions and grid spacing, while the output parameters store the coordinates of the grid points.", "input": "", "output": "  subroutine coordinate3dp(imax,jmax,ds0,xcol,zcol,xs1,xs2,xs3,xs4,zs1,zs2,zs3,zs4)\n    implicit none\n    integer,intent(in)::imax,jmax\n    real(8),intent(in)::ds0\n    real(8),intent(out)::xcol(:),zcol(:)\n    real(8),intent(out)::xs1(:),xs2(:),xs3(:),xs4(:),zs1(:),zs2(:),zs3(:),zs4(:)\n    real(8)::dx,dz\n    integer::i,j,k\n\n    dx=ds0\n    dz=ds0\n    do i=1,imax\n      do j=1,jmax\n        k=(i-1)*jmax+j\n        xcol(k)=(i-imax/2-0.5d0)*dx\n        zcol(k)=-(j-jmax/2-0.5d0)*dz\n        xs1(k)=xcol(k)+0.5d0*dx\n        xs2(k)=xcol(k)-0.5d0*dx\n        xs3(k)=xcol(k)-0.5d0*dx\n        xs4(k)=xcol(k)+0.5d0*dx\n        zs1(k)=zcol(k)+0.5d0*dz\n        zs2(k)=zcol(k)+0.5d0*dz\n        zs3(k)=zcol(k)-0.5d0*dz\n        zs4(k)=zcol(k)-0.5d0*dz\n      end do\n    end do\n    return\n  end subroutine coordinate3dp\n"}, {"instruction": "Create a Fortran subroutine named gauleg_ng to compute the Gaussian quadrature points and weights. The subroutine takes 4 input parameters of type integer, integer, real(ffp), and real(ffp), and 2 output parameters of type real(ffp). The input parameters correspond to the range of integration and the number of points, while the output parameters store the computed quadrature points and weights.", "input": "", "output": "subroutine gauleg_ng(x1,x2,x,w,n,nmax)\n\n   implicit none\n\n!  parameter argument\n\n   integer, parameter :: ffp = selected_real_kind(15)\n\n!  input/output\n\n      integer  , intent(in)  :: n,nmax\n      real(ffp), intent(in)  :: x1, x2\n      real(ffp), intent(out) :: x(nmax),w(nmax)\n\n      integer     :: i, m, j\n      real(ffp)   :: xm,xl,p1,p2,p3,pp,z,z1\n      real(ffp)   :: quant, rn, rj, pie, arg\n\n      real(ffp), parameter :: eps = 3.0d-14\n      real(ffp), parameter :: zero = 0.0_ffp\n      real(ffp), parameter :: one  = 1.0_ffp\n      real(ffp), parameter :: two  = 2.0_ffp\n      real(ffp), parameter :: half  = 0.5_ffp\n      real(ffp), parameter :: qtr   = 0.25_ffp\n\n      m=(n+1)/2\n      xm = half * (x2+x1)\n      xl = half * (x2-x1)\n      rn = real(n,ffp)\n      z1 = zero\n      pie = acos(-one)\n\n      do i=1,m\n            arg = ( real(i,ffp) - qtr ) / ( rn + half )\n!            z=cos(3.141592654d0*(i-.25d0)/(n+.5d0))\n            z  = cos ( pie * arg )\n            do while (abs(z-z1).gt.eps)\n                  p1=one\n                  p2=zero\n                  do j=1,n\n                        rj = real(j,ffp)\n                        p3=p2\n                        p2=p1\n                        p1= ( ( two*rj-one)*z*p2-(rj-one)*p3 ) / rj\n                        p1= ( ( two*rj-one)*z*p2-(rj-one)*p3 ) / rj\n                  enddo\n                  pp=rn*(z*p1-p2)/(z*z-one)\n                  z1=z\n                  z=z1-p1/pp\n            enddo\n            quant = two / ( ( one-z*z) * pp *pp )\n            x(i)     = xm - xl*z\n            x(n+1-i) = xm + xl*z\n            w(i)     = quant * xl\n            w(n+1-i) = w(i)\n      enddo\n      return\nend subroutine gauleg_ng\n"}, {"instruction": "Write a Fortran subroutine named firstpanel to extract information from an array. The subroutine takes 3 input parameters of type integer, and 2 output parameters of type integer. The input array panels has a dynamic size specified by ldpanels. The subroutine uses the values of ldpanels, ithd, and panels to calculate the values of j and np, which are then returned as output parameters. The subroutine should be used to extract specific information from the panels array and store it in the output variables j and np.", "input": "", "output": "subroutine firstpanel(panels,ldpanels,ithd,j,np)\r\n   implicit none\r\n\r\n   ! .. scalar arguements ..\r\n   integer, intent(in) :: ldpanels,ithd\r\n   integer, intent(out) :: j, np\r\n\r\n   ! .. array arguements ..\r\n   integer, intent(in) :: panels(ldpanels,*)\r\n\r\n   ! .. local scalars ..\r\n   integer :: ind\r\n\r\n   ind=ithd+1\r\n   j=panels(1,ind) !jfirst\r\n   np=panels(2,ind) !nfirst\r\n\r\nend subroutine firstpanel\r\n"}, {"instruction": "Create a Fortran subroutine named \"gregorian\" that takes a single input parameter of type real and returns three output parameters of type integer to convert the Julian date to Gregorian date.", "input": "", "output": "subroutine gregorian (julian, year, month, day)\n\nimplicit none\n\nreal,    intent(in)  :: julian\ninteger, intent(out) :: year, month, day\n\ninteger :: i, j, k, l, n\n\nl = julian + 68569\nn = 4*l/146097\nl = l - (146097*n+3)/4\ni = 4000*(l+1)/1461001\nl = l - 1461*i/4 + 31\nj = 80*l/2447\nk = l - 2447*j/80\nl = j/11\nj = j+2-12*l\ni = 100*(n-49) + i + l\n\nyear = i\nmonth = j\nday = k\n\nreturn\n\nend subroutine gregorian\n"}, {"instruction": "Write a Fortran subroutine named comp_correl that computes the correlation coefficient between two sets of data. The subroutine takes 2 input parameters: an integer 'n' representing the number of data points, and a 2D array 'ens' of size (2, n) containing the data points. The data points are of type double precision. The subroutine also has 1 output parameter named 'correl', which is of type double precision.", "input": "", "output": "subroutine comp_correl(ens, n, correl)\n \nimplicit none\n \ninteger, intent(in) :: n\ndouble precision, intent(in) :: ens(2, n)\ndouble precision, intent(out) :: correl\ndouble precision :: sum_x, sum_y, sum_xy, sum_x2, sum_y2\n\n\nsum_x = sum(ens(2, :))\nsum_y = sum(ens(1, :))\nsum_xy = sum(ens(2, :) * ens(1, :))\nsum_x2 = sum(ens(2, :) * ens(2, :))\n \n! computation of correlation \nsum_y2 = sum(ens(1, :) * ens(1, :))\n\ncorrel = (n * sum_xy - sum_x * sum_y) / &\n   sqrt((n * sum_x2 - sum_x**2) * (n * sum_y2 - sum_y**2))\n \nend subroutine comp_correl\n"}, {"instruction": "Write a Fortran subroutine named \"harmonicsr\" that calculates spherical harmonics for a given set of input parameters. The subroutine takes 2 input parameters: an integer value \"ll\" and a real array \"rvec\" of size 3. It also has 1 output parameter: a complex array \"y\" of size (ll + 1)^2. \n\nThe subroutine computes the spherical harmonics for each value of \"l\" and \"m\" using the input parameters \"ll\" and \"rvec\". The calculated values are stored in the output array \"y\". The subroutine uses various intermediate variables and operations such as complex numbers, trigonometric functions, and mathematical operations to perform the calculations.\n\nThe purpose of this subroutine is to provide an efficient and accurate method to compute spherical harmonics for a given set of input parameters.", "input": "", "output": "   pure subroutine harmonicsr(y, rvec, ll)\n\n      implicit none\n\n      integer  , intent(in)  :: ll\n      real  , intent(in)  :: rvec(3)\n      complex, intent(out) :: y((ll + 1)**2)\n      complex               :: c\n      real                    :: stheta, ctheta, sphi, cphi, r, rvec1(3)\n      integer                 :: l, m, lm\n      complex, parameter   :: img = (0.0, 1.0)\n\n      y(1) = 0.282094791773878\n      if (ll == 0) return\n\n      stheta = 0\n      ctheta = 0\n      sphi = 0\n      cphi = 0\n      r = norm2(rvec)\n      if (r > 1e-16) then\n         rvec1 = rvec/r\n         ctheta = rvec1(3)\n         stheta = sqrt(rvec1(1)**2 + rvec1(2)**2)\n         if (stheta > 1e-16) then\n            cphi = rvec1(1)/stheta\n            sphi = rvec1(2)/stheta\n         end if\n      else\n         y(2:) = 0.0\n         return\n      end if\n\n!     define y,l,-l and y,l,l\n      r = y(1)\n      c = 1\n      do l = 1, ll\n         r = r*stheta*sqrt(1.0 + 1.0/(2*l))\n         c = c*(cphi + img*sphi)\n         y(l**2 + 1) = r*conjg(c)  ! l,-l\n         y((l + 1)**2) = r*c*(-1)**l ! l,l\n      end do\n\n!     define y,l,-l+1 and y,l,l-1\n      y(3) = 0.48860251190292*ctheta\n      do l = 2, ll\n         r = sqrt(2.0*l + 1)*ctheta\n         y(l**2 + 2) = r*y((l - 1)**2 + 1) ! l,-l+1\n         y(l*(l + 2)) = r*y(l**2)       ! l,l-1\n      end do\n\n!     define y,l,m, |m|<l-1\n      do l = 2, ll\n         lm = l**2 + 2\n         do m = -l + 2, l - 2\n            lm = lm + 1\n            y(lm) = sqrt((2.0*l + 1)/(l + m)/(l - m))*( &\n                    sqrt(2.0*l - 1)*ctheta*y(lm - 2*l) - &\n                    sqrt((l + m - 1.0)*(l - m - 1)/(2*l - 3))*y(lm - 4*l + 2))\n         end do\n      end do\n\n   end subroutine harmonicsr\n"}, {"instruction": "Create a Fortran subroutine named \"ozphys_2015_init\" to initialize variables for error handling related to the \"oz_phys_2015\" logic. The subroutine takes 1 input parameter of type \"logical\" and 2 output parameters, one of type \"character(len=*)\" and the other of type \"integer\". \n\nIn the subroutine, first initialize the error handling variables. Then, check if the input parameter \"oz_phys_2015\" is false. If it is false, assign an error message to the \"errmsg\" parameter and set the \"errflg\" parameter to 1. Finally, return from the subroutine.", "input": "", "output": "      subroutine ozphys_2015_init(oz_phys_2015, errmsg, errflg)\n\n      implicit none\n      logical,          intent(in)  :: oz_phys_2015\n      character(len=*), intent(out) :: errmsg\n      integer,          intent(out) :: errflg\n\n      ! initialize ccpp error handling variables\n      errmsg = ''\n      errflg = 0\n\n      if (.not.oz_phys_2015) then\n        write (errmsg,'(*(a))') 'logic error: oz_phys_2015 == .false.'\n        errflg = 1\n        return\n      endif\n\n      end subroutine ozphys_2015_init\n"}, {"instruction": "Create a Fortran subroutine called sub_solve_quadratic_real128_equation to solve a quadratic equation with real128 precision. The subroutine takes 3 input arguments with the test_data type of ['real(kind = real128)', 'real(kind = real128)', 'real(kind = real128)'] and 2 output arguments with the test_data type of ['real(kind = real128)', 'real(kind = real128)']. The subroutine uses the if-else statement to check the sign of the second input argument. If it is greater than or equal to zero, it calculates the values of the output arguments using the quadratic formula with negative sign. Otherwise, it calculates the values using the quadratic formula with positive sign.", "input": "", "output": "pure subroutine sub_solve_quadratic_real128_equation(a, b, c, x1, x2)\n    use iso_fortran_env\n\n    implicit none\n\n    ! declare inputs/outputs ...\n    real(kind = real128), intent(in)                                            :: a\n    real(kind = real128), intent(in)                                            :: b\n    real(kind = real128), intent(in)                                            :: c\n    real(kind = real128), intent(out)                                           :: x1\n    real(kind = real128), intent(out)                                           :: x2\n\n    ! check sign of b ...\n    if(b >= 0.0e0_real128)then\n        x1 = (-b - sqrt(b ** 2 - 4.0e0_real128 * a * c)) / (2.0e0_real128 * a)\n        x2 = (2.0e0_real128 * c) / (-b - sqrt(b ** 2 - 4.0e0_real128 * a * c))\n    else\n        x1 = (2.0e0_real128 * c) / (-b + sqrt(b ** 2 - 4.0e0_real128 * a * c))\n        x2 = (-b + sqrt(b ** 2 - 4.0e0_real128 * a * c)) / (2.0e0_real128 * a)\n    end if\nend subroutine sub_solve_quadratic_real128_equation\n"}, {"instruction": "Write a Fortran subroutine named make_array_logspace that generates a logarithmically spaced array of values between a start and end point. The number of input arguments is 3, with the test_data types as follows: ['integer', 'double precision', 'double precision']. The number of output arguments is 1, with the test_data type being ['double precision'].\n\nThe subroutine takes as input the dimension of the array, the start value, and the end value. It calculates the logarithmic spacing between these values and stores the resulting array in the output argument.\n\nIf the dimension is greater than 1, the subroutine computes the logarithmically spaced values using a loop and the formula 10**exp, where exp is incrementally adjusted based on the desired spacing. If the dimension is 1, the start value is directly assigned to the output array. If the dimension is less than 1, an error message is displayed.\n\nMake sure to use the appropriate Fortran keywords and syntax when implementing the subroutine.", "input": "", "output": "      subroutine make_array_logspace(a_start, a_end, dim, out)\n      implicit none\n      integer         , intent(in) :: dim\n      double precision, intent(in) :: a_start, a_end\n      double precision, intent(out):: out(dim)\n      integer                      :: i\n      double precision             :: du,u1,u2,exp\n      if (dim.gt.1) then\n         u1=log10(a_start)\n         u2=log10(a_end)      \n         du=(u2-u1)/float(dim-1)\n         exp=log10(a_start)\n         do i=1, dim\n            out(i)=10**exp\n            exp=exp+du\n         enddo\n      else if(dim.eq.1) then\n       out(1)=a_start\n      else if(dim.lt.1) then\n       write(*,'(a)',advance=\"no\") 'error! it is impossible create' \n       write(*,*) ' the log scaled array: dim is less than 1'\n       stop\n      endif\n      return\n    end subroutine make_array_logspace\n"}, {"instruction": "Create a Fortran subroutine named approx_norm1 that calculates an approximate norm of a 2D array. The subroutine has 1 input parameter of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8).", "input": "", "output": "    subroutine approx_norm1(a, anorm)\n\n    implicit none\n    real(kind=8), dimension(:,:), intent(in) :: a\n    real(kind=8), intent(out) :: anorm\n\n    anorm = -1.d0   ! this obviously isn't correct\n\n    end subroutine approx_norm1\n"}, {"instruction": "Write a Fortran subroutine named score that calculates the score based on a given guess and a secret number. The number of input arguments is 2 and the test_data type is ['character(*)', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].\n\nThe subroutine takes a guess as input, which is a string of characters representing a number, and an array of integers representing the secret number. It calculates two values, 'b' and 'c', which represent the number of correct digits in the correct positions ('b') and the number of correct digits in incorrect positions ('c').\n\nInside the subroutine, 'b' and 'c' are initialized to 0. It then iterates over each character in the guess and compares it to the corresponding digit in the secret number. If the digits match, 'b' is incremented. If the digits don't match, it searches for the digit in the secret number starting from the current position and moving three positions ahead. If it finds a match, 'c' is incremented and the loop is exited.\n\nThe subroutine does not have a return statement as the values of 'b' and 'c' are updated directly in the output parameters.\n\nUse this subroutine to determine the score of a guess in a game or any other scenario where you need to compare two numbers.", "input": "", "output": "  subroutine score(n, guess, b, c)\n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n\n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do\n      end if\n    end do\n\n end subroutine score\n"}, {"instruction": "Create a Fortran subroutine named \"mah\" that takes an integer input parameter and returns an integer output parameter. The purpose of the subroutine is to perform certain operations on arrays of real and complex numbers. The input parameter is of type 'integer' and the output parameter is also of type 'integer'.", "input": "", "output": "subroutine mah (i, c)\n  !\n  integer, intent(in) :: i\n  integer, intent(out) :: c\n  !\n  type mix_type\n     real(8), allocatable :: a(:)\n     complex(8), allocatable :: b(:)\n  end type mix_type\n  type(mix_type), allocatable, save :: t(:)\n  integer :: j, n=1024\n  !\n  if (i==0) then\n     allocate (t(1))\n     allocate (t(1)%a(n))\n     allocate (t(1)%b(n))\n     do j=1,n\n        t(1)%a(j) = j\n        t(1)%b(j) = n-j\n     end do\n  end if\n  c = sum( t(1)%a(:) ) + sum( t(1)%b(:) )\n  if ( i==2) then\n     deallocate (t(1)%b)\n     deallocate (t(1)%a)\n     deallocate (t)\n  end if\nend subroutine mah\n"}, {"instruction": "Write a Fortran subroutine named beam_mm to calculate the stiffness matrix of a beam element based on its length and material properties. The number of input arguments is 2 with the test_data type real(iwp) and the number of output arguments is 1 with the test_data type real(iwp).", "input": "", "output": "subroutine beam_mm(mm,fs,ell)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::fs,ell\n real(iwp),intent(out)::mm(:,:)\n real(iwp)::fac\n fac=(fs*ell)/420.0_iwp \n mm(1,1)=156.0_iwp*fac\n mm(3,3)=mm(1,1)\n mm(1,2)=22.0_iwp*ell*fac\n mm(2,1)=mm(1,2)\n mm(3,4)=-mm(1,2)\n mm(4,3)=mm(3,4)\n mm(1,3)=54.0_iwp*fac\n mm(3,1)=mm(1,3)\n mm(1,4)=-13.0_iwp*ell*fac\n mm(4,1)=mm(1,4)\n mm(2,3)=-mm(1,4)\n mm(3,2)=mm(2,3)\n mm(2,2)=4.0_iwp*(ell**2)*fac\n mm(4,4)=mm(2,2)\n mm(2,4)=-3.0_iwp*(ell**2)*fac\n mm(4,2)=mm(2,4)\nreturn\nend subroutine beam_mm  \n"}, {"instruction": "Write a Fortran subroutine named simp to perform numerical integration using Simpson's rule. The subroutine takes 3 input parameters of type integer, integer, and real(8) and 1 output parameter of type real(8).", "input": "", "output": "  subroutine simp(f,s,n,m)\n    implicit none\n    integer,intent(in)  :: n,m\n    real(8),intent(in)  :: f(n)\n    real(8),intent(out) :: s\n    real(8),allocatable :: g(:)\n    integer :: i,nmax\n    nmax=int(n/m)*m\n    do i=0,m\n       nmax=nmax+i ; if ( nmax>=n ) exit\n    end do\n    allocate( g(nmax) ) ; g(1:n)=f ; if ( nmax>n ) g(n+1:)=0.d0\n    select case(m)\n    case default\n       s = 0.5d0*(f(1)+f(n)) + sum(f(2:n-1))\n    case(2)\n       s=0.d0\n       do i=1,nmax-2,2\n          s = s + g(i) + 4.d0*g(i+1) + g(i+2)\n       end do\n       s=s/3.d0\n    case(4)\n       s=0.d0\n       do i=1,nmax-4,4\n          s=s+7*g(i)+32*g(i+1)+12*g(i+2)+32*g(i+3)+7*g(i+4)\n       end do\n       s=s*2.d0/45.d0\n    case(6)\n       s=0.d0\n       do i=1,nmax-6,6\n          s=s+41*g(i)+216*g(i+1)+27*g(i+2)+272*g(i+3) &\n               +27*g(i+4)+216*g(i+5)+41*g(i+6)\n       end do\n       s=s/140.d0\n    end select\n    deallocate( g )\n    return\n  end subroutine simp\n"}, {"instruction": "Write a Fortran subroutine named gram_real that performs Gram-Schmidt orthonormalization on a matrix of real numbers. The subroutine takes 3 input parameters of types integer, integer, and real(8) and 1 output parameter of type real(8). The input parameters represent the dimensions and the input matrix, while the output parameter represents the orthonormalized matrix.", "input": "", "output": "subroutine gram_real(m,n,mat_v,mat_v_out)\r\n  ! cited from \r\n  !http://park.itc.u-tokyo.ac.jp/kato-yusuke-lab/nagai/note_141009_lobpcg.pdf\r\n  implicit none\r\n  ! m : \u30d9\u30af\u30c8\u30eb\u306e\u6b21\u5143\r\n  ! n : \u30d9\u30af\u30c8\u30eb\u306e\u672c\u6570\r\n  integer,intent(in)::m,n\r\n  real(8),intent(in)::mat_v(1:m,1:n)\r\n  real(8),intent(out)::mat_v_out(1:m,1:n)\r\n  integer::i,j\r\n  real(8)::v(1:m),nai,vi(1:m),viold(1:m)\r\n  real(8)::norm\r\n  mat_v_out = mat_v\r\n  do i = 1,n\r\n      viold = mat_v_out(:,i)\r\n      do j = 1,i-1\r\n          nai = dot_product(mat_v_out(1:m,j),viold(1:m))\r\n          vi = viold - nai*mat_v_out(:,j)\r\n          viold = vi\r\n      end do\r\n      norm = sqrt(dble(dot_product(viold,viold)))\r\n      if(norm==0.0d0)then\r\n          ! debug right?\r\n          print *, \"error gram_real :: norm-zero\"\r\n          mat_v_out(j,j) =1.0d0\r\n          !\r\n          !stop\r\n          \r\n          !mat_v_out(:,j) = viold\r\n      else\r\n          mat_v_out(:,j) = viold/norm\r\n      endif\r\n  end do\r\n  return\r\nend subroutine gram_real\r\n"}, {"instruction": "Write a Fortran subroutine named alloc_array_return that takes an integer n_items as input and returns an array of strings. The input parameter is of type integer. The output parameter is a pointer to an array of strings, where each string has a length of 60 characters.", "input": "", "output": "    subroutine alloc_array_return(n_items, array)\n        integer, intent(in) :: n_items\n        character(60), dimension(:), pointer, intent(out) :: array\n        integer :: i\n\n        allocate(array(n_items))\n\n        do i = 1, n_items\n            write (array(i), \"(i8)\") i\n        end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named bsel to calculate the number of bonds detected in the specified cutoff for a set of coordinates. The subroutine takes 3 input parameters of type integer*4, real*8, and real*8, dimension(n,3). The output parameter is of type integer*8.", "input": "", "output": "subroutine bsel(n, vp, rcut, dimcouples)\n\n    implicit none\n    integer*4, intent(in)                  :: n\n    real*8,    intent(in)                  :: rcut\n    real*8,    intent(in) , dimension(n,3) :: vp\n    integer*8, intent(out)                 :: dimcouples\n\n    integer*4                              :: i,j\n    real*8                                 :: xi,yi,zi,xj,yj,zj,dx,dy,dz,mdl\n    real*8                                 :: rcutsq\n\n    rcutsq = rcut*rcut\n\n\n    do i = 1, (n - 1)\n        xi = vp(i,1)\n        yi = vp(i,2)\n        zi = vp(i,3)\n\n        do j = 1, n\n            if (i >= j) cycle\n\n            xj = vp(j,1)\n            yj = vp(j,2)\n            zj = vp(j,3)\n\n            dx = abs(xj - xi)\n            dy = abs(yj - yi)\n            dz = abs(zj - zi)\n\n            mdl = dx*dx + dy*dy + dz*dz\n            !mdl = int(mdl * 10.0**3) / 10.0**3\n\n            if (mdl > rcutsq) then\n                cycle\n            else\n                dimcouples = dimcouples + 1        \n            end if\n        end do\n    end do\n\n    print *,\"bonds detected in the specified cutoff:\",dimcouples\n\n    return\nend subroutine bsel\n"}, {"instruction": "Create a Fortran subroutine named find_root that computes the root of a function using the Newton-Raphson method. The subroutine takes 4 input parameters of type real, real, real, and integer, and 2 output parameters of type real and logical.", "input": "", "output": "subroutine find_root( f, xinit, tol, maxiter, result, success )\n\n    interface\n        real function f(x)\n            real, intent(in) :: x\n        end function f\n    end interface\n\n    real, intent(in)     :: xinit\n    real, intent(in)     :: tol\n    integer, intent(in)  :: maxiter\n    real, intent(out)    :: result\n    logical, intent(out) :: success\n\n    real                 :: eps = 1.0e-4\n    real                 :: fx1\n    real                 :: fx2\n    real                 :: fprime\n    real                 :: x\n    real                 :: xnew\n    integer              :: i\n\n    result  = 0.0\n    success = .false.\n\n    x = xinit\n    do i = 1,max(1,maxiter)\n        fx1    = f(x)\n        fx2    = f(x+eps)\n        write(*,*) i, fx1, fx2, eps\n        fprime = (fx2 - fx1) / eps\n\n        xnew   = x - fx1 / fprime\n\n        if ( abs(xnew-x) <= tol ) then\n            success = .true.\n            result  = xnew\n            exit\n        endif\n\n        x = xnew\n        write(*,*) i, x\n     enddo\n\nend subroutine find_root\n"}, {"instruction": "Write a Fortran subroutine named findnorm that calculates the Euclidean norm of a given vector. The subroutine takes 2 input parameters: an integer n and a real*8 array v1 of length n. It also has 1 output parameter, a real*8 variable norm, which stores the computed norm.", "input": "", "output": "  subroutine findnorm(norm,v1,n)\n\n    integer,intent(in) :: n\n    real*8,intent(in) :: v1(n)\n    real*8, intent(out) :: norm\n\n    integer :: i\n\n    norm=0.d0\n\n    do i=1,n\n       norm=norm+v1(i)*v1(i)\n    enddo\n\n    norm=sqrt(norm)\n\n  end subroutine findnorm\n"}, {"instruction": "Write a Fortran subroutine named innerproduct that computes the inner product of two vectors. The subroutine takes 3 input parameters of type integer, real*8, and real*8, representing the dimension of the vectors and the vectors themselves. It also has 1 output parameter of type real*8.", "input": "", "output": "  subroutine innerproduct(v1dotv2,v1,v2,n)\n\n    integer, intent(in) :: n\n    real*8, intent(in) :: v1(n),v2(n)\n    real*8, intent(out) :: v1dotv2\n\n    integer :: i\n\n    v1dotv2=0.d0\n\n    do i=1,n\n       v1dotv2=v1dotv2+v1(i)*v2(i)\n    enddo\n\n  end subroutine innerproduct\n"}, {"instruction": "Write a Fortran subroutine named \"extrap\" that takes an integer parameter \"m\" as input and returns an array \"xcof\" of double precision numbers with dimension (0:m) as output. \n\nThe purpose of this subroutine is to calculate extrapolation coefficients for a given degree \"m\". \n\nIn the subroutine, initialize each element of the \"xcof\" array to 1. Then, using nested do loops, calculate the extrapolation coefficients by multiplying the current element with the ratio of (m+1-j) to (k-j), where \"k\" and \"j\" are loop variables. \n\nEnsure that \"j\" is not equal to \"k\" to avoid division by zero. \n\nOnce all the calculations are done, the subroutine will return the \"xcof\" array containing the extrapolation coefficients.", "input": "", "output": "  subroutine extrap(xcof,m)\n!\n  integer, intent(in) :: m\n  double precision, dimension(0:m), intent(out) :: xcof\n!\n! return extrapolation coefficients for degree m\n!\n  integer :: k,j\n!\n  do k=0,m\n    xcof(k)=1.d0\n    do j=0,m\n      if (j /= k) then\n        xcof(k)=xcof(k)*dble(m+1-j)/dble(k-j)\n      end if\n    end do\n  end do \n!\n  end subroutine extrap  \n"}, {"instruction": "Write a Fortran subroutine called size_comp that calculates the maximum size between an input array and a fixed array. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter is an array of integers. The subroutine compares the sizes of the input array and a fixed array of size 5 and returns the maximum size.", "input": "", "output": "    subroutine size_comp(val, ret)\n        integer, intent(in) :: val(:)\n        integer, intent(out) :: ret\n        integer, dimension(5) :: fixed\n        ret = maxval([size(val), size(fixed)])\n    end subroutine size_comp\n"}, {"instruction": "Write a Fortran subroutine named \"plag_coeff\" that calculates the Lagrange polynomial coefficients for a given number of points. The subroutine takes four input parameters: npoi (integer) - the number of points, nder (integer) - the number of derivatives to compute, x (double precision) - the point where function and derivatives are evaluated, and xp (double precision, dimension(npoi)) - an array of points where the function is known. The subroutine also has one output parameter: coef (double precision, dimension(0:nder,npoi)) - an array of weights for the computation of the function and derivatives.\n\nThe subroutine first calculates the coefficients for the function using the Lagrange interpolation formula. Then, if nder is greater than 0, it allocates memory for a temporary array called \"dummy\". It computes the coefficients for the derivatives using nested loops and stores them in the coef array. Finally, it deallocates the memory for the \"dummy\" array.\n\nTo use the subroutine, pass the appropriate values for npoi, nder, x, and xp, and allocate the coef array before calling the subroutine.", "input": "", "output": "subroutine plag_coeff(npoi,nder,x,xp,coef)\n  !\n  ! npoi - number of points (determines the order of lagrange\n  ! polynomial\n  ! which is equal npoi-1)\n  ! nder - number of derivatives computed 0 - function only, 1 - first\n  ! derivative\n  ! x - actual point where function and derivatives are evaluated\n  ! xp(npoi) - array of points where function is known\n  ! coef(0:nder,npoi) - weights for computation of function and\n  ! derivatives,\n  ! f=sum(fun(1:npoi)*coef(0,1:npoi) gives the function value\n  ! df=sum(fun(1:npoi)*coef(1,1:npoi) gives the derivative value value\n  !\n  implicit none\n  !\n  integer, intent(in)                                :: npoi,nder\n  double precision, intent(in)                          :: x\n  double precision, dimension(npoi), intent(in)         :: xp\n  double precision, dimension(0:nder,npoi), intent(out) :: coef\n  double precision, dimension(:), allocatable           :: dummy\n  !\n  integer                                            :: i,k,j\n  double precision                                      :: fac\n  !\n  do i=1,npoi\n      coef(0,i)=1.d0\n      do k=1,npoi\n        if(k.eq.i) cycle\n        coef(0,i)=coef(0,i)*(x-xp(k))/(xp(i)-xp(k))\n      enddo\n  enddo\n  !\n  if(nder.eq.0) return\n  !\n  !$omp critical\n  allocate(dummy(npoi))\n  !$omp end critical\n  !\n  do i=1,npoi\n      dummy=1.d0\n      dummy(i)=0.d0\n      do k=1,npoi\n        if(k.eq.i) cycle\n        fac=(x-xp(k))/(xp(i)-xp(k))\n        do j=1,npoi\n            if(j.eq.k) then\n              dummy(j)=dummy(j)/(xp(i)-xp(k))\n            else\n              dummy(j)=dummy(j)*fac\n            endif\n        enddo\n      enddo\n      coef(1,i)=sum(dummy)\n  enddo\n  !\n  !$omp critical\n  deallocate(dummy)\n  !$omp end critical\n  !\n  return\nend subroutine plag_coeff\n"}, {"instruction": "Create a Fortran subroutine named \"spline\" that calculates the spline interpolation coefficients. The subroutine takes 4 input arguments: n (integer), gam (real), x (real array of size n), and y (real array of size n). It also has 1 output argument: y2 (real array of size n). \n\nInside the subroutine, allocate memory for an auxiliary array u of size n. Compute the initial value yp1 based on the first element of x and the value of gam. Calculate the first element of y2 as -0.5. \n\nThen, use a loop to calculate the elements of y2 and u. Compute the values of sig and p based on the neighboring elements of x and y. Update y2 and u using the formula provided in the code. \n\nFinally, assign a value of 0.0 to the last element of y2. Use another loop to update the remaining elements of y2 based on the values of y2 and u. \n\nDeallocate the memory assigned to u and return from the subroutine.\n\nMake sure to use imperative language to give clear instructions.", "input": "", "output": "subroutine spline(x,y,n,gam,y2)\nimplicit none\ninteger, intent(in) :: n\nreal, intent(in) :: gam\nreal, intent(in) :: x(n,1), y(n,1)\nreal, intent(out) :: y2(n,1)\ninteger :: i, k\n!real :: qn, un\nreal :: yp1\nreal :: p, sig\nreal, allocatable :: u(:,:)\nallocate(u(n,1))\nyp1 = x(1,1)**(-gam)\ny2(1,1)=-0.5\nu(1,1)=(3.0/(x(2,1)-x(1,1)))*((y(2,1)-y(1,1))/(x(2,1)-x(1,1))-yp1)\ndo i=2,n-1\n   sig = (x(i,1)-x(i-1,1))/(x(i+1,1)-x(i-1,1))\n   p = sig*y2(i-1,1)+2.0\n   y2(i,1) = (sig-1.0)/p\n   u(i,1) = (6.0*((y(i+1,1)-y(i,1))/(x(i+1,1)-x(i,1))-(y(i,1)-y(i-1,1))/(x(i,1)-x(i-1,1)))/(x(i+1,1)-x(i-1,1))-sig*u(i-1,1))/p\nend do\ny2(n,1) =0.0\ndo k=n-1,1,-1\n   y2(k,1) = y2(k,1)*y2(k+1,1)+u(k,1)\nend do\ndeallocate(u)\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named look_up_message_type to determine the observation type based on the message type input. The subroutine takes 1 input parameter of type character with length 6 and 1 output parameter of type character with variable length.", "input": "", "output": "subroutine look_up_message_type(msg_type, obstype)\n! find observation type from \n! http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_4.htm\n character(len=6), intent(in)  :: msg_type\n character(len=*), intent(out) :: obstype \n\nselect case (msg_type)\n  case ('adpupa')\n    obstype = 'radiosonde'   ! fixme: dropsonde, too.\n  case ('aircar')\n    obstype = 'acars'\n  case ('aircft')\n    obstype = 'aircraft'\n  case ('satwnd')\n    obstype = 'sat'\n  case ('proflr')\n    obstype = 'profiler'\n  case ('adpsfc')\n    obstype = 'metar'        ! fixme: synop, too.\n  case ('msonet')\n    obstype = 'land_sfc'\n  case ('sfcshp')\n    obstype = 'marine'\n  case ('gpsipw')\n    obstype = 'gps'\n  case ('qkswnd')\n    obstype = 'qkswnd'\n  case default\n    obstype = 'unknown'\nend select\n\nend subroutine look_up_message_type\n"}, {"instruction": "Create a Fortran subroutine named look_up_obs_type to determine the DART observation type based on the message type and GRIB type provided. The subroutine takes 2 input parameters of type character(len=*) and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine look_up_obs_type(msg_type, grib_type, dart_obs_type)\n character(len=*), intent(in)  :: msg_type\n integer,          intent(in)  :: grib_type\n integer,          intent(out) :: dart_obs_type\n\nselect case (msg_type)\n  case ('adpupa')\n     ! t, q, p, u, v, sst\n     select case(grib_type)\n        case (11)\n           dart_obs_type = radiosonde_temperature\n        case (12)\n           dart_obs_type = radiosonde_temperature\n        case default\n           dart_obs_type = -1\n      end select\n  case ('aircar')\n  case ('aircft')\n  case ('satwnd')\n  case ('proflr')\n  case ('vadwnd')\n  case ('satemp')\n  case ('adpsfc')\n  case ('sfcshp')\n  case ('sfcbog')\n  case ('spssmi')\n  case ('syndat')\n  case ('ers1da')\n  case ('goesnd')\n  case ('qkswnd')\n  case ('msonet')\n  case ('gpsipw')\n  case ('rassda')\n  case ('wdsatr')\n  case ('ascatw')\n  case default\n     print *, 'unknown message type: '//trim(msg_type)\nend select\n\nend subroutine look_up_obs_type\n"}, {"instruction": "Create a Fortran subroutine named make_gl_nw to compute the Gauss-Legendre nodes and weights for numerical integration. The subroutine takes 1 input parameter of type integer*4 and 2 output parameters of type real(dbp).", "input": "", "output": "      subroutine  make_gl_nw(ngp, xabsc, weig)\n\n      implicit none\n\n      integer, parameter :: dbp = selected_real_kind (15,307)\n      real(dbp) :: newv\n      real(dbp) :: eps, m_pi\n      parameter (eps=3.0d-15)               !eps is the relative precision\n      parameter (m_pi=3.141592654d0) \n      \n      integer*4  i, j, m\n      real(dbp)  p1, p2, p3, pp, z, z1\n      integer*4, intent(in) :: ngp            ! # of gauss points\n      real(dbp), intent(out) :: xabsc(ngp), weig(ngp)\n\n\n           m = (ngp + 1) / 2\n!* roots are symmetric in the interval - so only need to find half of them  */\n\n           do i = 1, m                                ! loop over the desired roots */\n\n                     z = cos( m_pi * (i-0.25d0) / (ngp+0.5d0) )\n!*   starting with the above approximation to the ith root,\n!*          we enter the main loop of refinement by newton's method   */\n\n100             p1 = 1.0d0\n                p2 = 0.0d0\n!*  loop up the recurrence relation to get the legendre\n!*  polynomial evaluated at z                 */\n\n                do j = 1, ngp\n                   p3 = p2\n                   p2 = p1\n                   p1 = ((2.0d0*j-1.0d0) * z * p2 - (j-1.0d0)*p3) / j\n                enddo\n\n!* p1 is now the desired legendre polynomial. we next compute pp,\n!* its derivative, by a standard relation involving also p2, the\n!* polynomial of one lower order.      */\n                pp = ngp*(z*p1-p2)/(z*z-1.0d0)\n                z1 = z\n                z = z1 - p1/pp             ! newton's method  */\n\n                if (dabs(z-z1) .gt. eps) goto  100\n\n              xabsc(i) =  - z                            ! roots will be bewteen -1.0 & 1.0 */\n              xabsc(ngp+1-i) =  + z                        ! and symmetric about the origin   */\n              weig(i) = 2.0d0/((1.0d0-z*z)*pp*pp)     ! compute the weight and its       */\n              weig(ngp+1-i) = weig(i)                 ! symmetric counterpart            */\n\n      end do     ! i loop\n\n   end subroutine make_gl_nw\n"}, {"instruction": "Write a Fortran subroutine named dccon0 to calculate the medium constants and fault-dip constants. The subroutine takes 1 input parameter of type real*8 and outputs 2 parameters of type real*8.", "input": "", "output": "subroutine  dccon0(dip,sd,cd)\n!*******************************************************************\n!*****   calculate medium constants and fault-dip constants    *****\n!*******************************************************************\n!\n!***** input\n!*****   dip   : dip-angle (degree)\n!***** output\n!*****   sd,cd : sin, cos of dip-angle\n    implicit none\n    real*8, intent(in) :: dip\n    real*8, intent(out) :: sd,cd\n\n    real*8, parameter :: f0=0.0d0, f1=1.0d0\n    real*8, parameter :: pi2=6.283185307179586d0\n    real*8, parameter :: eps=1.0d-6\n    real*8, parameter :: p18=pi2/360.d0\n!-----\n    sd=dsin(dip*p18)\n    cd=dcos(dip*p18)\n!### caution ### if cos(dip) is sufficiently small, it is set to zero\n    if(dabs(cd)<eps) then\n      cd=f0\n      if(sd>f0) sd= f1\n      if(sd<f0) sd=-f1\n    endif\n    return\nend subroutine dccon0\n"}, {"instruction": "Create a Fortran subroutine named math_singularity to compute the values of theta, alx, and ale based on the input parameters xi, et, q, r, kxi, and ket, where xi, et, q, r are real*8, and kxi, ket are integers. The computed values of theta, alx, and ale will be of type real*8.", "input": "", "output": "subroutine math_singularity(xi,et,q,r,kxi,ket,theta,alx,ale)\n!***** input\n!*****   xi,et,q : station coordinates in fault system\n!*****   kxi,ket : kxi=1, ket=1 means r+xi<eps, r+et<eps, respectively\n    implicit none\n    real*8, intent(in) :: xi,et,q,r\n    integer, intent(in) :: kxi,ket\n    real*8, intent(out) :: theta,alx,ale\n\n    ! p.1034 (i)\n    if(q==0.0d0) then\n      theta=0.0d0\n    else\n      theta=datan(xi*et/(q*r))\n    endif\n    ! p.1034 (iii)\n    if(kxi==1) then\n      alx=-dlog(r-xi)\n    else\n      alx=dlog(r+xi)\n    endif\n    ! p.1034 (iv)\n    if(ket==1) then\n      ale=-dlog(r-et)\n    else\n      ale=dlog(r+et)\n    endif\n\n    return\nend subroutine math_singularity\n"}, {"instruction": "Create a Fortran subroutine named assign_alpha. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8 array. The subroutine calculates 5 coefficients based on the input alpha value and stores them in the output array alp.", "input": "", "output": "subroutine assign_alpha(alpha,alp)\n!***** input\n!*****   alpha : medium constant  (lambda+myu)/(lambda+2*myu)\n!***** output\n!*****   alp   : coefficients related to alpha value\n    implicit none\n    real*8, intent(in) :: alpha\n    real*8, intent(out) :: alp(5)\n    alp(1)=(1.0d0-alpha)/2.0d0\n    alp(2)= alpha/2.0d0\n    alp(3)=(1.0d0-alpha)/alpha\n    alp(4)=1.0d0-alpha\n    alp(5)=alpha\n    return\nend subroutine assign_alpha\n"}, {"instruction": "Create a Fortran subroutine named varout that takes an array of 12 real*8 numbers as input and outputs 12 real*8 values: ux, uy, uz, uxx, uyx, uzx, uxy, uyy, uzy, uxz, uyz, and uzz. The input parameter is of type real*8 and the output parameters are of type real*8.", "input": "", "output": "subroutine varout(u,ux,uy,uz,uxx,uyx,uzx,uxy,uyy,uzy,uxz,uyz,uzz)\n    implicit none\n    real*8, intent(in) :: u(12)\n    real*8, intent(out) :: ux,uy,uz,uxx,uyx,uzx,uxy,uyy,uzy,uxz,uyz,uzz\n    ux=u(1)\n    uy=u(2)\n    uz=u(3)\n    uxx=u(4)\n    uyx=u(5)\n    uzx=u(6)\n    uxy=u(7)\n    uyy=u(8)\n    uzy=u(9)\n    uxz=u(10)\n    uyz=u(11)\n    uzz=u(12)\n    return\nend subroutine varout\n"}, {"instruction": "Create a Fortran subroutine named calc_nnz_csrab to calculate the number of non-zero elements in a compressed sparse row (CSR) matrix. The subroutine takes 6 input parameters of type integer: nrow, ncol, ia(*), ja(*), ib(*), jb(*), and one output parameter of type integer: nnz.", "input": "", "output": "    subroutine calc_nnz_csrab(nrow,ncol,ia,ja,ib,jb,nnz)\n    integer,intent(in)::nrow,ncol,ia(*),ja(*),ib(*),jb(*)\n    integer,intent(out)::nnz\n\n    integer i,j,j1,k,k1\n    logical lzero(ncol)\n\n    nnz=0\n    do i=1,nrow\n        lzero=.true.\n        do j1=ia(i),ia(i+1)-1\n            j=ja(j1)\n            do k1=ib(j),ib(j+1)-1\n                k=jb(k1)\n                if(lzero(k))then\n                    nnz=nnz+1\n                    lzero(k)=.false.\n                endif\n            enddo\n        enddo\n    enddo\n    return\n\n    end subroutine calc_nnz_csrab\n"}, {"instruction": "Create a Fortran subroutine named lockad to process logical input and output parameters. The subroutine takes 1 input parameter of type logical and returns 3 output parameters of type logical. The subroutine processes the input and sets the output parameters based on certain conditions.", "input": "", "output": "      subroutine lockad(closed, med, slut, expand)\n!...translated by pacific-sierra research 77to90  4.3e  14:44:54  12/27/06\n!...switches:\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      logical , intent(out) :: slut\n      logical , intent(in) :: expand\n      logical , intent(out) :: closed(15,0:10)\n      logical , intent(out) :: med(15,0:10)\n!-----------------------------------------------\n!   l o c a l   p a r a m e t e r s\n!-----------------------------------------------\n      integer, parameter :: fil_1 = 7\n      integer, parameter :: fil_2 = 8\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: i, j, n, l\n      character :: rad*1000\n      character, dimension(0:10) :: orb\n!-----------------------------------------------\n      data (orb(i),i=0,10)/ 's', 'p', 'd', 'f', 'g', 'h', 'i', 'k', 'l', 'm', &\n         'n'/\n      if (expand) then\n         read (fil_2, *, end=40)\n         read (fil_2, 100, end=40) rad\n      else\n         read (fil_1, *, end=40)\n         read (fil_1, 100, end=40) rad\n      endif\n      do n = 1, 15\n         closed(n,1:min(10,n-1)) = .false.\n      end do\n      l30: do i = 0, 205\n         j = i*5\n         n = ichar(rad(j+3:j+3)) - ichar('0')\n         if (n>=1 .and. n<=15) then\n            do l = 0, min(10,n - 1)\n               if (rad(j+4:j+4) /= orb(l)) cycle\n               closed(n,l) = .true.\n               cycle  l30\n            end do\n         else\n            exit  l30\n         endif\n      end do l30\n      if (expand) then\n         read (fil_2, *, end=40)\n         read (fil_2, 100, end=40) rad\n      else\n         read (fil_1, *, end=40)\n         read (fil_1, 100, end=40) rad\n      endif\n      do n = 1, 15\n         med(n,1:min(10,n-1)) = .false.\n      end do\n      l130: do i = 0, 205\n         j = i*5\n         n = ichar(rad(j+3:j+3)) - ichar('0')\n         if (n>=1 .and. n<=15) then\n            do l = 0, min(10,n - 1)\n               if (rad(j+4:j+4) /= orb(l)) cycle\n               med(n,l) = .true.\n               cycle  l130\n            end do\n         else\n            return\n         endif\n      end do l130\n\n      return\n   40 continue\n      slut = .true.\n      return\n  100 format(a)\n      return\n      end subroutine lockad\n"}, {"instruction": "Write a Fortran subroutine named kendallstau to calculate Kendall's tau, a measure of association between two datasets. The subroutine takes 3 input parameters of type integer, real, and real, representing the dimension of the data set, data set 1, and data set 2, and 1 output parameter of type real, representing the calculated Kendall's tau.", "input": "", "output": "  subroutine kendallstau(n,data1,data2,tau)\r\n    \r\n    !argument declaration\r\n    integer, intent(in) :: n          !<dimension of data set\r\n    real, intent(in)    :: data1(n)   !<data set 1\r\n    real, intent(in)    :: data2(n)   !<data set 2\r\n    real, intent(out)   :: tau        !<calculated kendalls tau\r\n    \r\n    !variable declarations\r\n    integer j,k       !loop variables\r\n    integer is,n1,n2  !number of pairs\r\n    real a1,a2,aa     !help variables\r\n    \r\n    if(n==0)return    !no data\r\n    n1=0\r\n    n2=0\r\n    is=0\r\n    do j=1,n-1\r\n      do k=j+1,n\r\n        a1=data1(j)-data1(k)\r\n        a2=data2(j)-data2(k)\r\n        aa=a1*a2\r\n        if(aa.ne.0.)then\r\n          n1=n1+1\r\n          n2=n2+1\r\n          if(aa.gt.0.)then\r\n            is=is+1\r\n          else\r\n            is=is-1\r\n          endif\r\n        else\r\n          if(a1.ne.0.)n1=n1+1\r\n          if(a2.ne.0.)n2=n2+1\r\n        endif\r\n      enddo\r\n    enddo\r\n    tau = real(is)/sqrt(real(n1)*real(n2))\r\n    \r\n  end subroutine kendallstau\r\n"}, {"instruction": "Create a Fortran subroutine named calculate_meanmedian_number_of_observations that takes 3 input parameters of type integer, real, and real, and 1 output parameter of type real. The subroutine calculates the number of areas with criteria based on the given criteria values and the missing value.", "input": "", "output": "  subroutine calculate_meanmedian_number_of_observations(dim,crit,miss,num)\r\n\r\n    !argument declarations\r\n    integer, intent(in)  :: dim    !<number of areas\r\n    real, intent(in)  :: crit(dim)  !<criteria value for areas\r\n    real, intent(in)  :: miss       !<missing value\r\n    real, intent(out) :: num    !<number of areas with criteria\r\n    \r\n    !local variables\r\n    integer isb\r\n    \r\n    num = 0.\r\n    do isb = 1,dim\r\n      if(crit(isb)/=miss) then\r\n        num = num + 1.\r\n      endif\r\n    enddo\r\n    \r\n  end subroutine calculate_meanmedian_number_of_observations\r\n"}, {"instruction": "Create a Fortran subroutine named com_time2ymdh that takes an 8-byte integer itime as input and returns four integers iy, im, id, and ih. The subroutine extracts the year, month, day, and hour from itime and assigns them to iy, im, id, and ih, respectively.", "input": "", "output": "subroutine com_time2ymdh(itime,iy,im,id,ih)\n  implicit none\n  integer(8),intent(in) :: itime\n  integer,intent(out) :: iy\n  integer,intent(out) :: im\n  integer,intent(out) :: id\n  integer,intent(out) :: ih\n\n  iy = int(  itime / 1000000 )\n  im = int( (itime-iy*1000000) / 10000 )\n  id = int( (itime-iy*1000000-im*10000) / 100 )\n  ih = int(  itime-iy*1000000-im*10000-id*100 )\n\n  return\nend subroutine com_time2ymdh\n"}, {"instruction": "Write a Fortran subroutine named com_ymdh2time to convert the date and hour components into a single time value. The subroutine should take 4 input parameters of type integer (iy, im, id, ih) and produce 1 output parameter of type integer(8) (itime).", "input": "", "output": "subroutine com_ymdh2time(iy,im,id,ih,itime)\n  implicit none\n  integer,intent(in) :: iy\n  integer,intent(in) :: im\n  integer,intent(in) :: id\n  integer,intent(in) :: ih\n  integer(8),intent(out) :: itime\n\n  itime=iy*1000000+im*10000+id*100+ih\n\n  return\nend subroutine com_ymdh2time\n"}, {"instruction": "Create a Fortran subroutine named setfouunit to assign units to different variables based on the given parameters. The subroutine takes 4 input parameters of types ['character(*)', 'integer', 'integer', 'integer'] and returns 1 output parameter of type ['character(*)'].", "input": "", "output": "subroutine setfouunit(founam, lsal, ltem, fconno, fouvarunit)\n    !\n    ! parameters\n    character(*), intent(in)  :: founam\n    integer     , intent(in)  :: lsal\n    integer     , intent(in)  :: ltem\n    integer     , intent(in)  :: fconno\n    character(*), intent(out) :: fouvarunit\n    !\n    ! body\n    select case (founam(:2))\n    case ('s1')\n       fouvarunit = 'm'\n    case ('u1', 'v1')\n       fouvarunit = 'm/s'\n    case ('ta')\n       fouvarunit = 'n/m2'\n    case ('r1')\n       if (fconno == ltem) then\n          fouvarunit = 'degrees_celsius'\n       elseif (fconno == lsal) then\n          fouvarunit = 'ppt'\n       else\n          fouvarunit = 'kg/m3'\n       endif\n    case default\n       fouvarunit = ''\n    end select \nend subroutine setfouunit\n"}, {"instruction": "Create a Fortran subroutine named load_matlab_mesh to read mesh data from a file. The subroutine should have 1 input parameter of type character(len=*) and 1 output parameter of type real(8), allocatable.", "input": "", "output": "    subroutine load_matlab_mesh(filename, mesh)\n        character(len=*), intent(in) :: filename\n        real(8), allocatable, intent(out) :: mesh(:, :)\n\n        integer :: n_points, n\n        integer, parameter :: file_id = 1\n\n        open(unit=file_id, file=filename, status=\"old\", action=\"read\")\n\n        read(file_id, *) n_points\n        allocate(mesh(n_points, 3))\n\n        ! format:\n        ! npoints\n        ! x1 y1 z1\n        ! x2 y2 z2\n        do n = 1, n_points\n            read(file_id,*) mesh(n, 1), mesh(n, 2), mesh(n, 3)\n        end do\n\n        close(file_id)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"diffuse\" to perform a diffusion simulation over a specified number of timesteps. The subroutine takes 7 input parameters of type integer and real(kind=8), and one output parameter of type real(kind=8) with dimensions nx and ny. The input parameters are timesteps, nx, ny, nu, dt, dx, dy, and the output parameter is u. The subroutine uses nested do-loops to update the values of u based on the diffusion equation and boundary conditions.", "input": "", "output": "subroutine diffuse(timesteps, u, nu, dt, dx, dy, nx, ny)\n    implicit none\n    integer, intent(in) :: nx, ny, timesteps\n    real(kind=8), intent(in) :: nu, dt, dx, dy\n    real(kind=8), intent(out), dimension(nx,ny) :: u\n    real(kind=8), dimension(nx,ny) :: un\n    integer :: i, j, time\n    real(kind=8) :: ydisip, xdisip, yderiv, xderiv\n    time = timesteps\n\n    do time = 1, time\n            un = u\n        \n            do j=2, nx-1\n                do i=2, ny-1\n                    xderiv = (nu * dt) / (dx**2)\n                    yderiv = (nu * dt) / (dy**2)\n                    xdisip = un(j,i+1) - (2 * un(j,i)) + un(j,i-1)\n                    ydisip = un(j+1,i) - (2 * un(j,i)) + un(j-1,i)\n                    \n                    u(j,i) = un(j,i) + (xderiv * xdisip) + (yderiv * ydisip)\n\n                    u(1,j) = 1\n                    u(nx,j) = 1\n                    u(i,1) = 1\n                    u(i,ny) = 1\n        \n                    u(1,1) = 1\n                    u(1,nx) = 1\n                    u(ny,1) = 1\n                    u(ny,nx) = 1\n                end do\n            end do\n        end do\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named linear_interp to perform 2-point linear interpolation. The subroutine takes 3 input parameters of type real*8 and 2 output parameters of type real*8 and integer. The input parameters represent the point where the function is needed and the 2 points from the tables. The output parameters represent the function value at the given point and an error indicator. The subroutine uses the selected_real_kind function and follows Fortran's implicit none convention.", "input": "", "output": "subroutine linear_interp(x,x_tables,f_tables,fx,ierr)\n! 2 points linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x ! point where function needed\n  real*8, intent(in) ::x_tables(2),f_tables(2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx\n\n  ierr=0\n  hx=(x_tables(2)-x_tables(1))\n  if(hx.eq.0.0_r8) then\n     ierr=1\n     return\n  endif\n  fx = f_tables(1)+(x-x_tables(1))/hx*(f_tables(2)-f_tables(1))\n  return\n  \nend subroutine linear_interp\n"}, {"instruction": "Create a Fortran subroutine named linear_interp_2d to perform a 2D linear interpolation. The subroutine takes 3 input parameters with the test_data type ['real*8', 'real*8', 'real*8'] and returns 2 output parameters with the test_data type ['real*8', 'integer']. The subroutine uses the imperative tone to compute the function value at a given point using 4 points 2D linear interpolation formula.", "input": "", "output": "subroutine linear_interp_2d(x,x_tables,f_tables,fx,ierr)\n! 4 points 2d linear interpolation formula\n  implicit none\n  integer, parameter :: r8=selected_real_kind(12,100)\n  real*8, intent(in) :: x(2) ! point where function needed\n  real*8, intent(in) ::x_tables(4),f_tables(2,2) ! 2 points from tables f_i(x_i), i=1..2\n  real*8, intent(out) :: fx !function value at x f(x)\n  integer, intent(out) :: ierr\n  real*8 hx1,hx2,pe,qn,pe1,qn1\n\n  ierr=0\n  hx1=(x_tables(2)-x_tables(1))\n  hx2=(x_tables(4)-x_tables(3))\n  if((hx1.eq.0.0_r8).or.(hx2.eq.0.0_r8)) then\n     ierr=1\n     return\n  endif\n  !pe=(e-e0)/(e1-e0)\n  pe=(x(1)-x_tables(1))/hx1\n  !qn=(n-n0)/(n1-n0)\n  qn=(x(2)-x_tables(3))/hx2\n  !1-pe=(e1-e)/(e1-e0)\n  pe1=1.0_r8 - pe\n  !1-qn=(n1-n)/(n1-n0)\n  qn1=1.0_r8 - qn\n  !four points linear extrapolation\n  fx = pe1*qn1*f_tables(1,1)+pe*qn1*f_tables(2,1)+qn*pe1*f_tables(1,2)+&\n       &pe*qn*f_tables(2,2)\n  return\n  \nend subroutine linear_interp_2d\n"}, {"instruction": "Create a Fortran subroutine named check_lu that calculates the LU decomposition check values. The subroutine takes one input parameter of type real(8) and outputs an array of three real(8) values. The input parameter is intent(in) and the output parameter is intent(out).", "input": "", "output": "  subroutine check_lu( check, t )\n    implicit none\n    real(8),intent(out) :: check(3)\n    real(8),intent(in)  :: t(:,:)\n    integer :: i,j\n    do j=1,size(t,2)\n    do i=1,size(t,1)\n       if ( i <  j ) check(1)=check(1)+abs( t(i,j) )\n       if ( j <  i ) check(2)=check(2)+abs( t(i,j) )\n       if ( i == j ) check(3)=check(3)+abs( t(i,j) )\n    end do\n    end do\n  end subroutine check_lu\n"}, {"instruction": "Write a Fortran subroutine named fill to fill a 2D array with random integer values. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "  subroutine fill(a,n)\n    integer, intent(out), dimension(:,:) :: a\n    integer, intent(in) :: n\n    real, dimension(size(a,1),size(a,2)) :: r\n    call random_number(r)\n    a = int(2*n*r-n)\n  end subroutine fill\n"}, {"instruction": "Create a Fortran subroutine named \"emul_cshift\" to perform circular shift operation on a 3D array. The subroutine should take 3 input parameters of type integer, dimension(:,:,:), integer, dimension(:,:), and integer, and 1 output parameter of type integer, dimension(:,:,:).\n", "input": "", "output": "  subroutine emul_cshift(a,sh_in,dim, c)\n    integer, dimension(:,:,:), intent(in) :: a\n    integer, dimension(:,:,:), intent(out) :: c\n    integer, dimension(:,:), intent(in) :: sh_in\n    integer, intent(in) :: dim\n    integer :: sh, rsh\n    integer :: s1, s2, s3, n, i\n    integer :: n1, n2, n3\n    n1 = size(a,1)\n    n2 = size(a,2)\n    n3 = size(a,3)\n    if (dim == 1) then\n       n = n1\n       do s2=1,n2\n          do s3=1,n3\n             sh = modulo(sh_in(s2,s3), n)\n             rsh = n - sh\n             do i=1,rsh\n                c(i,s2,s3) = a(i+sh,s2,s3)\n             end do\n             do i=rsh+1,n\n                c(i,s2,s3) = a(i-rsh,s2,s3)\n             end do\n          end do\n       end do\n    else if (dim == 2) then\n       n = n2\n       do s3=1,n3\n          do s1=1,n1\n             sh = modulo(sh_in(s1,s3),n)\n             rsh = n - sh\n             do i=1,rsh\n                c(s1,i,s3) = a(s1,i+sh,s3)\n             end do\n             do i=rsh+1,n\n                c(s1,i,s3) = a(s1,i-rsh,s3)\n             end do\n          end do\n       end do\n\n    else if (dim == 3) then\n       n = n3\n       do s2=1,n2\n          do s1=1,n1\n             sh = modulo(sh_in(s1,s2),n)\n             rsh = n - sh\n             do i=1,rsh\n                c(s1,s2,i) = a(s1,s2,i+sh)\n             end do\n             do i=rsh+1,n\n                c(s1,s2,i) = a(s1,s2,i-rsh)\n             end do\n          end do\n       end do\n    else\n       stop \"illegal dim\"\n    end if\n  end subroutine emul_cshift\n"}, {"instruction": "Create a Fortran subroutine named minmod that takes three input parameters of types integer, real, and real, and one output parameter of type real. The subroutine computes the minimum of the absolute values of corresponding elements from the input arrays a and b, and sets the result in the output array c.", "input": "", "output": "subroutine minmod(c,a,b,nnn)\n    implicit none\n    ! argument list\n    integer, intent(in)   :: nnn\n    real, intent(in)      :: a(nnn), b(nnn)\n    real, intent(out)     :: c(nnn)\n    ! local variables\n    integer :: i\n\n    do i = 1, nnn\n        if (a(i)*b(i) .le. 0.0) then\n            c(i) = 0.0\n        else\n            if( abs(a(i)) .lt. abs(b(i)) ) then\n                c(i) = a(i)\n            else\n                c(i) = b(i)\n            end if\n        end if\n    end do\n\nend subroutine minmod\n"}, {"instruction": "Create a Fortran subroutine named repeat_bounds to handle the boundary conditions for a given cell in a grid. The subroutine takes 4 input parameters of type integer, integer, real*8, and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine repeat_bounds(cell,delta,grid_max,ncell_max,position)\nimplicit none\ninteger, intent(in) :: cell, ncell_max\nreal*8, intent(in) :: delta, grid_max\nreal*8, intent(out) :: position\n\nif (cell.lt.1) then\n  position=grid_max-delta\nelseif (cell.gt.ncell_max) then\n  position=delta\nelse\n  print*,'error in repeat bounds'\nendif\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cdiff2d to calculate the central difference of a 2D field along the specified axis. The subroutine takes 4 input parameters of types integer, integer, integer, and real, and one output parameter of type real.", "input": "", "output": "subroutine cdiff2d(ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(ysize,xsize)\n      real, intent(out) :: output(ysize,xsize)\n      integer dd1, dd2\n      integer i, j\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==1) then !x\n         dd1 = 1\n      elseif (axis==0) then !y\n         dd2 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do j=1+dd2,ysize-dd2\n         do i=1+dd1,xsize-dd1\n            if ((field(j+dd2,i+dd1)>-999.0).and.(field(j-dd2,i-dd1)>-999.0)) then\n               output(j,i) = field(j+dd2,i+dd1) - field(j-dd2,i-dd1)\n            endif\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff2d\n"}, {"instruction": "Create a Fortran subroutine named cdiff3d to calculate the finite difference along a specified axis in a 3D field. The subroutine takes 5 input parameters of types integer, integer, integer, integer, and real, representing the size of the field in the z, y, and x dimensions, the axis along which to calculate the difference, and the field itself. It also has 1 output parameter of type real, representing the resulting difference field.", "input": "", "output": "subroutine cdiff3d(zsize, ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: zsize, ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(zsize,ysize,xsize)\n      real, intent(out) :: output(zsize,ysize,xsize)\n      integer dd1, dd2, dd3\n      integer i, j, z\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      dd3 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==2) then\n         dd1 = 1\n      elseif (axis==1) then\n         dd2 = 1\n      elseif (axis==0) then\n         dd3 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do z=1+dd3,zsize-dd3\n         do j=1+dd2,ysize-dd2\n            do i=1+dd1,xsize-dd1\n               if ((field(z+dd3,j+dd2,i+dd1)>-999.0).and.(field(z-dd3,j-dd2,i-dd1)>-999.0)) then\n                  output(z,j,i) = field(z+dd3,j+dd2,i+dd1) - field(z-dd3,j-dd2,i-dd1)\n               endif\n            enddo\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff3d\n"}, {"instruction": "Create a Fortran subroutine named cdiff4d to calculate the 4-dimensional central difference of a given field along a specified axis. The subroutine takes 6 input parameters of type integer and real: tsize, zsize, ysize, xsize, field, and axis. It also has 1 output parameter of type real: output. The subroutine uses imperative tone to perform the central difference calculations and updates the output array according to the specified axis.", "input": "", "output": "subroutine cdiff4d(tsize, zsize, ysize, xsize, field, axis, output)\n!23456------------------------------------------------------------------------------------------------------------------------------\n      integer, intent(in) :: tsize, zsize, ysize, xsize\n      integer, intent(in) :: axis\n      real, intent(in) :: field(tsize,zsize,ysize,xsize)\n      real, intent(out) :: output(tsize,zsize,ysize,xsize)\n      integer dd1, dd2, dd3, dd4\n      integer i, j, z, t\n!23456------------------------------------------------------------------------------------------------------------------------------\n      dd1 = 0\n      dd2 = 0\n      dd3 = 0\n      dd4 = 0\n      output = -999.99\n!23456------------------------------------------------------------------------------------------------------------------------------\n      if (axis==3) then\n         dd1 = 1\n      elseif (axis==2) then\n         dd2 = 1\n      elseif (axis==1) then\n         dd3 = 1\n      elseif (axis==0) then\n         dd4 = 1\n      endif\n!23456------------------------------------------------------------------------------------------------------------------------------\n      do t=1+dd4,tsize-dd4\n         do z=1+dd3,zsize-dd3\n            do j=1+dd2,ysize-dd2\n               do i=1+dd1,xsize-dd1\n                  if ((field(t+dd4,z+dd3,j+dd2,i+dd1)>-999.0).and.(field(t-dd4,z-dd3,j-dd2,i-dd1)>-999.0)) then\n                     output(t,z,j,i) = field(t+dd4,z+dd3,j+dd2,i+dd1) - field(t-dd4,z-dd3,j-dd2,i-dd1)\n                  endif\n               enddo\n            enddo\n         enddo\n      enddo\n!23456------------------------------------------------------------------------------------------------------------------------------\nend subroutine cdiff4d\n"}, {"instruction": "Create a Fortran subroutine named \"interp_vec\" that takes 3 input parameters of type real, dimension(:), real, and logical, and 4 output parameters of type integer, integer, real, and real. The subroutine is designed to perform vector interpolation and determine the indices and weights for interpolation.", "input": "", "output": "  subroutine interp_vec(locvec,locwant,periodic,loc1,loc2,wght1,wght2)\n  implicit none\n  real, intent(in), dimension(:) :: locvec\n  real, intent(in) :: locwant\n  logical, intent(in) :: periodic\n  integer, intent(out) :: loc1, loc2\n  real, intent(out) :: wght1, wght2\n  integer :: vsize, n\n  real :: locv1, locv2\n  vsize = size(locvec)\n  loc1 = -1\n  loc2 = -1\n  do n = 1, vsize-1\n    if ( locvec(n) <= locwant .and. locvec(n+1) > locwant ) then\n      loc1 = n\n      loc2 = n+1\n      locv1 = locvec(n)\n      locv2 = locvec(n+1)\n      exit\n    end if\n  end do\n  if ( loc1 < 0 .and. loc2 < 0 ) then\n    if ( periodic ) then\n      if ( locwant < locvec(1) ) then\n        loc1 = vsize\n        loc2 = 1\n        locv1 = locvec(vsize)-360.0\n        locv2 = locvec(1)\n      else\n        loc1 = vsize\n        loc2 = 1\n        locv1 = locvec(vsize)\n        locv2 = locvec(1)+360.0\n      end if\n    else\n      if ( locwant < locvec(1) ) then\n        loc1 = 1\n        loc2 = 1\n        locv1 = locvec(1)\n        locv2 = locvec(1)\n      else\n        loc1 = vsize\n        loc2 = vsize\n        locv1 = locvec(vsize)\n        locv2 = locvec(vsize)\n      end if\n    end if\n  end if\n  wght2 = (locwant-locv1) / (locv2-locv1)\n  wght1 = 1.0 - wght2\n  return\n  end subroutine interp_vec\n"}, {"instruction": "Create a Fortran subroutine named bezlin that takes two input arguments of type real arrays and one output argument of type real array. The input arrays a and b represent the start and end points of a line segment, while the output array p stores a set of points that lie on the line segment between a and b.", "input": "", "output": "  pure subroutine bezlin(a, b, p)\n    real, intent(in) :: a(:), b(:)\n    real, intent(out) :: p(:, :)\n    real :: dx(size(a))\n    integer :: i, j, n\n\n    dx = b - a\n    n = size(p, 2) - 1\n    do i = 0, n\n      j = i + 1\n      p(:, j) = dx * real(i) / n + a\n    end do\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named davis_etal_2008 to calculate the roughness length z_0 based on the input ustar. The number of input arguments is 1, and the test_data type is [real]. The number of output arguments is 1, and the test_data type is [real]. The subroutine uses the imperative tone.", "input": "", "output": "   subroutine davis_etal_2008(z_0,ustar)\n       implicit none\n       real, intent(in) :: ustar\n       real, intent(out) :: z_0\n       real :: zw, zn1, zn2\n       real, parameter :: g=9.81, ozo=1.59e-5\n       zw = min((ustar/1.06)**(0.3),1.0)\n       zn1 = 0.011*ustar*ustar/g + ozo\n       zn2 = 10.*exp(-9.5*ustar**(-.3333)) + &\n             0.11*1.5e-5/amax1(ustar,0.01)\n       z_0 = (1.0-zw) * zn1 + zw * zn2\n       z_0 = max( z_0, 1.27e-7)\n       z_0 = min( z_0, 2.85e-3)\n       return\n   end subroutine davis_etal_2008\n"}, {"instruction": "Create a Fortran subroutine named \"garratt_1992\" with 3 input parameters of type real and 2 output parameters of type real. The inputs are ren, z_0, and landsea, and the outputs are zt and zq. The subroutine calculates zt and zq based on the values of ren, z_0, and landsea, using conditional statements and mathematical operations. Remember to use the \"intent(in)\" and \"intent(out)\" attributes to specify the purpose of each parameter.", "input": "", "output": "   subroutine garratt_1992(zt,zq,z_0,ren,landsea)\n       implicit none\n       real, intent(in) :: ren, z_0,landsea\n       real, intent(out) :: zt,zq\n       real :: rq\n       real, parameter :: e=2.71828183\n       if (landsea-1.5 .gt. 0) then\n          zt = z_0*exp(2.0 - (2.48*(ren**0.25)))\n          zq = z_0*exp(2.0 - (2.28*(ren**0.25)))\n          zq = min( zq, 5.5e-5)\n          zq = max( zq, 2.0e-9)\n          zt = min( zt, 5.5e-5)\n          zt = max( zt, 2.0e-9)\n       else\n          zq = z_0/(e**2.)\n          zt = zq\n       endif\n       return\n    end subroutine garratt_1992\n"}, {"instruction": "Create a Fortran subroutine named fairall_2001, which takes 3 input arguments of type real and returns 2 output arguments of type real. The function calculates the values of zt and zq based on the input parameters ren, ustar, and visc. The calculated values are then constrained to a specific range before being returned.", "input": "", "output": "    subroutine fairall_2001(zt,zq,ren,ustar,visc)\n       implicit none\n       real, intent(in) :: ren,ustar,visc\n       real, intent(out) :: zt,zq\n       if (ren .le. 2.) then\n          zt = (5.5e-5)*(ren**(-0.60))\n          zq = 0.2*visc/max(ustar,0.1)\n       else\n          zt = (5.5e-5)*(ren**(-0.60))\n          zq = zt\n       endif\n       zt = min(zt,1.0e-4)\n       zt = max(zt,2.0e-9)\n       zq = min(zt,1.0e-4)\n       zq = max(zt,2.0e-9)\n       return\n    end subroutine fairall_2001\n"}, {"instruction": "Write a Fortran subroutine named yang_2008 that calculates the values of zt and zq based on the input parameters z_0, zt, zq, ustar, tstar, qst, ren, visc, and landsea. The number of input arguments is 7 and the test_data type is [real, real, real, real, real, real, real]. The number of output arguments is 2 and the test_data type is [real, real].", "input": "", "output": "    subroutine yang_2008(z_0,zt,zq,ustar,tstar,qst,ren,visc,landsea)\n       implicit none\n       real, intent(in) :: z_0, ren, ustar, tstar, qst, visc, landsea\n       real :: ht, tstar2\n       real, intent(out) :: zt,zq\n       real, parameter :: renc=350., beta=0.5, e=2.71828183\n       ht = renc*visc/max(ustar,0.01)\n       tstar2 = min(tstar, 0.0)\n       zt = ht * exp(-beta*(ustar**0.5)*(abs(tstar2)**1.0))\n       zq = zt\n       zt = min(zt, z_0/2.0)\n       zq = min(zq, z_0/2.0)\n       return\n    end subroutine yang_2008\n"}, {"instruction": "Create a Fortran subroutine named psi_beljaars_holtslag_1991 to calculate the Beljaars and Holtslag (1991) universal stability functions. The subroutine should take 1 input argument of type real and provide 2 output arguments of type real. The input parameter should represent the stability parameter zl. The first output parameter, psi_m, represents the momentum flux stability function, and the second output parameter, psi_h, represents the sensible heat flux stability function.", "input": "", "output": "    subroutine psi_beljaars_holtslag_1991(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: a=1., b=0.666, c=5., d=0.35\n       if (zl .lt. 0.) then\n          write(*,*)\"warning: universal stability functions from\"\n          write(*,*)\"        beljaars and holtslag (1991) should only\"\n          write(*,*)\"        be used in the stable regime!\"\n          psi_m = 0.\n          psi_h = 0.\n       else\n          psi_m = -(a*zl + b*(zl -(c/d))*exp(-d*zl) + (b*c/d))\n          psi_h = -((1.+.666*a*zl)**1.5 + &\n                  b*(zl - (c/d))*exp(-d*zl) + (b*c/d) -1.)\n       endif\n       return\n    end subroutine psi_beljaars_holtslag_1991\n"}, {"instruction": "Create a Fortran subroutine named psi_zilitinkevich_esau_2007 to calculate the Monin-Obukhov stability functions psi_m and psi_h based on the input stability parameter zl, which is a real number. The subroutine should have 1 input parameter of type real and 2 output parameters of type real. If zl is less than 0, the subroutine should issue a warning message and set both psi_m and psi_h to 0. Otherwise, it should calculate psi_m and psi_h based on the zl value using specific formulas.", "input": "", "output": "    subroutine psi_zilitinkevich_esau_2007(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: cm=3.0, ct=2.5\n       if (zl .lt. 0.) then\n          write(*,*)\"warning: universal stability function from\"\n          write(*,*)\"        zilitinkevich and esau (2007) should only\"\n          write(*,*)\"        be used in the stable regime!\"\n          psi_m = 0.\n          psi_h = 0.\n       else\n          psi_m = -cm*(zl**(5./6.))\n          psi_h = -ct*(zl**(4./5.))\n       endif\n       return\n    end subroutine psi_zilitinkevich_esau_2007\n"}, {"instruction": "Create a Fortran subroutine named psi_businger_1971 to calculate the Monin-Obukhov stability functions psi_m and psi_h based on the input stability parameter z/l. The subroutine has 1 input parameter of type real and 2 output parameters of type real.", "input": "", "output": "    subroutine psi_businger_1971(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real :: x, y\n       real, parameter :: pi180 = 3.14159265/180.\n       if (zl .lt. 0.) then\n          x = (1. - 15.0*zl)**0.25\n          y = (1. - 9.0*zl)**0.5\n          psi_m = log(((1.+x)/2.)**2.) + &\n                 &log((1.+x**2.)/2.) - &\n                 &2.0*atan(x) + pi180*90.\n          psi_h = 2.*log((1.+y)/2.)\n       else\n          psi_m = -4.7*zl\n          psi_h = -(4.7/0.74)*zl\n       endif\n       return\n    end subroutine psi_businger_1971\n"}, {"instruction": "Write a Fortran subroutine named psi_suselj_sood_2010 to calculate the values of psi_m and psi_h based on the value of zl. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type real. The input parameter represents zl, while the output parameters represent psi_m and psi_h, respectively. Use the provided mathematical expressions to calculate the values of psi_m and psi_h based on the value of zl.", "input": "", "output": "    subroutine psi_suselj_sood_2010(psi_m, psi_h, zl)\n       implicit none\n       real, intent(in) :: zl\n       real, intent(out) :: psi_m, psi_h\n       real, parameter :: rfc=0.19, ric=0.183, phit=0.8\n       if (zl .gt. 0.) then\n          psi_m = -(zl/rfc + 1.1223*exp(1.-1.6666/zl))\n          psi_h = -(zl*ric/((rfc**2.)*5.) + 7.09*(zl**1.1091))\n       else\n          psi_m = 0.9904*log(1. - 14.264*zl)\n          psi_h = 1.0103*log(1. - 16.3066*zl)\n       endif\n       return\n    end subroutine psi_suselj_sood_2010\n"}, {"instruction": "Create a Fortran subroutine named \"li_etal_2010\" to calculate the stability parameter \"zl\" based on input parameters \"rib\", \"zaz0\", and \"z0zt\", which are real numbers. The subroutine takes 3 input parameters of type real and returns 1 output parameter of type real. ", "input": "", "output": "    subroutine li_etal_2010(zl, rib, zaz0, z0zt)\n       implicit none\n       real, intent(out) :: zl\n       real, intent(in) :: rib, zaz0, z0zt\n       real :: alfa, beta, zaz02, z0zt2\n       real, parameter :: au11=0.045, bu11=0.003, bu12=0.0059, &\n                          &bu21=-0.0828, bu22=0.8845, bu31=0.1739, &\n                          &bu32=-0.9213, bu33=-0.1057\n       real, parameter :: aw11=0.5738, aw12=-0.4399, aw21=-4.901,&\n                          &aw22=52.50, bw11=-0.0539, bw12=1.540, &\n                          &bw21=-0.669, bw22=-3.282\n       real, parameter :: as11=0.7529, as21=14.94, bs11=0.1569,&\n                          &bs21=-0.3091, bs22=-1.303\n       zaz02=zaz0\n       if (zaz0 .lt. 100.0) zaz02=100.\n       if (zaz0 .gt. 100000.0) zaz02=100000.\n       z0zt2=z0zt\n       if (z0zt .lt. 0.5) z0zt2=0.5\n       if (z0zt .gt. 100.0) z0zt2=100.\n       alfa = log(zaz02)\n       beta = log(z0zt2)\n       if (rib .le. 0.0) then\n          zl = au11*alfa*rib**2 + ( &\n               & (bu11*beta + bu12)*alfa**2 + &\n               & (bu21*beta + bu22)*alfa + &\n               & (bu31*beta**2 + bu32*beta + bu33))*rib\n          zl = max(zl,-15.)\n          zl = min(zl,0.)\n       elseif (rib .gt. 0.0 .and. rib .le. 0.2) then\n          zl = ((aw11*beta + aw12)*alfa + &\n             & (aw21*beta + aw22))*rib**2 + &\n             & ((bw11*beta + bw12)*alfa + &\n             & (bw21*beta + bw22))*rib\n          zl = min(zl,4.)\n          zl = max(zl,0.)\n       else\n          zl = (as11*alfa + as21)*rib + bs11*alfa + &\n             & bs21*beta + bs22\n          zl = min(zl,20.)\n          zl = max(zl,1.)\n       endif\n       return\n    end subroutine li_etal_2010\n"}, {"instruction": "Create a Fortran subroutine named assemble_system1 to assemble a linear system. It takes 1 input parameter of type integer. The output parameters are 3 arrays of type real(8).", "input": "", "output": "  subroutine assemble_system1(npts, a, b, x0)\n\n    implicit none\n\n    integer, intent(in)  :: npts\n    real(8), intent(out) :: a(npts,npts)\n    real(8), intent(out) :: b(npts)\n    real(8), intent(out) :: x0(npts)\n\n    integer :: m, n\n    integer :: i, j, k\n\n    ! zero all entries\n    a = 0.0d0\n\n    ! size of the linear system\n    m = npts ! nrows\n    n = npts ! ncols\n\n    ! assemble matrix\n    a(m,1) = 1.0d0\n    a(1,n) = 1.0d0\n    forall(i=1:m-1) a(i,i+1) = 1.0d0\n\n    ! assemble right hand side\n    b = 0.0d0\n    b(1) = 1.0d0\n\n    ! initial guess\n    x0 = 0.0d0\n\n  end subroutine assemble_system1\n"}, {"instruction": "Write a Fortran subroutine named msa to perform a two-dimensional Multiscale Shock Algorithm (MSA). The subroutine takes 5 input parameters of types integer, integer, real*8, real*8, and real*8 and 1 output parameter of type real*8.\n\nThe input parameters are x0 (input and output), n1 (integer), n2 (integer), y0 (real*8 array), x0 (real*8 array), and stepsize (real*8). The output parameter is x1 (real*8 array).\n\nThe subroutine calculates the updated values of x1 based on the input values of x0, y0, and stepsize using the Multiscale Shock Algorithm.", "input": "", "output": "    subroutine msa(x0,y0,x1,stepsize,n1,n2) ! two dimension msa\n    implicit none\n! x0 is input and also output\n    integer,intent(in)::n1,n2! two dimension\n    real*8,intent(in)::y0(n1,n2)\n    real*8,intent(in)::x0(n1,n2)\n    real*8,intent(out)::x1(n1,n2)\n    real*8,intent(in)::stepsize\n    integer:: i,j\n\n    x1=0.0\n    do i=1,n2\n      do j=1,n1\n        x1(j,i)=x0(j,i)+stepsize*(y0(j,i)-x0(j,i))\n      enddo \n    enddo \n    return \n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named nearsquare to find two nearest square numbers to the given integer n. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 2 and the test_data type is [integer, integer].", "input": "", "output": "    subroutine nearsquare(n, a, b)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: a, b\n\n        do a=ceiling(sqrt(n*1.0)),1,-1\n            b = n/a\n            if (a*b == n) exit\n        enddo\n    end subroutine nearsquare\n"}, {"instruction": "Create a Fortran subroutine named make_seeds to generate a sequence of random integer numbers. The subroutine takes 2 input parameters of type integer and returns an array of integer numbers with a specified length. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer,dimension(0:num)'].", "input": "", "output": "subroutine make_seeds(seed,iseeds,num)\n  implicit none\n  integer,intent(in):: num\n  integer,intent(in):: seed\n  integer,dimension(0:num),intent(out):: iseeds\n  integer:: i\n  integer,parameter:: ln = 1000\n  integer,dimension(0:ln-1):: iy\n  integer(kind=8),parameter:: aaa = z'ffffffff'\n\n  iy(0) = iand(seed,aaa)\n  iseeds = 0\n\n  do i=1,30\n   iy(i) = 1812433253 * ieor(iy(i-1),ishft(iy(i-1),-30))+i\n   iy(i) = iand(iy(i),aaa)\n  end do\n  do i=31,ln-1\n   iy(i) = ieor(iy(i-31),iy(i-13))\n  end do\n  do i=0,num\n   iseeds(i)=iy(ln-1-num+1+i)\n  end do\n\nend subroutine make_seeds\n"}, {"instruction": "Create a Fortran subroutine named make_output_filename, which takes two input parameters of type integer and character(len=*), and one output parameter of type character(len=*). The purpose of this subroutine is to generate an output filename based on the input id and fnbase. The output filename is constructed by appending \".dat\" and \".p_\" followed by the adjusted id to the fnbase.", "input": "", "output": "subroutine make_output_filename(datfname,id,fnbase)\n  implicit none\n  character(len=*),intent(out):: datfname\n  integer,intent(in):: id\n  character(len=*),intent(in):: fnbase\n  character(len=4),parameter:: dada = \".dat\"\n  character(len=10)::tail\n\n  write(tail,'(i4.4)') id\n  write(datfname,'(10a)') fnbase(1:len_trim(fnbase)),dada,\".p_\",adjustl(tail)\n\nend subroutine make_output_filename\n"}, {"instruction": "Write a Fortran subroutine named fibber that computes the most significant digits of a sum in a Fibonacci-like sequence. The subroutine should take 2 input parameters of type integer (kind=8) and produce 2 output parameters of type integer (kind=8).", "input": "", "output": "subroutine fibber(a,b,c,d)\n  ! compute most significant digits, fibonacci like.\n  implicit none\n  integer (kind=8), intent(in) :: a,b\n  integer (kind=8), intent(out) :: c,d\n  d = a + b\n  if (15 .lt. log10(float(d))) then\n    c = b/10\n    d = d/10\n  else\n    c = b\n  endif\nend subroutine fibber\n"}, {"instruction": "Create a Fortran subroutine named shift_mc_to_vc to shift data from a 2D array in single precision to a 2D array in double precision. The subroutine has 1 input parameter of type real, dimension( :, : ), and 1 output parameter of type double precision, dimension( :, : ). The subroutine should duplicate the input array into the output array and add an extra row and column of zeros at the end.", "input": "", "output": "  subroutine shift_mc_to_vc ( f_mc, f_vc )\n    implicit none\n\n    real, dimension( :, : ), intent(in) :: f_mc\n    double precision, dimension( :, : ), intent(out) :: f_vc\n    integer :: nlon, nlat\n\n    nlon = size( f_mc, 1)\n    nlat = size( f_mc, 2)\n\n    f_vc ( 1 : nlon, 1 : nlat ) = f_mc ( :, : )\n    f_vc ( nlon + 1, : ) = f_vc ( 1, : )\n    f_vc ( :, nlat + 1 ) = 0.0e0\n\n  end subroutine shift_mc_to_vc\n"}, {"instruction": "Create a Fortran subroutine named bar to perform the bar action. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is specified using the \"intent(in)\" attribute, and the output parameter is specified using the \"intent(out)\" attribute. The subroutine calculates the value of the output parameter by adding 100 to the input parameter and then subtracting 7.", "input": "", "output": "subroutine bar(a, b)\n\n!   performs the bar action\n\n    implicit none\n\n    integer, intent(in)  :: a\n    integer, intent(out) :: b\n\n    b = a + 100 - 7\n\nend subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named getgrid to generate a grid and Fourier frequencies for a 1D nonlinear Klein-Gordon equation simulation. The subroutine takes 3 input parameters of types integer(kind=4), real(kind=8), and real(kind=8), and returns 3 output parameters of types real(kind=8), complex(kind=8), and character*100.", "input": "", "output": "\tsubroutine getgrid(nx,lx,pi,name_config,x,kx)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! pseudospectral simulation of the 1d nonlinear klein-gordon equation\n\t!\n\t! u_{tt}-u_{xx}+u=es*u^3\n\t!\n\t! the boundary conditions are u(x=0)=u(2*lx*\\pi) \n\t!\n\t! input\n\t!\n\t! .. scalars ..\n\t!  nx\t\t\t\t= number of modes in x - power of 2 for fft\n\t!  pi\t\t\t\t= 3.142....\n\t!  lx\t\t\t\t= width of box in x direction\n\t! output\n\t!\n\t! .. vectors ..\n\t!  kx\t\t\t\t= fourier frequencies in x direction\n\t!  x\t\t\t\t= x locations\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t\t\t\t= loop counter in x direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n        implicit none\n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t        :: nx\n\treal(kind=8), intent(in)\t\t\t        :: lx,pi\n\treal(kind=8), dimension(1:nx), intent(out) \t        :: x\n\tcomplex(kind=8), dimension(1:nx/2 + 1), intent(out)\t:: kx\n\tcharacter*100, intent(out)\t\t\t        :: name_config\n\tinteger(kind=4)\t\t\t\t\t        :: i\n\t\t\n\tdo i=1,1+nx/2\n\t\tkx(i)= cmplx(0.0d0,1.0d0,kind(0d0))*real(i-1,kind(0d0))/lx  \t\t\t\n\tend do\n\tkx(1+nx/2)=0.0d0\n\t\t\n\tdo i=1,nx\n\t\tx(i)=(-1.0d0 + 2.0d0*real(i-1,kind(0d0))/real(nx,kind(0d0)))*pi*lx\n\tend do\n\t! save x grid points in text format\n\tname_config = 'xcoord.dat' \n\topen(unit=11,file=name_config,status=\"unknown\") \t\n\trewind(11)\n\tdo i=1,nx\n\t\twrite(11,*) x(i)\n\tend do\n\tclose(11)\n\t\n\tend subroutine getgrid\n"}, {"instruction": "Write a Fortran subroutine named get_sigini to compute the signature and original signature matrices based on the provided input data. The number of input arguments is 4 and the test_data type is [integer, integer, integer, integer]. The number of output arguments is 3 and the test_data type is [integer, integer, integer].", "input": "", "output": "subroutine get_sigini(cixdms, sigini, sigini_orig, sigind, sigind_orig, cixdm, maxdim)\n  implicit none\n  integer, intent(in)  :: sigind(maxdim,maxdim), sigind_orig(maxdim,maxdim), cixdm, maxdim\n  integer, intent(out) :: cixdms, sigini(cixdm,cixdm), sigini_orig(cixdm,cixdm)\n  ! locals\n  integer :: cind(cixdm), it, ip, iq, cini(cixdm)\n  \n  cixdms=0 ! real dimension, excluding states which must be projected out, because they are treated as non-correlated\n  cind=0   ! in most cases, cind(i)=i, however, when some states are projected out, cind points to smaller block\n  do ip=1,cixdm\n     it = sigind_orig(ip,ip)\n     if (it.gt.0) then\n        cixdms = cixdms + 1\n        cind(ip) = cixdms\n     endif\n  enddo\n     \n  do ip=1,cixdm\n     if (cind(ip).gt.0) cini(cind(ip))=ip\n  enddo\n  sigini=0\n  sigini_orig=0\n  do ip=1,cixdms\n     do iq=1,cixdms\n        sigini(ip,iq) = abs(sigind(cini(ip),cini(iq)))           \n        sigini_orig(ip,iq) = abs(sigind_orig(cini(ip),cini(iq))) \n     enddo\n  enddo\nend subroutine get_sigini\n"}, {"instruction": "Create a Fortran subroutine named gethighfrequency to approximate the values of a and c using the input complex numbers cc, the array of real numbers omega, and the integer n. The subroutine has 3 input parameters of type complex*16, real*8, and integer, and 2 output parameters of type real*8.", "input": "", "output": "subroutine gethighfrequency(a,c,cc,omega,n)\n  ! approximates cc ~  a/(i*om-c)\n  implicit none\n  real*8, intent(out)    :: a, c\n  complex*16, intent(in) :: cc(n)\n  real*8, intent(in)     :: omega(n)\n  integer, intent(in)    :: n\n  !print *, 'cc(n)=', cc(n)\n  if (abs(cc(n)).lt.1e-6) then\n     a=0.d0\n     c=1.d0\n  else\n     a = 1./aimag(1/(cc(n)*omega(n)))\n     c = -a*dble(1./cc(n))\n  endif\nend subroutine gethighfrequency\n"}, {"instruction": "Create a Fortran subroutine named binary_search to perform a binary search on a sorted integer array. The subroutine should take 4 input parameters of type integer (s, ls, le, list_s) and 2 output parameters of type integer (b, bmin).", "input": "", "output": "  subroutine binary_search(s,list_s,ls,le,b,bmin)\n    integer, intent(out) :: b, bmin\n    integer, intent(in) :: s,ls,le\n    integer, intent(in) :: list_s(le)\n    integer :: bmax\n    bmin = ls; bmax = le\n    do\n       b = bmin + (bmax-bmin)/2\n       if(s<list_s(b))then\n          bmax = b-1\n       else if(list_s(b)<s)then\n          bmin = b+1\n       else\n          bmin = b\n          return\n       end if\n       if(bmin>bmax)then\n          b = -1\n          return\n       end if\n    end do\n  end subroutine binary_search\n"}, {"instruction": "Create a Fortran subroutine named findstate to search for a specific integer value within a sorted integer array. The subroutine takes 3 input parameters of type integer: s, m, and list_s(m), and one output parameter of type integer, b.", "input": "", "output": "  subroutine findstate(s,list_s,b,m) \n    integer, intent(out) :: b\n    integer, intent(in) :: s, m, list_s(m)\n    integer :: bmin, bmax \n    bmin = 1; bmax = m\n    do\n      b = bmin + (bmax-bmin)/2\n      if(s < list_s(b))then\n        bmax = b-1\n      else if(s > list_s(b))then\n        bmin = b+1\n      else\n        return\n      end if\n      if(bmin>bmax)then\n        b = -1; return\n      end if\n    end do\n  end subroutine findstate\n"}, {"instruction": "Create a Fortran subroutine named getfilename that takes two input parameters of type character*128 and integer, and one output parameter of type character*132. This subroutine generates a filename based on the base name and the provided index. If the index is less than 10, the filename is constructed using a single-digit index. If the index is between 10 and 99, a two-digit index is used. If the index is between 100 and 999, a three-digit index is used. If the index is between 1000 and 9999, a four-digit index is used. The generated filename is then returned in the output parameter.", "input": "", "output": "subroutine getfilename(base_name,i,current_filename)\n\n  implicit none\n  character*128, intent(in) ::  base_name\n  character*132, intent(out) ::  current_filename\n  integer, intent(in) :: i \n\n  if (i < 10) then\n     write(current_filename,1000),trim(base_name),i\n  else if (i < 100) then\n     write(current_filename,1001),trim(base_name),i\n  else if (i < 1000) then\n     write(current_filename,1002),trim(base_name),i\n  else if (i < 10000) then\n     write(current_filename,1003),trim(base_name),i\n  else\n     print *,'error: index too large!'\n     stop\n  end if\n\n  current_filename = trim(current_filename)\n\n1000 format(a,i1)\n1001 format(a,i2)\n1002 format(a,i3)\n1003 format(a,i4)\n\nend subroutine getfilename\n"}, {"instruction": "Create a Fortran subroutine named use_analytic_function to calculate a value based on the input parameters. The subroutine takes 2 input parameters of type real(8) and one output parameter of type real(8). The input parameters are rr and cdd_coef, while the output parameter is d. This subroutine performs a series of calculations using the input parameters and stores the result in the output parameter.", "input": "", "output": "  subroutine use_analytic_function( rr, cdd_coef, d )\n    implicit none\n    real(8),intent(in)  :: rr, cdd_coef(:,:)\n    real(8),intent(out) :: d\n    real(8) :: a,b,c\n    integer :: i\n    d=0.0d0\n    do i=1,size(cdd_coef,2)\n       a=cdd_coef(1,i)\n       b=cdd_coef(2,i)\n       c=cdd_coef(3,i)\n       d=d+(a+b*rr)*exp(-c*rr)\n    end do\n  end subroutine use_analytic_function\n"}, {"instruction": "Write a Fortran subroutine named get_nearest_index to find the index of the element in the array \"rad\" that is closest to the value \"r\". The number of input arguments is 2 and the test_data type is ['real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  subroutine get_nearest_index( rad, r, ir )\n    implicit none\n    real(8),intent(in)  :: rad(:), r\n    integer,intent(out) :: ir\n    integer :: ir0,ir1\n    ir0=1\n    ir1=size( rad )\n1   if ( ir1 - ir0 > 1 ) then\n       ir = ( ir0 + ir1 )/2\n       if ( rad(ir) > r ) then\n          ir1=ir\n       else\n          ir0=ir\n       end if\n       goto 1\n    end if\n  end subroutine get_nearest_index\n"}, {"instruction": "Write a Fortran subroutine named loc_index that takes 2 input parameters of type integer array and 2 output parameters of type integer. The subroutine searches for a specific value within the integer array and returns the index and direction of the found value. Use the imperative tone and summarize the function of the code.", "input": "", "output": "        subroutine loc_index (pe, list, dir, ind)\n\n        integer, intent(in)  :: pe, list(0:)\n        integer, intent(out) :: dir, ind\n\n        logical :: found\n        integer :: n\n\n        found = .false.\n        n = 0\n        dir = -1\n        ind = -1\n        do while ((.not. found) .and. (n < list(0)))\n           n = n + 1\n           if (list(n) == pe) then\n              found = .true.\n              dir = list(n)\n              ind = n\n           end if\n        end do\n\n        end subroutine loc_index\n"}, {"instruction": "Create a Fortran subroutine named count_correct to compare two strings and count the number of correct letters. The subroutine should take 2 input parameters of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine count_correct(g, w, c)\n  implicit none\n  character(len=*), intent(in) :: g, w ! the user's guess and the secret word\n  integer, intent(out) :: c ! the number of correct letters\n  integer :: i\n  c = 0\n  do i = 1, len(w)\n    if (g(i:i) == w(i:i)) then\n      c = c + 1\n    end if\n  end do\n  end subroutine count_correct\n"}, {"instruction": "Create a Fortran subroutine named tria_getneighbourvertex to calculate the vertex number of the neighbor vertex of a given vertex on an edge. The subroutine takes 3 input parameters of type integer: ivertex, ivt1, and ivt2. It also has 1 output parameter of type integer: ineighbour.", "input": "", "output": "  elemental subroutine tria_getneighbourvertex(ivertex,ivt1,ivt2,ineighbour)\n\n!<description>\n  ! calculates the vertex number of the neighbour vertex of a vertex on an\n  ! edge.\n  !\n  ! ivt1 and ivt2 are the vertex numbers of two vertices connected\n  ! by an edge. ivertex is either ivt1 or ivt2.\n  ! the result of this routine is the number of the neighbour vertex\n  ! of ivertex, i.e. if ivertex=ivt1, ineighbour=ivt2 and if\n  ! ivertex=ivt2, ineighbour=ivt1.\n!</description>\n\n!<input>\n  ! vertex number. either ivt1 or ivt2.\n  integer, intent(in) :: ivertex\n\n  ! vertex number of one vertex adjacent to an edge.\n  integer, intent(in) :: ivt1\n\n  ! vertex number of the other vertex adjacent to that edge.\n  integer, intent(in) :: ivt2\n!</input>\n\n!<output>\n  ! vertex number of the neighbour of ivertex.\n  integer, intent(out) :: ineighbour\n!</output>\n\n\n    ! note: directly implementing this formula into the program\n    ! code brings more speed :-)\n    ! but to have a reference not to forget the formula, we have\n    ! this routine...\n\n    ineighbour = ivt1 + ivt2 - ivertex\n\n  end subroutine tria_getneighbourvertex\n"}, {"instruction": "Create a Fortran subroutine named bl_clamp that performs bilinear interpolation within the interval [xlo, xhi]. The function takes 5 input parameters of type double precision (xlo, xhi, flo, fhi, x) and returns 1 output parameter of type double precision (f). The subroutine interpolates the values flo and fhi at x and assigns the result to f. If x is less than or equal to xlo, f is assigned the value of flo. If x is greater than or equal to xhi, f is assigned the value of fhi.", "input": "", "output": "  subroutine bl_clamp(xlo, xhi, flo, fhi, x, f)\n    \n    ! perform bilinear interpolation within the interval [xlo, xhi]\n    ! where the function values at the endpoints are defined by:\n    ! flo = f(xlo)\n    ! fhi = f(xhi)\n    ! returns f(x), the values flo and fhi interpolated at x\n    ! f(x) = flo if x <= xlo\n    ! f(x) = fhi if x >= xhi\n    double precision, intent(in)  :: xlo, xhi, flo, fhi, x\n    double precision, intent(out) :: f\n    if ( x .le. xlo ) then\n       f = flo\n    else if ( x .ge. xhi ) then\n       f = fhi\n    else\n       f = ( flo * ( xhi - x ) + fhi * ( x - xlo ) ) / ( xhi - xlo )\n    end if\n  end subroutine bl_clamp\n"}, {"instruction": "Provide a Fortran subroutine named sediment that calculates the new elevations for each mauza based on subsidence and deposition. The subroutine takes 9 input parameters: flooding (real), m_frfl (real array), m_elev (real array), p_frfl (real), elvband (integer array), nummz (integer), nbands (integer), t (integer), and p (integer). It also has 2 output parameters: elev_new (real array) and eband_new (integer array).\n\nInside the subroutine, the subsidence and deposition values are set. The subsidence rate is 0.02/12.0. The deposition value is initially set to 0.0 but can be uncommented and assigned a different value if a deposition scenario is considered. \n\nA loop iterates over the mauza (c) and checks if it is flooded based on the condition m_frfl(c) > 0.5 and flooding > 0.001. If true, the new elevation for the mauza is calculated by subtracting the subsidence and adding the deposition multiplied by p_frfl. If false, only the subsidence is subtracted from the current elevation.\n\nAnother loop iterates over the bands (b) and checks if the new elevation is lower than a specific elevation band. If true, the corresponding category value is assigned to eband_new. The category values are determined based on the order of the categories with category 10 being read in first. If the new elevation is greater than the lowest elevation band and this condition occurs for the first band (b=1), a message is written to the output.\n\nThe subroutine returns the updated elevations (elev_new) and the assigned category values (eband_new).", "input": "", "output": " subroutine sediment (flooding,m_frfl, m_elev, p_frfl, elvband, nummz,nbands, elev_new, eband_new,t,p)\r\n   !calculates new elevation for each mauza based on subsidence and deposition (if included)\r\n   implicit none\r\n   real, intent(in):: flooding, m_frfl(nummz), m_elev(nummz), p_frfl\r\n   integer, intent(in) :: elvband(nbands), nummz,nbands,t,p\r\n   real, intent(out) :: elev_new (nummz)\r\n   integer, intent(out) :: eband_new(nummz)\r\n   \r\n   real :: subs, deps\r\n   integer :: c, b\r\n   \r\n   subs=0.02/12.0   !subsidence of 2cm/yr (auerbach et al)\r\n   !deps=0.37    !deposition reported by auerbach with an average of 37 cm and as high as 60-70cm in the two years after the storm. turn on if using for deposition scenario\r\n   deps=0.0\r\n   \r\n   do c=1,nummz\r\n     if (m_frfl (c)>0.5 .and. flooding > 0.001) then       !mauza is flooded (frfl equal to 1. the 0.5 is arbitrary)\r\n       elev_new(c)= m_elev(c)-subs+ deps*p_frfl\r\n     else\r\n\t   elev_new(c)= m_elev(c)-subs     !subsidence only\r\n\t end if\r\n\t do b=1,nbands\r\n\t   if (elev_new(c) < elvband(b)) eband_new(c) = nbands+1-b !nbands+1-b to account for the order of the categories with category 10 read in first (ie b=1)\r\n\t   if (elev_new(c) > elvband(b) .and. b==1) write(*,*) 'new elevation greater than existing band'\r\n\t end do\r\n   end do\r\n    \r\n end subroutine sediment\n"}, {"instruction": "Write a Fortran subroutine named `moninshoc_init` to initialize variables used for error handling in a computational physics model. The subroutine takes 1 input argument of type `logical` and 2 output arguments of types `character(len=*)` and `integer`. \n\nThe subroutine first initializes the error message variable (`errmsg`) and the error flag variable (`errflg`). \n\nThen, it performs consistency checks on the input argument `do_shoc`. If `do_shoc` is `false`, it sets the error flag to 1 and writes an error message to `errmsg`, indicating a logic error. \n\nThe subroutine ends after the consistency checks.", "input": "", "output": "      subroutine moninshoc_init (do_shoc, errmsg, errflg)\n\n      implicit none\n      logical, intent(in) :: do_shoc\n      character(len=*), intent(out) :: errmsg\n      integer,          intent(out) :: errflg\n\n      ! initialize ccpp error handling variables\n      errmsg = ''\n      errflg = 0\n\n      ! consistency checks\n      if (.not. do_shoc) then\n        errflg = 1\n        write(errmsg,'(*(a))') 'logic error: do_shoc = .false.'\n       return\n      end if\n \n      end subroutine moninshoc_init\n"}, {"instruction": "Write a Fortran subroutine named \"sub\" that takes in an integer array \"a\" of length \"n\" as input and outputs an integer array \"b\" of the same length. The subroutine should copy the values from array \"a\" to array \"b\". The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    subroutine sub(n, a, b)\n    integer, intent(in) :: n\n    integer, intent(in) :: a(n)\n    integer, intent(out) :: b(n)\n    integer :: i\n    do i = 1, size(a)\n        b(i) = a(i)\n    end do\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named util__split that separates a given input buffer into multiple fields based on a specified separator. The number of input arguments is 2 and the test_data type is ['character(*)', 'character(*)']. The number of output arguments is 2 and the test_data type is ['integer', 'character(*), allocatable'].\n\nIn the subroutine, the input buffer and separator are provided as arguments. The subroutine counts the number of separator occurrences in the buffer and determines the number of separated fields. It allocates memory for an array to store the separated fields. Then, it iterates through the buffer, identifying the position of each separator and extracting the corresponding field. The separated fields are stored in the allocated array.\n\nTo summarize, the util__split subroutine takes an input buffer and a separator and splits the buffer into multiple fields. It returns the number of separated fields and an array containing the separated fields.", "input": "", "output": "  subroutine util__split(buf, sep, n, nm)\n    \n    character(*), intent(in)  :: buf  !< input buffer\n    character(*), intent(in)  :: sep  !< separator\n    integer,      intent(out) :: n    !< number of separated fields\n    !--\n    character(*), allocatable, intent(out) :: nm(:)  !< separated variables\n    integer :: i, j, k\n    !----\n    \n    ! count separator\n    n = 0\n    i = 1\n    j = 1\n    do\n      i = index(buf(j:), sep)\n      if( i == 0 ) exit\n      j = j + i\n      n = n + 1\n    end do\n    n = n + 1  !! #words = #separator + 1\n    allocate(nm(n))\n\n    i = 1\n    j = 1\n    do k=1, n-1\n      i = index(buf(j:), sep)\n      nm(k) = trim(adjustl(buf(j:i+j-2)))\n      j = j + i\n    end do\n    nm(n) = trim(adjustl(buf(j:)))\n\n  end subroutine util__split\n"}, {"instruction": "Write a Fortran subroutine named \"trans_rank_2\" that performs a rank-2 matrix transpose. The code takes a 2-dimensional real array as input, with the test_data type of ['real(8)']. The output is an allocatable 2-dimensional real array, with the test_data type of ['real(8),allocatable']. The subroutine uses the \"intent(in)\" keyword to specify that the input array is read-only. The subroutine allocates memory for the output array if it is not already allocated. Inside the subroutine, the transpose operation is performed by iterating over the elements of the input array and assigning them to the corresponding positions in the output array. The subroutine uses the \"integer\" keyword to declare the variables used for looping.", "input": "", "output": "   subroutine trans_rank_2(a,a_t)\r\n\t  real(8),intent(in)::a(:,:)\r\n\t  real(8),allocatable,intent(out)::a_t(:,:)\r\n\t  integer n,m,i,j\r\n\t  \r\n\t  n=size(a,1)\r\n\t  m=size(a,2)\r\n\t  if(.not. allocated(a_t) )allocate(a_t(m,n))\r\n\t  \r\n\t  do i=1,n\r\n\t\tdo j=1, m\r\n\t\t\ta_t(j,i)=a(i,j)\r\n\t\tenddo\r\n\t  enddo\r\n\t  \r\n   end subroutine trans_rank_2\r\n"}, {"instruction": "Create a Fortran subroutine named layout_procs to calculate the layout of processor grid given the total number of processors. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer.", "input": "", "output": "  subroutine layout_procs(n_procs, n_procs_row, n_procs_col)\n    integer, intent(in) :: n_procs\n    integer, intent(out) :: n_procs_row, n_procs_col\n\n    n_procs_row = int(sqrt(dble(n_procs + 1)))\n    do while (mod(n_procs, n_procs_row) /= 0)\n      n_procs_row = n_procs_row - 1\n    end do\n    n_procs_col = n_procs / n_procs_row\n  end subroutine layout_procs\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_v_l_1d to allocate memory for a 1D array. The subroutine should take 2 input parameters of type character(kind=c_char) and integer(c_size_t), and 2 output parameters of type type(c_ptr).", "input": "", "output": "    subroutine f_kokkos_allocate_v_l_1d(c_a, v_a, n_a, e0) &\n      & bind (c, name='c_kokkos_allocate_v_l_1d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type(c_ptr), intent(out) :: c_a\n      type(c_ptr), intent(out) :: v_a\n      character(kind=c_char), intent(in) :: n_a(*)\n      integer(c_size_t), intent(in) :: e0      \n    end subroutine f_kokkos_allocate_v_l_1d\n"}, {"instruction": "Create a Fortran subroutine named forward to perform a numerical simulation using the forward time, central space method for solving a partial differential equation. The subroutine takes 4 input parameters of type double precision and dimension, and 1 output parameter of type double precision and dimension. The input parameters are a (velocity), dx (spatial step size), dt (time step size), and u0 (initial vector). The output parameter is u (solution vector).", "input": "", "output": "  subroutine forward(u0,u,a,dx,dt)\n\n    ! eingabe:\n    ! u0 = ausgangsvektor\n    ! u = ausgabevektor\n    ! a = geschwindigkeit (>0)\n    ! dx = ortsschrittweite\n    ! dt = zeitschrittweite\n\n    double precision, intent(in)\t\t\t:: a, dx, dt\n    double precision, dimension(:), intent(out)\t\t:: u\n    double precision, dimension(:), intent(in)\t\t:: u0\n    integer\t\t\t\t\t\t:: i,j\n    double precision\t\t\t\t\t:: k1\n\n    ! hilfsvariable\n    k1 = a*dt/dx\n\n    ! berechne den loesungsvektor fuer alle ausser dem linken x (parallel)\n    forall(i=lbound(u0,1)+1:ubound(u0,1))\n       u(i) = u0(i)-k1*(u0(i)-u0(i-1))\n    end forall\n\n    ! berechne den loesungswert fuer das linke x\n    u(lbound(u0,1)) = u0(lbound(u0,1))+k1*u0(lbound(u0,1))\n\n  end subroutine forward\n"}, {"instruction": "Write a Fortran subroutine named dhaj to calculate the weights for expanding an equally sampled grid into spherical harmonics using the sampling theorem. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type real*8. The input parameter represents the number of samples in longitude and latitude, while the output parameter contains the weights.", "input": "", "output": "subroutine dhaj(n, aj)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n\n!\texpand an equally sampled grid into spherical harmonics by using\n!\tthe sampling theorem presented in driscoll and healy (1994).\n!\n!\tnote that the number of samples, n, must be even! also, a_j(1) = 0\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tn\tnumber of samples in longitude and latitude.\n!\t\tout\n!\t\t\taj\tvector of length n containing the weights.\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek (may, 2004)\n!\n!\tcopyright (c) 2005, 2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\tinteger, intent(in) ::\tn\n\treal*8, intent(out) ::\taj(:)\n\tinteger ::\t\tj, l\n\treal*8 ::\t\tsum1, pi\n\t\n\tpi = acos(-1.0d0)\n\t\n\taj = 0.0d0\n\t\n\tif (mod(n,2) /= 0) then\n\t\tprint*, \"error --- dh_aj\"\n\t\tprint*, \"the number of samples in the equi-dimensional grid must be even for use with shexpanddh\"\n\t\tprint*, \"input value of n is \", n\n\t\tstop\n\telseif (size(aj) < n) then\n\t\tprint*, \"error --- dh_aj\"\n\t\tprint*, \"the size of aj must be greater than or equal to n where n is \", n\n\t\tprint*, \"input array is dimensioned as \", size(aj)\n\t\tstop\n\tendif\n\t\n\tdo j=0, n-1\n\t\tsum1 = 0.0d0\n\t\t\n\t\tdo l=0, n/2 -1\n\t\t\tsum1 = sum1 + sin( dble(2*l+1) * pi * dble(j) / dble(n) ) / dble(2*l+1)\n\t\tenddo\n\t\n\t\taj(j+1) = sum1  * sin(pi * dble(j)/dble(n)) * sqrt(8.0d0) / dble(n)\n\t\n\tenddo\n\t\nend subroutine dhaj\n"}, {"instruction": "Write a Fortran subroutine named \"vmflow\" that calculates the von Mises flow stress. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The input parameters are stress and dsbar, and the output parameter is vmfl. Use the imperative tone when writing the subroutine.", "input": "", "output": "subroutine vmflow(stress,dsbar,vmfl)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::stress(:),dsbar\n real(iwp),intent(out)::vmfl(:)\n real(iwp)::sigm,onept5=1.5_iwp,two=2.0_iwp,d3=3.0_iwp\n sigm=(stress(1)+stress(2)+stress(4))/d3\n vmfl(1)=stress(1)-sigm\n vmfl(2)=stress(2)-sigm\n vmfl(3)=stress(3)*two \n vmfl(4)=stress(4)-sigm\n vmfl=vmfl*onept5/dsbar\nreturn\nend subroutine vmflow\n"}, {"instruction": "Create a Fortran subroutine named initialdata, which initializes and computes the initial solution for a three-dimensional wave equation. The subroutine takes 6 input parameters: nx, ny, nz (integer kind=4), x, y, z (real kind=8 arrays). It also has 2 output parameters: u, uold (complex kind=8 arrays of dimensions 1:nx, 1:ny, 1:nz).", "input": "", "output": "\tsubroutine initialdata(nx,ny,nz,x,y,z,u,uold)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! in 3 dimensions\n\t! u_{tt}-(u_{xx}+u_{yy}+u_{zz})+u=es*u^3+\n\t!\n\t! the boundary conditions are u(x=-lx*\\pi,y,z)=u(x=lx*\\pi,y,z), \n\t!\tu(x,y=-ly*\\pi,z)=u(x,y=ly*\\pi,z),u(x,y,z=-ly*\\pi)=u(x,y,z=ly*\\pi)\n\t! the initial condition is u=0.5*exp(-x^2-y^2-z^2)*sin(10*x+12*y)\n\t!\n\t! input\n\t!\n\t! .. parameters ..\n\t!  nx\t\t\t\t= number of modes in x - power of 2 for fft\n\t!  ny\t\t\t\t= number of modes in y - power of 2 for fft\n\t!  nz\t\t\t\t= number of modes in z - power of 2 for fft\n\t! .. vectors ..\n\t!  x\t\t\t\t= x locations\n\t!  y\t\t\t\t= y locations\n\t!  z\t\t\t\t= z locations\n\t!\n\t! output\n\t!\n\t! .. arrays ..\n\t!  u \t\t\t\t= initial solution\n\t!  uold \t\t\t= approximate solution based on time derivative of\n\t!\t\t\t\t\tinitial solution\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t\t\t\t= loop counter in x direction\n\t!  j\t\t\t\t= loop counter in y direction\n\t!  k\t\t\t\t= loop counter in z direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n\t! openmp library\n\tuse omp_lib\t\t \t   \n\timplicit none\t\t\t\t\t \n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t\t\t\t\t:: nx,ny,nz\n\treal(kind=8), dimension(1:nx), intent(in) \t\t\t:: x\n\treal(kind=8), dimension(1:ny), intent(in) \t\t\t:: y\n\treal(kind=8), dimension(1:nz), intent(in) \t\t\t:: z\n\tcomplex(kind=8), dimension(1:nx,1:ny,1:nz), intent(out)\t:: u,uold\n\tinteger(kind=4)\t\t\t\t\t\t\t\t\t\t:: i,j,k\n\t!$omp parallel do private(i,j) schedule(static)\n\tdo k=1,nz\n\t\tdo j=1,ny\n\t\t\tdo i=1,nx\n\t\t\t\tu(i,j,k)=0.5d0*exp(-1.0d0*(x(i)**2 +y(j)**2+z(k)**2))!*&\n\t\t\t\t\t!sin(10.0d0*x(i)+12.0d0*y(j))\n\t\t\tend do\n\t\tend do\n\tend do\n\t!$omp end parallel do\n\t!$omp parallel do private(i,j) schedule(static)\n\tdo k=1,nz\n\t\tdo j=1,ny\n\t\t\tdo i=1,nx\n\t\t\t\tuold(i,j,k)=0.5d0*exp(-1.0d0*(x(i)**2 +y(j)**2+z(k)**2))!*&\n\t\t\t\t\t!sin(10.0d0*x(i)+12.0d0*y(j))\n\t\t\tend do\n\t\tend do\n\tend do\n\t!$omp end parallel do\n\t\n\tend subroutine initialdata\n"}, {"instruction": "Create a Fortran subroutine named \"lf_omq\" that calculates various statistical parameters for a given set of input data. The subroutine should have 6 input parameters: an integer \"no_bins\", real*8 arrays \"om\" and \"q\" with dimensions (3, no_bins), a real*8 array \"sigma_data\" with dimension (no_bins), and real*8 arrays \"om_true\" and \"q_true\" with dimension (no_bins). The subroutine should also have 3 output parameters: real*8 arrays \"chi\" and \"chi2\" with dimension (3), and a single real*8 \"lf_q_sum\" value.\n", "input": "", "output": "subroutine lf_omq (no_bins,om,q,chi,chi2,lf_q_sum,om_true,q_true,sigma_data)\n\timplicit none\n\tinteger,intent(in) :: no_bins\n\treal*8,intent(in),dimension(3,no_bins) :: om,q\n\treal*8,intent(in),dimension(no_bins) ::sigma_data\n\treal*8,dimension(no_bins) :: q_sum\n\treal*8,intent(out),dimension(3) :: chi,chi2\n\treal*8,intent(out) :: lf_q_sum\n\tinteger :: i,t\n\treal*8,intent(in),dimension(no_bins) :: om_true,q_true\n\n\tchi = 0.0d0\n\tchi2 = 0.0d0\n\ndo t =1,3\n\tdo i = 3, (no_bins-2)\n\t\tchi(t) = chi(t) +  ( ((om(t,i)) - (om_true(i)))/(sigma_data(i))   )**2\n\tend do\n\tdo i = 3, (no_bins-2)\n\t\tchi2(t) = chi2(t) + (((q(t,i)) - (q_true(i)))/(sigma_data(i)) )**2  \n\tend do\nend do\n\n\tlf_q_sum = 0d0\n\tq_sum = sum(q,dim = 1)\n\tq_sum = (q_sum)/(3.0d0)\n\tdo i = 3, (no_bins-2)\n\t\tlf_q_sum = lf_q_sum + (((q_sum(i)) - (q_true(i)))/(sigma_data(i)) )**2  \n\tend do\n\n\nreturn\nend subroutine lf_omq\n"}, {"instruction": "Create a Fortran subroutine named reconstruction to perform a specific calculation related to cosmology. The subroutine takes 3 input parameters of type integer, real*8 array of dimension no_bins, and another real*8 array of dimension no_bins. It returns 2 output parameters, both being real*8 arrays of dimension no_bins. The subroutine calculates values for h and q based on the input arrays z and dm.", "input": "", "output": "subroutine reconstruction (no_bins,dm,z,h,q)\n implicit none\n\n  integer :: j\n  real*8 :: h0\n  integer,intent(in) :: no_bins\n  real*8,intent(in),dimension(no_bins):: z\n  real*8,intent(in),dimension(no_bins):: dm\n  real*8,dimension(no_bins):: l\n  real*8,intent(out),dimension(no_bins):: h,q!,om\n\n  h = 0.0d0;q = 0.0d0\n\n  do j = 1, no_bins\n\tl (j) = (1.0d0/3.0d10)*((10.0d0**((dm (j))/(5.0d0)))/(1.0d0 + z(j))) ! in mpc.s/km\n  end do\n\n  h (1) = (z(2)-z(1))/(l(2)-l(1))\n  do j = 2, (no_bins-1)\n\th (j) = (z(j+1)-z(j-1))/((l(j+1)-l(j-1)))\n  end do\n  h0 = ((-1.0*z(2))*((h(3)-h(2))/(z(3)-z(2))))+h(2)! by extrapolation i find h(z = 0) and then devide all values by that to get h(z) = h(z)/h(0)\n\n!\tdividing h(z) by h(z = 0)\n  do j = 2, (no_bins-1)\n\th (j) = h (j)/h0\n  end do\n\n\n\n  do j=3,(no_bins-2)\n\tq(j) = (( (1+z(j)) / (h(j))) * ((h(j+1)-h(j-1))/(z(j+1)-z(j-1)))) - 1.0d0\n  end do\n\n!  do j=3,(no_bins-2)\n!\tom(j) = (((h(j+1))**2)-((h(j-1))**2))/(((1.0d0+z(j+1))**3)-((1.0d0+z(j-1))**3)) \n!  end do\n\n\nreturn\nend subroutine reconstruction\n"}, {"instruction": "Create a Fortran subroutine named interpolate that takes 5 input parameters and 1 output parameter. The input parameters consist of two integers (no_data, no_bins) and three arrays of real*8 type (z, x, z_data), each with different dimensions. The output parameter is an array of real*8 type (y) with the dimension no_data. The subroutine interpolates values using the given data and stores the results in the array y.", "input": "", "output": "subroutine interpolate(no_data,no_bins,z,x,z_data,y)\n  implicit none\n\n  integer :: i,j\n  integer,intent(in) :: no_data,no_bins\n  real*8,intent(in),dimension(no_bins) :: z,x\n  real*8,intent(in),dimension(no_data) :: z_data\n  real*8,intent(out),dimension(no_data) :: y\n\n do j=1,no_bins\n\t   do i = 1, no_data\n\t\tif (z_data(i) .le. z(j+1) .and. z_data(i) .ge. z(j)) y(i) = ((z_data(i)-z(j))*((x(j+1)-x(j))/(z(j+1)-z(j))))+x(j)\n       end do\n end do\nreturn\nend subroutine interpolate\n"}, {"instruction": "Write a Fortran subroutine named linspace to generate a linearly spaced vector of real numbers between two given values. The number of input arguments is 3 and the test_data type is ['integer', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(n)'].", "input": "", "output": "  subroutine linspace(l, k, n, z)\n    implicit none\n!// argument declarations\n    integer, intent(in) :: n\n    real(kind=8), dimension(n), intent(out) :: z\n    real(kind=8), intent(in) :: l\n    real(kind=8), intent(in) :: k\n!// local variables\n    integer :: i\n    real(kind=8) :: d\n    d = (k-l)/(n-1)\n    z(1) = l\n    do i=2,n-1\n      z(i) = z(i-1) + d\n    end do\n    z(1) = l\n    z(n) = k\n    return\n  end subroutine linspace\n"}, {"instruction": "Create a Fortran subroutine named transpose2_d to transpose a 2D matrix and its derivative matrix. The subroutine takes 4 input parameters of type integer, integer, real(kind=8), and real(kind=8) and 2 output parameters of type real(kind=8) and real(kind=8).", "input": "", "output": "  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(in) :: mtxd(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    real(kind=8), intent(out) :: new_mtxd(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtxd(j, i) = mtxd(i, j)\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2_d\n"}, {"instruction": "Create a Fortran subroutine named transpose2 that takes 3 input parameters of type integer, integer, and real(kind=8) to represent the dimensions and elements of a matrix, and 1 output parameter of type real(kind=8) to store the transposed matrix. The subroutine transposes the input matrix and stores the result in the output parameter using nested do-loops.", "input": "", "output": "  subroutine transpose2(m, n, mtx, new_mtx)\n    implicit none\n    integer, intent(in) :: m, n\n    real(kind=8), intent(in) :: mtx(m, n)\n    real(kind=8), intent(out) :: new_mtx(n, m)\n    integer :: i, j\n    do i=1,m\n      do j=1,n\n        new_mtx(j, i) = mtx(i, j)\n      end do\n    end do\n  end subroutine transpose2\n"}, {"instruction": "Create a Fortran subroutine named matmul2_d to perform matrix multiplication. It accepts 7 input parameters of types integer, integer, integer, real(kind=8), real(kind=8), real(kind=8), and real(kind=8). It also has 2 output parameters of type real(kind=8).", "input": "", "output": "  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(in) :: ad(m, n), bd(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    real(kind=8), intent(out) :: cd(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    cd = 0.0_8\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2_d\n"}, {"instruction": "Create a Fortran subroutine named matmul2 to perform matrix multiplication. The subroutine takes 5 input parameters: m, n, p of type integer, and arrays a and b of type real(kind=8). It also has 1 output parameter, array c of type real(kind=8). The subroutine multiplies the matrices a and b and stores the result in array c.", "input": "", "output": "  subroutine matmul2(m, n, p, a, b, c)\n    implicit none\n    integer, intent(in) :: m, n, p\n    real(kind=8), intent(in) :: a(m, n), b(n, p)\n    real(kind=8), intent(out) :: c(m, p)\n    integer :: i, j, k\n    c(:, :) = 0.\n    do i=1,m\n      do j=1,p\n        do k=1,n\n          c(i, j) = c(i, j) + a(i, k)*b(k, j)\n        end do\n      end do\n    end do\n  end subroutine matmul2\n"}, {"instruction": "Create a Fortran subroutine named dot to calculate the dot product of two 3-dimensional real arrays. The subroutine takes 2 input parameters of type real(kind=8) and intent(in) and 1 output parameter of type real(kind=8) and intent(out).", "input": "", "output": "  subroutine dot(a, b, dot_prod)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: dot_prod\n    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  end subroutine dot\n"}, {"instruction": "Write a Fortran subroutine named cross to calculate the cross product of two 3D vectors. The subroutine takes 2 input parameters of type real(kind=8) and intent(in) and 1 output parameter of type real(kind=8) and intent(out). The number of input arguments is 2 and the test_data type is ['real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8)'].", "input": "", "output": "  subroutine cross(a, b, c)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(out) :: c(3)\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n  end subroutine cross\n"}, {"instruction": "Create a Fortran subroutine named mean_group to calculate the mean of groups based on the input data. The subroutine has 2 input parameters of type real(8) and integer, and 2 output parameters of type real(8) and integer.", "input": "", "output": "  subroutine mean_group(xn, mu, gk, numk)\n    implicit none\n\n    real(8),intent(in) :: xn(:, :)\n    real(8),intent(out) :: mu(:, :)\n    integer,intent(in) :: gk(:)\n    integer,intent(out) :: numk(:)\n    real(8) :: now\n    real(8) :: tmp\n    integer :: i\n    integer :: j\n\n    numk = 0\n    do j = 1, size(mu(1, :))\n       mu(:, j) = (/0d0, 0d0/)\n       do i = 1, size(xn(1, :))\n          if(gk(i) .eq. j) then\n             numk(j) = numk(j) + 1\n             mu(:, j) = mu(:, j) + xn(:, i)\n          end if\n       end do\n       mu(:, j) = mu(:, j)/numk(j)\n    end do\n\n  end subroutine mean_group\n"}, {"instruction": "Write a Fortran subroutine named initialdata to initialize the solution for a partial differential equation. The subroutine takes 4 input parameters of types integer(kind=4), real(kind=8) arrays of size nx, real(kind=8), and real(kind=8). It returns 2 output parameters of real(kind=8) arrays of size nx and real(kind=8) arrays of size nx.", "input": "", "output": "\tsubroutine initialdata(nx,dt,c,x,u,uold)\n\t!--------------------------------------------------------------------\n\t!\n\t!\n\t! purpose\n\t!\n\n\t! in 1 dimensions\n\t! u_{tt}-u_{xx}+u=es*u^3\n\t!\n\t! the boundary conditions are u(x=-lx*\\pi)=u(x=lx*\\pi), \n\t! the initial condition is u=sqrt(2)*sech((x(i)-c*t)/sqrt(1-c**2)\n\t!\n\t! input\n\t!\n\t! .. parameters ..\n\t!  nx\t= number of modes in x - power of 2 for fft\n        !  dt   = timestep\n        !  c    = wavespeed\n\t! .. vectors ..\n\t!  x\t= x locations\n\t!\n\t! output\n\t!\n\t! .. arrays ..\n\t!  u \t= initial solution\n\t!  uold = approximate solution at previous timestep\n\t!\n\t! local variables\n\t!\n\t! .. scalars ..\n\t!  i\t= loop counter in x direction\n\t!\n\t! references\n\t!\n\t! acknowledgements\n\t!\n\t! accuracy\n\t!\t\t\n\t! error indicators and warnings\n\t!\n\t! further comments\n\t! check that the initial iterate is consistent with the \n\t! boundary conditions for the domain specified\n\t!--------------------------------------------------------------------\n\t! external routines required\n\t! \n\t! external libraries required\n\t! openmp library\n\t!use omp_lib\t\t \t   \n\timplicit none\t\t\t\t\t \n\t! declare variables\n\tinteger(kind=4), intent(in)\t\t\t\t:: nx\n\treal(kind=8), dimension(1:nx), intent(in) \t\t:: x\n\treal(kind=8), dimension(1:nx), intent(out)\t\t:: u,uold\n\tinteger(kind=4)\t\t\t\t\t\t:: i\n        real(kind=8), intent(in)                                :: c,dt\n        real(kind=8)                                            :: t=0.0d0\n\tdo i=1,nx\n\t\tu(i)=sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2)))\n                !u(i)=sqrt(2.0d0)/cosh(x(i)+t)\n\tend do\n        t=-1.0d0*dt;\n\tdo i=1,nx\n\t\tuold(i)=sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2)))\n                !uold(i)=sqrt(2.0d0)/cosh(x(i)+t)\n\tend do\n\t\n\tend subroutine initialdata\n"}, {"instruction": "Create a Fortran subroutine named getlinestartendpts to calculate the endpoints of a line given the line direction and a distance. The subroutine takes 4 input parameters of type real*8: rpt (input line direction), vnx (input), vny (input), rdelta (input). It also returns 2 output parameters of type real*8: p1 (output points), p2 (output points).", "input": "", "output": "    subroutine getlinestartendpts(rpt,vnx,vny,rdelta,p1,p2)\n      implicit none\n      real*8 , intent(in)::vnx,vny,rdelta,rpt(2) !- input line direction\n      real*8 , intent(out)::p1(2),p2(2) !-output points\n      real*8 ::v1xv2 !- output intersection point\n      p1(1)=rpt(1)-rdelta*vnx\n      p1(2)=rpt(2)-rdelta*vny\n\n      p2(1)=rpt(1)+rdelta*vnx\n      p2(2)=rpt(2)+rdelta*vny\n\n    end subroutine getlinestartendpts\n"}, {"instruction": "Create a Fortran subroutine named getptonline that calculates the intersection point of a line and a point. The subroutine takes 3 input parameters of type real*8 and outputs 1 parameter of type real*8. The input parameters are rp1(2), rp2(2), and distratio, representing two points and a distance ratio. The output parameter is rptc(2), which represents the calculated intersection point.", "input": "", "output": "    subroutine getptonline(rp1,rp2,distratio,rptc)\n        implicit none\n        real*8 , intent(in)::rp1(2),rp2(2),distratio !- input line direction\n        real*8 , intent(out)::rptc(2) !-output points\n        real*8 ::v21(2) !- output intersection point\n\n        v21=rp2-rp1\n        rptc=rp1+distratio*v21\n\n    end subroutine getptonline\n"}, {"instruction": "Write a Fortran subroutine named eul2quat that converts Euler angles to a quaternion representation. The subroutine should have 1 input parameter of type real and intent(in), and 1 output parameter of type real and intent(out). The input parameter represents the Euler angles and the output parameter represents the quaternion. Use the given formula to compute the quaternion components based on the input Euler angles. Use the imperative tone and specify the number and type of input and output parameters clearly in the instructions.", "input": "", "output": "subroutine eul2quat(eul,q) \nreal, intent(in):: eul(3)\nreal, intent(out):: q(4)\nreal:: cy, sy, cp, sp, cr, sr\ncy = cos(eul(1)*.5);\nsy = sin(eul(1)*.5);\ncp = cos(eul(2)*.5);\nsp = sin(eul(2)*.5);\ncr = cos(eul(3)*.5);\nsr = sin(eul(3)*.5);\nq(1) = cy * cp * sr - sy * sp * cr\nq(2) = sy * cp * sr + cy * sp * cr\nq(3) = sy * cp * cr - cy * sp * sr\nq(4) = cy * cp * cr + sy * sp * sr\nend subroutine eul2quat\n"}, {"instruction": "Create a Fortran subroutine named quat2eul that takes in an array of 4 real numbers as input and outputs an array of 3 real numbers. The input array should represent a quaternion, and the output array should contain the corresponding Euler angles. Use the atan2 and asin functions to compute the Euler angles based on the quaternion input.", "input": "", "output": "subroutine quat2eul(q,eul) \nreal, intent(in):: q(4)\nreal, intent(out):: eul(3)\neul(1) = atan2(2.*(q(4)*q(3)+q(1)*q(2)), &\n\t1.-2.*(q(2)**2.+q(3)**2.))\neul(2) = asin(2.*(q(4)*q(2)-q(3)*q(1)))\neul(3) = atan2(2.*(q(4)*q(1)+q(2)*q(3)), &\n\t1.-2.*(q(1)**2.+q(2)**2.))\nend subroutine quat2eul\n"}, {"instruction": "Write a Fortran subroutine named mytest to transfer the first 8 bytes of a 16-byte character array into a real value. The number of input parameters is 1, of test_data type ['character(len=1), dimension(16)']. The number of output parameters is 1, of test_data type ['real(r8_)'].", "input": "", "output": "subroutine mytest(byte_array,val)\n  integer, parameter :: r8_ = selected_real_kind(15,307)  ! = real*8\n  character(len=1), dimension(16), intent(in) :: byte_array\n  real(r8_),intent(out) :: val\n  val = transfer(byte_array(1:8),val)    \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cholesky to perform the Cholesky decomposition on a symmetric positive-definite matrix. The subroutine takes 2 input parameters: an integer n and a real*8 matrix sst of size n x n. It returns 1 output parameter: a real*8 matrix s of size n x n.", "input": "", "output": "subroutine cholesky(sst, s, n)\n\n    integer, intent(in)  :: n\n    real*8, intent(in)   :: sst(n,n)\n    real*8, intent(out)   :: s(n,n)\n    real*8 :: d(n), l(n,n)\n\n    integer i,j,k\n\n    d = 0.d0\n    l = 0.d0\n    do i = 1,n\n        l(i,i)=1.\n        d(i)=sst(i,i)\n        do j=1,i-1\n            l(i,j)=sst(i,j);\n            do k=1,j-1\n                l(i,j)=l(i,j)-l(i,k)*l(j,k)*d(k)\n            end do\n            if (d(j).ne.0.) l(i,j)=l(i,j)/d(j)\n        end do\n        do k=1,i-1\n            d(i)=d(i)-l(i,k)*l(i,k)*d(k)\n        end do\n    end do\n    s=0.\n    do i=1,n\n        do j=1,i\n            if (d(j)>0.) s(i,j)=s(i,j)+l(i,j)*sqrt(d(j))\n        end do\n    end do\n\nend subroutine cholesky\n"}, {"instruction": "Create a Fortran subroutine named exp2reg that calculates the values of h and hder based on the input parameters r and damagepar. The number of input parameters is 2 with test_data type ['real*8', 'real*8'], and the number of output parameters is 2 with test_data type ['real*8 ', 'real*8 ']. The subroutine uses the features of Fortran and implements imperative logic to perform the calculations.", "input": "", "output": "subroutine exp2reg(h,hder,r,damagepar)\n\treal*8 , intent(out) :: h , hder\n\treal*8, intent(in) :: r , damagepar(:)\n\treal*8 :: r0, gf, lmu, beta\n\t\n\tr0 = damagepar(3)\n\tgf = damagepar(4)\n\tlmu = damagepar(5)\n\t\t\n\tbeta = 0.5*(-r0 + dsqrt((4.0d0*gf/lmu)-r0*r0))\n\twrite(0,*) beta\n\t\n\th = dexp(-(r- r0)/beta)*(1.0d0 - r/beta)\n\thder = - dexp(-(r-r0)/beta)*(2.0d0 - r/beta)/beta\n\t\n\t\t\n\twrite(0,*) r0,gf,lmu\n\t\n\tpause \n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named exp3dinf to calculate the value of h and hder based on the input parameters r and damagepar. The number of input parameters is 2, and their test_data type is ['real*8', 'real*8']. The number of output parameters is 2, and their test_data type is ['real*8 ', 'real*8 '].", "input": "", "output": "subroutine exp3dinf(h,hder,r,damagepar)\n\treal*8 , intent(out) :: h , hder\n\treal*8, intent(in) :: r , damagepar(:)\n\treal*8 :: r0, dinf, alpha, e\n\t\n\tr0 = damagepar(3)\n\talpha = damagepar(4)\n\tdinf = damagepar(5)\n\t\n\te = dexp(-alpha*(r- r0)/r0)\n\t\n\th = e*dinf*(1.0d0 - alpha*r/r0) + 1.0d0 - dinf\n\t\n\thder = - (alpha*e*dinf/r0)*(2.0d0 - alpha*r/r0)\n\t\n\twrite(0,*) r0,alpha, dinf\n\t\n\tpause \n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named compute_surface_tension to calculate the surface tension of a two-dimensional surface given surfactant concentration and specific parameters. The subroutine takes 3 input parameters of types integer, integer, and double precision array of dimension (nx, ny), and 1 output parameter of type double precision array of dimension (nx, ny).", "input": "", "output": "subroutine compute_surface_tension(nx, ny, surfactant, surface_tension)\n    implicit none\n    double precision :: beta, kappa, delta, mu, right_film_height\n    common /surfactant_config/ beta, kappa, delta, mu, right_film_height\n\n    integer, intent(in) :: nx, ny\n    double precision, dimension(nx, ny), intent(in) :: surfactant\n    double precision, dimension(nx, ny), intent(out) :: surface_tension\n\n    integer :: ix, iy\n\n    do iy = 1, ny\n        do ix = 1, nx\n            ! surface_tension(ix, iy) = (1.d0 + mu * surfactant(ix, iy))**(-3)\n            surface_tension(ix, iy) = 1.d0 - surfactant(ix, iy)\n        end do\n    end do\nend subroutine compute_surface_tension\n"}, {"instruction": "Create a Fortran subroutine named compute_surface_tension_d1 to calculate the first derivative of surface tension. The subroutine takes 3 input parameters: two integers (nx, ny) and a 2D array of double precision numbers (surfactant), and has 1 output parameter of a 2D array of double precision numbers (surface_tension_d1).", "input": "", "output": "subroutine compute_surface_tension_d1(nx, ny, surfactant, surface_tension_d1)\n    implicit none\n    double precision :: beta, kappa, delta, mu, right_film_height\n    common /surfactant_config/ beta, kappa, delta, mu, right_film_height\n\n    integer, intent(in) :: nx, ny\n    double precision, dimension(nx, ny), intent(in) :: surfactant\n    double precision, dimension(nx, ny), intent(out) :: surface_tension_d1\n\n    integer :: ix, iy\n\n    do iy = 1, ny\n        do ix = 1, nx\n            ! surface_tension_d1(ix, iy) = -3.d0 * mu * (1.d0 + mu * surfactant(ix, iy))**(-4)\n            surface_tension_d1(ix, iy) = -1.d0\n        end do\n    end do\nend subroutine compute_surface_tension_d1\n"}, {"instruction": "Create a Fortran subroutine named skipline that reads a specified number of lines from a formatted, sequentially accessed file in order to position the file marker. The subroutine has 2 input parameters of type integer and 1 output parameter of type character(len=*).", "input": "", "output": "subroutine skipline(iounit, record, lines)\n!  ========================================================================\n! |  reads a number of lines in a formatted, sequentially accessed file    |\n! |  to position the file marker.                                          |\n!  ========================================================================\n\n    implicit none\n\n    integer, intent(in) :: iounit\n    character(len=*), intent(out) :: record\n    integer, intent(in) :: lines\n    integer :: i, istat\n\n    do i = 1, lines\n      read(unit=iounit, fmt = \"(a)\", iostat=istat) record\n    end do\n\n    return\n\nend subroutine skipline\n"}, {"instruction": "Create a Fortran subroutine named t1 that takes an integer input parameter and returns an integer output parameter. The input parameter is declared with the intent(in) attribute, while the output parameter is declared with the intent(out) attribute. The function negates the input value and assigns it to the output parameter.", "input": "", "output": " subroutine t1(i,j) ! { dg-error \"redefine an intrinsic type assignment\" }\n   integer, intent(out)  :: i\n   integer, intent(in)  :: j\n   i=-j\n end subroutine t1\n"}, {"instruction": "Create a Fortran subroutine named readthirdpart_of_in1 to read and parse specific data from an input file. The subroutine takes 1 input parameter of type integer and returns 6 output parameters of type real*8, real*8, real*8, real*8, integer, and integer respectively. The subroutine reads certain lines from the input file referenced by fh_in1 and assigns values to itape, emin, emax, nband, sproj_limit, and eshift_iter based on the parsed data.", "input": "", "output": "subroutine readthirdpart_of_in1(itape,emin,emax,nband,sproj_limit,eshift_iter,fh_in1)\n  implicit none\n  real*8,  intent(out) :: emin, emax, sproj_limit, eshift_iter\n  integer, intent(out) :: itape, nband\n  integer, intent(in)  :: fh_in1\n  ! locals\n  character*80 :: line\n  integer      :: ios\n  real*8       :: test1, test2\n  \n  read(fh_in1,'(a)')line\n  nband=99999999\n  read(line(21:),*,iostat=ios) itape,emin,emax,nband  ! itape==klist unit ; emin==min_e ; emax==max_e ; nband==maximum number of bands\n  if (ios.ne.0) then\n     read(line(21:),*,iostat=ios) itape,emin,emax   ! maybe nbands is missing ; can be in two formats, either [int,real,real] or [int,real,real,it]\n  endif\n  read(fh_in1,'(a)',iostat=ios)line              ! maybe case.in1 contains also sproj_limit ?\n  if (ios.eq.0) then\n     read(line,*,iostat=ios) test1,test2   ! parse possible sproj_limit and eshift_iter\n     if (ios.ne.0) then                    ! did not find both numbers. maybe just one?\n        read(line,*,iostat=ios) test1\n        if (ios.ne.0) then\n           sproj_limit=1.0d-15\n           eshift_iter=0.d0\n        else\n           if(test1.gt.0.d0 .and. test1.lt.1.d-6) then\n              sproj_limit=test1\n              eshift_iter=0.d0\n           else if(abs(test1).lt.4.d0 .and. abs(test1).gt.1.d-6) then\n              sproj_limit=1.0d-15\n              eshift_iter=test1\n           else\n              sproj_limit=1.0d-15\n              eshift_iter=0.d0 \n           endif\n        endif\n     else\n        if(test1.gt.0.d0 .and. test1.lt.1.d-6) then\n           sproj_limit=test1\n           eshift_iter=0.d0\n           if(abs(test2).lt.4.d0 .and. abs(test2).gt.1.d-6) eshift_iter=test2\n        else if(abs(test1).lt.4.d0 .and. abs(test1).gt.1.d-6) then\n           sproj_limit=1.0d-15\n           eshift_iter=test1\n           if(test2.gt.0.d0 .and. test2.lt.1.d-6) sproj_limit=test2\n        else\n           sproj_limit=1.0d-15\n           eshift_iter=0.d0 \n        endif\n     endif\n  else\n     sproj_limit=1.0d-15   ! default value \n     eshift_iter=0.d0      ! default value\n  endif\n  !\nend subroutine readthirdpart_of_in1\n"}, {"instruction": "Write a Fortran subroutine named int_args_subr that takes three input integer arguments of kind 1, 2, and 4, and one output integer argument of kind 8. The subroutine calculates the sum of the input arguments and assigns the result to the output argument.", "input": "", "output": "subroutine int_args_subr(a,b,c,d)\n      integer(kind=1), intent(in) :: a\n      integer(kind=2), intent(in) :: b\n      integer(kind=4), intent(in) :: c\n      integer(kind=8), intent(out) :: d\n\n      d = a + b + c\n\nend subroutine int_args_subr\n"}, {"instruction": "Create a Fortran subroutine named inarea to determine whether a point is within the integral area. The subroutine takes 2 input parameters of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "subroutine inarea(x, y, h)\n    ! judge whether the dot is in the integral area\n    real(8), intent(in) :: x, y\n    real(8), intent(out) :: h\n\n    h = 1.d0\nend subroutine inarea\n"}, {"instruction": "Create a Fortran subroutine named \"maxi\" to calculate the maximum value of a given real(8) vector. It takes 2 input parameters: an integer representing the length of the input vector and a real(8) vector. It has 1 output parameter of type real(8) to deliver the result. Use the imperative tone to define the subroutine.", "input": "", "output": "subroutine maxi(vect, vect_len, mm)\n!simple example for computing the maximum of a given vector\n!dec$ attributes dllexport,c,reference,alias:'maxi_' :: maxi\n    !the previous line is necessary for r to find the external function under its name\n\n    implicit none\n    !-------------------------------------------------------------------------------\n    !input\n    integer, intent(in)                     :: vect_len !length of input vector (needs to be specified explicitly)\n    real(8), intent(in), dimension(vect_len):: vect !actual vector\n    !-------------------------------------------------------------------------------\n    ! output\n    real(8), intent(out):: mm  !for delivering the result\n    !-------------------------------------------------------------------------------\n\n    !-------------------------------------------------------------------------------\n    ! code\n        mm = maxval(vect) \n    !-------------------------------------------------------------------------------\nend subroutine maxi\n"}, {"instruction": "Create a Fortran subroutine named mockweightinitmethod. This subroutine takes 1 input parameter of type real and 1 output parameter of type real. The input parameter is passed by reference using the \"intent(in)\" attribute and is an array of real numbers. The output parameter is passed by reference using the \"intent(out)\" attribute. The function initializes the output parameter \"weight\" with the value of the first element of the input array \"args\".", "input": "", "output": "        subroutine mockweightinitmethod(weight, args)\n            real, intent(out) :: weight\n            real, intent(in) :: args(0:)\n        \n            weight = args(0)\n\n        end subroutine mockweightinitmethod\n"}, {"instruction": "Write a Fortran subroutine named fopen that takes a file name as input and returns a unit number as output. The input parameter is of type character(len=*) and the output parameter is of type integer. The fopen subroutine checks if the file with the given name exists, and if it does, opens it with a new unit number for appending. If the file does not exist, it opens a new file with a new unit number for writing.", "input": "", "output": "            subroutine fopen(fname,u)\n            implicit none\n            character(len=*), intent(in) :: fname\n            integer, intent(out)         :: u\n            logical                      :: yes\n            inquire(file=fname,exist=yes)\n            if( yes ) then\n               open(newunit=u,file=fname,status=\"old\",action=\"write\",access=\"append\")\n            else\n               open(newunit=u,file=fname,status=\"new\",action=\"write\")\n            end if\n            end subroutine\n"}, {"instruction": "Create a Fortran subroutine named swigtm_fout_bool to convert an integer to a logical value. The subroutine takes 1 input parameter of type integer(kind=c_int) and returns 1 output parameter of type logical.", "input": "", "output": "subroutine swigtm_fout_bool(imout, fout)\n  use, intrinsic :: iso_c_binding\n  integer(kind=c_int), intent(in) :: imout\n  logical, intent(out) :: fout\n  fout = (imout /= 0)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sys_countparameters to determine the number of parameters in a given string. The input parameter is a string with a length of characters, and the output parameter is an integer representing the number of parameters in the string.", "input": "", "output": "  subroutine sys_countparameters (sstring,ntokens)\n  \n!<description>\n  ! returns the number of parameters in sstring\n!</description>\n\n!<input>\n  ! a string with parameters, e.g. \"0.1 0.2 0.3\",...\n  character(len=*), intent(in) :: sstring\n!</input>\n\n!<output>\n  ! number of parameters in sstring\n  integer, intent(out) :: ntokens\n!</output>\n\n\n    integer :: slen, istart\n    \n    ! if the string length is =0, finish.\n    ntokens = 0\n    \n    slen = len_trim(sstring)\n    if (slen .eq. 0) return\n    \n    ! find all substrings  \n    istart = 1\n    \n    do\n      ! cancel if nothing left.\n      if (istart .gt. slen) exit\n\n      ! skip whitespaces.\n      do while (istart .le. slen)\n        if (sstring(istart:istart) .eq. \" \") then\n          istart = istart + 1\n        else\n          exit\n        end if\n      end do\n      \n      ! cancel if we reached the string end\n      if (istart .gt. slen) exit\n      \n      ! end of the string?\n      do while (istart .le. slen)\n        if (sstring(istart:istart) .ne. \" \") then\n          istart = istart + 1\n        else\n          exit\n        end if\n      end do\n      \n      ! one more\n      ntokens = ntokens + 1\n      \n    end do\n    \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named converttocapital to convert a given character string to all capital letters. The subroutine takes 1 input parameter of type character(*) and returns 1 output parameter of type character(*).", "input": "", "output": "  subroutine converttocapital(cbuf,ckey)\n    implicit none\n    character(*),intent(in)  :: cbuf\n    character(*),intent(out) :: ckey\n    integer :: j,k,n\n    n=len_trim(cbuf)\n    ckey=\"\"\n    do j=1,n\n      k=iachar( cbuf(j:j) )\n      if ( k >= 97 ) k=k-32\n      ckey(j:j) = achar(k)\n    end do\n  end subroutine converttocapital\n"}, {"instruction": "Create a Fortran subroutine named split_date_char that takes a character input representing a date and splits it into individual components such as century_year, month, day, hour, minute, and second. The subroutine should have 1 input parameter of type character(len=19) and 6 output parameters of type integer.", "input": "", "output": "   subroutine split_date_char ( date , century_year , month , day , hour , minute , second )\n     \n      implicit none\n   \n      !  input data.\n   \n      character(len=19) , intent(in) :: date \n   \n      !  output data.\n   \n      integer , intent(out) :: century_year , month , day , hour , minute , second\n      \n      read(date,fmt='(    i4.4)') century_year\n      read(date,fmt='( 5x,i2.2)') month\n      read(date,fmt='( 8x,i2.2)') day\n      read(date,fmt='(11x,i2.2)') hour\n      read(date,fmt='(14x,i2.2)') minute\n      read(date,fmt='(17x,i2.2)') second\n   \n   end subroutine split_date_char\n"}, {"instruction": "Create a Fortran subroutine named func to calculate the differential equations of a dynamical system. The subroutine takes 5 input parameters of types integer and double precision, and returns 3 output parameters of type double precision.", "input": "", "output": " subroutine func(ndim,u,icp,par,ijac,f,dfdu,dfdp) \n!---------- ---- \n\n   implicit none\n   integer, intent(in) :: ndim, ijac, icp(*)\n   double precision, intent(in) :: u(ndim), par(*)\n   double precision, intent(out) :: f(ndim), dfdu(ndim,*), dfdp(ndim,*)\n\n   double precision x,y,z,xp,yp,zp,rmu,t,de,dm,rmc,de3,dm3\n\n   x  = u(1)        \n   y  = u(2) \n   z  = u(3) \n   xp = u(4) \n   yp = u(5) \n   zp = u(6) \n\n   rmu = par(2)\n   t   = par(11)\n\n   de  = sqrt((x+rmu)**2 + y**2 + z**2)\n   dm  = sqrt( (x-1+rmu)**2 + y**2 + z**2 )\n   rmc = 1 - rmu\n   de3 = 1./de**3\n   dm3 = 1./dm**3\n\n   f(1)= xp\n   f(2)= yp\n   f(3)= zp\n   f(4)= 2*yp + x - rmc*de3*(x+rmu) - rmu*dm3*(x-1+rmu) \n   f(5)=-2*xp + y - rmc*de3*y       - rmu*dm3*y        \n   f(6)=          - rmc*de3*z       - rmu*dm3*z       \n\n   f = t*f\n\n end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named \"bcnd\" to solve a boundary value problem. The subroutine takes 7 input parameters of types integer and double precision and returns 2 output parameters of type double precision. The function computes boundary conditions for a specific problem involving celestial mechanics. The subroutine calculates the boundary conditions based on the input parameters and stores the results in the output parameters.", "input": "", "output": " subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc)\n!---------- ----\n\n   implicit none\n   integer, intent(in) :: ndim, icp(*), nbc, ijac\n   double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n   double precision, intent(out) :: fb(nbc), dbc(nbc,*)\n\n   double precision eps,x,y,z,xp,yp,zp,rmu,de,dm,u,e\n   integer m\n\n   eps=par(6)\n!  par(25:30) are ustart and par(31:36) are vstart\n   m=min(nbc,ndim)\n   fb(1:m) =  u0(1:m) - ( par(25:25+m-1) + eps*par(31:31+m-1) )\n\n   fb(ndim+1:ndim+3) = u1(1:3) - par(21:23)\n\n   x  = u1(1)\n   y  = u1(2)\n   z  = u1(3)\n   xp = u1(4)\n   yp = u1(5)\n   zp = u1(6)\n\n   rmu = par(2)\n\n   de = sqrt((x+rmu)**2 + y**2 + z**2)\n   dm = sqrt( (x-1+rmu)**2 + y**2 + z**2 )\n\n   u = (x**2 + y**2)/2 + (1-rmu)/de + rmu/dm\n   e = (xp**2 + yp**2 + zp**2)/2 - u - rmu*(1-rmu)/2\n   fb(ndim+4) = par(3) - e\n\n end subroutine bcnd\n"}, {"instruction": "Write a Fortran subroutine named \"phixyzp\" to calculate the coordinates (ixp, iyp, izp) based on the input parameters is, ic, and level, which are integers. The subroutine returns the integers ixp, iyp, and izp as output parameters. The input parameters are is, ic, and level, while the output parameters are ixp, iyp, and izp.", "input": "", "output": "subroutine phixyzp(is,ic,ixp,iyp,izp,level)\n\n      implicit none\n\n      integer,intent(in) :: is,ic,level\n      integer,intent(out) :: ixp,iyp,izp\n! *** input is, ic and level and return ixp,iyp,iz\n! *** s: state (or kind) of curve segment\n! *** c: index in each segment from 0 to 7\n      integer icp\n      integer icstate(0:7,0:11)\n! *** define the order in each ph state in level 0 position ***\n      data icstate(0:7,0)/0,1,2,3,4,5,6,7/ &\n        ,icstate(0:7,1)/0,3,4,7,6,5,2,1/ &\n        ,icstate(0:7,2)/0,7,6,1,2,5,4,3/ &\n        ,icstate(0:7,3)/2,3,0,1,6,7,4,5/ &\n        ,icstate(0:7,4)/4,3,2,5,6,1,0,7/ &\n        ,icstate(0:7,5)/6,5,2,1,0,3,4,7/ &\n        ,icstate(0:7,6)/4,7,0,3,2,1,6,5/ &\n        ,icstate(0:7,7)/6,7,4,5,2,3,0,1/ &\n        ,icstate(0:7,8)/2,5,4,3,0,7,6,1/ &\n        ,icstate(0:7,9)/6,1,0,7,4,3,2,5/ &\n        ,icstate(0:7,10)/2,1,6,5,4,7,0,3/ &\n        ,icstate(0:7,11)/4,5,6,7,0,1,2,3/\n      integer ixind(0:7),iyind(0:7),izind(0:7)\n! *** ixp,iyp,izp value as a function of icp\n      data ixind/0,0,1,1,1,1,0,0/ &\n       ,iyind/0,0,0,0,1,1,1,1/ &\n       ,izind/0,1,1,0,0,1,1,0/\n\n      if(level.eq.1) then\n!        is=0\n        icp=ic\n      else\n        icp=icstate(ic,is)\n      endif\n      ixp=ixind(icp)\n      iyp=iyind(icp)\n      izp=izind(icp)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named producttrace3_ that calculates the product trace of two complex matrices. The subroutine takes 3 input parameters of type complex*16, complex*16, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine producttrace3_(c, a,b,ndim)\n  ! c(i) = sum_j a(j,i)*b(j,i)\n  implicit none\n  complex*16, intent(out):: c(ndim)\n  complex*16, intent(in) :: a(ndim,ndim), b(ndim,ndim)\n  integer, intent(in)    :: ndim\n  ! locals                                                                                                                                                                                                                                                                                    \n  integer :: i, j\n  complex*16 :: res\n  c=0\n  do i=1,ndim\n     res=0\n     do j=1,ndim\n        res = res + a(j,i)*b(j,i)\n     enddo\n     c(i) = res\n  enddo\nend subroutine producttrace3_\n"}, {"instruction": "Create a Fortran subroutine named calculate_factors to calculate the prime factors of an integer input. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer array with dynamic allocation. Ensure that the subroutine does not go over the maximum length of 1000 for the output array.", "input": "", "output": "subroutine calculate_factors(n, fac)\ninteger, intent(in) :: n\ninteger, intent(out), allocatable :: fac(:)\n! todo: add checks that we don't go over max_length below:\ninteger, parameter :: max_length = 1000\ninteger :: fac_tmp(max_length)\ninteger, parameter :: ntryh(4) = [3, 4, 2, 5]\ninteger :: nl, nf, i, j, ntry, ib, nq, nr\nif (n == 1) then\n    allocate(fac(1))\n    fac(1) = 1\n    return\nend if\nnl = n\nnf = 0\nj = 0\nntry = 0\ndo while (nl /= 1)\n    j = j+1\n    if (j <= 4) then\n        ntry = ntryh(j)\n    else\n        ntry = ntry+2\n    end if\n    ! divide by ntry as many times as we can:\n    do while (nl /= 1)\n        nq = nl/ntry\n        nr = nl-ntry*nq\n        if (nr /= 0) exit\n        nf = nf+1\n        fac_tmp(nf) = ntry\n        nl = nq\n        if (ntry == 2 .and. nf > 1) then\n            do i = 2, nf\n                ib = nf-i+2\n                fac_tmp(ib) = fac_tmp(ib-1)\n            end do\n            fac_tmp(1) = 2\n        end if\n    end do\nend do\nallocate(fac(nf))\nfac = fac_tmp(:nf)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two real input parameters and returns a real output parameter to compute the sum of the input values. The number of input parameters is 2 with the test_data type ['real', 'real'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "subroutine add(a, b, c)\nreal, intent(in) :: a, b\nreal, intent(out) :: c\nc = a + b\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"swigtm_fin_bool\" that takes a logical input parameter and returns an integer output parameter. The input parameter should be of type logical, and the output parameter should be of type integer with kind c_int. The subroutine should convert the logical input to an integer output, where true is represented as 1 and false is represented as 0.", "input": "", "output": "subroutine swigtm_fin_bool(finp, iminp)\n  use, intrinsic :: iso_c_binding\n  logical, intent(in) :: finp\n  integer(kind=c_int), intent(out) :: iminp\n  if (finp .eqv. .true.) then\n    iminp = 1\n  else\n    iminp = 0\n  end if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named itemwise_calc to perform element-wise calculations on an input array and store the results in an output array. The number of input parameters is 1, with the test_data type ['real*8, dimension(:)'], and the number of output parameters is 1, with the test_data type ['real*8, dimension(size(input))']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine itemwise_calc(input, output)\n\n  implicit none\n\n  real*8, dimension(:), intent(in) :: input\n  real*8, dimension(size(input)), intent(out) :: output\n  integer :: n\n\n  !$omp parallel do\n  do n = 1, size(input)\n    output(n) = (input(n) - 3) * (input(n) - 2) * (input(n) - 1) * input(n) * (input(n) + 1) * (input(n) + 2) * (input(n) + 3)\n  end do\n  !$omp end parallel do\n\n  return\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named f_strcpy to copy a given character string to another, with the length of the destination string adjusted to match the source string. The subroutine takes 1 input argument of type character(len=*) and 1 output argument of type character(len=*).", "input": "", "output": "  pure subroutine f_strcpy(dest,src)\n    implicit none\n    character(len=*), intent(out) :: dest\n    character(len=*), intent(in) :: src\n    !local variables\n    integer :: i,n\n    !dest=repeat(' ',len(dest))\n    n=min(len(src),len(dest))\n    do i=1,n\n       dest(i:i)=src(i:i)\n    end do\n    do i=n+1,len(dest)\n       dest(i:i)=' '\n    end do\n\n  end subroutine f_strcpy\n"}, {"instruction": "Write a Fortran subroutine named convert_f_char_ptr that takes an array of characters as input and converts it to a single character string. The input parameter is of type character, dimension(*), and intent(in). The output parameter is of type character(len=*), and intent(out).", "input": "", "output": "  subroutine convert_f_char_ptr(src,dest)\n    implicit none\n    character, dimension(*), intent(in) :: src\n    character(len=*), intent(out) :: dest\n    !local variables\n    integer :: i\n    dest(1:len(dest))=' '\n    seek_and_copy: do i=1,len(dest)\n       if (src(i)==char(0)) exit seek_and_copy\n       dest(i:i)=src(i)\n    end do seek_and_copy\n  end subroutine convert_f_char_ptr\n"}, {"instruction": "Write a Fortran subroutine named ppnd7 that implements the algorithm for producing the normal deviate z corresponding to a given lower tail area of p. The subroutine uses one input parameter of type real (sp) and two output parameters of type integer and real (sp).", "input": "", "output": "subroutine ppnd7 (p, normal_dev, ifault)\r\n\r\n! algorithm as241  appl. statist. (1988) vol. 37, no. 3, 477- 484.\r\n\r\n! produces the normal deviate z corresponding to a given lower tail area of p;\r\n! z is accurate to about 1 part in 10**7.\r\n\r\n! the hash sums below are the sums of the mantissas of the coefficients.\r\n! they are included for use in checking transcription.\r\n\r\n! this elf90-compatible version by alan miller - 20 august 1996\r\n\n\r\nimplicit none\r\ninteger, parameter  :: sp = selected_real_kind(6, 30)\r\n\r\nreal (sp), intent(in)   :: p\r\ninteger, intent(out)    :: ifault\r\nreal (sp), intent(out)  :: normal_dev\r\n\r\n! local variables\r\n\r\nreal (sp) :: zero = 0.0, one = 1.0, half = 0.5, split1 = 0.425,  &\r\n             split2 = 5.0, const1 = 0.180625, const2 = 1.6, q, r\r\n\r\n! coefficients for p close to 0.5\r\n\r\nreal (sp) :: a0 = 3.3871327179e+00, a1 = 5.0434271938e+01, &\r\n                   a2 = 1.5929113202e+02, a3 = 5.9109374720e+01, &\r\n                   b1 = 1.7895169469e+01, b2 = 7.8757757664e+01, &\r\n                   b3 = 6.7187563600e+01\r\n! hash sum ab          32.3184577772\r\n\r\n! coefficients for p not close to 0, 0.5 or 1.\r\n\r\nreal (sp) :: c0 = 1.4234372777e+00, c1 = 2.7568153900e+00, &\r\n             c2 = 1.3067284816e+00, c3 = 1.7023821103e-01, &\r\n             d1 = 7.3700164250e-01, d2 = 1.2021132975e-01\r\n! hash sum cd    15.7614929821\r\n\r\n! coefficients for p near 0 or 1.\r\n\r\nreal (sp) :: e0 = 6.6579051150e+00, e1 = 3.0812263860e+00, &\r\n             e2 = 4.2868294337e-01, e3 = 1.7337203997e-02, &\r\n             f1 = 2.4197894225e-01, f2 = 1.2258202635e-02\r\n! hash sum ef    19.4052910204\r\n\r\nifault = 0\r\nq = p - half\r\nif (abs(q) <= split1) then\r\n  r = const1 - q * q\r\n  normal_dev = q * (((a3 * r + a2) * r + a1) * r + a0) / &\r\n               (((b3 * r + b2) * r + b1) * r + one)\r\n  return\r\nelse\r\n  if (q < zero) then\r\n    r = p\r\n  else\r\n    r = one - p\r\n  end if\r\n  if (r <= zero) then\r\n    ifault = 1\r\n    normal_dev = zero\r\n    return\r\n  end if\r\n  r = sqrt(-log(r))\r\n  if (r <= split2) then\r\n    r = r - const2\r\n    normal_dev = (((c3 * r + c2) * r + c1) * r + c0) / ((d2 * r + d1) * r + one)\r\n  else\r\n    r = r - split2\r\n    normal_dev = (((e3 * r + e2) * r + e1) * r + e0) / ((f2 * r + f1) * r + one)\r\n  end if\r\n  if (q < zero) normal_dev = - normal_dev\r\n  return\r\nend if\r\nreturn\r\nend subroutine ppnd7\r\n"}, {"instruction": "Create a Fortran subroutine named inverse to calculate the inverse of a 3x3 matrix. The subroutine takes 1 input parameter of type real (kind=8) and 1 output parameter of type real (kind=8), both representing 3x3 matrices. Use the imperative tone to implement the inverse calculation.", "input": "", "output": "subroutine inverse(input,output)\n\n  implicit none \n  real (kind=8), intent(in) :: input(3,3)\n  real (kind=8), intent(out) :: output(3,3)\n  real (kind=8) :: determinant\n   \n  ! calculate the inverse of a 3x3 matrix\n   \n  determinant = -input(1,3)*input(2,2)*input(3,1)+input(1,2)*input(2,3)*input(3,1)+input(1,3)*input(2,1)*input(3,2)-&\n  input(1,1)*input(2,3)*input(3,2)-input(1,2)*input(2,1)*input(3,3)+input(1,1)*input(2,2)*input(3,3)\n\n  output(1,1) = (-input(2,3)*input(3,2)+input(2,2)*input(3,3)) / determinant\n  output(1,2) = (+input(1,3)*input(3,2)-input(1,2)*input(3,3)) / determinant\n  output(1,3) = (-input(1,3)*input(2,2)+input(1,2)*input(2,3)) / determinant\n\n  output(2,1) = (+input(2,3)*input(3,1)-input(2,1)*input(3,3)) / determinant\n  output(2,2) = (-input(1,3)*input(3,1)+input(1,1)*input(3,3)) / determinant\n  output(2,3) = (+input(1,3)*input(2,1)-input(1,1)*input(2,3)) / determinant\n\n  output(3,1) = (-input(2,2)*input(3,1)+input(2,1)*input(3,2)) / determinant\n  output(3,2) = (+input(1,2)*input(3,1)-input(1,1)*input(3,2)) / determinant\n  output(3,3) = (-input(1,2)*input(2,1)+input(1,1)*input(2,2)) / determinant\n\nend subroutine inverse\n"}, {"instruction": "Create a Fortran subroutine named m44inv to compute the inverse of a 4x4 matrix. The subroutine takes one input parameter of type double precision, dimension(4,4) and returns one output parameter of type double precision, dimension(4,4).", "input": "", "output": "subroutine m44inv (a, ainv)\n! http://web.hku.hk/~gdli/usefulfiles/matrix/m44inv_f90.txt\n  implicit none\n\n  double precision, dimension(4,4), intent(in)  :: a\n  double precision, dimension(4,4), intent(out) :: ainv\n\n  double precision :: det\n  double precision, dimension(4,4) :: cofactor\n\n\n  det =  a(1,1)*(a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)- &\n         a(3,3)*a(4,2)))-a(1,2)*(a(2,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+ &\n         a(2,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1)))+a(1,3)*(a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)- &\n         a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))-a(1,4)*(a(2,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+ &\n         a(2,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(2,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1)))\n\n  cofactor(1,1) = a(2,2)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(2,3)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(2,4)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))\n  cofactor(1,2) = a(2,1)*(a(3,4)*a(4,3)-a(3,3)*a(4,4))+a(2,3)*(a(3,1)*a(4,4)-a(3,4)*a(4,1))+a(2,4)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))\n  cofactor(1,3) = a(2,1)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(2,2)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+a(2,4)*(a(3,1)*a(4,2)-a(3,2)*a(4,1))\n  cofactor(1,4) = a(2,1)*(a(3,3)*a(4,2)-a(3,2)*a(4,3))+a(2,2)*(a(3,1)*a(4,3)-a(3,3)*a(4,1))+a(2,3)*(a(3,2)*a(4,1)-a(3,1)*a(4,2))\n  cofactor(2,1) = a(1,2)*(a(3,4)*a(4,3)-a(3,3)*a(4,4))+a(1,3)*(a(3,2)*a(4,4)-a(3,4)*a(4,2))+a(1,4)*(a(3,3)*a(4,2)-a(3,2)*a(4,3))\n  cofactor(2,2) = a(1,1)*(a(3,3)*a(4,4)-a(3,4)*a(4,3))+a(1,3)*(a(3,4)*a(4,1)-a(3,1)*a(4,4))+a(1,4)*(a(3,1)*a(4,3)-a(3,3)*a(4,1))\n  cofactor(2,3) = a(1,1)*(a(3,4)*a(4,2)-a(3,2)*a(4,4))+a(1,2)*(a(3,1)*a(4,4)-a(3,4)*a(4,1))+a(1,4)*(a(3,2)*a(4,1)-a(3,1)*a(4,2))\n  cofactor(2,4) = a(1,1)*(a(3,2)*a(4,3)-a(3,3)*a(4,2))+a(1,2)*(a(3,3)*a(4,1)-a(3,1)*a(4,3))+a(1,3)*(a(3,1)*a(4,2)-a(3,2)*a(4,1))\n  cofactor(3,1) = a(1,2)*(a(2,3)*a(4,4)-a(2,4)*a(4,3))+a(1,3)*(a(2,4)*a(4,2)-a(2,2)*a(4,4))+a(1,4)*(a(2,2)*a(4,3)-a(2,3)*a(4,2))\n  cofactor(3,2) = a(1,1)*(a(2,4)*a(4,3)-a(2,3)*a(4,4))+a(1,3)*(a(2,1)*a(4,4)-a(2,4)*a(4,1))+a(1,4)*(a(2,3)*a(4,1)-a(2,1)*a(4,3))\n  cofactor(3,3) = a(1,1)*(a(2,2)*a(4,4)-a(2,4)*a(4,2))+a(1,2)*(a(2,4)*a(4,1)-a(2,1)*a(4,4))+a(1,4)*(a(2,1)*a(4,2)-a(2,2)*a(4,1))\n  cofactor(3,4) = a(1,1)*(a(2,3)*a(4,2)-a(2,2)*a(4,3))+a(1,2)*(a(2,1)*a(4,3)-a(2,3)*a(4,1))+a(1,3)*(a(2,2)*a(4,1)-a(2,1)*a(4,2))\n  cofactor(4,1) = a(1,2)*(a(2,4)*a(3,3)-a(2,3)*a(3,4))+a(1,3)*(a(2,2)*a(3,4)-a(2,4)*a(3,2))+a(1,4)*(a(2,3)*a(3,2)-a(2,2)*a(3,3))\n  cofactor(4,2) = a(1,1)*(a(2,3)*a(3,4)-a(2,4)*a(3,3))+a(1,3)*(a(2,4)*a(3,1)-a(2,1)*a(3,4))+a(1,4)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\n  cofactor(4,3) = a(1,1)*(a(2,4)*a(3,2)-a(2,2)*a(3,4))+a(1,2)*(a(2,1)*a(3,4)-a(2,4)*a(3,1))+a(1,4)*(a(2,2)*a(3,1)-a(2,1)*a(3,2))\n  cofactor(4,4) = a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))+a(1,2)*(a(2,3)*a(3,1)-a(2,1)*a(3,3))+a(1,3)*(a(2,1)*a(3,2)-a(2,2)*a(3,1))\n\n  ainv = transpose(cofactor) / det\n\n  return\n\n  end subroutine m44inv\n"}, {"instruction": "Create a Fortran subroutine named uncell to convert a 3x3 matrix representing a crystallographic unit cell into its corresponding cell parameters. The input parameter is a 3x3 matrix of real numbers, and the output parameter is an array of 6 real numbers representing the cell parameters.", "input": "", "output": " subroutine uncell(rv,cell_0)\n! ======================\n! gulp\n! ======================\n  implicit none\n  real,intent(out)   :: cell_0(6)\n  real,intent(in)    :: rv(3,3)\n  integer            :: i,j\n  real               :: temp(6)\n  real               :: radtodeg\n  real, parameter    :: pi=acos(-1.0)\n  radtodeg=180.0/pi\n  do i = 1,3\n    temp(i) = 0.0\n    do j = 1,3\n      temp(i) = temp(i) + rv(j,i)**2\n    enddo\n    temp(i) = sqrt(temp(i))\n  enddo\n  cell_0(1) = abs(temp(1))\n  cell_0(2) = abs(temp(2))\n  cell_0(3) = abs(temp(3))\n  do i = 1,3\n    temp(3+i) = 0.0\n  enddo\n  do j = 1,3\n    temp(4) = temp(4) + rv(j,2)*rv(j,3)\n    temp(5) = temp(5) + rv(j,1)*rv(j,3)\n    temp(6) = temp(6) + rv(j,1)*rv(j,2)\n  enddo\n  temp(4) = temp(4)/(temp(2)*temp(3))\n  temp(5) = temp(5)/(temp(1)*temp(3))\n  temp(6) = temp(6)/(temp(1)*temp(2))\n  cell_0(4) = radtodeg*acos(temp(4))\n  cell_0(5) = radtodeg*acos(temp(5))\n  cell_0(6) = radtodeg*acos(temp(6))\n  do i=4,6\n     if (abs(cell_0(i) - 90.0 ).lt.0.00001) cell_0(i) = 90.0\n     if (abs(cell_0(i) - 120.0).lt.0.00001) cell_0(i) = 120.0\n  enddo\n  return\n end subroutine uncell\n"}, {"instruction": "Create a Fortran subroutine named check_isnew to check if a target integer is new in the input integer array. The subroutine takes 3 input parameters of type integer: inlist, n, and tgt. It also has 1 output parameter of type logical: isnew. The subroutine sets isnew to .true. initially and then iterates through the inlist to check if tgt is present. If tgt is found in inlist, isnew is set to .false. and the loop exits.", "input": "", "output": "subroutine check_isnew( inlist, n, tgt, isnew )\n    integer, intent(in) :: inlist(:), n, tgt\n    logical, intent(out) :: isnew\n    integer :: nctr\n\n    isnew = .true.\n    do nctr = 1, n\n        if (inlist(nctr).eq.tgt) then\n            isnew = .false.\n            exit\n        end if\n    end do\nend subroutine check_isnew\n"}, {"instruction": "Create a Fortran subroutine named random3 that generates a vector of normal (gaussian) random numbers with a mean of 0 and variance of 1. The subroutine takes 2 input parameters of type integer, n_var and n_ens, and has 1 output parameter of type real(8), work1(n_var,n_ens).", "input": "", "output": "subroutine random3(work1,n_var,n_ens)\r\n! returns a vector of normal (gaussian) random numbers n(mean=0,variance=1)\r\n!\r\n  implicit none\r\n  integer             :: i,j\r\n  integer,intent(in)  :: n_var,n_ens\r\n  real(8),intent(out) :: work1(n_var,n_ens)\r\n  real(8)             :: work2(n_var,n_ens)\r\n  real(8),parameter   :: pi = 3.141592653589d0\r\n!\r\n  do j=1,n_ens\r\n    call random_number(work1(1:n_var,j))  ! uniform random number between 0 and 1\r\n    call random_number(work2(1:n_var,j))\r\n  enddo\r\n!\r\n! box-muller's method\r\n  do j=1,n_ens\r\n  do i=1,n_var\r\n    work1(i,j)= dsqrt(-2.d0*dlog(work1(i,j)))*dcos(2.d0*pi*work2(i,j))\r\n  enddo\r\n  enddo\r\n!\r\nend subroutine random3\r\n"}, {"instruction": "Write a Fortran subroutine named put_1d_to_2d to rearrange a 1D array into a 2D array. The input parameter is a 1D real(8) array, and the output parameter is a 2D real(8) array.", "input": "", "output": "  subroutine put_1d_to_2d( tau, xin )\n    implicit none\n    real(8),intent(out) ::  tau(:,:)\n    real(8),intent(in)  :: xin(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          tau(j,i) = xin(k)\n       end do\n    end do\n  end subroutine put_1d_to_2d\n"}, {"instruction": "Create a Fortran subroutine named put_2d_to_1d to flatten a 2D array into a 1D array. The input parameter is a 2D array of real(8) type, and the output parameter is a 1D array of real(8) type.", "input": "", "output": "  subroutine put_2d_to_1d( tau, xout )\n    implicit none\n    real(8),intent(in)  :: tau(:,:)\n    real(8),intent(out) :: xout(:)\n    integer :: j,k,i\n    k=0\n    do i=1,size(tau,2)\n       do j=1,size(tau,1)\n          k=k+1\n          xout(k) = tau(j,i)\n       end do\n    end do\n  end subroutine put_2d_to_1d\n"}, {"instruction": "Create a Fortran subroutine named constraint_func_distance to calculate the Euclidean distance between two 3D points and the difference between the calculated distance and a given reference distance. The subroutine takes 3 input parameters of type real(8) and returns 2 output parameters of type real(8). The input parameter types are ['real(8)', 'real(8)', 'real(8)'] and the output parameter types are ['real(8)', 'real(8)'].", "input": "", "output": "  subroutine constraint_func_distance( fd, d, d0, x, y )\n    implicit none\n    real(8),intent(in)  :: d0, x(3), y(3)\n    real(8),intent(out) :: d, fd\n    d  = sqrt( sum( (x-y)**2 ) )\n    fd = d - d0\n  end subroutine constraint_func_distance\n"}, {"instruction": "Create a Fortran subroutine named diff_func_distance that calculates the difference vector between two 3D points. The subroutine takes 2 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are r1 and r2, representing the 3D coordinates of two points. The output parameter is dr, which is an array of 6 real(8) values representing the components of the difference vector.", "input": "", "output": "  subroutine diff_func_distance( dr,r1,r2 )\n    implicit none\n    real(8),intent(out) :: dr(6)\n    real(8),intent(in) :: r1(3),r2(3)\n    real(8),parameter :: epsilon=1.d-12\n    real(8) :: r,x,y,z\n    x = r1(1) - r2(1)\n    y = r1(2) - r2(2)\n    z = r1(3) - r2(3)\n    r = sqrt( x*x + y*y + z*z )\n    if ( r < epsilon ) then\n       dr(1) = 0.0d0\n       dr(2) = 0.0d0\n       dr(3) = 0.0d0\n       dr(4) = 0.0d0\n       dr(5) = 0.0d0\n       dr(6) = 0.0d0\n    else\n       dr(1) =  x/r\n       dr(2) =  y/r\n       dr(3) =  z/r\n       dr(4) = -x/r\n       dr(5) = -y/r\n       dr(6) = -z/r\n    end if\n  end subroutine diff_func_distance\n"}, {"instruction": "Create a Fortran subroutine named rhs_eqns to calculate the right-hand side (r.h.s) of a system of ordinary differential equations. The subroutine will take 3 input parameters of type real(kind = 8) and 1 output parameter of type real(kind = 8).", "input": "", "output": "subroutine rhs_eqns(t, y0, rhs, gravity)\n\timplicit none\n\n\treal(kind = 8), intent(in) :: t, y0(4)\n\treal(kind = 8), intent(out) :: rhs(4)\n\treal(kind = 8) x, y, vx, vy\n\n\t! constants normalized\n\treal(kind = 8), intent(in) :: gravity\n\n\t! intialize vectors\n\tx = y0(1)\n\ty = y0(2)\n\tvx = y0(3)\n\tvy = y0(4)\n\n\t! r.h.s of x-position equations\n\trhs(1) = vx\n\n\t! r.h.s of y-position equations\n\trhs(2) = vy\n\n\t! r.h.s of x-velocity equations\n\trhs(3) = -gravity * x / (x**2 + y**2)**1.5d0\n\n\t! r.h.s of y-velocity equations\n\trhs(4) = -gravity * y / (x**2 + y**2)**1.5d0\nend subroutine rhs_eqns\n"}, {"instruction": "Create a Fortran subroutine named dlocate that takes in an array of double precision numbers, a single double precision number, and returns the index of the array where the given number should be inserted to maintain the ascending order. The number of input arguments is 2, with test_data types ['double precision, dimension(:)', 'double precision'], and the number of output arguments is 1 with a test_data type of ['integer'].", "input": "", "output": "      subroutine dlocate(xx,x,indx)\n      implicit none\n      double precision, dimension(:), intent(in) :: xx\n      double precision, intent(in) :: x\n      integer, intent(out) :: indx\n      integer :: n,jl,jm,ju\n      logical :: ascnd\n!      write(6,*) 'xx: ',xx,x,size(xx)\n      n=size(xx)\n      ascnd = (xx(n) >= xx(1))\n      jl=0\n      ju=n+1\n      do\n        if (ju-jl <= 1) exit\n        jm=(ju+jl)/2\n        if (ascnd .eqv. (x >= xx(jm))) then\n          jl=jm\n        else\n          ju=jm\n        end if\n      end do\n      if (x == xx(1)) then\n        indx=1\n      else if (x == xx(n)) then\n        indx=n-1\n      else\n        indx=jl\n      end if\n      end subroutine dlocate\n"}, {"instruction": "Create a Fortran subroutine named rmoi to calculate the total moment of inertia of a collection of atoms. The subroutine takes 4 input parameters: mass (real*8 array), xyz (real*8 2D array), atnum (integer array), natm (integer). It returns 1 output parameter: itot (real*8).", "input": "", "output": "subroutine rmoi(mass, xyz ,atnum , itot ,natm)\r\nimplicit none\r\nreal*8,intent(out) ::itot\r\nreal*8,intent(in) ::mass(:),xyz(:,:)\r\ninteger,intent(in) ::atnum(:) ,natm\r\nreal*8 :: tot, il, ir\r\ninteger ::iatm ,i\r\n\r\ntot=0\r\nil=0 \r\ndo iatm=1, natm\r\n    tot=(mass(iatm)*(xyz(iatm,1)**2+xyz(iatm,2)**2)+tot)\r\nend do\r\ndo i=1, natm \r\n    if (0/=atnum(i)) then\r\n        il=mass(atnum(i))*(xyz(atnum(i),1)**2+xyz(atnum(i),2)**2)+il\r\n    else \r\n        exit\r\n    end if\r\nend do\r\nir=tot-il\r\nitot=1/((1/il)+(1/ir))\r\n\r\nend subroutine rmoi\r\n"}, {"instruction": "Create a Fortran subroutine named str2int to convert a string to an integer and provide the status of the conversion. The subroutine has 1 input parameter of type character(len=*) and 2 output parameters of type integer.", "input": "", "output": "subroutine str2int(str, i, stat)\n    implicit none\n    ! arguments\n    character(len=*), intent(in) :: str\n    integer, intent(out)         :: i\n    integer, intent(out)         :: stat\n\n    read(str,*,iostat=stat) i\nend subroutine str2int\n"}, {"instruction": "Write a Fortran subroutine named ones_1d to initialize a one-dimensional array with ones. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type real(8), allocatable.", "input": "", "output": "  subroutine ones_1d(vec, n)\n    real(8), allocatable, intent(out) :: vec(:)\n    integer, intent(in) :: n\n    allocate(vec(n))\n    vec = 1.0d0\n  end subroutine ones_1d\n"}, {"instruction": "Write a Fortran subroutine named ones_2d that initializes a 2D array with ones. The subroutine takes 2 input parameters of type integer, and the test_data type is ['integer', 'integer']. It also has 1 output parameter of type real(8), allocatable, and the test_data type is ['real(8), allocatable'].", "input": "", "output": "  subroutine ones_2d(arr, m, n)\n    real(8), allocatable, intent(out) :: arr(:,:)\n    integer, intent(in) :: m, n\n    allocate(arr(m,n))\n    arr = 1.0d0\n  end subroutine ones_2d\n"}, {"instruction": "Create a Fortran subroutine named \"lnrf_frame_real\" to calculate the transformed velocities in a non-rotating frame from input parameters. The subroutine takes 6 input parameters of type real, dimension(:) and one output parameter of type real, dimension(size(r)). The subroutine also has 3 output parameters of type real, dimension(size(r)).", "input": "", "output": "        subroutine lnrf_frame_real(vr,vt,omega,r,a,th,vrl,vtl,vpl)\n        real, dimension(:), intent(in) :: vr,vt,omega,r,th\n        real, intent(in) :: a\n        real, dimension(size(r)), intent(out) :: vrl,vtl,vpl\n        real, dimension(size(r)) :: zero,d,ar,rho,enu,emu1, &\n         emu2,epsi,om,mu\n        zero=0d0\n        mu=cos(th)\n        d=r*r-2.*r+a*a\n        ar=(r*r+a*a)**2-a*a*d*(1.-mu*mu)\n        rho=r*r+a*a*mu*mu\n        enu=sqrt(d*rho/ar)\n        emu1=sqrt(rho/d)\n        emu2=sqrt(rho)\n        epsi=sqrt(1.-mu*mu)*sqrt(ar/rho)\n        om=2.*a*r/ar\n        vrl=emu1/enu*vr\n        vtl=emu2/enu*vt\n        vpl=epsi/enu*(omega-om)\n        vrl=merge(vrl,zero,d.gt.0d0)\n        vtl=merge(vtl,zero,d.gt.0d0)\n        vpl=merge(vpl,zero,d.gt.0d0)\n        end subroutine lnrf_frame_real\n"}, {"instruction": "Create a Fortran subroutine named fmkdke to calculate the stiffness matrices ke and kd based on given input matrices km, kp, and c, along with the parameter theta. The input parameters consist of 4 real(iwp) arrays: km, kp, c, and theta. The output parameters include 2 real(iwp) arrays: ke and kd.", "input": "", "output": "subroutine fmkdke(km,kp,c,ke,kd,theta)\n!\n\n! the 'elastic' stiffness km, fluid stiffness kp and coupling matrix c.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::km(:,:),kp(:,:),c(:,:),theta\n real(iwp),intent(out)::ke(:,:),kd(:,:)\n integer::ndof\n real::one=1.0_iwp\n ndof=size(km,1)\n ke(:ndof,:ndof)=theta*km\n ke(:ndof,ndof+1:)=theta*c\n ke(ndof+1:,:ndof)=theta*transpose(c)\n ke(ndof+1:,ndof+1:)=-theta**2*kp\n kd(:ndof,:ndof)=(theta-one)*km\n kd(:ndof,ndof+1:)=(theta-one)*c\n kd(ndof+1:,:ndof)=ke(ndof+1:,:ndof)\n kd(ndof+1:,ndof+1:)=theta*(one-theta)*kp\nreturn\nend subroutine fmkdke\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_qpw4p0 to calculate the global degrees of freedom of quadrilateral, piecewise linear p0 elements based on the input element indices and the number of vertices adjacent to each element. The subroutine takes 3 input parameters of type integer, dimension(:,:), integer, dimension(:), and integer, and 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "  subroutine dof_locglobunimult_qpw4p0(iverticesatelement, ielidx, idofglob, nvt)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be quadrilateral, piecewise linear\n  ! p0 elements.\n  ! a uniform grid is assumed, i.e. a grid completely discretised the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! an array with the number of vertices adjacent to each element of the\n  ! triangulation.\n  integer, dimension(:,:), intent(in) :: iverticesatelement\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n  ! total number of vertices\n  integer, intent(in) :: nvt\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s.\n      idofglob(1,i) = 4*(ielidx(i)-1)+1\n      idofglob(2,i) = 4*(ielidx(i)-1)+2\n      idofglob(3,i) = 4*(ielidx(i)-1)+3\n      idofglob(4,i) = 4*(ielidx(i)-1)+4\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_qpw4p1t to map the local degrees of freedom of quadrilateral, piecewise rotated linear nonconforming p1~ elements to their corresponding global degrees of freedom. The subroutine takes 3 input parameters of type ['integer, dimension(:,:)', 'integer, dimension(:)', 'integer'] and 1 output parameter of type ['integer, dimension(:,:)'].", "input": "", "output": "  subroutine dof_locglobunimult_qpw4p1t(iedgesatelement, ielidx, idofglob, nmt)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be quadrilateral, piecewise rotated\n  ! linear nonconforming p1~ elements.\n  ! a uniform grid is assumed, i.e. a grid completely discretised the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! an array with the number of edges adjacent on each element of the\n  ! triangulation.\n  integer, dimension(:,:), intent(in) :: iedgesatelement\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n  ! total number of edges\n  integer, intent(in) :: nmt\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s - which are simply the edge numbers.\n      idofglob(1:4,i) = iedgesatelement(1:4,ielidx(i))\n\n      ! plus 4 times the element, for the four inner edges\n      idofglob(5,i) = nmt + 4*(ielidx(i)-1) + 1\n      idofglob(6,i) = nmt + 4*(ielidx(i)-1) + 2\n      idofglob(7,i) = nmt + 4*(ielidx(i)-1) + 3\n      idofglob(8,i) = nmt + 4*(ielidx(i)-1) + 4\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dof_locglobunimult_dgq22d to calculate the global degree of freedom numbers for a list of element indices. The input parameter is an array of element indices of type integer and dimension (:), and the output parameter is a 2D array of global degree of freedom numbers of type integer and dimension (:,:).", "input": "", "output": "  subroutine dof_locglobunimult_dgq22d(ielidx, idofglob)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be the dg q2.\n  ! a uniform grid is assumed, i.e. a grid completely discretised by the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s. every element gives 9 dof`s which are\n      ! not coupled to any other element\n      idofglob(1,i) = 1+9*(ielidx(i)-1)\n      idofglob(2,i) = 2+9*(ielidx(i)-1)\n      idofglob(3,i) = 3+9*(ielidx(i)-1)\n      idofglob(4,i) = 4+9*(ielidx(i)-1)\n      idofglob(5,i) = 5+9*(ielidx(i)-1)\n      idofglob(6,i) = 6+9*(ielidx(i)-1)\n      idofglob(7,i) = 7+9*(ielidx(i)-1)\n      idofglob(8,i) = 8+9*(ielidx(i)-1)\n      idofglob(9,i) = 9+9*(ielidx(i)-1)\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named y_gauleg to compute the positions for function evaluations and weights using the Gauss-Legendre quadrature method. The subroutine takes 3 input parameters of type integer, real, and real, and returns 2 output parameters of type real.", "input": "", "output": "subroutine y_gauleg(x1,x2,x,w,n)\n!-------------------------------------------------------------------\ninteger, intent(in) ::  n    ! number of intervals\nreal, intent(in)    ::  x1   ! lower limit of integration interval\nreal, intent(in)    ::  x2   ! upper limit of integration interval\nreal, intent(out)   ::  x(n) ! positions for function evaluations\nreal, intent(out)   ::  w(n) ! weights\n!\n!-----------------------------------------------------------------------\ndouble precision eps\nparameter (eps=3.d-14)\ninteger i,j,m\ndouble precision p1,p2,p3,pp,xl,xm,z,z1\n!-----------------------------------------------------------------------\n      m=(n+1)/2\n      xm=0.5d0*(x2+x1)\n      xl=0.5d0*(x2-x1)\n      do 12 i=1,m\n        z=cos(3.141592654d0*(i-.25d0)/(n+.5d0))\n1       continue\n          p1=1.d0\n          p2=0.d0\n          do 11 j=1,n\n            p3=p2\n            p2=p1\n            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j\n11        continue\n          pp=n*(z*p1-p2)/(z*z-1.d0)\n          z1=z\n\n          z=z1-p1/pp\n        if(abs(z-z1).gt.eps)goto 1\n        x(i)=xm-xl*z\n        x(n+1-i)=xm+xl*z\n        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)\n        w(n+1-i)=w(i)\n12    continue\n!\nreturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named legp to compute the associated Legendre polynomials and their derivatives. The subroutine takes 2 input parameters of type double precision and integer, and returns 2 output parameters of type double precision. The input parameters are x (cosine of the angle) and n (degree of the polynomial), while the output parameters are pn (Legendre polynomial) and pp (derivative of the Legendre polynomial).", "input": "", "output": "        subroutine legp(n, x, pn, pp) ! standard 3 terms rec for pn and dpn / d cth\n        implicit none\n        double precision, intent(in) :: x  ! cos(tht)\n        integer, intent(in) :: n\n        double precision, intent(out) :: pn, pp\n        double precision p2, p3\n        integer j\n        pn = 1.0d0\n        p2 = 0.0d0\n        do j=1,n\n            p3 = p2\n            p2 = pn\n            pn = ((2*j-1)*x*p2-(j-1)*p3)/j\n        end do\n        pp = n*(x*pn-p2)/(x*x-1)\n        end subroutine legp\n"}, {"instruction": "Create a Fortran subroutine named \"anbncn_jacobi\" to calculate the 3-terms recursion relation coefficients for Jacobi polynomials. The subroutine should take 3 input parameters of type integer, double precision, and double precision, and return 3 output parameters of type double precision.", "input": "", "output": "    subroutine anbncn_jacobi(a, b, lmax, an, bn, cn)\n        !returns 3-terms recursion relation coefficients for jacobi polynomials\n        ! ~0.1ms at most even for high lmax\n        implicit none\n        integer, intent(in) :: lmax\n        double precision, intent(in) :: a, b\n        double precision apb\n        integer il\n        double precision, intent(out):: an(0:lmax-1), bn(0:lmax-1), cn(0:lmax-1)\n        apb = a + b\n        cn(0) = 0.\n        an(0) = (1 + apb) / 2 * (2 + apb) / (1 + apb)\n        do il = 1, lmax - 1\n            an(il) = (2 * il + 1 + apb) / (2 * (il + 1)) * (2 * il + 2 + apb) / (il + 1 + apb)\n            cn(il) = (il + a) * (il + b) / (il + 1) * (2 * il + 2 + apb) / (il + 1 + apb) / (2 * il + apb)\n        end do\n        if (abs(a) == abs(b)) then\n            bn = 0.d0\n        else\n            do il = 0, lmax - 1\n              bn(il) = 0.5d0 * apb * (a - b) * (2 * il + 1 + apb) / (il + 1) / (2 * il + apb) / (il + 1 + apb)\n            end do\n        end if\n    end subroutine anbncn_jacobi\n"}, {"instruction": "Create a Fortran subroutine named bi_linear_coef to calculate the coefficients of a bi-linear interpolation. The subroutine takes 2 input parameters of type real, ys and zs, and 1 output parameter of type real, dimension(0:1,0:1), coef.", "input": "", "output": "  subroutine bi_linear_coef(ys,zs, coef)\n\n    real, intent(in) :: ys,zs\n    real, dimension(0:1,0:1), intent(out) :: coef\n\n    coef(0,0) = (1.-ys)*(1.-zs)\n    coef(0,1) = (1.-ys)*zs\n    coef(1,0) = ys*(1.-zs)\n    coef(1,1) = ys*zs\n\n    return\n  end subroutine bi_linear_coef\n"}, {"instruction": "Write a Fortran subroutine named running_avg that calculates the running average and standard deviation of a series of input values. The subroutine takes 2 input arguments of type real and logical. It returns 3 output arguments of type real, real, and integer.", "input": "", "output": "subroutine running_avg(x, avg, std_dev, nvals, reset)\nimplicit none\n\nreal, intent(in) :: x\nreal, intent(out) :: avg, std_dev\ninteger, intent(out) :: nvals\nlogical, intent(in) :: reset\ninteger, save :: n\nreal, save :: sum_x, sum_x2\n\ncalc_sums: if(reset) then\n  n       = 0\n  sum_x   = 0.\n  sum_x2  = 0.\n  avg     = 0.\n  std_dev = 0.\n  nvals   = 0\nelse\n  n      = n + 1\n  sum_x  = sum_x + x\n  sum_x2 = sum_x2 + x**2\n\n  avg = sum_x / real(n)\n\n  if (n >= 2) then\n    std_dev = sqrt((real(n) * sum_x2 - sum_x**2) &\n            / (real(n) * real(n-1)))\n  else\n    std_dev = 0.\n  end if\n\n  nvals = n\nend if calc_sums\nend subroutine running_avg\n"}, {"instruction": "Create a Fortran subroutine named parallel_reduce_i to perform parallel reduction operation. The subroutine takes 4 input arguments of type integer, with the first two being mandatory and the last two optional. Additionally, there is 1 output argument of type integer.", "input": "", "output": "  subroutine parallel_reduce_i(r, a, op, proc, comm)\n    integer, intent(in) :: a\n    integer, intent(in) :: op\n    integer, intent(in), optional :: proc, comm\n    integer, intent(out) :: r\n    r = a\n  end subroutine parallel_reduce_i\n"}, {"instruction": "Create a Fortran subroutine named get_freq_len to read data from a file and assign values to the output variables. The subroutine takes 1 input parameter of type character*2500 and 2 output parameters of type integer. The input parameter represents the file path, while the output parameters represent the frequency length and g length.", "input": "", "output": "subroutine get_freq_len(path,freq_len,g_len)\n\n  implicit none\n  ! i/o\n  character*2500, intent(in) :: path\n  integer, intent(out) :: freq_len, g_len\n\n  g_len = 1\n  open(unit=10,file=trim(adjustl(path))//'/opacities/lines/corr_k/h2o/kappa_g_info.dat')\n  read(10,*) freq_len, g_len\n  close(10)\n  freq_len = freq_len-1\n  ! g_len = g_len-2 ! for old 32 grid\n\nend subroutine get_freq_len\n"}, {"instruction": "Create a Fortran subroutine named get_freq to read frequency data from a file and calculate the average frequencies. The subroutine takes 2 input parameters of type character*1500 and integer, and 2 output parameters of type double precision and double precision. The subroutine reads the frequency data from the specified file path, performs calculations, and stores the results in the output arrays.", "input": "", "output": "subroutine get_freq(path,freq_len,freq,freq_use_ck)\n\n  implicit none\n  ! i/o\n  character*1500, intent(in) :: path\n  integer, intent(in) :: freq_len\n  double precision, intent(out) :: freq(freq_len), &\n       freq_use_ck(freq_len+1)\n  ! internal\n  integer :: i_freq, freq_len_use_ck\n  double precision :: buffer\n\n  ! because freqs fot c-k are stored as borders!\n  freq_len_use_ck = freq_len + 1\n  open(unit=10,file=trim(adjustl(path))//'/opacities/lines/corr_k/h2o/kappa_g_info.dat')\n  read(10,*)\n  do i_freq = 1, freq_len_use_ck-2\n     read(10,*) buffer, freq_use_ck(i_freq)\n  end do\n  read(10,*) freq_use_ck(freq_len_use_ck), &\n       freq_use_ck(freq_len_use_ck-1)\n  close(10)\n  freq = (freq_use_ck(1:freq_len_use_ck-1)+freq_use_ck(2:freq_len_use_ck))/2d0\n\nend subroutine get_freq\n"}, {"instruction": "Write a Fortran subroutine named read_wlen to read a specified number of double precision values from a file. The subroutine takes 3 input parameters of type integer, integer, and character*4000, and 1 output parameter of type double precision. The subroutine uses the imperative tone.", "input": "", "output": "subroutine read_wlen(arr_min, arr_len, file_path, wlen)\n\n  implicit none\n  ! i/o\n  integer, intent(in)           :: arr_min\n  integer, intent(in)           :: arr_len\n  character*4000, intent(in)     :: file_path\n  double precision, intent(out) :: wlen(arr_len)\n\n  integer          :: i_lamb\n\n  open(unit=49, file=trim(adjustl(file_path)), &\n       form = 'unformatted', access='stream')\n\n  read(49, pos = (arr_min-1)*8+1) wlen(1)\n  do i_lamb = 2, arr_len\n     read(49) wlen(i_lamb)\n  end do\n\n  close(49)\n\nend subroutine read_wlen\n"}, {"instruction": "Create a Fortran subroutine named \"index\" to calculate the refractive index in a magnetized plasma using the Appleton-Hartree equation. The subroutine should have 4 input parameters of type real(kind=8) and arrays, and 1 output parameter of type real(kind=8) array. The calling sequence is \"call index(x,y,k,mode,mu)\".", "input": "", "output": "subroutine index(x,y,k,mode,mu)\n\t!------------------------------------\n\t! calculation of the mu refractive index in a magnetised\n\t! plasma according to the appleton-hartree equation\n\t! [haselgrove, 1960]\n\t! calling sequence: call index(x,y,th,mu)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!        th: (k,b) angle\n\t! outputs: mu\n\t!------------------------------------\n\treal(kind=8), dimension(:), intent(in)     \t :: x\n\treal(kind=8), dimension(:,:), intent(in)   \t :: y,k\n\tcharacter(len=1), intent(in), dimension(:) \t :: mode\n\treal(kind=8), dimension(:), intent(out)    \t :: mu\n\treal(kind=8), dimension(size(mu))          \t :: normy,normk,vdotk,a,b,c,b2mac\n\treal(kind=8), dimension(size(mu))\t\t   \t :: nmode\n\t\n\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\tnormk = sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\twhere (normy .eq.0.d0)\n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\ta = 1.d0-x-normy**2*(1.d0-x*vdotk**2/normk**2)\n\tb = 0.5d0*(-2.d0*(1.d0-x)*(1.d0-x-normy**2)+x*normy**2*(1.d0-vdotk**2/normk**2))\n\tc = (1.d0-x)*((1.d0-x)**2-normy**2)\n\t\n\tb2mac = b**2-a*c\n\t\n\t! when magnetic field -> 0 then b2mac -> 0 => numerical effects => when abs(b2mac) < 1.d-15 => b2mac=0\n\twhere (abs(b2mac) < 1.d-15)\n\t\tb2mac = 0.d0\n\tend where\n\t\n\tmu = sqrt((-b+nmode*sqrt(b2mac))/a)\n\t\n\t\n\t!write(*,*) b2mac, -b+sqrt(b2mac), mu\n\t\nend subroutine index\n"}, {"instruction": "Create a Fortran subroutine named calcp to calculate the p solution of a quadratic equation using the Haselgrove method. The subroutine takes 4 input parameters: y and k as real(kind=8) arrays, x as a real(kind=8) array, and mode as a character(len=1) array. The output parameter is p as a real(kind=8) array.", "input": "", "output": "subroutine calcp(x,y,k,mode,p)\n\t!------------------------------------\n\t! compute p solution of a*p^2+2b*p+c*=0\n\t! [haselgrove (1963)]\n\t! calling sequence: call calcp(x,y,k,p)\n\t! inputs: x: (fp/f)^2\n\t!         y: fc/f\n\t!         k: wave vector in cartesian coordinates.\n\t! outputs: p [haselgrove,63]\n\t!------------------------------------\n\treal(kind=8), dimension(:,:), intent(in)   :: y,k \n\treal(kind=8), dimension(:), intent(in)     :: x\n\tcharacter(len=1), intent(in), dimension(:) :: mode\n\treal(kind=8), dimension(:), intent(out)    :: p\n\treal(kind=8), dimension(size(p))           :: normy, vdotk,alpha,beta,gamma,nmode\n\t\n\t!------------------------------------------\n\t!mode o +/- mode x\n\t!p = (-beta +/- sqrt(beta**2-alpha*gamma))/alpha\n\n\t\n\twhere (mode .eq. 'x')\n\t\tnmode =-1.d0\n\telse where\n\t\tnmode = 1.d0\n\tend where\n\t\n\tnormy = sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\t\n\t!si b=0 (y=0) alors direction de y = verticale\n\twhere (normy .eq. 0.d0) \n\t\tvdotk(:) = maxval(k(:,:))\n\telsewhere\n\t\tvdotk(:) = (y(1,:)*k(1,:)+y(2,:)*k(2,:)+y(3,:)*k(3,:))/normy(:)\n\tend where\n\t\n\t!determination de p: py=(q+1) et q=(n^2-1)/x\n\talpha = 1.d0-x-normy**2\n\tbeta = normy*(1.+(vdotk)**2)/2.\n\tgamma = -(vdotk)**2\n\t\n\tp = (-beta+nmode*sqrt(beta**2-alpha*gamma))/alpha\n\t!p = gamma/(-beta -nmode*sqrt(beta**2-alpha*gamma))\n\nend subroutine calcp\n"}, {"instruction": "Create a Fortran subroutine named cal_mon_day to calculate the month and day from the given Julian day and year. \nThe subroutine takes 2 input parameters of type integer: julday and julyr. It returns 2 output parameters of type integer: jmonth and jday.", "input": "", "output": "    subroutine cal_mon_day(julday,julyr,jmonth,jday)\n    implicit none\n    integer, intent(in) :: julday,julyr\n    integer, intent(out) :: jmonth,jday\n    logical :: leap,not_find_date\n    integer :: month (12),itmpday,itmpmon,i\n    data month/31,28,31,30,31,30,31,31,30,31,30,31/\n    not_find_date = .true.\n    itmpday = julday\n    itmpmon = 1\n    leap=.false.\n    if(mod(julyr,4).eq.0)then\n      month(2)=29\n      leap=.true.\n    endif\n    i = 1\n    do while (not_find_date)\n       if(itmpday.gt.month(i))then\n         itmpday=itmpday-month(i)\n       else\n         jday=itmpday\n         jmonth=i\n         not_find_date = .false.\n       endif\n       i = i+1\n    end do\n    end subroutine cal_mon_day\n"}, {"instruction": "Create a Fortran subroutine named calc_gmin_subroutine to calculate gmin_gmins and gmin_nfracs based on the provided input parameters. The subroutine takes 3 input parameters of type real(kind=8), real(kind=8), and real(kind=8), dimension(:), and returns 2 output parameters of type real(kind=8), dimension(size(gmin_theta)) and real(kind=8), dimension(size(gmin_theta)).", "input": "", "output": "         subroutine calc_gmin_subroutine(gmin_p,gmin_theta,gmin_etas,gmin_gmins,gmin_nfracs)\n           real(kind=8), intent(in) :: gmin_p\n           real(kind=8) :: gmin_lin_cons, gmin_lin_coeff, gmin_lin_power\n           real(kind=8) :: gmin_inv_cons, gmin_inv_coeff, gmin_inv_power\n           real(kind=8) :: gmin_inv_sin_coeff, gmin_inv_sin_freq, gmin_inv_sin_delay\n           real(kind=8) :: gmin_lin_sin_coeff, gmin_lin_sin_freq, gmin_lin_sin_delay\n           real(kind=8), dimension(:), intent(in) :: gmin_theta, gmin_etas\n           real(kind=8), dimension(size(gmin_theta)) :: one\n           real(kind=8), dimension(size(gmin_theta)) :: gmin_linear_constant, gmin_inverse_constant, gmin_atheta\n           real(kind=8), dimension(size(gmin_theta)) :: gmin_raw_gmins\n           real(kind=8) :: acenter, anormal, azero, astwo\n!          intermediate variables\n           real(kind=8), dimension(size(gmin_theta)), intent(out) :: gmin_gmins, gmin_nfracs\n           one = 1d0\n           acenter = 0.5668090982352612\n           anormal = 0.52624783\n           azero = 3d0 / sqrt(2d0)\n           astwo = log(sqrt(2d0))\n\n\n           if(gmin_p==3.5) then\n              gmin_lin_power =0.276589155355\n              gmin_lin_coeff =-13.5593749125\n              gmin_lin_cons =16.0797900684\n              gmin_inv_power =6.53997654139\n              gmin_inv_coeff =151.597731214\n              gmin_inv_cons =0.722506578136\n              gmin_lin_sin_coeff =-0.143307918052\n              gmin_lin_sin_freq =-0.143307918052\n              gmin_lin_sin_delay =-0.143307918052\n              gmin_lin_sin_coeff =0.121815691108\n              gmin_lin_sin_freq =0.121815691108\n              gmin_lin_sin_delay =0.121815691108\n\n           else\n              gmin_lin_cons = 21.38307186\n              gmin_lin_coeff = -16.7811712\n              gmin_lin_power = 0.15128533\n!           gmin_inv_cons = 0.53189121\n!           gmin_inv_coeff = 0.91485025\n!           gmin_inv_power = 1.14368368\n!           gmin_inv_sin_coeff = .0111806594\n!           gmin_inv_sin_freq = -17.0100822\n!           gmin_inv_sin_delay = 4.03979965\n              gmin_inv_cons = 0.74798712\n              gmin_inv_coeff = 0.62609462\n              gmin_inv_power = 0.81567379\n              gmin_inv_sin_coeff = .00638946501\n              gmin_inv_sin_freq = -16.8034428\n              gmin_inv_sin_delay = 3.72208398\n              gmin_lin_sin_coeff = 0.\n              gmin_lin_sin_freq = 0.\n              gmin_lin_sin_delay = 0.\n           endif\n\n           gmin_linear_constant = gmin_lin_cons + gmin_lin_coeff*(gmin_etas**gmin_lin_power)&\n                + gmin_lin_sin_coeff*sin(gmin_etas*gmin_lin_sin_freq + gmin_lin_sin_delay)\n           gmin_inverse_constant = gmin_inv_cons + gmin_inv_coeff*(gmin_etas**gmin_inv_power)&\n                + gmin_inv_sin_coeff*sin(gmin_etas*gmin_inv_sin_freq + gmin_inv_sin_delay)\n\n\n           gmin_raw_gmins = gmin_theta* gmin_linear_constant + gmin_inverse_constant  \n           gmin_gmins = merge(gmin_raw_gmins,one,gmin_raw_gmins.ge.1d0)\n!i decided to combine a(theta) *theta into a single function atheta\n           gmin_atheta = gmin_theta * azero * exp(astwo * tanh(anormal*log(gmin_theta / acenter)))\n!azero is moving tanh down to the midpoint of 1.5 and 3.0\n!astwo is scaling the amplitude of tanh in loglog space to sqrt(2)\n!           gmin_atheta = -0.918344120 + 2.99892343*gmin_theta\n\n           gmin_nfracs = gmin_etas*gmin_atheta*((gmin_p - 2.)/(gmin_p - 1.)) * (gmin_gmins**(gmin_p - 2.))\n\n         end subroutine calc_gmin_subroutine\n"}, {"instruction": "Write a Fortran subroutine named interp that computes the interpolation of a complex value res based on the function values f, input value x, interpolation index ix, array of real values r, and the size of the array n. The subroutine takes 5 input parameters with test_data type ['complex*16', 'complex*16', 'real*8', 'integer', 'real*8', 'integer'] and has 1 output parameter with test_data type ['complex*16'].", "input": "", "output": "subroutine interp(res, f, x, ix, r, n)\n  implicit none\n  complex*16, intent(out) :: res\n  complex*16, intent(in)  :: f(n)\n  real*8, intent(in)  :: x\n  integer, intent(in) :: ix\n  real*8, intent(in)  :: r(n)\n  integer, intent(in) :: n\n  !f2py integer intent(hide), depend(r)      :: n = shape(r,0)\n  if (x.lt.r(ix) .or. x.gt.r(ix+1)) then\n     print *, 'tezave:', x, r(ix), r(ix+1), ix, n\n  endif\n  res = f(ix) + (f(ix+1)-f(ix))*(x-r(ix))/(r(ix+1)-r(ix))\n  return\nend subroutine interp\n"}, {"instruction": "Create a Fortran subroutine named \"ztable_integral\" to calculate the integral of a complex function. The subroutine has 3 input parameters of types integer, real, and real, and 1 output parameter of type complex. The subroutine uses explicit typing and the \"intent\" attribute to specify the purpose of each parameter. The subroutine performs numerical integration using a while loop and complex arithmetic to compute the integral value.\n\nThe subroutine's main purpose is to numerically integrate a complex function over a specified range. It uses input parameters to control the integration process and outputs the integrated complex value. The subroutine is written in Fortran and follows the imperative programming style.", "input": "", "output": "      subroutine ztable_integral(k,zeta,alpha,zfunc)\n!         use kinds\n         implicit none\n         integer     , intent(in)  :: k\n         real        , intent(in)  :: zeta,alpha\n         complex , intent(out) :: zfunc\n         integer  , parameter :: nperiod = 100  ! ... points per zeta-cycle\n         real, parameter :: beta = 4.5\n         logical      :: l_at_alpha_inv,l_alpha_positive\n         real    :: tol,twopi,zetascale\n         real    :: dt,halfdt,t,dtz\n         real    :: amplitude_factor,deriv_factor,test\n         complex :: eye,phase_factor\n!\n         twopi = 8.0*atan(1.0)\n         eye = cmplx(0.0,1.0)\n         tol = exp(-beta**2)\n         l_alpha_positive = alpha.gt.0.0\n         zetascale = sqrt(1.0+abs(alpha))\n         dt = twopi/sqrt(zeta**2+real(k+1)**2*zetascale**2)/nperiod\n         halfdt = 0.5*dt\n         zfunc = cmplx(0.0,0.0)\n         dtz = halfdt\n         t   = 0.0\n         l_at_alpha_inv = .false.\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol.and.(.not.l_at_alpha_inv))\n            t = t+dt\n            if (l_alpha_positive) l_at_alpha_inv = (t+halfdt).ge.(1.0/alpha)\n            if (l_at_alpha_inv) dtz = t+halfdt-1.0/alpha\n            if (l_at_alpha_inv) t   = 1.0/alpha-0.5*dtz\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            if (l_alpha_positive) amplitude_factor = amplitude_factor - &\n                                  exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                      -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n         if (.not.l_alpha_positive) return\n         dtz = halfdt\n         t   = 0.0\n         amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n         amplitude_factor = amplitude_factor - &\n                            exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                -0.0625/alpha**2)\n         deriv_factor = t**k\n         phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n         zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n         test = amplitude_factor*max(1.0,abs(deriv_factor))\n         dtz = dt\n         do while (test.gt.tol)\n            t = t-dt\n            amplitude_factor = exp(-0.25*t**2*(1.0-0.5*alpha*t)**2)\n            amplitude_factor = amplitude_factor - &\n                               exp(-0.0625*(1.0-alpha*t)**2*(3.0-alpha*t)**2/alpha**2 &\n                                   -0.0625/alpha**2)\n            deriv_factor = t**k\n            phase_factor = (eye**(k+1))*exp(eye*(zeta*t))\n            zfunc = zfunc + (dtz*amplitude_factor*deriv_factor)*phase_factor\n            test = amplitude_factor*max(1.0,abs(deriv_factor))\n         enddo\n!\n      end subroutine ztable_integral\n"}, {"instruction": "Create a Fortran subroutine named hourglass_nc to perform a specific computation involving arrays. The subroutine takes 5 input parameters of type real, integer, integer, integer, and integer, and returns 1 output parameter of type real. The subroutine contains parallel do loops to efficiently compute the values of the output array.", "input": "", "output": "subroutine hourglass_nc(df, f, iq, i, i1, i2)\nreal, intent(out) :: df(:,:,:)\nreal, intent(in) :: f(:,:,:,:)\ninteger, intent(in) :: iq, i, i1(3), i2(3)\ninteger :: j, k, l\n\nif (any(i1 > i2)) return\n\nselect case (iq)\ncase (1)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        + f(j,k+1,l+1,i) + f(j+1,k,l,i) &\n        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        - f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (2)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        + f(j+1,k,l+1,i) + f(j,k+1,l,i) &\n        - f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (3)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) + f(j+1,k+1,l+1,i) &\n        - f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        - f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        + f(j+1,k+1,l,i) + f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\ncase (4)\n    !$omp parallel do schedule(static) private(j, k, l)\n    do l = i1(3), i2(3)\n    do k = i1(2), i2(2)\n    do j = i1(1), i2(1)\n        df(j,k,l) = &\n          f(j,k,l,i) - f(j+1,k+1,l+1,i) &\n        + f(j,k+1,l+1,i) - f(j+1,k,l,i) &\n        + f(j+1,k,l+1,i) - f(j,k+1,l,i) &\n        + f(j+1,k+1,l,i) - f(j,k,l+1,i)\n    end do\n    end do\n    end do\n    !$omp end parallel do\nend select\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named arithmetic that takes two real numbers as input and returns their sum and product as output. The number of input arguments is 2 and the test_data type is [real,real]. The number of output arguments is 2 and the test_data type is [real,real].", "input": "", "output": "subroutine arithmetic(a,b,c,d)\n  \n  implicit none\n\n  ! declarations\n  real, intent(in) :: a,b\n  real, intent(out) :: c,d\n\n  c = a + b\n  d = a * b\n\nend subroutine arithmetic\n"}, {"instruction": "Write a Fortran subroutine named init_array to initialize an integer array with the squares of consecutive integers up to n. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer, allocatable, dimension(:)].", "input": "", "output": "    subroutine init_array(n, x)\n        implicit none\n        integer, intent(in) :: n\n        integer, allocatable, dimension(:), intent(out) :: x\n        integer :: status, i\n        allocate(x(n), stat=status)\n        if (status /= 0) then\n            print '(a)', '### error: can not allocate'\n            stop\n        end if\n        do i = 1, n\n            x(i) = i**2\n        end do\n    end subroutine init_array\n"}, {"instruction": "Create a Fortran subroutine named solve_band to solve a reduced unsymmetric band matrix. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The input parameters are pb and work, both of type real(iwp) array. The output parameter is loads, also of type real(iwp) array. The subroutine uses advanced linear algebra techniques to perform the matrix operations necessary to solve the given band matrix.", "input": "", "output": "subroutine solve_band(pb,work,loads)\n!\n\n! on the reduced unsymmetric band matrix pb.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::pb(:,:),work(:,:)\n real(iwp),intent(out)::loads(0:)\n integer::iwp1,n,n1,i,iv,l,iq,iv1\n real(iwp)::s,pt5=0.5_iwp\n iwp1=(ubound(pb,2)-1)/2+1\n n=ubound(pb,1)\n iq=2*iwp1-1  \n n1=n-1\n do iv=1,n1\n   i=int(work(iwp1,iv)+pt5)\n   if(i/=iv)then\n     s=loads(iv)\n     loads(iv)=loads(i)\n     loads(i)=s\n   end if\n   l=iv+iwp1-1\n   if(l>n)l=n\n   iv1=iv+1\n   do i=iv1,l\n     loads(i)=loads(i)-work(i-iv,iv)*loads(iv)\n   end do\n end do\n loads(n)=loads(n)/pb(n,1)\n iv=n-1\n do while(iv/=0)\n   s=loads(iv)\n   l=iq\n   if(iv+l-1>n)l=n-iv+1\n   do i=2,l\n     s=s-pb(iv,i)*loads(iv+i-1)\n     loads(iv)=s/pb(iv,1)\n   end do\n iv=iv-1\n end do\nreturn\nend subroutine solve_band\n"}, {"instruction": "Write a Fortran subroutine named findetacell to find the index of the cell in which a given departure point eta value lies. The subroutine takes 3 input parameters of type integer, real*8, and real*8, and 1 output parameter of type integer.", "input": "", "output": "subroutine findetacell(eta,etad,n,ix)\n\n! given eta values at cell top and bottom boundaries and a\n! departure point eta value etad, find the index of the\n! cell that etad lies in.\n!\n! if etad lies below the first cell then ix is set to 0\n! if etad lies above the top cell then ix is set to n\n\nimplicit none\n\ninteger, parameter :: maxkount = 10\ninteger, intent(in) :: n\nreal*8, intent(in) :: eta(n), etad\ninteger, intent(out) :: ix\ninteger :: ix1, ix2, ixnew, itkount\nlogical :: converged\nreal*8 :: eta1, eta2, rixnew\n\n\n! first guess is based on assuming eta is linear in level number.\n! a better first guess could be obtained by using more information about\n! how eta is distributed\n!e.g.    ix = floor(n*sqrt(etad/(eta(n) - eta(1))))\nix = floor(n*(etad/(eta(n) - eta(1))))\nix1 = min(max(ix,1),n-1)\nix2 = ix1 + 1\n\n! now iterate\nconverged = .false.\nitkount = 0\ndo while (.not. converged)\n  itkount = itkount + 1\n  eta1 = eta(ix1)\n  eta2 = eta(ix2)\n  rixnew = ((etad - eta1)*ix2 + (eta2 - etad)*ix1)/(eta2 - eta1)\n  ixnew = floor(rixnew)\n  if (ixnew == ix .or. itkount .ge. maxkount) converged = .true.\n  ix = ixnew\n  ix1 = min(max(ix,1),n-1)\n  ix2 = ix1 + 1\nenddo\n\nix = min(max(ix,0),n)\n\n\nend subroutine findetacell\n"}, {"instruction": "Create a Fortran subroutine named inject to inject data from a fine grid to a coarser grid. The subroutine takes 12 input parameters of types ['integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'logical', 'real*8', 'real*8', 'real*8'], and 1 output parameter of type ['real*8'].", "input": "", "output": "subroutine inject(ff,cf,lsplit,ixsplit,caf,cacinv,nx,ny,nz,nnxf,nnyf,nnxc,nnyc)\n\n! inject data from a fine grid to a coarser grid\n! using full area weighting for phi\n\nimplicit none\n\ninteger, intent(in) :: nx, ny, nz, nnxf, nnyf, nnxc, nnyc, ixsplit(ny)\nlogical, intent(in) :: lsplit(ny)\nreal*8, intent(in) :: ff(nz,nnxf,nnyf),caf(ny),cacinv(ny)\nreal*8, intent(out) :: cf(nz,nnxc,nnyc)\ninteger :: ic, i, ip, jc, j, jp, k\n\n\ndo jc = 1, nnyc\n\n  if (lsplit(jc)) then\n    ! merge cells in both latitude and longitude\n    j = ixsplit(jc)\n    jp = j + 1\n    do ic = 1, nnxc\n      ip = ic + ic\n      i = ip - 1\n      ! weight by area\n      do k = 1, nz\n        cf(k,ic,jc) = ((ff(k,i,j)  + ff(k,ip,j) )*caf(j)  &\n\t         +     (ff(k,i,jp) + ff(k,ip,jp))*caf(jp) &\n                                                         )*cacinv(jc)\n      enddo\n    enddo\n  else\n    ! merge cells only in longitude\n    j = ixsplit(jc)\n    do ic = 1, nnxc\n      ip = ic + ic\n      i = ip - 1\n      ! weight by area\n      do k = 1, nz\n        cf(k,ic,jc) = ((ff(k,i,j) + ff(k,ip,j))*caf(j)  &\n\t                                              )*cacinv(jc)\n      enddo\n    enddo\n  endif\n\nenddo\n\nend subroutine inject\n"}, {"instruction": "Write a Fortran subroutine named \"locatemax\" to determine the maximum absolute value and its indices within a 3D field. The subroutine should take 4 input parameters of type integer, integer, integer, and real*8, and 4 output parameters of type integer, integer, integer, and real*8.", "input": "", "output": "subroutine locatemax(q,qmax,ix,iy,iz,nx,ny,nz)\n\n! determine the value and indices of the max abs of field q(nz,nx,ny)\n\nimplicit none\n\ninteger, intent(in) :: nx, ny, nz\nreal*8, intent(in) :: q(nz,nx,ny)\ninteger, intent(out) :: ix, iy, iz\nreal*8, intent(out) :: qmax\ninteger :: i, j, k\nreal*8 :: aq\n\n\n! find and location of max abs\nqmax = 0.0d0\nix = 0\niy = 0\niz = 0\ndo j = 1, ny\n  do i = 1, nx\n    do k = 1, nz\n      aq = abs(q(k,i,j))\n      if (aq .gt. qmax) then\n        ix = i\n        iy = j\n        iz = k\n        qmax = aq\n      endif\n    enddo\n  enddo\nenddo\n\nend subroutine locatemax\n"}, {"instruction": "Write a Fortran subroutine named get_command_argument to retrieve a command-line argument. The subroutine takes 1 input argument of type integer and 2 output arguments of type integer and character(len = *), respectively. Upon execution, the subroutine sets the value of the character argument to an empty string and the status argument to 1.", "input": "", "output": "subroutine get_command_argument(count, value, status)\n  implicit none\n  integer, intent(in) :: count\n  integer, intent(out) :: status\n  character(len = *), intent(out) :: value\n\n  write(value, \"(a)\") \"\"\n  status = 1\nend subroutine get_command_argument\n"}, {"instruction": "Create a Fortran subroutine named byte_open that takes 4 input parameters of type integer, character(len=*), character(len=*), and character(len=*), and 1 output parameter of type logical. The subroutine opens a file with the specified parameters and sets the output parameter esito to true if the file opening is successful.", "input": "", "output": "subroutine byte_open(uni, filename, action, status, esito)\r\n  integer,          intent(in):: uni  !fortran unit#\r\n  character(len=*), intent(in):: filename\r\n  character(len=*), intent(in):: action\r\n  character(len=*), intent(in):: status\r\n  logical,         intent(out):: esito\r\n  integer:: ii\r\n!  open(unit=uni, file= filename, action= action, status=status, access=\"stream\", iostat=ii)         !##g95##\r\n  open(unit=uni, file= filename, action= action, status=status, access=\"transparent\", iostat=ii)   !##lf95##  \r\n  esito= (ii==0)\r\nend subroutine byte_open\r\n"}, {"instruction": "Create a Fortran subroutine named two_stream to compute the reflectance and transmittance in a single layer using the two stream approximation. It takes 3 input parameters of type real: tauint, gint, and w0int. It produces 2 output parameters of type real: ref and tra.", "input": "", "output": "  pure subroutine two_stream(tauint, gint, w0int, ref, tra) \n    real, intent(in)  :: tauint, gint, w0int\n    real, intent(out) :: ref, tra\n    !\n    ! compute reflectance in a single layer using the two stream approximation \n    !   the code itself is from lazaros oreopoulos via steve platnick \n    !\n    ! ------------------------\n    ! local variables \n    !   for delta eddington code\n    !   xmu, gamma3, and gamma4 only used for collimated beam approximation (i.e., beam=1)\n    integer, parameter :: beam = 2\n    real,    parameter :: xmu = 0.866, minconservativew0 = 0.9999999\n    real :: tau, w0, g, f, gamma1, gamma2, gamma3, gamma4, &\n            rh, a1, a2, rk, r1, r2, r3, r4, r5, t1, t2, t3, t4, t5, beta, e1, e2, ef1, ef2, den, th\n    !\n    ! compute reflectance and transmittance in a single layer using the two stream approximation \n    !   the code itself is from lazaros oreopoulos via steve platnick \n    !\n    f   = gint**2\n    tau = (1 - w0int * f) * tauint\n    w0  = (1 - f) * w0int / (1 - w0int * f)\n    g   = (gint - f) / (1 - f)\n\n    ! delta-eddington (joseph et al. 1976)\n    gamma1 =  (7 - w0* (4 + 3 * g)) / 4.0\n    gamma2 = -(1 - w0* (4 - 3 * g)) / 4.0\n    gamma3 =  (2 - 3*g*xmu) / 4.0\n    gamma4 =   1 - gamma3\n\n    if (w0int > minconservativew0) then\n      ! conservative scattering\n      if (beam == 1) then\n          rh = (gamma1*tau+(gamma3-gamma1*xmu)*(1-exp(-tau/xmu)))\n          ref = rh / (1 + gamma1 * tau)\n          tra = 1 - ref       \n      else if(beam == 2) then\n          ref = gamma1*tau/(1 + gamma1*tau)\n          tra = 1 - ref\n      endif\n    else\n      ! non-conservative scattering\n      a1 = gamma1 * gamma4 + gamma2 * gamma3\n      a2 = gamma1 * gamma3 + gamma2 * gamma4\n\n      rk = sqrt(gamma1**2 - gamma2**2)\n      \n      r1 = (1 - rk * xmu) * (a2 + rk * gamma3)\n      r2 = (1 + rk * xmu) * (a2 - rk * gamma3)\n      r3 = 2 * rk *(gamma3 - a2 * xmu)\n      r4 = (1 - (rk * xmu)**2) * (rk + gamma1)\n      r5 = (1 - (rk * xmu)**2) * (rk - gamma1)\n      \n      t1 = (1 + rk * xmu) * (a1 + rk * gamma4)\n      t2 = (1 - rk * xmu) * (a1 - rk * gamma4)\n      t3 = 2 * rk * (gamma4 + a1 * xmu)\n      t4 = r4\n      t5 = r5\n\n      beta = -r5 / r4         \n      \n      e1 = min(rk * tau, 500.) \n      e2 = min(tau / xmu, 500.) \n      \n      if (beam == 1) then\n         den = r4 * exp(e1) + r5 * exp(-e1)\n         ref  = w0*(r1*exp(e1)-r2*exp(-e1)-r3*exp(-e2))/den\n         den = t4 * exp(e1) + t5 * exp(-e1)\n         th  = exp(-e2)\n         tra = th-th*w0*(t1*exp(e1)-t2*exp(-e1)-t3*exp(e2))/den\n      elseif (beam == 2) then\n         ef1 = exp(-e1)\n         ef2 = exp(-2*e1)\n         ref = (gamma2*(1-ef2))/((rk+gamma1)*(1-beta*ef2))\n         tra = (2*rk*ef1)/((rk+gamma1)*(1-beta*ef2))\n      endif\n    end if\n  end subroutine two_stream\n"}, {"instruction": "Create a Fortran subroutine named adding_doubling to calculate the total reflectance and transmittance values using the adding/doubling formulas based on the input layer values. The subroutine takes 2 input parameters of type real, dimension(:), and returns 2 output parameters of type real.", "input": "", "output": "\tpure subroutine adding_doubling (refl, tran, refl_tot, tran_tot)      \n      real,    dimension(:), intent(in)  :: refl,     tran\n      real,                  intent(out) :: refl_tot, tran_tot\n\t  !\n\t  ! use adding/doubling formulas to compute total reflectance and transmittance from layer values\n\t  !\n\t  \n\t  integer :: i\n      real, dimension(size(refl)) :: refl_cumulative, tran_cumulative\n      \n      refl_cumulative(1) = refl(1); tran_cumulative(1) = tran(1)\t\n      \n      do i=2, size(refl)\n          ! place (add) previous combined layer(s) reflectance on top of layer i, w/black surface (or ignoring surface):\n          refl_cumulative(i) = refl_cumulative(i-1) + refl(i)*(tran_cumulative(i-1)**2)/(1 - refl_cumulative(i-1) * refl(i))\n          tran_cumulative(i) = (tran_cumulative(i-1)*tran(i)) / (1 - refl_cumulative(i-1) * refl(i))\n      end do\n      \n      refl_tot = refl_cumulative(size(refl))\n      tran_tot = tran_cumulative(size(refl))\n\n\tend subroutine adding_doubling\n"}, {"instruction": "Create a Fortran subroutine named errorcalc that calculates the L2 norm of the error for the solution of the nonlinear Klein-Gordon equation in 1 dimension. The subroutine takes 6 input parameters of types: integer(kind=4), integer(kind=4), real(kind=8) array, complex(kind=8) array, real(kind=8), and real(kind=8). It returns 1 output parameter of type real(kind=8).", "input": "", "output": "        subroutine errorcalc(nt,nx,dt,c,x,u,err)\n        !--------------------------------------------------------------------\n        !\n        !\n        ! purpose\n        !\n\n        ! solution\n        ! of the nonlinear klein-gordon equation in 1 dimensions\n        ! u_{tt}-u_{xx}+u=es*u^3+\n        !\n        ! the boundary conditions are u(x=-lx*\\pi)=u(x=lx*\\pi), \n        ! the initial condition is\n        ! u=sqrt(2)*sech((x(i)-c*t)/sqrt(1-c**2)\n        !\n        ! input\n        !\n        ! .. parameters ..\n        !  nx   = number of modes in x - power of 2 for fft\n        !  nt   = number of timesteps taken\n        !  dt   = timestep\n        !  c    = wavespeed\n        ! .. vectors ..\n        !  x    = x locations\n        !  u    = solution at current timestep\n        !\n        ! output\n        !\n        ! .. l2 norm of error ..\n        !\n        ! local variables\n        !\n        ! .. scalars ..\n        !  i    = loop counter in x direction\n        !\n        ! references\n        !\n        ! acknowledgements\n        !\n        ! accuracy\n        !               \n        ! error indicators and warnings\n        !\n        ! further comments\n        ! check that the initial iterate is consistent with the \n        ! boundary conditions for the domain specified\n        !--------------------------------------------------------------------\n        ! external routines required\n        ! \n        ! external libraries required\n        ! openmp library\n        implicit none                                    \n        ! declare variables\n        integer(kind=4), intent(in)                             :: nx,nt\n        real(kind=8), dimension(1:nx), intent(in)               :: x\n        complex(kind=8), dimension(1:nx), intent(in)            :: u\n        integer(kind=4)                                         :: i\n        real(kind=8), intent(in)                                :: c,dt\n        real(kind=8), intent(out)                               :: err\n        real(kind=8)                                            :: t\n        t=dble(nt)*dt\n        err=0.0d0\n        do i=1,nx\n          err=err+&\n          (u(i)-sqrt(2.0d0)/(cosh((x(i)-c*t)/sqrt(1.0d0-c**2))))**2\n        !        err=err+&\n        !        (u(i)-sqrt(2.0d0)/cosh(x(i)+t))**2\n        end do\n        print *,'the final l2 error is ',sqrt(err/dble(nx))\n        end subroutine errorcalc\n"}, {"instruction": "Create a Fortran subroutine named matvec to perform matrix-vector multiplication. The subroutine takes 4 input parameters: size1 (integer), size2 (integer), a (real, 2D array of size size1 x size2), and b (real, 1D array of size size2). It also has 1 output parameter: c (real, 1D array of size size1). The subroutine computes the matrix-vector product c = a * b, where a is a matrix of size size1 x size2 and b is a vector of size size2. Use the imperative tone to write the instructions.", "input": "", "output": "subroutine matvec(size1,size2,a,b,c)\r\n  implicit none\r\n  integer,                      intent(in)  :: size1,size2\r\n  real, dimension(size1,size2), intent(in)  :: a\r\n  real, dimension(size2),       intent(in)  :: b\r\n  real, dimension(size1),       intent(out) :: c\r\n  integer                                   :: i,j,k\r\n\r\n  c=0.\r\n  do j=1,size2\r\n\r\n!dir$ if defined(aligned)\r\n!dir$ vector aligned\r\n!dir$ end if\r\n     do i=1,size1\r\n        c(i) = c(i) + a(i,j) * b(j)\r\n     enddo\r\n  enddo\r\n\r\nend subroutine matvec\r\n"}, {"instruction": "Create a Fortran subroutine named \"gout_0layer_sub\" with 11 input parameters and 2 output parameters. The input parameters should consist of 3 integers, 6 real(8) numbers, and 2 complex(8) numbers. The output parameters should be a complex(8) number and an integer. The subroutine performs a specific calculation related to the given input parameters.", "input": "", "output": "  subroutine gout_0layer_sub(nmode,k0,kx0,ky0,epsout,nout,kout,l,a,epsm,km,gout,maxn_out)\n    implicit none\n\tinteger,    intent(in) :: nmode\n\treal(8),    intent(in) :: k0\n\treal(8),    intent(in) :: kx0\n\treal(8),    intent(in) :: ky0\n\tcomplex(8), intent(in) :: epsout\n\tcomplex(8), intent(in) :: nout\n\tcomplex(8), intent(in) :: kout \n\treal(8),    intent(in) :: l\n\treal(8),    intent(in) :: a\n\tcomplex(8), intent(in) :: epsm \n\tcomplex(8), intent(in) :: km \n\tcomplex(8), intent(out) :: gout\n\tinteger,    intent(out) :: maxn_out\n  end subroutine gout_0layer_sub \n"}, {"instruction": "Write a Fortran subroutine named generate that takes an integer input parameter and produces a string output. The input parameter is of type integer, and the output parameter is of type character with variable length. The generate subroutine generates a string of square brackets based on random numbers, with the length of the string determined by the input integer.", "input": "", "output": "  subroutine generate(n, s)\n    implicit none\n    integer, intent(in) :: n\n    character(len=*), intent(out) :: s\n    integer :: l, r, i\n    real, dimension(2*n) :: harvest\n    character :: c\n    i = 1\n    l = 0\n    r = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((l < n) .and. (r < n))\n       if (harvest(i) < 0.5) then\n          l = l+1\n          s(i:i) = '['\n       else\n          r = r+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', l < n)\n    do while (i <= 2*n)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\n"}, {"instruction": "Provide a Fortran subroutine called getargreal to retrieve a real*8 value from the command line based on a given tag. The subroutine has 1 input parameter of type character(len=*) and 1 output parameter of type real*8.", "input": "", "output": "    subroutine getargreal(tag,var)\n      character(len=*), intent(in) :: tag\n      character(len=10) :: temptag\n      real*8, intent(out)          :: var\n      integer :: i\n      integer :: narg\n      narg=command_argument_count()\n\n      do i=1,narg\n        call get_command_argument(i,temptag)\n        if(trim(tag).eq.trim(temptag)) then\n          call get_command_argument(i+1,temptag)\n          read(temptag,'(f32.0)') var\n          exit\n        endif\n      end do\n  end subroutine getargreal\n"}, {"instruction": "Create a Fortran subroutine named maxval_i to find the maximum value in an array of integers. The subroutine takes 2 input parameters: an integer and an integer array of variable size. It returns 2 output parameters: an integer representing the maximum value, and an optional integer representing the position of the maximum value in the array.", "input": "", "output": "  subroutine maxval_i(array, nvals, value_max, pos_maxval)\n  implicit none\n  integer, intent(in) :: nvals\n  integer, intent(in), dimension(nvals) :: array\n  integer, intent(out) :: value_max\n  integer, intent(out), optional :: pos_maxval\n  integer :: i\n  integer :: pos_max\n  value_max = array(1)\n  pos_max = 1\n  do i = 2, nvals\n    if (array(i) > value_max) then\n      value_max = array(i)\n      pos_max = i\n    end if\n  end do\n  if (present(pos_maxval)) then\n    pos_maxval = pos_max\n  end if\n  end subroutine maxval_i\n"}, {"instruction": "Write a Fortran subroutine named \"times2boo\" that takes in a single input argument of any type and returns two output arguments, one of type integer and the other of type real. The subroutine should double the input value and assign the result to the respective output argument based on the type of the input. Use the \"class(*), intent(in), target\" declaration for the input argument.", "input": "", "output": "  subroutine times2boo(val, resi, resr)\n    class(*), intent(in), target :: val\n    integer, intent(out) :: resi\n    real, intent(out) :: resr\n\n    select type(val)\n    type is (integer)\n       resi = val*2\n    type is (real)\n       resr = val*2.0\n    end select\n  end subroutine times2boo\n"}, {"instruction": "Create a Fortran subroutine named calc_phig_sub to calculate the value of phig based on the input parameters nr, dr, phi, and g. The input parameters consist of an integer (nr), two double precision real numbers (dr, g), and an array of double precision real numbers (phi). The output parameter is a double precision real number (phig).", "input": "", "output": "  subroutine calc_phig_sub( nr, dr, phi, g, phig )\n    implicit none\n    integer,intent(in) :: nr\n    real(8),intent(in) :: dr, phi(nr), g\n    real(8),intent(out) :: phig\n    integer :: i,ig\n    real(8) :: r,sum0,pi4\n\n    pi4 = 4.0d0*acos(-1.0d0)\n\n    if ( g <= 1.d-9 ) then\n\n       sum0=0.0d0\n       do i=1,nr\n          r = i*dr\n          sum0 = sum0 + r*r*phi(i)\n       end do\n       phig=pi4*sum0*dr\n\n    else\n\n       sum0=0.0d0\n       do i=1,nr\n          r = i*dr\n          sum0 = sum0 + r*phi(i)*sin(g*r)\n       end do\n       phig=pi4/g*sum0*dr\n\n    end if\n\n  end subroutine calc_phig_sub\n"}, {"instruction": "Create a Fortran subroutine named calc_edx_lda to calculate the exchange-correlation energy and potential for a given density using the local density approximation method. The subroutine takes 2 input parameters: an integer nn and an array of real(8) values rho with length nn. It also has 2 optional output parameters: arrays of real(8) values edx_lda and vdx_lda, both with length nn.", "input": "", "output": "  subroutine calc_edx_lda( nn, rho, edx_lda, vdx_lda )\n    implicit none\n    integer,intent(in)  :: nn\n    real(8),intent(in)  :: rho(nn)\n    real(8),optional,intent(out) :: edx_lda(nn)\n    real(8),optional,intent(out) :: vdx_lda(nn)\n    real(8) :: onethr, twothr, thrfou, thrpi, pi, factor\n    integer :: s\n\n    pi     = acos(-1.0d0)\n    onethr = 1.0d0/3.0d0\n    twothr = 2.0d0/3.0d0\n    thrfou = 3.0d0/4.0d0\n    thrpi  = 3.0d0/pi\n\n    factor = 1.0d0\n    if ( nn == 2 ) factor = 2.0d0**onethr\n\n    if ( present(edx_lda) ) then\n       do s=1,nn\n          edx_lda(s) = -factor*thrfou*( thrpi*rho(s) )**onethr\n       end do\n    end if\n\n    if ( present(vdx_lda) ) then\n       do s=1,nn\n          if ( rho(s) > 0.0d0 ) then\n             vdx_lda(s) = -pi*thrfou/(3.0d0*pi*pi*rho(s))**twothr\n          else\n             vdx_lda(s)=0.0d0\n          end if\n       end do\n    end if\n\n  end subroutine calc_edx_lda\n"}, {"instruction": "Write a Fortran subroutine named tw_rate that calculates the twist rates for blade stations based on the twist distribution and station locations. The subroutine has 3 input parameters of type integer, real(dbp) array of dimension naf, and real(dbp) array of dimension naf. It also has 1 output parameter of type real(dbp) array of dimension naf.", "input": "", "output": "    subroutine tw_rate(naf, sloc, tw_aero, th_prime)\n\n\n        implicit none\n        integer, parameter :: dbp = kind(0.d0)\n\n        ! inputs\n        integer, intent(in) :: naf  ! no of blade stations\n        real(dbp), intent(in), dimension(naf) :: sloc ! vector of station locations\n        real(dbp), intent(in), dimension(naf) :: tw_aero ! vector of twist distribution\n\n        ! outputs\n        real(dbp), intent(out), dimension(naf) :: th_prime ! vector of twist rates\n\n        ! local\n        real(dbp) :: f0, f1, f2, h1, h2\n        integer :: i\n\n        do i = 2, naf-1\n            f0 = tw_aero(i)\n            f1 = tw_aero(i-1)\n            f2 = tw_aero(i+1)\n            h1 = sloc(i) - sloc(i-1)\n            h2 = sloc(i+1) - sloc(i)\n            th_prime(i) = (h1*(f2-f0) + h2*(f0-f1))/(2.*h1*h2)\n        enddo\n\n        th_prime(1) = (tw_aero(2)-tw_aero(1))/(sloc(2)-sloc(1))\n        th_prime(naf)=(tw_aero(naf)-tw_aero(naf-1))/(sloc(naf)-sloc(naf-1))\n\n    end subroutine tw_rate\n"}, {"instruction": "Create a Fortran subroutine named cubic_spline_init to initialize the cubic spline coefficients. The subroutine takes 2 input parameters of type real, dimension(:) and 1 output parameter of type real, dimension(:). The subroutine initializes the cubic spline coefficients based on the input data.", "input": "", "output": "    subroutine cubic_spline_init(t, y, s2)\n        implicit none \n\n        real, dimension(:), intent(in)  :: t, y\n        real, dimension(:), intent(out) :: s2 \n\n        real, dimension(size(t))        :: beta\n        real                            :: a_i, b_i, c_i, r_i\n        integer                         :: i \n\n        ! natural spline\n        ! this gives rise to a n-2 linear system of equations  \n        s2 = 0.0\n\n        ! note: i = 2, n-1\n        ! beta(1) and beta(n) is undefined because of boundary condition \n        beta(2) = 2 * (t(3) - t(1))\n        s2(2)   = 6 * ((y(3) - y(2)) / (t(3) - t(2)) - (y(2) - y(1)) / (t(2) - t(1)))  \n\n        ! forward elimination \n        do i = 3, size(t) - 1 \n            ! off-diagonal term ( symmetric matrix a(i) = c(i-1) )\n            a_i = t(i) - t(i-1) \n            c_i = a_i\n\n            ! diagonal term   \n            b_i = 2.0 * (t(i+1) - t(i-1))\n\n            ! right-hand side \n            r_i = 6.0 * ((y(i+1) - y(i)) / (t(i+1) - t(i)) - (y(i) - y(i-1)) / (t(i) - t(i-1)))\n\n            ! eliminiation \n            beta(i) = b_i - a_i * c_i     / beta(i-1) \n            s2(i)   = r_i - a_i * s2(i-1) / beta(i-1)\n        end do \n\n        ! backward substitution \n        s2(size(t) - 1) = s2(size(t) - 1) / beta(size(t) - 1)\n        do i = size(t) - 2, 2, -1\n            c_i   = t(i+1) - t(i) \n            s2(i) = (s2(i) - c_i * s2(i+1)) / beta(i) \n        end do \n    end subroutine cubic_spline_init\n"}, {"instruction": "Create a Fortran subroutine named v_wire_nonperiodic to calculate the electric potential due to a charged wire at a given distance. The subroutine takes 2 input parameters of type double precision (x and lambda) and outputs 1 parameter of type double precision (potential). The input parameter x represents the distance in angstroms between the wire and the point of interest, while lambda is the line charge density of the wire in e/cm. The output parameter potential represents the electric potential in volts. Ensure that the subroutine uses the imperative tone and follows Fortran syntax.", "input": "", "output": "subroutine v_wire_nonperiodic(x,lambda,potential)\n\n  !! charged wire at a distance x\n\n  double precision, intent(in) :: x \n  !! x is the distance in ang between the wire and the point of interest\n  double precision, intent(in) :: lambda \n  !! lambda is the line charged density of the wire in e/cm\n\n  double precision, intent(out) :: potential \n  !! in v\n  double precision :: lamb \n  !! lambda in units of e/ang\n\n  double precision :: pi, epsilon0\n  parameter(pi = 3.1415926535897932d0)\n  parameter(epsilon0 = 0.0055263496) ! in e/(v*ang)\n\n  !first off, need lambda in e/ang\n  lamb = lambda*1.e-8\n\n  potential = -lamb/(2.*pi*epsilon0) * log(x)\n\nend subroutine v_wire_nonperiodic\n"}, {"instruction": "Create a Fortran subroutine named invar to calculate the stress invariants and principal stresses. The subroutine takes 1 input parameter of type real(iwp) and returns 3 optional output parameters of type real(iwp) to store the stress invariants, sigm, dsbar, and theta.", "input": "", "output": "subroutine invar(stress,sigm,dsbar,theta)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::stress(:)\r\n real(iwp),intent(out),optional::sigm,dsbar,theta\r\n real(iwp)::sx,sy,sz,txy,dx,dy,dz,xj3,sine,s1,s2,s3,s4,s5,s6,ds1,ds2,ds3, &\r\n   d2,d3,sq3,zero=0.0_iwp,small=1.e-10_iwp,one=1.0_iwp,two=2.0_iwp,       &\r\n   three=3.0_iwp,six=6.0_iwp,thpt5=13.5_iwp\r\n integer::nst \r\n nst=ubound(stress,1)\r\n select case(nst)\r\n case(4)\r\n   sx=stress(1)\r\n   sy=stress(2)\r\n   txy=stress(3)\r\n   sz=stress(4)\r\n   sigm=(sx+sy+sz)/three\r\n   dsbar=sqrt((sx-sy)**2+(sy-sz)**2+(sz-sx)**2+six*txy**2)/sqrt(two)\r\n   if(dsbar<small)then\r\n     theta=zero\r\n   else\r\n     dx=(two*sx-sy-sz)/three\r\n     dy=(two*sy-sz-sx)/three\r\n     dz=(two*sz-sx-sy)/three\r\n     xj3=dx*dy*dz-dz*txy**2\r\n     sine=-thpt5*xj3/dsbar**3\r\n     if(sine>=one)sine=one\r\n     if(sine<-one)sine=-one\r\n     theta=asin(sine)/three\r\n   end if\r\n case(6)\r\n   sq3=sqrt(three)\r\n   s1=stress(1)  \r\n   s2=stress(2)\r\n   s3=stress(3) \r\n   s4=stress(4)\r\n   s5=stress(5)\r\n   s6=stress(6)\r\n   sigm=(s1+s2+s3)/three\r\n   d2=((s1-s2)**2+(s2-s3)**2+(s3-s1)**2)/six+s4*s4+s5*s5+s6*s6\r\n   ds1=s1-sigm \r\n   ds2=s2-sigm  \r\n   ds3=s3-sigm\r\n   d3=ds1*ds2*ds3-ds1*s5*s5-ds2*s6*s6-ds3*s4*s4+two*s4*s5*s6\r\n   dsbar=sq3*sqrt(d2)\r\n   if(dsbar<small)then\r\n     theta=zero\r\n   else\r\n     sine=-three*sq3*d3/(two*sqrt(d2)**3)\r\n     if(sine>=one)sine=one \r\n     if(sine<-one)sine=-one \r\n     theta=asin(sine)/three\r\n   end if\r\n case default\r\n   write(*,*)\"wrong size for nst in invar\"\r\n end select\r\nreturn\r\nend subroutine invar\r\n"}, {"instruction": "Create a Fortran subroutine named coreq that takes a single input parameter of type character with a length of 2. The output parameter is of type integer. The subroutine assigns a specific integer value based on the input character element symbol. If the input element symbol is found, the corresponding atomic number is assigned to the output parameter; otherwise, an error message is displayed.", "input": "", "output": "subroutine coreq(el,q)\n  implicit none\n  character(len=2), intent(in)                :: el\n  integer, intent(out)                        :: q\n\n  if(el == 'h')then\n    q = 1\n  elseif(el == 'he')then\n    q = 2\n  elseif(el == 'li')then\n    q = 3\n  elseif(el == 'be')then\n    q = 4\n  elseif(el == 'b')then\n    q = 5\n  elseif(el == 'c')then\n    q = 6\n  elseif(el == 'n')then\n    q = 7\n  elseif(el == 'o')then\n    q = 8\n  elseif(el == 'f')then\n    q = 9\n  elseif(el == 'ne')then\n    q = 10\n  elseif(el == 'na')then\n    q = 11\n  elseif(el == 'mg')then\n    q = 12\n  elseif(el == 'al')then\n    q = 13\n  elseif(el == 'si')then\n    q = 14\n  elseif(el == 'p')then\n    q = 15\n  elseif(el == 's')then\n    q = 16\n  elseif(el == 'cl')then\n    q = 17\n  elseif(el == 'ar')then\n    q = 18\n  else\n    write(*,*) \"  !error: element \", el, \" not found!\"\n  endif\n\nend subroutine coreq\n"}, {"instruction": "Create a Fortran subroutine named \"arad\" that takes a single input parameter of type character and returns a double precision value. The subroutine should calculate and return the radius of an element based on the input element symbol. Use conditional statements to assign the corresponding radius value based on the input element symbol. If the input element symbol is not found, output an error message.", "input": "", "output": "subroutine arad(el,rad)\n  implicit none\n  character, intent(in)                       :: el\n  double precision, intent(out)               :: rad\n\n  if(el == 'h')then\n    rad = 1.0015547741d0\n  elseif(el == 'he')then\n    rad = 0.585815056d0\n  elseif(el == 'li')then\n    rad = 3.155842401d0\n  elseif(el == 'be')then\n    rad = 2.116493107d0\n  elseif(el == 'b')then\n    rad = 1.64406161d0\n  elseif(el == 'c')then\n    rad = 1.266116412d0\n  elseif(el == 'n')then\n    rad = 1.058246554d0\n  elseif(el == 'o')then\n    rad = 0.907068475d0\n  elseif(el == 'f')then\n    rad = 0.793684915d0\n  elseif(el == 'ne')then\n    rad = 0.718095876d0\n  elseif(el == 'na')then\n    rad = 3.5904796544504d0\n  elseif(el == 'mg')then\n    rad = 2.7401028941858d0\n  elseif(el == 'al')then\n    rad = 2.2298768380271d0\n  elseif(el == 'si')then\n    rad = 2.0975960086526d0\n  elseif(el == 'p')then\n    rad = 1.8519316112428d0\n  elseif(el == 's')then\n    rad = 1.6629589978507d0\n  elseif(el == 'cl')then\n    rad = 1.4928836457978d0\n  elseif(el == 'ar')then\n    rad = 1.3417055550841d0\n  else\n    write(*,*) \"  !error: element \", el, \" not found!\"\n  endif\n\nend subroutine arad\n"}, {"instruction": "Write a Fortran subroutine named gammln to calculate the natural logarithm of the absolute value of the gamma function. The subroutine takes 1 input parameter of type real(4) and provides 1 output parameter of type real(4).", "input": "", "output": "subroutine gammln(g,xx)\nreal(4),intent(in) :: xx\nreal(4),intent(out):: g\nreal(8)         :: cof(6),stp,half,one,fpf,x,tmp,ser\ninteger         :: j\ndata cof,stp/76.18009173d0,-86.50532033d0,24.01409822d0, &\n     -1.231739516d0,.120858003d-2,-.536382d-5,2.50662827465d0/\ndata half,one,fpf/0.5d0,1.0d0,5.5d0/\nx=xx-one\ntmp=x+fpf\ntmp=(x+half)*log(tmp)-tmp\nser=one\ndo j=1,6\n   x=x+one\n   ser=ser+cof(j)/x\nenddo\ng=tmp+log(stp*ser)\nend subroutine gammln\n"}, {"instruction": "Write a Fortran subroutine named g1matrix to calculate a 2x2x2x2 array g1_matrix based on the input length. The input parameter is a real(kind=8) variable, and the output is a 2x2x2x2 array of real(kind=8) values.", "input": "", "output": " subroutine g1matrix(leng,g1_matrix)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: leng\n  real(kind=8),intent(out) :: g1_matrix(2,2,2,2)\n  !internal variables\n  real(8),parameter :: zero=0.d0,one=1.d0\n  !routine\n  g1_matrix(1,1,1,1) = one/leng**2\n  g1_matrix(1,2,1,1) = zero\n  g1_matrix(2,1,1,1) = zero\n  g1_matrix(2,2,1,1) = one/leng**2\n\n  g1_matrix(1,1,1,2) = -one/leng**2\n  g1_matrix(1,2,1,2) = zero\n  g1_matrix(2,1,1,2) = zero\n  g1_matrix(2,2,1,2) = -one/leng**2\n\n  g1_matrix(1,1,2,1) = -one/leng**2\n  g1_matrix(1,2,2,1) = zero\n  g1_matrix(2,1,2,1) = zero\n  g1_matrix(2,2,2,1) = -one/leng**2\n \n  g1_matrix(1,1,2,2) = one/leng**2\n  g1_matrix(1,2,2,2) = zero\n  g1_matrix(2,1,2,2) = zero\n  g1_matrix(2,2,2,2) = one/leng**2\n end subroutine g1matrix\n"}, {"instruction": "Create a Fortran subroutine named \"g2matrix\" to compute the elements of a 2x2x2x2 matrix based on input coordinates and a parameter xi. The subroutine should take 2 input parameters of type real(kind=8) for coordinates and xi and one output parameter of type real(kind=8) for the g2 matrix. The subroutine should use the imperative tone and calculate the matrix elements according to the provided formulae.", "input": "", "output": " subroutine g2matrix(coords,xi,g2_matrix)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: xi,coords(2)\n  real(kind=8),intent(out) :: g2_matrix(2,2,2,2)\n  !internal variables\n  real(8),parameter :: zero=0.d0,one=1.d0,two=2.d0,four=4.d0\n  !routine\n  g2_matrix(1,1,1,1) = zero\n  g2_matrix(1,2,1,1) = zero\n  g2_matrix(2,1,1,1) = zero\n  g2_matrix(2,2,1,1) = (one-xi)**2/(four*coords(2)**2)\n  \n  g2_matrix(1,1,1,2) = zero\n  g2_matrix(1,2,1,2) = zero\n  g2_matrix(2,1,1,2) = zero\n  g2_matrix(2,2,1,2) = (one-xi**2)/(four*coords(2)**2)\n\n  g2_matrix(1,1,2,1) = zero\n  g2_matrix(1,2,2,1) = zero\n  g2_matrix(2,1,2,1) = zero\n  g2_matrix(2,2,2,1) = (one-xi**2)/(four*coords(2)**2)\n\n  g2_matrix(1,1,2,2) = zero\n  g2_matrix(1,2,2,2) = zero\n  g2_matrix(2,1,2,2) = zero\n  g2_matrix(2,2,2,2) = (one+xi)**2/(four*coords(2)**2)\n end subroutine g2matrix\n"}, {"instruction": "Write a Fortran subroutine named decomp_default to decompose an integer into a product of three integers. The number of input parameters is 1 of type integer(kind=4), and the number of output parameters is 1 of type integer(kind=4), dimension(3).", "input": "", "output": "   subroutine decomp_default(n, a2a3d_decomp)\n      implicit none\n      integer(kind=4), intent(in) :: n\n      integer(kind=4), dimension(3), intent(out) :: a2a3d_decomp\n      integer(kind=4) :: sqrtn, numdiv, tmpn, i\n      integer(kind=4), allocatable, dimension(:) :: divlist\n      integer(kind=4), dimension(3) :: tmpa\n\n      sqrtn = sqrt(real(n))\n      allocate(divlist(sqrtn+1))\n\n      ! make the list of divisors 'divlist'.\n      tmpn = n\n      numdiv=0\n      do\n         sqrtn = sqrt(real(tmpn))\n         do i = 2, sqrtn\n            if(mod(tmpn,i) == 0) then\n               tmpn = tmpn/i\n               numdiv = numdiv + 1\n               divlist(numdiv) = i\n               exit\n            end if\n         end do\n         if(i == sqrtn+1) then\n            numdiv = numdiv + 1\n            divlist(numdiv) = tmpn\n            exit\n         end if\n      end do\n\n      ! make 3 factors 'tmpa' as far as close.\n      tmpa = 1\n      do i = numdiv, 1, -1\n         if(tmpa(1) <= tmpa(2)) then\n            if(tmpa(1) <= tmpa(3)) then\n               tmpa(1) = tmpa(1)*divlist(i)\n            else\n               tmpa(3) = tmpa(3)*divlist(i)\n            end if\n         else\n            if(tmpa(2) <= tmpa(3)) then\n               tmpa(2) = tmpa(2)*divlist(i)\n            else\n               tmpa(3) = tmpa(3)*divlist(i)\n            end if\n         end if\n      end do\n\n      ! sort 'tmpa' and make 'a2a3d_decomp'.\n      a2a3d_decomp(1) = maxval(tmpa)\n      a2a3d_decomp(3) = minval(tmpa)\n      a2a3d_decomp(2) = n/a2a3d_decomp(1)/a2a3d_decomp(3)\n\n      ! check 'a2a3d_decomp'.\n      if(product(a2a3d_decomp) /= n) then\n         write(0,'(a)') 'error! invalid decomposition!'\n         write(0,'(a,i6)') 'n = ', n\n         write(0,'(a,3i6)') 'a2a3d_decomp = ', a2a3d_decomp\n      end if\n\n      deallocate(divlist)\n\n      return\n   end subroutine decomp_default\n"}, {"instruction": "Create a Fortran subroutine named binstream_init, which initializes a binary stream with a given logical unit number. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer.", "input": "", "output": "subroutine binstream_init( lun, ierr )\n    integer, intent(in)          :: lun\n    integer, intent(out)         :: ierr\n\n    character(len=5)             :: c\n\n    open( lun, status = 'scratch', access = 'direct', recl = 1 )\n    write( lun, rec=1, iostat = ierr ) c(1:1)\n    if ( ierr .ne. 0 ) then\n        return\n    endif\n    !\n    ! this will cause an error when the record length\n    ! is 1 byte, otherwise we \"know\" the length is 4 bytes\n    !\n    write( lun, rec=1, iostat = ierr ) c(1:4)\n    if ( ierr .ne. 0 ) then\n        reclen = 4\n    else\n        reclen = 1\n\n        !\n        ! one last check: it is indeed 4 bytes?\n        !\n        write( lun, rec=1, iostat = ierr ) c(1:5)\n        if ( ierr .eq. 0 ) then\n            ierr = 1\n        endif\n    endif\n    close( lun )\nend subroutine binstream_init\n"}, {"instruction": "Write a Fortran subroutine named get_levels that takes two input parameters and one output parameter. The input parameters are an array of real numbers (x) and a logical variable (fancy_style). The output parameter is an array of characters with a length of 25 (levels). \n\nThe purpose of this subroutine is to assign levels to each element in the input array based on its normalized value. The normalized value is calculated by dividing the difference between the element and the minimum value in the array by the difference between the maximum and minimum values. \n\nIf the fancy_style parameter is set to true, the levels are represented by emojis such as \":smiling_imp:\", \":frowning_face:\", etc. If the fancy_style parameter is false, the levels are represented by strings like \"_lv1_\", \"_lv2_\", etc. \n\nThe highest value in the input array is marked with \":skull:\" if fancy_style is true, or \"_max_\" if fancy_style is false. \n\nThe subroutine assigns the appropriate level or representation to each element in the levels array and returns it as the output.", "input": "", "output": "    subroutine get_levels(x, levels, fancy_style)\n        real, intent(in) :: x(:)\n        character(len=25), intent(out) :: levels(size(x))\n        logical, intent(in) :: fancy_style\n        real :: norm, min_x, max_x\n        integer :: i, j\n        character(len=:), allocatable :: level_names(:)\n\n        if (fancy_style) then\n            level_names = &\n                [character(len=25) :: &\n                 \":smiling_imp:\", &\n                 \":frowning_face:\", &\n                 \":slightly_frowning_face:\", &\n                 \":confused:\", &\n                 \":neutral_face:\", \"\"]\n        else\n            level_names = &\n                [character(len=25) :: &\n                 \"_lv1_\", \"_lv2_\", \"_lv3_\", \"_lv4_\", \"_lv5_\", \"\"]\n        end if\n\n        min_x = minval(x)\n        max_x = maxval(x)\n        levels = \"\" ! initilization\n\n        outer: do i = 1, size(x)\n            norm = (x(i) - min_x)/(max_x - min_x)\n            inner: do j = 5, 1, -1\n                if (norm >= 10.**(-j) .and. norm <= 10.**(-j + 1)) then\n                    levels(i) = trim(level_names(j))\n                    exit inner\n                end if\n            end do inner\n        end do outer\n\n        if (fancy_style) then\n            levels(maxloc(x)) = \":skull:\"\n        else\n            levels(maxloc(x)) = \"_max_\"\n        end if\n\n    end subroutine get_levels\n"}, {"instruction": "Write a Fortran subroutine named mult_noise that generates random numbers with noise. The subroutine takes one input argument of type real and one output argument of type real. \n\nTo use the subroutine, pass a value for the input argument 'ampl' which represents the amplitude of the noise. The subroutine will compute the natural logarithm of 'ampl' and store it in the variable 'logampl'. It will then generate a random number between 0 and 1 using the 'random_number' function and store it in the variable 'x'. \n\nNext, the subroutine will scale 'x' to the range [-ampl, ampl] by multiplying it by 2 and subtracting 1. It will then multiply 'x' by 'logampl' to introduce the noise. Finally, the subroutine will compute the exponential of 'x' and update the value of 'x' with the result.\n\nAfter calling the subroutine, the output argument 'x' will contain the generated random number with noise.", "input": "", "output": "  subroutine mult_noise(x,ampl)\n  !\n    real,intent(out):: x\n    real,intent(in):: ampl\n    real:: logampl\n  !\n    logampl = log(ampl)\n    call random_number(x)\n    x = (2*x - 1)  *  logampl\n    x = exp(x)\n  !\n  end subroutine mult_noise\n"}, {"instruction": "Write a Fortran subroutine named read_energy_dont_store to read energy data from files without storing it. The subroutine takes 2 input parameters of type integer and character*200, and 5 output parameters of type real*8, integer, integer, integer, and integer.\n\nThe subroutine reads the energy data from the specified energy files and determines the values of nkpt (number of k-points), nmat (maximum value of n), nume (maximum value of nen), nspin (number of spins), and sumw0 (sum of weights). It also checks if both vector and vectordn exist in the energy files and sets nspin accordingly.\n\nTo use the subroutine, provide the energy file names and the number of atoms as input. After executing the subroutine, you can access the values of sumw0, nkpt, nmat, nume, and nspin as output.\n\nMake sure to close the energy files after reading the data.", "input": "", "output": "subroutine read_energy_dont_store(energy_filenames, sumw0, nkpt, nmat, nume, nspin, nat)\n  implicit none\n  !\n  real*8, intent(out) :: sumw0\n  integer, intent(out):: nkpt, nmat, nume, nspin\n  integer, intent(in) :: nat\n  character*200, intent(in) :: energy_filenames(2)\n  !\n  character*10  :: kname\n  integer       :: ik, itape, ios\n  integer       :: n, nen, num, i, ii\n  real*8        :: emist, ss, tt, zz, wgh, e1\n  !--------------------------------------------------------------------- \n  !find nkpt, nmat and nume in energy file\n  open(30, file=energy_filenames(1),status='old')\n  do i=1,nat \n     read(30,'(f9.5)') emist\n     read(30,'(f9.5)') emist\n  enddo\n  \n  sumw0=0\n  ik=0  \n  nmat=0\n  nume=0\n  ios=0\n  do while (ios == 0)\n     read(30,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wgh\n     if (ios /= 0) cycle\n     ik=ik+1\n     nmat=max(n,nmat)\n     nume=max(nen,nume)\n     do ii=1,nen\n        read(30,*) num,e1\n     enddo\n  enddo\n  nkpt=ik\n  close(30)\n  \n  !***************************\n  ! check if both vector and vectordn exists. set nspin accordingly\n  nspin=1                                                         \n  open(29, file=energy_filenames(2),status='unknown')\n  do i=1,nat                                                  \n     read(29,'(f9.5)',end=1004) emist\n     read(29,'(f9.5)',end=1004) emist\n  enddo\n  nspin=2\n1004 continue\n\n  if(nspin.eq.2) then\n     ios=0\n     do while (ios == 0)\n        read(29,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wgh\n        nmat=max(n,nmat)\n        nume=max(nen,nume)\n        do ii=1,nen\n           read(29,*) num,e1\n        enddo\n     end do\n     sumw0=sumw0+wgh\n  end if\n  close(29)\n  !print *, 'nkpt=', nkpt, 'nume=', nume\nend subroutine read_energy_dont_store\n"}, {"instruction": "Write a Fortran subroutine named \"read_energy_file\" that reads energy data from a file. The subroutine takes 5 input parameters of types ['character*200', 'integer', 'integer', 'integer', 'integer'] and 1 output parameter of type ['real*8']. \n\nThe subroutine reads energy data from two input files specified by the \"energy_filenames\" parameter. The number of energy values to read is determined by the \"nume\" parameter. The energy values are stored in the \"eb\" array of size (nume, nkpt, nspin), where nkpt and nspin are the number of k-points and spin components, respectively.\n\nWithin the subroutine, the energy values are initialized to 3.0d0. Each file is opened and read in a nested loop structure. The first loop iterates over the spin components, and the second loop reads data for each k-point. The energy values are then read and stored in the \"eb\" array.\n\nThe subroutine does not return any values explicitly, but the energy values are stored in the \"eb\" array, which can be accessed after calling the subroutine.\n\nUse the \"read_energy_file\" subroutine to read energy data from files and populate the \"eb\" array.", "input": "", "output": "subroutine read_energy_file(energy_filenames, eb, nkpt, nume, nspin, nat)\n  implicit none\n  !\n  real*8, intent(out) :: eb(nume,nkpt,nspin)\n  !integer,intent(out) :: ne(nkpt,nspin)\n  character*200, intent(in) :: energy_filenames(2)\n  integer, intent(in) :: nkpt, nume, nspin, nat\n  !\n  character*10  :: kname\n  integer       :: ik, itape, ios, nen, n, num, inum, ispin, i\n  real*8        :: emist, ss, tt, zz, wei, e1\n  !--------------------------------------------------------------------- \n  \n  eb(:,:,:)=3.0d0\n  do ispin=1,nspin\n     itape=30-ispin+1\n     open(itape, file=energy_filenames(ispin),status='old')\n     do i=1,nat \n        read(itape,'(f9.5)') emist\n        read(itape,'(f9.5)') emist\n     enddo\n     \n     do ik=1,nkpt\n        read(itape,'(3e19.12,a10,2i6,f5.1)',iostat=ios) ss,tt,zz,kname,n,nen,wei\n        !ne(ik,ispin) = nen\n        do inum=1,nen\n           read(itape,*) num,e1\n           eb(num,ik,ispin)=e1\n        enddo\n     enddo\n  enddo\nend subroutine read_energy_file\n"}, {"instruction": "Create a Fortran subroutine named fortran_kernel to calculate the scale vector potential of a system of charged particles. The subroutine takes 5 input parameters: an integer n, and arrays x, y, z, and tau of real(dp) type and dimension(n). It returns an output parameter out, an array of real(dp) type and dimension(n).", "input": "", "output": "subroutine fortran_kernel(n,x,y,z,tau,out)\n    implicit none\n\n    integer, parameter                    :: dp=kind(0.d0)\n    integer,                 intent(in)   :: n\n    real(dp), dimension(n),  intent(in)   :: x, y, z, tau\n    real(dp), dimension(n),  intent(out)  :: out\n    integer                               :: i, j\n    real(dp)                              :: scale, d\n\n    scale = 0.25_dp/(4.0_dp*atan(1.0_dp))\n\n    out(:) = 0.0_dp\n    do i = 1, n\n        do j = 1, n\n            if (i .ne. j) then\n                d = sqrt((x(i)-x(j))**2 + (y(i)-y(j))**2 + (z(i)-z(j))**2)\n                out(i) = out(i) + out(j)/d\n            end if\n        end do\n    end do\n    out(:) = out(:) * scale\n\nend subroutine fortran_kernel\n"}, {"instruction": "Create a Fortran subroutine named read_data to read data from a file into a 2D integer array. The subroutine takes 1 input parameter of type character(*) for the data file name and 1 output parameter of type integer(4), dimension(:,:), to store the read data. Use the imperative tone in the generated instructions.", "input": "", "output": "  subroutine read_data(array,data_file)\n    ! default\n    implicit none\n\n    integer(4), dimension(:,:), intent(out) :: array\n    character(*),               intent(in)  :: data_file\n\n    ! local variables\n    integer(4) :: i\n    integer(4), dimension(2) :: arr_shape\n\n    ! find array size\n    arr_shape = shape(array)\n\n    ! read in data\n    open(11,file=data_file)\n    do i=1,arr_shape(2)\n       read(11,*) array(:,i)\n    enddo\n    close(11)\n\n    return\n  end subroutine read_data\n"}, {"instruction": "Create a Fortran subroutine named read_natoms that reads the number of atoms from a file. The subroutine takes 1 input parameter of type integer and provides 1 output parameter of type integer. The input parameter is specified using the keyword \"intent(in)\" and the output parameter is specified using the keyword \"intent(out)\". After reading the number of atoms from the file, the subroutine calculates the number of words (nw) as the number of atoms divided by 3.", "input": "", "output": "subroutine read_natoms(iunit, nw)\n!*** reads the number of atoms from a file\nimplicit none\ninteger, intent(in) :: iunit\ninteger, intent(out) :: nw\ninteger :: natoms\n\nread(10,*)natoms\nread(10,*)\nnw = natoms/3\n\nend subroutine read_natoms\n"}, {"instruction": "Create a Fortran subroutine named readxyz to read the coordinates of atoms from a file and store them properly in the array (rr). The subroutine takes 2 input parameters of type integer and 1 output parameter of type double precision, dimension(3, 3*nw).", "input": "", "output": "subroutine readxyz(iunit, nw, rr)\n!*** reads the coordinates of atoms from a file and stores them properly in\n!*** the array (rr)\nimplicit none\ninteger, intent(in) :: iunit\ninteger, intent(in) :: nw\ndouble precision, intent(out), dimension(3, 3*nw) :: rr\ndouble precision, parameter :: rcsq_wat =2.2025d0\ninteger         :: i, j, i_top, i_end, atom_id, i_conn, idx, natoms\ndouble precision, dimension(3) :: tmpr, r_o\ncharacter(len=100) :: filename\ncharacter(len=2) :: atom_name\ncharacter(len=2) :: adj\n\nnatoms = 3*nw\ni_top = 1\ni_end = natoms\ndo i=1,natoms\n   read(10,*)atom_name,tmpr(1:3)\n    adj = adjustl(atom_name)\n   if ((adj == \"8\") .or. (adj==\"o\") .or. (adj==\"o\") ) then\n      rr(1:3, i_top) = tmpr(1:3)\n      i_top = i_top + 1\n   else if ((adj == \"1\") .or. (adj==\"h\") .or. (adj==\"h\"))  then\n      rr(1:3, i_end) = tmpr(1:3)\n      i_end = i_end-1\n   endif\nenddo\n\ndo i=1, nw\n   r_o(1:3) = rr(1:3, i)\n   i_conn = 0\n   do j=nw+1, natoms\n      if (dot_product(r_o(1:3)-rr(1:3,j), r_o(1:3)-rr(1:3,j)) < rcsq_wat ) then\n         i_conn=i_conn+1\n         idx = nw+ 2*(i-1) + i_conn\n         tmpr(1:3)    = rr(1:3,j)\n         if (i_conn<=2) then\n            rr(1:3,j)    = rr(1:3, idx)\n            rr(1:3, idx) = tmpr(1:3)\n         endif\n      endif\n   enddo\n   if (i_conn/=2) then\n      print*, 'error in the det,of the structure water=',i,' conn. h=',i_conn\n      stop\n   endif\nenddo\nreturn\nend subroutine readxyz\n"}, {"instruction": "Create a Fortran subroutine named sieve that utilizes the sieve of Eratosthenes algorithm to generate a logical array of size n_max, where the presence of .true. in element i indicates that i is a prime number. The subroutine should have 1 input parameter of type integer and 1 output parameter of type logical. The input parameter represents n_max, and the output parameter is the logical array is_prime of size n_max.", "input": "", "output": "subroutine sieve(is_prime, n_max)\n! =====================================================\n! uses the sieve of eratosthenes to compute a logical\n! array of size n_max, where .true. in element i\n! indicates that i is a prime.\n! =====================================================\n    integer, intent(in)   :: n_max\n    logical, intent(out)  :: is_prime(n_max)\n    integer :: i\n    is_prime = .true.\n    is_prime(1) = .false.\n    do i = 2, int(sqrt(real(n_max)))\n        if (is_prime (i)) is_prime (i * i : n_max : i) = .false.\n    end do\n    return\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named logical_to_integer that translates a logical array from a sieve into an array of prime numbers. The subroutine takes 3 input parameters of type integer, logical, and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine logical_to_integer(prime_numbers, is_prime, num_primes, n)\n! =====================================================\n! translates the logical array from sieve to an array\n! of size num_primes of prime numbers.\n! =====================================================\n    integer                 :: i, j=0\n    integer, intent(in)     :: n\n    logical, intent(in)     :: is_prime(n)\n    integer, intent(in)     :: num_primes\n    integer, intent(out)    :: prime_numbers(num_primes)\n    do i = 1, size(is_prime)\n        if (is_prime(i)) then\n            j = j + 1\n            prime_numbers(j) = i\n        end if\n    end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named noop_init_iarray to initialize an integer array with a specified value. The subroutine takes one input parameter of type integer array and one input parameter of type integer. The output is the initialized integer array.", "input": "", "output": "        subroutine noop_init_iarray ( wpe, val )\n\n        implicit none\n\n        integer, intent(out) :: wpe(:)\n        integer, intent(in) :: val\n\n        integer i\n\n        do i = 1, size(wpe,1)\n           wpe(i) = val\n        end do\n\n        end subroutine noop_init_iarray \n"}, {"instruction": "Create a Fortran subroutine named noop_hi_lo_bnd_pe. It takes 1 input parameter of type character and 2 output parameters of type logical. The subroutine sets both output parameters to true.", "input": "", "output": "        subroutine noop_hi_lo_bnd_pe (ori, low_index, high_index)\n\n        implicit none\n\n        character, intent(in) :: ori\n        logical, intent(out) :: low_index, high_index\n\n        low_index = .true.\n        high_index = .true.\n\n        end subroutine noop_hi_lo_bnd_pe\n"}, {"instruction": "Write a Fortran subroutine named parse_flpth to extract the file name and file path from a given full pathname. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 2 and the test_data type is ['character(len=*)', 'character(len=*)'].", "input": "", "output": "      subroutine parse_flpth( fullpath, filename, filepath )\n\n      implicit none\n\n!-------------------------------------------------------\n!       ... dummy args\n!-------------------------------------------------------\n      character(len=*), intent(in) ::    fullpath   ! incoming full pathname\n      character(len=*), intent(out) ::   filename   ! the file name\n      character(len=*), intent(out) ::   filepath   ! the file path\n\n!-------------------------------------------------------\n!       ... local variables\n!-------------------------------------------------------\n      integer  ::  i\n\n      i = index( fullpath(:len_trim(fullpath)), '/', back = .true. )\n      filename = fullpath(i+1:)\n      if( i /= 0 ) then\n         filepath = fullpath(:i) \n      else\n         filepath = ' '\n      end if\n\n      end subroutine parse_flpth\n"}, {"instruction": "Create a Fortran subroutine named mkdate to convert a given time in days to a date in the format yymmdd. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type character with a length of 6 for the date.", "input": "", "output": "      subroutine mkdate( time, date )\n\n      implicit none\n\n!-------------------------------------------------------\n!       ... dummy args\n!-------------------------------------------------------\n      real, intent(in) ::     time             ! time to convert in days\n      character(len=6), intent(out) :: date    ! date in form yymmdd\n\n!-------------------------------------------------------\n!       ... local variables\n!-------------------------------------------------------\n      integer  :: years, days\n      integer  :: mnth\n      integer  :: mdys(0:12) = (/ 0, 31, 59, 90, 120, 151, &\n\t\t\t\t  181, 212, 243, 273, 304, 334, 365 /)\n\n      years = int( time/365. )\n      if( years > 1900 ) then\n         years = years - 1900\n      end if\n      write(date(1:2),'(i2)') years\n\n      days = int( time - real(years)*365. )\n      do mnth = 1,12\n         if( days <= mdys(mnth) ) then\n            exit\n         end if\n      end do\n\n      mnth = max( 1,min( 12, mnth ) )\n      if( mnth < 10 ) then\n         write(date(3:4),'(''0'',i1)') mnth\n      else\n         write(date(3:4),'(i2)') mnth\n      end if\n\n      days = days - mdys(mnth-1)\n      if( days < 10 ) then\n         write(date(5:6),'(''0'',i1)') days\n      else\n         write(date(5:6),'(i2)') days\n      end if\n      \n      end subroutine mkdate\n"}, {"instruction": "Write a Fortran subroutine named tridiagxvector to perform tridiagonal matrix-vector multiplication. The subroutine takes 4 input parameters of type real(8) arrays and 1 output parameter of type real(8) array. The input parameters represent the tridiagonal matrix components and the vector, while the output parameter stores the result of the matrix-vector multiplication.", "input": "", "output": "subroutine tridiagxvector(ad, al, au, v, w)\n\nimplicit none\n\nreal(8), dimension(:), intent(in) :: ad, al, au, v\nreal(8), dimension(:), intent(out) :: w\n\ninteger:: n\n\nn = size(ad)\n\nw = 0\n\nw(1:n) = ad*v(1:n)\nw(1:n-1)=w(1:n-1) + au*v(2: n)\nw(2:n) = w(2:n) + al*v(1:n-1)\n\nprint*,\nprint*, 'tridiag: ', w\nprint*,\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_multiplication that takes two input matrices of real numbers and an integer n, and produces an output matrix of real numbers. The input parameters are of type real, real, and integer, and the output parameter is of type real. The subroutine performs matrix multiplication using parallel processing and stores the result in the output matrix c of size n x n.", "input": "", "output": "      subroutine matrix_multiplication(a, b, n, c)\n\n      implicit none\n        \n      real, intent(in) :: a(n, n)\n      real, intent(in) :: b(n, n)\n      real, intent(out) :: c(n, n)\n      integer, intent(in) :: n\n\n      integer :: i, j\n\n      !$omp parallel do\n      do i = 1, n \n          do j = 1, n\n              c(j,i) = sum(a(:,j) * b(i,:))\n          enddo\n      enddo\n      !$omp end parallel do\n\n      end subroutine matrix_multiplication\n"}, {"instruction": "Create a Fortran subroutine named load_3d_field to load a 3D field from a file starting at a given record number. The subroutine takes 2 input parameters of type integer - nfile and nrec. It also has 1 output parameter of type real with dimensions (imt, jmt, km), where imt=3600, jmt=2400, and km=42.", "input": "", "output": "subroutine load_3d_field(nfile,nrec,field)\n!\n!  loads 3d field (starting with record number nrec) from file with\n!  number nfile\n!\nimplicit none\n\ninteger                                     :: k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: nfile,nrec\nreal,    dimension(imt,jmt)                 :: work\nreal,    dimension(imt,jmt,km), intent(out) :: field\n\ndo k = 1,km\n  read (nfile,rec=nrec+k-1) work\n  field(:,:,k) = work\nenddo\n\nend subroutine load_3d_field\n"}, {"instruction": "Write a Fortran subroutine named load_2d_field to load a 2D field from a file starting with a specific record number. The subroutine takes 2 input parameters of type integer: nfile and nrec. It has 1 output parameter of type real with dimensions imt and jmt.", "input": "", "output": "subroutine load_2d_field(nfile,nrec,field)\n!\n!  loads 2d field (starting with record number nrec) from file with\n!  number nfile\n!\nimplicit none\n\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\ninteger,                     intent(in)  :: nfile,  nrec\nreal,    dimension(imt,jmt), intent(out) :: field\n\nread (nfile,rec=nrec) field\n\nend subroutine load_2d_field\n"}, {"instruction": "Create a Fortran subroutine named e_rshift to shift the elements of a 2D double precision array to the east. The subroutine takes 3 input parameters of type integer, integer, and double precision array dimensioned imt and jmt. It also has 1 output parameter of type double precision array dimensioned imt and jmt.", "input": "", "output": "subroutine e_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from east (double precision arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,ip\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  do i=1,imt\n    ip = i + 1\n    if(i == imt) ip = 1\n    xout(i,j) = x(ip,j)\n  enddo\nenddo\n\nend subroutine e_rshift\n"}, {"instruction": "Create a Fortran subroutine named s_rshift to shift a 2D array of double precision values by one index to the south. The subroutine takes 3 input parameters: two integers (imt, jmt) and a 2D array of double precision values (x), and produces 1 output parameter: a 2D array of double precision values (xout).", "input": "", "output": "subroutine s_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from south (real arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,jm\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  jm = j - 1\n  if(j == 1) jm = 1\n  do i=1,imt\n    xout(i,j) = x(i,jm)\n  enddo\nenddo\n\nend subroutine s_rshift\n"}, {"instruction": "Create a Fortran subroutine named n_rshift to shift the elements of a double precision array towards the north. The subroutine takes 3 input parameters of type integer, integer, and double precision array with dimensions imt and jmt. It produces 1 output parameter of type double precision array with dimensions imt and jmt.", "input": "", "output": "subroutine n_rshift(xout,x,imt,jmt)\nimplicit none\n!-----------------------------------------------------------------------\n!     shift from north (double precision arrays)\n!-----------------------------------------------------------------------\ninteger                                           :: i,j,n,jp\ninteger,                              intent(in)  :: imt,jmt\ndouble precision, dimension(imt,jmt), intent(in)  :: x    ! array to be shifted\ndouble precision, dimension(imt,jmt), intent(out) :: xout ! shifted result\n\ndo j=1,jmt\n  jp = j+1\n  if(j == jmt) jp = jmt\n  do i=1,imt\n    xout(i,j) = x(i,jp)\n  end do\nend do\n\nend subroutine n_rshift\n"}, {"instruction": "Create a Fortran subroutine named check_vector to search for a specific integer value within an array of integers. The subroutine takes 3 input parameters and 1 output parameter. The input parameters are of type integer*4, integer*4, and integer*4, dimension(n). The output parameter is of type integer*4. The subroutine checks if the specified integer exists in the array and sets the output parameter to 1 if found, otherwise 0.", "input": "", "output": "    subroutine check_vector(n,v,ind,tt)\n    \n    implicit none\n    \n    integer*4 :: i\n    \n    integer*4, intent(in) ::n,ind\n    integer*4, dimension(n), intent(in)  :: v\n    integer*4, intent(out) :: tt\n\n    tt = 0\n    i = 1\n    \n    do while (i.le.n)\n       if (v(i) .eq. ind) then\n          tt = 1\n          return\n       endif   \n       i=i+1\n    enddo    \n    \n    end subroutine check_vector\n"}, {"instruction": "Write a Fortran subroutine named calcgradu that calculates the gradient of a given solution field for a finite element analysis. The subroutine takes 5 input parameters of type integer, integer, integer, real*8, and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine calcgradu(gradu,sol,dphi_g,ndime,nodelt,idofsol)\n\tinteger, intent(in) :: ndime, nodelt, idofsol \n\treal*8, intent(out) :: gradu(ndime,ndime)\n\treal*8, intent(in) ::dphi_g(ndime,nodelt) , sol(idofsol*nodelt)\n\tinteger :: i, j , e ,ep \n\t\n\tgradu = 0.0d0\n\tdo e = 1 , nodelt\n\t\tep = (e-1)*idofsol\n\t\tdo i = 1, ndime\n\t\t\tdo j = 1, ndime\n\t\t\t\tgradu(i,j) = gradu(i,j) + sol(ep+i)*dphi_g(j,e)\n\t\t\tend do\n\t\tend do\n\tend do\t\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named modifytospatial to modify the values of the input arrays ds and sigma. The subroutine takes 3 input parameters of type real*8 and integer, and 2 output parameters of type real*8. The input parameters are ds(ndime,ndime,ndime,ndime), sigma(ndime,ndime), f(ndime,ndime), and detf, where ndime is the dimension. The subroutine modifies the values of sigma and ds based on the input arrays and detf.", "input": "", "output": "subroutine modifytospatial(ds,sigma,f,detf,ndime)\n\treal*8 , intent(out) :: sigma(ndime,ndime), ds(ndime,ndime,ndime,ndime)\n\treal*8 , intent(in) :: f(ndime,ndime),detf\n\tinteger , intent(in) :: ndime \n\t\n\treal*8 :: d(ndime,ndime,ndime,ndime), detftemp\n\tinteger :: i,j,k,l,m,n,p,q\n\t\n\td = ds\n\t\n\tsigma = (1.0d0/detf)*matmul(sigma,transpose(f))\n\t\n\tds = 0.0d0\n\t\n\tdo i = 1,ndime\n\tdo j = 1,ndime\n\tdo k = 1,ndime\n\tdo l = 1,ndime\n\tdo p = 1,ndime\n\tdo q = 1,ndime\n\t\tds(i,j,k,l) = ds(i,j,k,l) +  d(i,p,k,q)*f(j,p)*f(l,q)/detf\n\tend do\n\tend do\n\tend do\n\tend do\n\tend do\n\tend do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named collect_identical to map unique atoms to their corresponding indices in the identity array. The subroutine takes 1 input parameter of type integer array and 1 output parameter of type integer array. The input parameter should contain chemical identities, and the output parameter will store the mapping from unique atoms.", "input": "", "output": "pure subroutine collect_identical(identity, mapping)\n\n   !> chemical identity\n   integer, intent(in) :: identity(:)\n\n   !> mapping from unique atoms\n   integer, intent(out) :: mapping(:)\n\n   integer :: iid, iat\n\n   do iid = 1, size(mapping)\n      do iat = 1, size(identity)\n         if (identity(iat) == iid) then\n            mapping(iid) = iat\n            exit\n         end if\n      end do\n   end do\n\nend subroutine collect_identical\n"}, {"instruction": "Create a Fortran subroutine named apply_lap_double to apply the Laplacian matrix to a 3D array of double precision values. The subroutine should have 4 input parameters of type integer, integer, integer, and double precision, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine apply_lap_double( mx, my, nx, x, ax)\n! multiply x by laplacian matrix for a square of size mx by my\n\n    implicit none\n\n    integer, intent(in) :: mx, my, nx\n    double precision, intent(in) :: x(mx, my, nx)\n    double precision, intent(out) :: ax(mx, my, nx)\n    integer :: i, j, k\n    double precision :: z\n\n    do k = 1, nx\n      do i = 1, mx\n        do j = 1, my\n          z = 4*x(i, j, k)\n          if ( i > 1 ) z = z - x(i - 1, j, k) \n          if ( j > 1 ) z = z - x(i, j - 1, k) \n          if ( i < mx ) z = z - x(i + 1, j, k) \n          if ( j < my ) z = z - x(i, j + 1, k) \n          ax(i, j, k) = z\n        end do    \n      end do    \n    end do    \n\n  end subroutine apply_lap_double\n"}, {"instruction": "Create a Fortran subroutine named apply_gs_double to perform one Gauss-Seidel step for preconditioning. The subroutine takes 4 input parameters of types integer, integer, integer, and double precision, and 1 output parameter of type double precision. The input parameters are mx, my, nx, and x, while the output parameter is tx.", "input": "", "output": "  subroutine apply_gs_double( mx, my, nx, x, tx )\n! apply one gauss-seidel step for preconditioning\n\n    implicit none\n\n    integer, intent(in) :: mx, my, nx\n    double precision, intent(in) :: x(mx, my, nx)\n    double precision, intent(out) :: tx(mx, my, nx)\n    integer :: i, j, k\n    double precision :: z\n    tx = x/4\n    do k = 1, nx\n      do i = 1, mx ! forward update\n        do j = 1, my\n          z = 0\n          if ( i > 1 ) z = z + tx(i - 1, j, k) \n          if ( j > 1 ) z = z + tx(i, j - 1, k) \n          if ( i < mx ) z = z + tx(i + 1, j, k) \n          if ( j < my ) z = z + tx(i, j + 1, k) \n          tx(i, j, k) = (tx(i, j, k) + z/4)/4\n        end do\n      end do    \n      do i = mx, 1, -1 ! backward update\n        do j = my, 1, -1\n          z = 0\n          if ( i > 1 ) z = z + tx(i - 1, j, k) \n          if ( j > 1 ) z = z + tx(i, j - 1, k) \n          if ( i < mx ) z = z + tx(i + 1, j, k) \n          if ( j < my ) z = z + tx(i, j + 1, k) \n          tx(i, j, k) = (tx(i, j, k) + z/4)/4\n        end do\n      end do    \n    end do    \n  end subroutine apply_gs_double\n"}, {"instruction": "Write a Fortran subroutine named matrix_diagonal to extract the diagonal elements of a square matrix. The subroutine should take 2 input parameters of type real, dimension(:,:) and integer, and 1 output parameter of type real, dimension(:).", "input": "", "output": "    subroutine matrix_diagonal(a, diag, n)\n        implicit none\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:), intent(out) :: diag\n        integer, intent(in) :: n\n        real, dimension(1:size(a)) :: tmp\n\n        tmp = pack(a,.true.)\n        diag = tmp(1:n*n:n+1)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named bounceroots that calculates the values of gout based on the inputs neq, t, y, and ng. The number of input parameters is 4, with the test_data type being ['integer', 'integer', 'real(8)', 'real(8)']. The number of output parameters is 1, with the test_data type being ['real(8)'].", "input": "", "output": "  subroutine bounceroots (neq, t, y, ng, gout)\n     integer, intent(in) :: neq, ng\n     real(8), intent(in) :: t, y(neq)\n     real(8), intent(out) :: gout(ng)\n     gout(1) = y(1) - th0\n     gout(2) = 2d0*pi - (y(1) - th0)\n     return\n   end subroutine bounceroots\n"}, {"instruction": "Write a Fortran subroutine named bbox to calculate the values of mathematical functions based on the input parameters. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and returns 1 output parameter of type real(8). The subroutine computes the values and assigns them to the output array gout.", "input": "", "output": "  subroutine bbox (neq, t, y, ng, gout)\n    integer, intent(in) :: neq, ng\n    real(8), intent(in) :: t, y(neq)\n    real(8), intent(out) :: gout(ng)\n    gout(1) = 1d0\n    gout(2) = 1d0 - y(1)\n    gout(3) = y(2)\n    gout(4) = 1d0 - y(2)\n    return\n  end subroutine bbox\n"}, {"instruction": "Write a Fortran subroutine named func that takes 5 input parameters of type integer and double precision, and 3 output parameters of type double precision. The input parameters are ndim, u, icp, par, ijac, and the output parameters are f, dfdu, dfdp. The subroutine computes the values of f, dfdu, and dfdp based on the input parameters and the defined mathematical operations. Ensure that the subroutine func is implemented according to these requirements.", "input": "", "output": " subroutine func(ndim,u,icp,par,ijac,f,dfdu,dfdp)\n!---------- ---- \n\n   implicit none\n   integer, intent(in) :: ndim, ijac, icp(*)\n   double precision, intent(in) :: u(ndim), par(*)\n   double precision, intent(out) :: f(ndim), dfdu(ndim,*), dfdp(ndim,*)\n\n   double precision x1,x2,x3,d,alpha,beta,b,s,e,x1c\n\n   x1 = u(1)\n   x2 = u(2)\n   x3 = u(3)\n\n   d = par(1)\n   alpha = par(2)\n   beta = par(3)\n   b = par(4)\n   s = par(5)\n\n   e = dexp(x3)\n   x1c = 1 - x1\n\n   f(1) = -x1 + d*x1c*e\n   f(2) = -x2 + d*e*(x1c - s*x2)\n   f(3) = -x3 - beta*x3 + d*b*e*(x1c + alpha*s*x2)\n\n   if(ijac.eq.0)return \n\n   dfdu(1,1) = -1.d0 - d*e\n   dfdu(1,2) = 0.d0\n   dfdu(1,3) = d*x1c*e\n\n   dfdu(2,1) = -d*e\n   dfdu(2,2) = -1.d0 - d*e*s\n   dfdu(2,3) = d*e*(x1c - s*x2)\n\n   dfdu(3,1) = -d*b*e\n   dfdu(3,2) = d*b*e*alpha*s\n   dfdu(3,3) = -1.d0 - beta + d*b*e*(x1c + alpha*s*x2)\n\n   if(ijac.eq.1)return\n\n   dfdp(1,1) = x1c*e\n   dfdp(1,2) = 0.d0\n   dfdp(1,3) = 0.d0\n   dfdp(1,4) = 0.d0\n   dfdp(1,5) = 0.d0\n   dfdp(2,1) = e*(x1c - s*x2)\n   dfdp(2,2) = 0.d0\n   dfdp(2,3) = 0.d0\n   dfdp(2,4) = 0.d0\n   dfdp(2,5) = -d*e*x2\n   dfdp(3,1) = b*e*(x1c + alpha*s*x2)\n   dfdp(3,2) = d*b*e*s*x2\n   dfdp(3,3) = -x3\n   dfdp(3,4) = d*e*(x1c + alpha*s*x2)\n   dfdp(3,5) = d*b*e*alpha*x2\n\n end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named stpnt that initializes the arrays u and par. The subroutine takes 2 input parameters, ndim of type integer and t of type double precision. It also has 2 output parameters, u of type double precision array and par of type double precision array. The subroutine initializes par(1:5) with the values (0.0, 1.0, 1.55, 8.0, 0.04) and sets u(1:3) to 0.", "input": "", "output": " subroutine stpnt(ndim,u,par,t) \n!---------- ----- \n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   par(1:5)=(/0.0,1.0,1.55,8.,0.04/)\n\n   u(1:3)=0.\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named \"c_f_string_chars\" to convert a C-style string (array of characters) to a Fortran-style string. The subroutine should take 1 input parameter of type character(len=1,kind=c_char) and produce 1 output parameter of type character(len=*).", "input": "", "output": "subroutine c_f_string_chars(c_string, f_string)\n    ! helper function\n    use iso_c_binding\n    implicit none\n    character(len=1,kind=c_char), intent(in) :: c_string(*)\n    character(len=*), intent(out) :: f_string\n    integer :: i\n    i=1\n    do while(c_string(i)/=c_null_char .and. i<=len(f_string))\n        f_string(i:i) = c_string(i)\n        i=i+1\n    end do\n    if (i<=len(f_string)) f_string(i:) = ' '\nend subroutine c_f_string_chars\n"}, {"instruction": "Write a Fortran subroutine named get_final_integer that takes in a character string and returns an integer. The input parameter is 1 of type character, and the output parameter is 1 of type integer. This subroutine extracts an integer from a string by locating the integer following a \":\" and converts it to an integer value.", "input": "", "output": "  subroutine get_final_integer(string,num)\n    implicit none\n    character,intent(in) :: string*(132)\n    integer,intent(out) :: num\n    integer :: ibeg,iend,nsign,ntemp\n    character :: sub_string*(40)\n\n    iend=len(string) !get the length of the string\n    ibeg=index(string,\":\")+1 !get location of integer in string, follows \":\"\n    sub_string = adjustl(string(ibeg:iend)) ! get the characters beyond \":\"\n    iend=len(sub_string) !length of the sub-string\n    if(sub_string(1:1).eq.'-')then !check for negative sign\n       nsign=-1\n       ibeg=2\n    else\n       nsign=1\n       ibeg=1\n    endif\n    read (sub_string(ibeg:iend), '(i10)' ) ntemp !get integer values\n    ntemp=ntemp*nsign !apply sign to number\n\n    num=ntemp !return the integer value\n\n  end subroutine get_final_integer\n"}, {"instruction": "Create a Fortran subroutine named calc_vectorlength that takes a 3x3 matrix of real(8) as input and computes the Euclidean length of each column. The input parameter is a 3x3 matrix of real(8), and the output parameter is a 1D array of real(8) containing the lengths of each column.", "input": "", "output": "  subroutine calc_vectorlength( aa, aal )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: aal(3)\n    aal(1) = sqrt( sum(aa(1:3,1)**2) )\n    aal(2) = sqrt( sum(aa(1:3,2)**2) )\n    aal(3) = sqrt( sum(aa(1:3,3)**2) )\n  end subroutine calc_vectorlength\n"}, {"instruction": "Create a Fortran subroutine named calc_volume_lattice to calculate the volume of a lattice defined by a 3x3 matrix. The subroutine takes one input parameter of type real(8) and one output parameter of type real(8).", "input": "", "output": "  subroutine calc_volume_lattice( aa, va )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: va\n    va = aa(1,1)*aa(2,2)*aa(3,3)+aa(1,2)*aa(2,3)*aa(3,1) &\n        +aa(1,3)*aa(2,1)*aa(3,2)-aa(1,3)*aa(2,2)*aa(3,1) &\n        -aa(1,2)*aa(2,1)*aa(3,3)-aa(1,1)*aa(2,3)*aa(3,2)\n  end subroutine calc_volume_lattice\n"}, {"instruction": "Write a Fortran subroutine named mat_vec_mult to perform matrix-vector multiplication. The subroutine takes 4 input parameters: m (integer), n (integer), a (2D integer array of dimension m x n), and b (integer array of size n). It produces 1 output parameter: ab (integer array of size m). The subroutine uses the matmul function to compute the matrix-vector product.", "input": "", "output": "  subroutine mat_vec_mult(m,n,a,b,ab)\n    integer, intent(in) :: m,n, b(n)\n    integer, intent(in), dimension(m,n) :: a\n    integer, intent(out) :: ab(m)\n    ab = matmul(a,b)\n  end subroutine mat_vec_mult\n"}, {"instruction": "Create a Fortran subroutine named parrat_amplitude to calculate the reflectivity of a multilayer system using the Parratt formalism. The subroutine should have 6 input parameters of types ['double precision, dimension(nq)', 'complex*16, dimension(nlayers)', 'double precision, dimension(nlayers)', 'double precision, dimension(nlayers)', 'integer', 'integer'], and 1 output parameter of type ['complex*16, dimension(nq)'].", "input": "", "output": "    subroutine parrat_amplitude(q, sld, sigma, thickness, nlayers, nq, refl)\n        double precision, intent(in), dimension(nq) :: q\n        complex*16, intent(in), dimension(nlayers) :: sld\n        double precision, intent(in), dimension(nlayers) :: sigma, thickness\n        integer, intent(in):: nlayers, nq\n        complex*16, intent(out), dimension(nq) :: refl\n\n        integer :: iq, ir\n        \n        double precision :: k0, k02\n        complex*16 :: ksub, kj, knext, rnext, p2, refl_val\n\n        !$omp parallel\n        !$omp do\n        do iq=1,nq\n            k0 = q(iq)/2d0\n            k02= k0**2\n            \n            ksub = cdsqrt(k02 - 4d0*pi*sld(1))\n            kj = cdsqrt(k02 - 4d0*pi*sld(2))\n            refl_val = (kj-ksub)/(kj+ksub) * cdexp(-2d0*ksub*kj*sigma(1)**2)\n            do ir=2, nlayers-1\n                knext = cdsqrt(k02 - 4d0*pi*sld(ir+1))\n                rnext = (knext-kj)/(knext+kj)*cdexp(-2d0*knext*kj*sigma(ir)**2)\n                p2 = cdexp(2d0*ci*thickness(ir)*kj)\n                refl_val = (rnext + refl_val*p2) / ( 1 + rnext*refl_val*p2)\n                kj = knext\n            end do\n            refl(iq) = refl_val\n        end do\n        !$omp end do\n        !$omp end parallel\n    end subroutine parrat_amplitude\n"}, {"instruction": "Write a Fortran subroutine named scattering_matrix_translation to compute the scattering matrix for a given wave vector and thickness. The subroutine takes 2 input parameters of type complex*16 and double precision, and 1 output parameter of type complex*16 with a dimension of 2x2.", "input": "", "output": "    subroutine scattering_matrix_translation(k1, thickness, s)\n        complex*16, intent(in) :: k1\n        double precision, intent(in) :: thickness\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        s(1,1) = 0d0\n        s(1,2) = cdexp(-ci*thickness*k1)\n        s(2,1) = cdexp(-ci*thickness*k1)\n        s(2,2) = 0d0\n    end subroutine scattering_matrix_translation\n"}, {"instruction": "Create a Fortran subroutine named connect_scattering_matrices that takes two input parameters of type complex*16, dimension(2,2) and intent(in), named s1 and s2. It also has one output parameter of type complex*16, dimension(2,2) and intent(out), named s. This subroutine is designed to compute scattering matrices and performs complex computations to connect the input scattering matrices s1 and s2 and store the result in the output scattering matrix s.", "input": "", "output": "    subroutine connect_scattering_matrices(s1, s2, s)\n        complex*16, dimension(2,2), intent(in) :: s1, s2\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        complex*16 :: nominator\n        nominator = 1d0/(1d0 - s1(2,2)*s2(1,1))\n        s(1,1) = s1(1,1) + s1(1,2)*s2(1,1)*s1(2,1)*nominator\n        s(2,2) = s2(2,2) + s2(2,1)*s1(2,2)*s2(1,2)*nominator\n        s(2,1) = s1(2,1)*s2(2,1)*nominator\n        s(1,2) = s1(1,2)*s2(1,2)*nominator\n    end subroutine connect_scattering_matrices\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_v_i32_3d to allocate a 3D array using Kokkos. The subroutine takes 4 input parameters of type (c_ptr), integer (c_int), and allocates 2 output parameters of type (c_ptr).", "input": "", "output": "    subroutine f_kokkos_allocate_v_i32_3d(c_a, v_a, n_a, e0, e1, e2) &\n      & bind (c, name='c_kokkos_allocate_v_i32_3d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type (c_ptr), intent(out) :: c_a\n      type (c_ptr), intent(out) :: v_a\n      type (c_ptr), intent(in) :: n_a\n      integer (c_int), intent(in) :: e0\n      integer (c_int), intent(in) :: e1\n      integer (c_int), intent(in) :: e2\n    end subroutine f_kokkos_allocate_v_i32_3d\n"}, {"instruction": "Create a Fortran subroutine named f_kokkos_allocate_dv_i64_3d to allocate a three-dimensional array. It takes 4 input parameters of type (c_ptr), integer (c_int), integer (c_int), integer (c_int), and 2 output parameters of type (c_ptr), type (c_ptr). Use the \"bind\" attribute to bind the subroutine to a specific name.", "input": "", "output": "    subroutine f_kokkos_allocate_dv_i64_3d(c_a, v_a, n_a, e0, e1, e2) &\n      & bind (c, name='c_kokkos_allocate_dv_i64_3d')\n      use, intrinsic :: iso_c_binding\n      implicit none\n      type (c_ptr), intent(out) :: c_a\n      type (c_ptr), intent(out) :: v_a\n      type (c_ptr), intent(in) :: n_a\n      integer (c_int), intent(in) :: e0\n      integer (c_int), intent(in) :: e1\n      integer (c_int), intent(in) :: e2\n    end subroutine f_kokkos_allocate_dv_i64_3d\n"}, {"instruction": "Create a Fortran subroutine named size that takes in 3 input parameters of type integer (l, m, n) and returns 3 output parameters of type integer (nnodes, ntet, ntface). The subroutine computes the number of nodes, tetrahedra, and triangular faces based on the input dimensions l, m, and n.", "input": "", "output": "  subroutine size(l,m,n, nnodes, ntet, ntface)\n\n    integer, intent(in) :: l,m,n\n    integer, intent(out) :: nnodes, ntet, ntface\n\n    continue\n\n    nnodes = l*m*n\n    ntet = 6*(l-1)*(m-1)*(n-1)\n    ntface=4*(l-1)*(m-1)+4*(m-1)*(n-1)+4*(n-1)*(l-1)\n  end subroutine size\n"}, {"instruction": "Create a Fortran subroutine named tridiagonal to solve a tridiagonal linear system using forward and backward substitution. The subroutine takes 4 input parameters of type real, dimension(:), and intent(in) for the tridiagonal coefficients (a, b, c) and the right-hand side vector (r). It returns 1 output parameter of type real, dimension(:), and intent(out) for the solution vector (x). The subroutine utilizes forward elimination and backward substitution to solve the tridiagonal system.", "input": "", "output": "    subroutine tridiagonal(a, b, c, x, r) \n        implicit none \n\n        real, dimension(:), intent(in)  :: a, b, c, r\n        real, dimension(:), intent(out) :: x \n\n        real, dimension(:), allocatable :: beta\n        integer                         :: i, nsize\n\n        ! initialization \n        nsize = size(b)\n        allocate(beta(nsize))\n\n        beta(1) = b(1) \n        x(1)    = r(1) \n\n        ! forward elimination of x_i  \n        do i = 2, nsize \n            beta(i) = b(i) - a(i) * c(i-1) / beta(i-1)\n            x(i)    = r(i) - a(i) * x(i-1) / beta(i-1)\n        end do \n\n        ! backward substitution \n        x(nsize) = x(nsize) / beta(nsize) \n        do i = nsize - 1, 1, -1 \n            x(i) = (x(i) - c(i) * x(i+1)) / beta(i)\n        end do \n\n        deallocate(beta)\n    end subroutine tridiagonal \n"}, {"instruction": "Create a Fortran subroutine named copy_int that takes one input argument of any data type and one output argument of any data type. The input argument is of type class(*) and is passed by intent(in), while the output argument is of type class(*) and is passed by intent(out). If the input argument is of type integer, then the value of the input argument is assigned to the output argument.", "input": "", "output": "  subroutine copy_int(a,b)\n    class(*), intent(in) :: a\n    class(*), intent(out) :: b\n    select type(a); type is(integer) \n    select type(b); type is(integer)\n      b = a\n    end select; end select\n  end subroutine copy_int \n"}, {"instruction": "Write a Fortran subroutine named maxt to calculate the phi values based on the input eflux, ezer, ener, del, nbins, itail, fmono, and emono. The number of input arguments is 8 and the test_data type is ['integer', 'integer', 'real', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "  subroutine maxt (eflux,ezer,ener,del,nbins,itail,fmono,emono,phi)\n\n    implicit none\n\n    integer,intent(in) :: nbins, itail\n    real,intent(in) :: eflux, ezer, ener(nbins), del(nbins), fmono, emono\n    real,intent(out) :: phi(nbins)\n\n    integer :: k\n    real :: te, b, phimax, erat\n\n    te = 0.\n\n    if (ezer < 500.) then\n      b = 0.8*ezer\n    else\n      b = 0.1*ezer + 350.\n    endif\n\n    phimax = exp(-1.)\n\n    do k=1,nbins\n      erat = ener(k) / ezer\n      if (erat > 60.) erat = 60.\n      phi(k) = erat * exp(-erat)\n      if (itail > 0) phi(k) = phi(k) + 0.4*phimax*(ezer/ener(k))*exp(-ener(k)/b)\n      te = te + phi(k) * del(k) * ener(k) * 1.6022e-12\n    enddo\n\n    do k=1,nbins\n      phi(k) = phi(k) * eflux / te\n    enddo\n\n    if (fmono > 0.) then\n      do k=1,nbins\n        if (emono > ener(k)-del(k)/2. .and. emono < ener(k)+del(k)/2.) &\n          phi(k)=phi(k)+fmono/(1.6022e-12*del(k)*ener(k))\n      enddo\n    endif\n\n    return\n\n  end subroutine maxt\n"}, {"instruction": "Create a Fortran subroutine named mean_molecular_weight to calculate the mean molecular weight. The subroutine takes 2 input parameters of type real(8) in arrays x(21) and m(21), and 1 output parameter of type real(8) named mm.", "input": "", "output": "        subroutine mean_molecular_weight(x, m, mm)\n                real(8), intent(in) :: x(21), m(21)\n                real(8), intent(out) :: mm\n                integer :: i\n\n                mm = 0\n                do i = 1, size(x)\n                mm = mm + x(i) * m(i)\n                end do\n                mm = mm / 1000 ! translate to kilograms\n        end subroutine mean_molecular_weight\n"}, {"instruction": "Write a Fortran subroutine named zeta that takes 2 input parameters of type real(8) and a 3x3 matrix of real(8) and returns 1 output parameter of type real(8). The function computes the value of z as 1.d0 plus the product of delta and the element of ar at the 2nd row and 1st column.", "input": "", "output": "   subroutine zeta(delta, ar, z)\n      real(8), intent(in) :: delta, ar(3, 3)\n      real(8), intent(out) :: z\n      z = 1.d0 + delta * ar(2, 1)\n   end subroutine zeta\n"}, {"instruction": "Create a Fortran subroutine named isochoric_heat to calculate the isochoric specific heat. The subroutine takes 4 input parameters of type real(8) (tau, r, ao(3, 3), ar(3, 3)) and 1 output parameter of type real(8) (cv).", "input": "", "output": "   subroutine isochoric_heat(tau, r, ao, ar, cv)\n      real(8), intent(in) :: tau, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: cv\n\n      cv = - tau ** 2.d0 * (ao(3, 2) + ar(3, 2))\n      cv = cv * r\n   end subroutine isochoric_heat\n"}, {"instruction": "Create a Fortran subroutine named isobaric_heat to calculate the isobaric heat capacity. The subroutine takes 5 input parameters of type real(8) (delta, tau, r, ao(3, 3), ar(3, 3)) and 1 output parameter of type real(8) (cp).", "input": "", "output": "   subroutine isobaric_heat(delta, tau, r, ao, ar, cp)\n      real(8), intent(in) :: delta, tau, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: cp\n      real(8) :: up, down\n\n      up = (1.d0 + delta * ar(2, 1) - delta * tau * ar(3, 3)) ** 2.d0\n      down = 1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2.d0 * ar(3, 1)\n\n      cp = - tau ** 2.d0 * (ao(3, 2) + ar(3, 2)) + up / down\n      cp = cp * r\n   end subroutine isobaric_heat\n"}, {"instruction": "Create a Fortran subroutine named isothermal_thermal_coefficent to calculate the isothermal thermal coefficient. The subroutine takes 4 input parameters of type real(8) - delta, tau, rho, and an array ar(3,3), and returns 1 output parameter of type real(8) - delta_t.", "input": "", "output": "   subroutine isothermal_thermal_coefficent(delta, tau, rho, ar, delta_t)\n      real(8), intent(in) :: delta, ar(3, 3), tau, rho\n      real(8), intent(out) :: delta_t\n      real(8) :: up, down\n\n      up = 1.d0 + delta * ar(2, 1) - delta * tau * ar(3, 3)\n      down = 1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 1)\n\n      delta_t = (1.d0 - up / down) / rho\n   end subroutine isothermal_thermal_coefficent\n"}, {"instruction": "Create a Fortran subroutine named dp_drho to calculate the value of dpdrho based on the input parameters. The subroutine has 4 input parameters of type real(8), and they are t, delta, r, and ar (a 3x3 matrix of real(8)). It also has 1 output parameter of type real(8) for the dpdrho value.", "input": "", "output": "   subroutine dp_drho(t, delta, r, ar, dpdrho)\n      real(8), intent(in) :: delta, r, t\n      real(8), intent(out) :: dpdrho\n      real(8), dimension(3, 3), intent(in) :: ar\n\n      dpdrho = r * t * (1.d0 + 2.d0 * delta * ar(2, 1) + (delta ** 2) * ar(3, 1))\n\n   end subroutine dp_drho\n"}, {"instruction": "Create a Fortran subroutine named gibbs_free_energy to calculate the Gibbs free energy using the provided parameters. The subroutine takes 5 input parameters of type real(8) - delta, r, t, ao(3, 3), ar(3, 3), and has 1 output parameter of type real(8) - g.", "input": "", "output": "   subroutine gibbs_free_energy(delta, r, t, ao, ar, g)\n      real(8), intent(in) :: delta, r, t, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: g\n\n      g = (1.d0 + ao(1, 1) + ar(1, 1) + delta * ar(2, 1)) * r * t\n   end subroutine gibbs_free_energy\n"}, {"instruction": "Write a Fortran subroutine named joule_thomson_coeff to calculate the Joule-Thomson coefficient. The subroutine takes 6 input parameters of type real(8) (delta, tau, rho, r, ao(3, 3), ar(3, 3)) and returns 1 output parameter of type real(8) (jt).", "input": "", "output": "   subroutine joule_thomson_coeff(delta, tau, rho, r, ao, ar, jt)\n      real(8), intent(in) :: delta, tau, rho, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: jt\n      real(8) :: up, down_1, down_2\n\n      up = - (delta * ar(2, 1) + delta ** 2 * ar(3, 1) + delta * tau * ar(3, 3))\n      down_1 = (1.d0 + delta * ar(2, 1) - delta * tau * ar (3, 3)) ** 2\n      down_2 = - tau ** 2 * (ao(3, 2) + ar(3, 2)) * (1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 1))\n\n      jt = up / (down_1 + down_2) / (r * rho * 1000)\n\n   end subroutine joule_thomson_coeff\n"}, {"instruction": "Create a Fortran subroutine named isentropic_exponent to compute the isentropic exponent (k) based on the input parameters delta, tau, ao(3,3), and ar(3,3). The input parameters are of type real(8) and intent in, while the output parameter k is of type real(8) and intent out.", "input": "", "output": "   subroutine isentropic_exponent(delta, tau, ao, ar, k)\n      real(8), intent(in) :: delta, tau, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: k\n      real(8) :: up1, down1, up2, down2\n\n      up1 = 1.d0 + 2 * delta * ar(2, 1) + delta ** 2 * ar(3, 1)\n      down1 = 1.d0 + delta * ar(2, 1)\n      up2 = (1.d0 + delta * ar(2, 1) - delta * tau * ar(2, 3)) ** 2\n      down2 = tau ** 2 * (ao(3, 2) + ar(2, 2)) * (1.d0 + 2.d0 * delta * ar(2, 1) + delta ** 2 * ar(3, 2))\n\n      k = (up1 / down1) * (1.d0 - up2 / down2)\n   end subroutine isentropic_exponent\n"}, {"instruction": "Write a Fortran subroutine named second_thermal_virial_coeff to calculate the second thermal virial coefficient. The subroutine should take 2 input parameters of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "   subroutine second_thermal_virial_coeff(rho_r, ar, b)\n      real(8), intent(in) :: rho_r, ar(3, 3)\n      real(8), intent(out) :: b\n      real(8) :: delta\n\n      delta = 1d-15\n      b = ar(2, 1) / rho_r\n   end subroutine second_thermal_virial_coeff\n"}, {"instruction": "Write a Fortran subroutine named third_thermal_virial_coeff to calculate the third thermal virial coefficient. The subroutine takes 2 input parameters of type real(8) and an array of size 3x3. It returns 1 output parameter of type real(8).", "input": "", "output": "   subroutine third_thermal_virial_coeff(rho_r, ar, c)\n      real(8), intent(in) :: rho_r, ar(3, 3)\n      real(8), intent(out) :: c\n      real(8) :: delta\n\n      delta = 1d-15\n      c = ar(3, 1) / (rho_r ** 2)\n   end subroutine third_thermal_virial_coeff\n"}, {"instruction": "Write a Fortran subroutine named \"first_order_upwind_real\" to calculate the first-order upwind scheme for a given set of input data. The subroutine takes 4 input parameters of types integer, real array of dimension llim, real, and integer. It produces 1 output parameter of type real array of dimension llim.", "input": "", "output": "   subroutine first_order_upwind_real(llim, f, del, sgn, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n\n      if (sgn == -1) then\n         istart = llim\n         iend = llim + n - 1\n      else\n         istart = llim + n - 1\n         iend = llim\n      end if\n\n      ! zero bc, 1st order accurate upwind\n      df(istart) = -f(istart) * sgn / del\n      do i = istart - sgn, iend, -sgn\n         df(i) = sgn * (f(i + sgn) - f(i)) / del\n      end do\n\n   end subroutine first_order_upwind_real\n"}, {"instruction": "Create a Fortran subroutine named fifth_order_upwind_complex to perform 5th order upwind differencing on complex arrays. The subroutine takes 4 input parameters of types integer, complex array of dimension llim, real, and integer. It also has 1 output parameter of type complex array of dimension llim. The subroutine implements a 5th order accurate upwind differencing scheme for complex arrays using the provided input parameters.", "input": "", "output": "   subroutine fifth_order_upwind_complex(llim, f, del, sgn, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      if (sgn == -1) then\n         istart = llim\n         iend = llim + n - 1\n      else\n         istart = llim + n - 1\n         iend = llim\n      end if\n\n      ! zero bc, 1st order accurate upwind\n      df(istart) = -f(istart) * sgn / del\n      ! zero bc, 3rd order accurate upwind\n      i = istart - sgn\n      df(i) = -sgn * (2.*f(i - sgn) + 3.*f(i) - 6.*f(i + sgn)) / (6.*del)\n      ! zero bc, 5th order accurate upwind\n      i = istart - 2 * sgn\n      df(i) = -sgn * (-3.*f(i - 2 * sgn) + 30.*f(i - sgn) + 20.*f(i) - 60.*f(i + sgn) + 15.*f(i + 2 * sgn)) / (60.*del)\n\n      ! 1st order accurate upwind\n      df(iend) = sgn * (f(iend + sgn) - f(iend)) / del\n      ! 3rd order accurate upwind\n      df(iend + sgn) = -sgn * (2.*f(iend) + 3 * f(iend + sgn) - 6.*f(iend + 2 * sgn) + f(iend + 3 * sgn)) / (6.*del)\n\n      ! 5th order accurate upwind\n      do i = istart - 3 * sgn, iend + 2 * sgn, -sgn\n         df(i) = -sgn * (-3.*f(i - 2 * sgn) + 30.*f(i - sgn) + 20.*f(i) - 60.*f(i + sgn) + 15.*f(i + 2 * sgn) - 2.*f(i + 3 * sgn)) &\n                 / (60.*del)\n      end do\n\n   end subroutine fifth_order_upwind_complex\n"}, {"instruction": "Write a Fortran subroutine named third_order_upwind_zed that calculates the third order accurate upwind scheme for a given set of input parameters. The number of input parameters is 9 and the test_data types are ['integer', 'integer', 'integer', 'complex, dimension(llim:)', 'real', 'integer', 'logical', 'complex, dimension(:)', 'complex, dimension(:)']. The number of output parameters is 1 and the test_data type is ['complex, dimension(llim:)'].\n\nThe subroutine takes as input the lower limit (llim), current segment (iseg), total number of segments (nseg), function values (f), grid spacing (del), sign (sgn), left boundary values (fl), right boundary values (fr), and a logical value indicating periodicity (periodic). It calculates the third order accurate upwind scheme and stores the results in the output array df.\n\nThe subroutine first determines the upper limit (ulim) based on the size of the input array f. Depending on the sign value, it sweeps through the array either from more positive to more negative or vice versa. It handles the boundary conditions and computes the appropriate values for df based on the upwind scheme formula. Finally, it calculates the values for df using a loop and stores them in the output array.\n\nEnsure that all input and output arrays are properly dimensioned and initialized before calling this subroutine.", "input": "", "output": "   subroutine third_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df)\n\n      implicit none\n\n      integer, intent(in) :: llim, iseg, nseg\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      logical, intent(in) :: periodic\n      complex, dimension(:), intent(in) :: fl, fr\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, istart, iend, ulim\n\n      ulim = size(f) + llim - 1\n      ! if sgn > 0, then stream speed is negative\n      ! so sweep from more positive to more negative zed\n      if (sgn > 0) then\n         if (iseg == nseg .and. .not. periodic) then\n            i = ulim\n            df(i) = -f(i) / del\n            i = ulim - 1\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*f(i + 1)) / (6.*del)\n         else\n            i = ulim\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*fr(1) + fr(2)) / (6.*del)\n            i = ulim - 1\n            df(i) = -(2.*f(i - 1) + 3.*f(i) - 6.*f(i + 1) + fr(1)) / (6.*del)\n         end if\n         if (iseg == 1 .and. .not. periodic) then\n            i = llim\n            df(i) = (f(i + 1) - f(i)) / del\n         else\n            i = llim\n            df(i) = -(2.*fl(2) + 3 * f(i) - 6.*f(i + 1) + f(i + 2)) / (6.*del)\n         end if\n         istart = ulim\n         iend = llim\n      else\n         if (iseg == 1 .and. .not. periodic) then\n            i = llim\n            df(i) = f(i) / del\n            i = llim + 1\n            df(i) = (2.*f(i + 1) + 3.*f(i) - 6.*f(i - 1)) / (6.*del)\n         else\n            i = llim\n            df(i) = (2.*f(i + 1) + 3 * f(i) - 6.*fl(2) + fl(1)) / (6.*del)\n            i = llim + 1\n            df(i) = (2.*f(i + 1) + 3 * f(i) - 6.*f(i - 1) + fl(2)) / (6.*del)\n         end if\n         if (iseg == nseg .and. .not. periodic) then\n            i = ulim\n            df(i) = (f(i) - f(i - 1)) / del\n         else\n            i = ulim\n            df(i) = (2.*fr(1) + 3 * f(i) - 6.*f(i - 1) + f(i - 2)) / (6.*del)\n         end if\n         istart = llim\n         iend = ulim\n      end if\n\n      ! 3rd order accurate upwind\n      do i = istart - 2 * sgn, iend + sgn, -sgn\n         df(i) = -sgn * (2.*f(i - sgn) + 3 * f(i) - 6.*f(i + sgn) + f(i + 2 * sgn)) / (6.*del)\n      end do\n\n   end subroutine third_order_upwind_zed\n"}, {"instruction": "Write a Fortran subroutine named second_order_centered_real that calculates the second-order centered difference approximation for the derivative of a real-valued function. The number of input parameters is 3, with types ['integer', 'real, dimension(llim:)', 'real']. The number of output parameters is 1, with type ['real, dimension(llim:)'].\n\nThe subroutine takes in an integer llim, which represents the lower limit of the array indices, an array f with indices ranging from llim to the size of f, and a real number del representing the spacing between the points in the function. It then calculates the derivative of the function and stores it in the array df, which also has indices ranging from llim to the size of df.\n\nThe subroutine first sets the derivative at the lower and upper limits to zero. Then, using a for loop, it calculates the derivative at the remaining points using the second-order centered difference approximation. The derivative at each point is computed as the difference between the neighboring points divided by twice the spacing del.\n\nMake sure to call this subroutine with the appropriate input and output arguments to calculate the derivative of a real-valued function using the second-order centered difference approximation.", "input": "", "output": "   subroutine second_order_centered_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      df(istart) = f(istart + 1) / (2.*del)\n      df(iend) = -f(iend - 1) / (2.*del)\n\n      ! 2nd order accurate centered\n      do i = istart + 1, iend - 1\n         df(i) = (f(i + 1) - f(i - 1)) / (2.*del)\n      end do\n\n   end subroutine second_order_centered_real\n"}, {"instruction": "Create a Fortran subroutine named d2_3pt_real to compute the second derivative of a real, one-dimensional array using a 3-point finite difference formula. The subroutine takes two input parameters of type real, dimension(:), and one output parameter of type real, dimension(:). The number of input arguments is 2 and the test_data type is ['real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(:)'].", "input": "", "output": "   subroutine d2_3pt_real(f, d2f, dr)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: f\n      real, dimension(:), intent(in) :: dr\n      real, dimension(:), intent(out) :: d2f\n\n      real :: a, b, c, d\n      integer :: i, n\n\n      n = size(f)\n\n      do i = 2, n - 1\n         a = 2./(dr(i - 1) * (dr(i) + dr(i - 1)))\n         b = -2./(dr(i - 1) * dr(i))\n         c = 2./(dr(i) * (dr(i) + dr(i - 1)))\n         d2f(i) = a * f(i - 1) + b * f(i) + c * f(i + 1)\n      end do\n      i = 1\n      a = (6.*dr(1) + 4.*dr(2) + 2.*dr(3)) &\n          / (dr(1) * (dr(1) + dr(2)) * (dr(1) + dr(2) + dr(3)))\n      b = -(4.*(dr(1) + dr(2)) + 2.*dr(3)) &\n          / (dr(1) * dr(2) * (dr(2) + dr(3)))\n      c = (4.*dr(1) + 2.*(dr(2) + dr(3))) &\n          / ((dr(2) + dr(1)) * dr(2) * dr(3))\n      d = -(4.*dr(1) + 2.*dr(2)) &\n          / ((dr(3) + dr(2) + dr(1)) * (dr(3) + dr(2)) * dr(3))\n      d2f(i) = a * f(1) + b * f(2) + c * f(3) + d * f(4)\n      i = n\n      a = -(4.*dr(n - 1) + 2.*dr(n - 2)) &\n          / (dr(n - 3) * (dr(n - 3) + dr(n - 2)) * (dr(n - 3) + dr(n - 2) + dr(n - 1)))\n      b = (4.*dr(n - 1) + 2.*(dr(n - 2) + dr(n - 3))) &\n          / (dr(n - 3) * dr(n - 2) * (dr(n - 2) + dr(n - 1)))\n      c = -(4.*(dr(n - 1) + dr(n - 2)) + 2.*dr(n - 3)) &\n          / (dr(n - 1) * dr(n - 2) * (dr(n - 2) + dr(n - 3)))\n      d = (6.*dr(n - 1) + 4.*dr(n - 2) + 2.*dr(n - 3)) &\n          / (dr(n - 1) * (dr(n - 1) + dr(n - 2)) * (dr(n - 1) + dr(n - 2) + dr(n - 3)))\n      d2f(i) = a * f(n - 3) + b * f(n - 2) + c * f(n - 1) + d * f(n)\n\n!     ! flag -- this is a hack\n!     ! do not anticipate needing 2nd derivatives\n!     ! at first and last grid points\n!     d2f(1) = d2f(2)\n!     d2f(n) = d2f(n-1)\n\n   end subroutine d2_3pt_real\n"}, {"instruction": "Write a Fortran subroutine named countlen to determine the number of characters in a string before the first \"space\" character is encountered. The subroutine takes 1 input parameter of type character (len=*) and returns 1 output parameter of type integer.", "input": "", "output": "subroutine countlen(string, strlen)\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! \n! name: countlen\n!\n! purpose: this routine receives a fortran string, and returns the number of \n!    characters in the string before the first \"space\" is encountered. it \n!    considers ascii characters 33 to 126 to be valid characters, and ascii \n!    0 to 32, and 127 to be \"space\" characters.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! \n\n   implicit none\n\n   ! arguments\n   character (len=*), intent(in) :: string\n   integer, intent(out) :: strlen\n\n   ! local variables\n   integer :: i, len_str, aval\n   logical :: space\n\n   space = .false.\n   i = 1\n   len_str = len(string)\n   strlen = len_str\n   do while ((i .le. len_str) .and. (.not. space))\n      aval = ichar(string(i:i))\n      if ((aval .lt. 33) .or. (aval .gt. 126)) then\n         strlen = i - 1\n         space = .true.\n      end if\n      i = i + 1\n   end do\nend subroutine countlen\n"}, {"instruction": "Write a Fortran subroutine named createlist to generate an array of real numbers based on the start value, a specified increment (delta), and the number of elements (num). The input parameters include 3 arguments of type real, real, and integer, and the output parameter is an array of real numbers with a dimension of num.", "input": "", "output": "subroutine createlist(start, delta, num, array)\n  implicit none\n  ! parameter\n  real, intent(in)    :: start\n  real, intent(in)    :: delta\n  integer, intent(in) :: num\n  real, intent(out) ,dimension(num) :: array\n\n  ! local\n  integer :: i \n  do i =1, num\n    array(i) = start + (i-1)*delta\n  end do   \n\nend subroutine createlist\n"}, {"instruction": "Create a Fortran subroutine named readnew to read data from a file. The subroutine takes 3 input parameters of type character(len=*), integer, and integer, and 3 output parameters of type real, each with dimensions nx and ny. The function reads the data from the file specified by fname and assigns it to the output arrays lats, lons, and array. If the file opening fails, it stops the program and displays an error message.", "input": "", "output": "subroutine readnew(fname, nx, ny, lats, lons, array)\n  implicit none\n  ! calling\n  character(len=*),intent(in) :: fname\n  integer, intent(in)         :: nx\n  integer, intent(in)         :: ny\n  real, intent(out) ,dimension(nx, ny) :: lats\n  real, intent(out) ,dimension(nx, ny) :: lons\n  real, intent(out) ,dimension(nx, ny) :: array\n\n  ! local\n  character(200)    :: errormg ! the message of fail opening   \n  integer           :: ierror  ! flag for allocate \n  open(100,file=fname, form='unformatted', iostat=ierror, iomsg=errormg)\n       read(100) lats\n       read(100) lons\n       read(100) array\n  ! check if writing data is successfule. \n  if(ierror /= 0) then\n    write(*,*) errormg\n    stop\n  end if\n  close(100)\nend subroutine readnew\n"}, {"instruction": "Create a Fortran subroutine named ind to determine the indices of the lon and lat values in the lons and lats arrays, respectively. The subroutine takes 6 input parameters of types integer, integer, real array with dimension nx, real array with dimension ny, real, and real. It returns 2 output parameters of type integer.", "input": "", "output": "subroutine ind(nx, ny, lons, lats, lon, lat, ix, iy)\n  implicit none\n  ! calling\n  integer, intent(in)   :: nx\n  integer, intent(in)   :: ny\n  real, intent(in), dimension(nx) :: lons\n  real, intent(in), dimension(ny) :: lats  \n\n  real, intent(in)  ::  lon\n  real, intent(in)  ::  lat\n\n  integer, intent(out) :: ix\n  integer, intent(out) :: iy\n\n  ! local\n   integer :: i \n\n   ix=0\n   iy=0  \n   do i=1,nx-1\n      if ( lons(i)<= lon .and. lons(i+1)> lon  ) then\n        ix=i\n        exit \n      end if   \n   end do  \n\n   do i=1,ny-1\n      if ( lats(i)<= lat .and. lats(i+1)> lat  ) then\n        iy=i\n        exit \n      end if   \n   end do \nend subroutine  ind\n"}, {"instruction": "Create a Fortran subroutine named get_commandline_option to retrieve the position and number of arguments for a specified command from the command line. The subroutine takes 1 input parameter of type character(len=*), and provides 2 output parameters of type integer.", "input": "", "output": "subroutine get_commandline_option(cmd,pos,nargs)\n   character(len=*),intent(in) :: cmd\n   integer,intent(out) :: pos\n   integer,intent(out) :: nargs\n   character(len=len_trim(cmd)) :: buf\n   character(len=2) :: x\n   integer :: i,j,n,cmdlen\n   pos = 0\n   nargs = 0\n   cmdlen = len_trim(cmd)\n   n = command_argument_count()\n   do i=1,n\n      call get_command_argument(i,buf)\n      if(cmd(1:cmdlen)==buf(1:cmdlen)) then\n         pos = i\n         do j=i+1,n\n            call get_command_argument(j,x)\n            if(x(1:2)=='--') return\n            nargs = nargs + 1\n         end do\n      end if\n   end do\nend subroutine get_commandline_option\n"}, {"instruction": "Write a Fortran subroutine named split to separate a string into individual words. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters: an integer representing the number of words and an array of characters containing the individual words.", "input": "", "output": "subroutine split(str,n,items)\n   character(len=*),intent(in) :: str\n   integer,intent(out) :: n\n   character(len=*),intent(out) :: items(:)\n   character(len=len(str)) :: line\n   integer :: i,p,c,limit\n   n = 0\n   line = str\n   limit = size(items)\n   do i=1,limit\n      line = adjustl(line)\n      p = index(line,' ')\n      if(p == 1) then\n         exit\n      else if(p == 0) then\n         c = len(line)\n      else\n         c = p-1\n      end if\n      items(i) = line(1:c)\n      line(1:c) = repeat(' ',c)\n      n = n + 1\n   end do\nend subroutine split\n"}, {"instruction": "Create a Fortran subroutine named ising to perform the Ising model simulation. This subroutine takes 5 input parameters of types ['integer (kind=4)', 'integer (kind=4)', 'integer (kind=4)', 'integer (kind=4)', 'real (kind=8)'] and 3 output parameters of types ['real (kind=8)', 'real (kind=8)', 'real (kind=8)']. The subroutine initializes a lattice and performs the Ising model simulation for a specified number of Monte Carlo steps. The output parameters m, chi, and c represent the magnetization, susceptibility, and specific heat, respectively.", "input": "", "output": "    subroutine ising(l, t, next_i, prev_i, mcs, m, chi, c)\n    implicit none\n    integer (kind=4),intent(in) :: l, mcs, next_i(l), prev_i(l)\n    real (kind=8), intent(in) :: t\n    real (kind=8), intent(out) :: m, chi, c\n    integer (kind=4):: lattice(l,l), i,j,k, delta_e, no_of_probes\n    real (kind=8) :: boltzmann_factor(5), e=0.0d0, m_k=0.0d0, magnetizations = 0.0d0, magnetizations2 = 0.0d0, energies=0.0d0,&\n             energies2=0.0d0, r\n\n    no_of_probes=(mcs-30000)/100\n    lattice = 1\n    \n    do i=-8,8,4\n        boltzmann_factor(i/4 + 3) = exp(-i / t)\n    end do\n\n    magnetizations = 0.0d0\n    magnetizations2 = 0.0d0\n    energies = 0.0d0\n    energies2 = 0.0d0\n    do k=1, mcs\n        do j=1, l\n            do i=1, l\n                delta_e = 2 * lattice(i,j) * (lattice(next_i(i),j) + lattice(prev_i(i),j) + &\n                                                lattice(i,next_i(j)) + lattice(i, prev_i(j)))\n                if (delta_e <= 0) then\n                    lattice(i,j) = -lattice(i,j)\n                else\n                    call random_number(r) \n                    if (r <= boltzmann_factor(delta_e/4 + 3)) then\n                        lattice(i,j) = -lattice(i,j)\n                    end if\n                end if\n            end do\n        end do\n\n        if ((30000 < k) .and. (mod(k,100)==0)) then\n            m_k = 0.0d0\n            e = 0.0d0\n            do j=1,l\n                do i=1,l\n                    m_k = m_k + lattice(i,j)\n                    e = e + lattice(i,j) * (lattice(next_i(i),j) + lattice(i,next_i(j)))\n                end do\n            end do\n            m_k = abs(m_k / l**2)\n            magnetizations = magnetizations + m_k\n            magnetizations2 = magnetizations2 + m_k**2\n            energies = energies + e\n            energies2 = energies2 + e**2\n        end if\n    end do\n    m = magnetizations / no_of_probes\n    chi = l**2 / t * (magnetizations2 - magnetizations**2 / no_of_probes)/no_of_probes\n    c = (energies2 - energies**2 / no_of_probes)/no_of_probes / l**2 / t**2    \n    end subroutine ising\n"}, {"instruction": "Write a Fortran subroutine named array_out to initialize two arrays. The subroutine should take 2 input arguments of type integer and 2 output arguments of type integer and integer array of size ny. The subroutine initializes the array x with the value 20 and array y with the value 30.", "input": "", "output": "  subroutine array_out(nx,ny,x,y)\n    integer, intent(in) :: nx,ny\n    integer, intent(out) :: x(nx)\n    integer, dimension(ny), intent(out) :: y\n    x = 20\n    y = 30\n  end subroutine  array_out\n"}, {"instruction": "Create a Fortran subroutine named set_occupied_orbitals that takes two input parameters of type integer, \"state\" and \"n\", and one output parameter of type integer, \"ia\". The subroutine sets the occupied orbitals based on the state and the number of orbitals, and stores the result in the \"ia\" array.", "input": "", "output": "    subroutine set_occupied_orbitals(state,ia,n)\n    integer,intent(in)::state,n\n    integer,intent(out)::ia(n)\n\n    integer i,isum\n\n    ia=0; isum=0\n    do i=1,n\n        if(btest(state,i-1))then\n            isum=isum+1\n            ia(isum)=i\n        endif\n    enddo\n    return\n\n    end subroutine set_occupied_orbitals\n"}, {"instruction": "Write a Fortran subroutine named sum_empty_slots_fs that takes 3 input parameters of type integer: bs, m, and ilist(m), and 1 output parameter of type integer: sume. The subroutine calculates the sume by counting the number of empty slots in an array ilist based on the bit pattern specified by bs.", "input": "", "output": "    subroutine sum_empty_slots_fs(bs,m,ilist,sume)\n    integer,intent(in)::bs,m,ilist(m)\n    integer,intent(out)::sume\n\n    integer i\n\n    sume=0\n    do i=1,m\n        if(.not.btest(bs,ilist(i)-1))then\n            sume=sume+1\n        endif\n    enddo\n    return\n\n    end subroutine sum_empty_slots_fs\n"}, {"instruction": "Create a Fortran subroutine named chk_sum_first_empty_slots_fs to check the status of slots in a given array. The subroutine takes 4 input parameters of type integer (bs, m, ilist(m), mfirste) and 1 output parameter of type logical (lfirste). This subroutine checks if the first mfirste slots are empty and the remaining slots are occupied.", "input": "", "output": "    subroutine chk_sum_first_empty_slots_fs(bs,m,ilist,mfirste,lfirste)\n    integer,intent(in)::bs,m,ilist(m),mfirste\n    logical,intent(out)::lfirste\n\n    integer i\n\n    lfirste=.false.\n    ! first mfirste slots should be empty\n    do i=1,mfirste \n        if(btest(bs,ilist(i)-1))return\n    enddo\n    ! the remaining should be occupied.\n    do i=1+mfirste,m\n        if(.not.btest(bs,ilist(i)-1))return\n    enddo\n    lfirste=.true.\n    return\n\n    end subroutine chk_sum_first_empty_slots_fs\n"}, {"instruction": "Create a Fortran subroutine named chk_i_in_list to check if an integer value exists in a given list. The subroutine takes 3 input parameters of type integer: l, m, and list(m), and 1 output parameter of type logical: linls.", "input": "", "output": "    subroutine chk_i_in_list(l,m,list,linls)\n    integer,intent(in)::l,m,list(m)\n    logical,intent(out)::linls\n\n    integer i\n\n    linls=.false.\n    do i=1,m\n        if(l==list(i))then\n            linls=.true.\n            return\n        endif\n    enddo\n    return\n\n    end subroutine chk_i_in_list\n"}, {"instruction": "Create a Fortran subroutine named get_nf90_symbol that takes a single input parameter of type character(len=*) and returns a single output parameter of type integer. The subroutine sets the integer output parameter to -999.", "input": "", "output": "   subroutine get_nf90_symbol(sym_name, ivalue)\n      character(len=*),      intent(in)  :: sym_name\n      integer,               intent(out) :: ivalue\n      ivalue = -999\n   end subroutine get_nf90_symbol\n"}, {"instruction": "Write a Fortran subroutine named extract to search for a specific tag in a list of tags and corresponding real values. The subroutine takes 4 input parameters of type character (of any length), real, character (of length 16), and integer respectively. It also has 2 output parameters of type real and integer. The subroutine's function is to search for a specific tag in the list of tags and return the corresponding real value and an error indicator. If the tag is found, the real value is assigned to the rval parameter, and ierr is set to 0; otherwise, ierr is set to 1 and rval is set to 0.0.", "input": "", "output": "  subroutine extract(tag,rval,rarr,tags,ntags,ierr)    \n    \n    character(len=*), intent(in)  :: tag\n    real, intent(out) :: rval\n    real, intent(in)  :: rarr(:)\n    character(len=16), intent(in)  :: tags(:)\n    integer, intent(in)  :: ntags\n    integer, intent(out) :: ierr\n    logical :: matched\n    integer :: i\n    \n    ierr = 1\n    matched = .false.\n    rval = 0.0 ! default if not found\n    over_tags: do i=1,min(ntags,size(tags))\n       if (trim(tags(i))==trim(adjustl(tag))) then\n          if (size(rarr) >= i) then\n             rval = rarr(i)\n             matched = .true.\n          endif\n          exit over_tags  ! only match first occurrence\n       endif\n    enddo over_tags\n    if (matched) ierr = 0\n    if (ierr.ne.0) print \"(a)\", &\n         ' error: could not find '//trim(adjustl(tag))//' in header'\n  end subroutine extract\n"}, {"instruction": "Write a Fortran subroutine named basisfuns to compute the basis functions for a given parameter value. The subroutine takes 4 input parameters: i (integer), uu (real), p (integer), u (real array), and outputs n (real array).", "input": "", "output": "subroutine basisfuns(i,uu,p,u,n)\n  implicit none\n  integer(kind=4), intent(in) :: i, p\n  real   (kind=8), intent(in) :: uu, u(0:i+p)\n  real   (kind=8), intent(out):: n(0:p)\n  integer(kind=4) :: j, r\n  real   (kind=8) :: left(p), right(p), saved, temp\n  n(0) = 1\n  do j = 1, p\n     left(j)  = uu - u(i+1-j)\n     right(j) = u(i+j) - uu\n     saved = 0\n     do r = 0, j-1\n        temp = n(r) / (right(r+1) + left(j-r))\n        n(r) = saved + right(r+1) * temp\n        saved = left(j-r) * temp\n     end do\n     n(j) = saved\n  end do\nend subroutine basisfuns\n"}, {"instruction": "Create a Fortran subroutine named dersbasisfuns to compute the derivatives of the basis functions for B-spline curves. The subroutine takes 5 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'real   (kind=8)', 'real   (kind=8)'], and 1 output parameter of type ['real   (kind=8)'].", "input": "", "output": "subroutine dersbasisfuns(i,uu,p,n,u,ders)\n  implicit none\n  integer(kind=4), intent(in) :: i, p, n\n  real   (kind=8), intent(in) :: uu, u(0:i+p)\n  real   (kind=8), intent(out):: ders(0:p,0:n)\n  integer(kind=4) :: j, k, r, s1, s2, rk, pk, j1, j2\n  real   (kind=8) :: saved, temp, d\n  real   (kind=8) :: left(p), right(p)\n  real   (kind=8) :: ndu(0:p,0:p), a(0:1,0:p)\n  ndu(0,0) = 1\n  do j = 1, p\n     left(j)  = uu - u(i+1-j)\n     right(j) = u(i+j) - uu\n     saved = 0\n     do r = 0, j-1\n        ndu(j,r) = right(r+1) + left(j-r)\n        temp = ndu(r,j-1) / ndu(j,r)\n        ndu(r,j) = saved + right(r+1) * temp\n        saved = left(j-r) * temp\n     end do\n     ndu(j,j) = saved\n  end do\n  ders(:,0) = ndu(:,p)\n  do r = 0, p\n     s1 = 0; s2 = 1;\n     a(0,0) = 1\n     do k = 1, n\n        d = 0\n        rk = r-k; pk = p-k;\n        if (r >= k) then\n           a(s2,0) = a(s1,0) / ndu(pk+1,rk)\n           d =  a(s2,0) * ndu(rk,pk)\n        end if\n        if (rk > -1) then\n           j1 = 1\n        else\n           j1 = -rk\n        end if\n        if (r-1 <= pk) then\n           j2 = k-1\n        else\n           j2 = p-r\n        end if\n        do j = j1, j2\n           a(s2,j) = (a(s1,j) - a(s1,j-1)) / ndu(pk+1,rk+j)\n           d =  d + a(s2,j) * ndu(rk+j,pk)\n        end do\n        if (r <= pk) then\n           a(s2,k) = - a(s1,k-1) / ndu(pk+1,r)\n           d =  d + a(s2,k) * ndu(r,pk)\n        end if\n        ders(r,k) = d\n        j = s1; s1 = s2; s2 = j;\n     end do\n  end do\n  r = p\n  do k = 1, n\n     ders(:,k) = ders(:,k) * r\n     r = r * (p-k)\n  end do\nend subroutine dersbasisfuns\n"}, {"instruction": "Create a Fortran subroutine named insertknot that takes 9 input parameters of types integer(kind=4) and real(kind=8), and 2 output parameters of type real(kind=8). The purpose of the code is to insert a knot into a B-spline curve. The subroutine uses the imperative tone to define the process of inserting the knot and modifying the control points.", "input": "", "output": "subroutine insertknot(d,n,p,u,pw,uu,k,s,r,v,qw)\n  implicit none\n  integer(kind=4), intent(in)  :: d\n  integer(kind=4), intent(in)  :: n, p\n  real   (kind=8), intent(in)  :: u(0:n+p+1)\n  real   (kind=8), intent(in)  :: pw(d,0:n)\n  real   (kind=8), intent(in)  :: uu\n  integer(kind=4), intent(in)  :: k, s, r\n  real   (kind=8), intent(out) :: v(0:n+p+1+r)\n  real   (kind=8), intent(out) :: qw(d,0:n+r)\n  integer(kind=4) :: i, j, idx\n  real   (kind=8) :: alpha, rw(d,0:p)\n  ! load new knot vector\n  forall (i = 0:k) v(i) = u(i)\n  forall (i = 1:r) v(k+i) = uu\n  forall (i = k+1:n+p+1) v(i+r) = u(i)\n  ! save unaltered control points\n  forall (i = 0:k-p) qw(:,i)   = pw(:,i)\n  forall (i = k-s:n) qw(:,i+r) = pw(:,i)\n  forall (i = 0:p-s) rw(:,i)   = pw(:,k-p+i)\n  ! insert the knot r times\n  do j = 1, r\n     idx = k-p+j\n     do i = 0, p-j-s\n        alpha = (uu-u(idx+i))/(u(i+k+1)-u(idx+i))\n        rw(:,i) = alpha*rw(:,i+1)+(1-alpha)*rw(:,i)\n     end do\n     qw(:,idx) = rw(:,0)\n     qw(:,k+r-j-s) = rw(:,p-j-s)\n  end do\n  ! load remaining control points\n  idx = k-p+r\n  do i = idx+1, k-s-1\n     qw(:,i) = rw(:,i-idx)\n  end do\nend subroutine insertknot\n"}, {"instruction": "Create a Fortran subroutine named tensorprod1 that takes 2 input parameters: an integer (kind=4) named ina and a 2D array of real numbers (kind=8) named in with dimensions (ina,0:4). It also has 5 output parameters: n0, n1, n2 (optional), n3 (optional), and n4 (optional), all of type real (kind=8). The subroutine computes the tensor product of the input array in and assigns the results to the output parameters n0, n1, n2, n3, and n4 based on the presence of each optional parameter. Use the imperative tone to specify these requirements when creating the subroutine.", "input": "", "output": "subroutine tensorprod1(ina,in,n0,n1,n2,n3,n4)\n  implicit none\n  integer(kind=4), intent(in)  :: ina\n  real   (kind=8), intent(in)  :: in(ina,0:4)\n  real   (kind=8), intent(out) :: n0(  ina)\n  real   (kind=8), intent(out) :: n1(1,ina)\n  real   (kind=8), intent(out), optional :: n2(    1,1,ina)\n  real   (kind=8), intent(out), optional :: n3(  1,1,1,ina)\n  real   (kind=8), intent(out), optional :: n4(1,1,1,1,ina)\n  integer(kind=4)  :: ia\n  do ia=1,ina\n     n0(ia) = in(ia,0)\n  end do\n  do ia=1,ina\n     n1(1,ia) = in(ia,1)\n  end do\n  if (.not. present(n2)) return\n  do ia=1,ina\n     n2(1,1,ia) = in(ia,2)\n  end do\n  if (.not. present(n3)) return\n  do ia=1,ina\n     n3(1,1,1,ia) = in(ia,3)\n  end do\n  if (.not. present(n4)) return\n  do ia=1,ina\n     n4(1,1,1,1,ia) = in(ia,3)\n  end do\nend subroutine tensorprod1\n"}, {"instruction": "Create a Fortran subroutine named evaluate0 to copy the elements of an input array pw to an output array cw. The subroutine has 2 input parameters: an integer array d and a real array pw of length d, and 1 output parameter: a real array cw of length d. Use the imperative tone in your instructions.", "input": "", "output": "subroutine evaluate0(d,pw,cw)\n  integer(kind=4), intent(in)  :: d\n  real   (kind=8), intent(in)  :: pw(d)\n  real   (kind=8), intent(out) :: cw(d)\n  cw = pw\nend subroutine evaluate0\n"}, {"instruction": "Create a Fortran subroutine named getgrid to generate a grid in the specified domain. The subroutine takes 5 input parameters of types integer(kind=4), integer(kind=4), real(kind=8), real(kind=8), and real(kind=8) and returns 5 output parameters of types real(kind=8) of dimension(1:nx), real(kind=8) of dimension(1:ny), complex(kind=8) of dimension(1:nx), complex(kind=8) of dimension(1:ny), and character*100. The subroutine uses OpenMP for parallelization and saves the grid points in text format.", "input": "", "output": "subroutine getgrid(nx,ny,lx,ly,pi,name_config,x,y,kx,ky)\n  use omp_lib\n  implicit none\n  integer(kind=4), intent(in)                           :: nx,ny\n  real(kind=8), intent(in)                              :: lx,ly,pi\n  real(kind=8), dimension(1:nx), intent(out)            :: x\n  real(kind=8), dimension(1:ny), intent(out)            :: y\n  complex(kind=8), dimension(1:nx), intent(out)         :: kx\n  complex(kind=8), dimension(1:ny), intent(out)         :: ky\n  character*100, intent(out)                            :: name_config\n  integer(kind=4)                                       :: i,j\n  !$omp parallel do private(i) schedule(static)\n  do i=1,1+nx/2\n     kx(i)= cmplx(0.0d0,1.0d0)*real(i-1,kind(0d0))/lx\n  end do\n  !$omp end parallel do\n  kx(1+nx/2)=0.0d0\n  !$omp parallel do private(i) schedule(static)\n  do i = 1,nx/2 -1\n     kx(i+1+nx/2)=-kx(1-i+nx/2)\n  end do\n  !$omp end parallel do\n\n  !$omp parallel do private(i) schedule(static)\n  do i=1,nx\n     x(i)=(-1.0d0 + 2.0d0*real(i-1,kind(0d0))/real(nx,kind(0d0)))*pi*lx\n  end do\n  !$omp end parallel do\n  !$omp parallel do private(j) schedule(static)\n  do j=1,1+ny/2\n     ky(j)= cmplx(0.0d0,1.0d0)*real(j-1,kind(0d0))/ly\n  end do\n  !$omp end parallel do\n  ky(1+ny/2)=0.0d0\n  !$omp parallel do private(j) schedule(static)\n  do j = 1,ny/2 -1\n     ky(j+1+ny/2)=-ky(1-j+ny/2)\n  end do\n  !$omp end parallel do\n  !$omp parallel do private(j) schedule(static)\n  do j=1,ny\n     y(j)=(-1.0d0 + 2.0d0*real(j-1,kind(0d0))/real(ny,kind(0d0)))*pi*ly\n  end do\n  !$omp end parallel do\n  ! save x grid points in text format\n  name_config = 'xcoord.dat'\n  open(unit=11,file=name_config,status=\"unknown\")\n  rewind(11)\n  do i=1,nx\n     write(11,*) x(i)\n  end do\n  close(11)\n  ! save y grid points in text format\n  name_config = 'ycoord.dat'\n  open(unit=11,file=name_config,status=\"unknown\")\n  rewind(11)\n  do j=1,ny\n     write(11,*) y(j)\n  end do\n  close(11)\nend subroutine getgrid\n"}, {"instruction": "Write a Fortran subroutine named calcenergy to calculate the potential energy of a system consisting of atoms in a given dimensional space. The number of input parameters is 3, with test data types ['integer', 'integer', 'real(8), dimension(0:natom-1, 0:dim-1)']. The number of output parameters is 1, with the test data type ['real(8)'].", "input": "", "output": "subroutine calcenergy(pos, penergy, dim, natom)\r\n    implicit none\r\n    integer, intent(in) :: dim, natom\r\n    real(8), intent(in), dimension(0:natom-1, 0:dim-1) :: pos\r\n    real(8), intent(out) :: penergy\r\n    real(8), dimension(dim) :: rij, posi\r\n    real(8) :: d2, id2, id6, id12\r\n    real(8) :: alpha\r\n    integer :: i, j\r\n    !alpha varies with system size\r\n    alpha = 0.0001 * dble(natom)**(-2./3.)\r\n    penergy = 0.\r\n    do i = 0, natom - 1\r\n        !store pos(i,:) in a temporary array for faster access in j loop\r\n        posi = pos(i,:)\r\n        do j = i + 1, natom - 1\r\n            rij = pos(j,:) - posi\r\n            d2 = sum(rij * rij)\r\n            id2 = 1. / d2            !inverse squared distance\r\n            id6 = id2 * id2 * id2    !inverse sixth distance\r\n            id12 = id6 * id6         !inverse twelvth distance\r\n            penergy = penergy + 4. * (id12 - id6)\r\n        enddo\r\n        !compute the single-body term\r\n        penergy = penergy + alpha * sum(posi * posi)\r\n    enddo\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named loadx to calculate a table of x-values based on a given density code. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 2, with test_data type ['integer', 'real,dimension(:)']. The subroutine calculates the x-values based on the density code, with very dense values at the nose, less dense on the forward airfoil, and much less dense on the aft airfoil.", "input": "", "output": "subroutine loadx(dencode,nx,x)\r\n! ------------------------------------------------------------------------------\r\n! purpose -calculates a table of x-values to be used for the output.\r\n!   they are very dense at the nose, less dense on the forward airfoil\r\n!   and much less dense on the aft airfoil.\r\n\r\nimplicit none\r\n  integer,intent(in):: dencode   ! density code: 1=sparse; 2=medium; 3=dense\r\n  integer,intent(out):: nx\r\n  real,intent(out),dimension(:):: x\r\n\r\n  real,parameter,dimension(26):: coarse = (/ 0.0,0.005,0.0075,0.0125,       &\r\n    0.025,0.05,0.075,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,          &\r\n    0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.0 /)\r\n  real,parameter,dimension(64):: medium = (/ 0.0, 0.0002, 0.0005, 0.001,    &\r\n    0.0015,0.002,0.005,0.01,0.015,0.02,0.03,0.04,0.05,0.06,0.08,0.10,0.12,  &\r\n    0.14,0.16,0.18,0.20,0.22,0.24,0.26,0.28,0.30,0.32,0.34,0.36,0.38,0.40,  &\r\n    0.42,0.44,0.46,0.48,0.50,0.52,0.54,0.56,0.58,0.60,0.62,0.64,0.66,0.68,  &\r\n    0.70,0.72,0.74,0.76,0.78,0.80,0.82,0.84,0.86,0.88,0.90,0.92,0.94,0.96,  &\r\n    0.97,0.98,0.99,0.995,1.0 /)\r\n  real,parameter,dimension(98):: fine = (/ 0.0, 0.00005, 0.0001, 0.0002,    &\r\n    0.0003, 0.0004, 0.0005, 0.0006, 0.0008, 0.0010, 0.0012, 0.0014, 0.0016, &\r\n    0.0018,0.002,0.0025,0.003,0.0035,0.004,0.0045,0.005,0.006,0.007,0.008,  &\r\n    0.009, 0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.018,0.02,0.025,0.03,  &\r\n    0.035,0.04,0.045,0.05,0.055,0.06,0.07,0.08,0.09,0.10,0.12,              &\r\n    0.14,0.16,0.18,0.20,0.22,0.24,0.26,0.28,0.30,0.32,0.34,0.36,0.38,0.40,  &\r\n    0.42,0.44,0.46,0.48,0.50,0.52,0.54,0.56,0.58,0.60,0.62,0.64,0.66,0.68,  &\r\n    0.70,0.72,0.74,0.76,0.78,0.80,0.82,0.84,0.86,0.88,0.90,0.92,0.94,0.95,  &\r\n    0.96,0.97,0.975,0.98,0.985,0.99,0.995,0.999,1.0 /)\r\n!  integer:: k\r\n!----------------------------------------------------------------------------\r\n  select case (dencode)\r\n      case (2)\r\n        nx=size(medium)\r\n        x(1:nx)=medium\r\n      case (3)\r\n        nx=size(fine)\r\n        x(1:nx)=fine\r\n      case default    ! dencode=1 and anything else (probably an accident)\r\n        nx=size(coarse)\r\n        x(1:nx)=coarse\r\n  end select\r\n  return\r\nend subroutine loadx   ! -------------------------------------------------------\r\n"}, {"instruction": "Write a Fortran subroutine named meanline2 to calculate the displacement and slope of the NACA 2-digit mean line. The subroutine takes 3 input parameters of type real (cmax, xmaxc) and real array x. It returns 2 output parameters of type real arrays ym and ymp.", "input": "", "output": "subroutine meanline2(cmax,xmaxc,x,ym,ymp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute displacement and slope of the naca 2-digit mean line.\r\n! note - e.g., a naca mean line 64 has cmax=0.06 and xmax=0.4\r\n! ref - eq 6.4, p.114 of abbott and von doenhoff\r\n\r\nimplicit none\r\n\r\n  real,intent(in):: cmax   ! max. camber as fraction of chord\r\n  real,intent(in):: xmaxc  ! fraction of chord where the camber is max.\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: ym,ymp\r\n\r\n  integer:: k,n\r\n  real:: slope,slope1,slope2\r\n  real:: theta\r\n!-------------------------------------------------------------------------------\r\n  slope1=2.0*cmax/xmaxc\r\n  slope2=-2.0*cmax/(1.0-xmaxc)\r\n  n=size(x)\r\n  do k=1,n\r\n    if (x(k) < xmaxc) then\r\n      theta=x(k)/xmaxc\r\n      slope=slope1\r\n    else\r\n      theta=(1.0-x(k))/(1.0-xmaxc)\r\n      slope=slope2\r\n    end if\r\n    ym(k)=theta*(2.0-theta)\r\n    ymp(k)=slope*(1.0-theta)\r\n  end do\r\n\r\n  ym(1:n)=cmax*ym(1:n)\r\n  return \r\nend subroutine meanline2   ! ---------------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named meanline6m to compute the displacement and slope of a modified six-series mean line for use with the 6A-series airfoil profiles. The subroutine should take 2 input parameters of type real and real, dimension(:), and return 2 output parameters of type real, dimension(:), and real, dimension(:).", "input": "", "output": "subroutine meanline6m(cl,x,ym,ymp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the displacement and slope of a modified six-series mean \r\n!   line as designed for use with the 6a-series profiles.\r\n! ref - p.210 of naca report 903 (larry loftin).\r\n! note - a is not an input variable; it is always 0.8 for this mean line.\r\n\r\nimplicit none\r\n\r\n  real,intent(in):: cl   ! the design lift coefficient\r\n \r\n  real,intent(in),dimension(:):: x   ! fraction of chord\r\n  real,intent(out),dimension(:):: ym   ! y-coor of meanline\r\n  real,intent(out),dimension(:):: ymp   ! dy/dx of mean line\r\n\r\n  real,parameter:: a = 0.8   ! chordwise extent of uniform loading 0<=a<=1\r\n  real,parameter:: zero=0.0, one=1.0, two=2.0, half=0.5, fourth=0.25\r\n  real,parameter:: pi=3.141592654, twopi=two*pi, eps= 1e-7\r\n\r\n  real:: amx\r\n  real:: g,h\r\n  integer:: k,n\r\n  real:: oma\r\n  real:: omx\r\n  real:: term1,term2, term1p,term2p\r\n  real:: teslope\r\n  real:: xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  ym(1:n)=zero\r\n  ymp(1:n)=zero\r\n\r\n  oma=one-a\r\n  teslope=-0.24521*cl\r\n\r\n  do k=1,n\r\n    xx=x(k)\r\n\r\n    if (xx<eps) then\r\n      ym(k)=zero\r\n      ymp(k)=zero\r\n      cycle\r\n    end if\r\n\r\n    omx= one-xx\r\n    if (omx < eps) then\r\n      ym(k)=zero\r\n      ymp(k)=teslope\r\n      cycle\r\n    end if\r\n\r\n    g=-(a*a*(half*log(a)-fourth)+fourth)/oma\r\n    h=g+(half*oma*oma*log(oma)-fourth*oma*oma)/oma\r\n\r\n    amx= a-xx\r\n    if (abs(amx) < eps) then\r\n      term1=zero\r\n      term1p=zero\r\n    else\r\n      term1=amx*amx*(two*log(abs(amx))-one)\r\n      term1p=-amx*log(abs(amx))\r\n    end if\r\n\r\n    term2=omx*omx*(one-two*log(omx))\r\n    term2p=omx*log(omx)\r\n\r\n    ym(k)=fourth*(term1+term2)/oma - xx*log(xx) + g - h*xx\r\n    ymp(k)=(term1p+term2p)/oma - one - log(xx) - h\r\n  end do\r\n\r\n  ym(1:n)=ym(1:n)*cl*0.97948/(twopi*(a+one))\r\n  ymp(1:n)=ymp(1:n)*cl*0.97948/(twopi*(a+one))\r\n\r\n  do k=1,n   ! this is the special treatment...\r\n    if (x(k) > 0.86) then      \r\n      ym(k)=teslope*(x(k)-1.0)\r\n      ymp(k)=teslope\r\n    end if\r\n  end do\r\n\r\n  return\r\nend subroutine meanline6m  ! ---------------------------------------------------\r\n"}, {"instruction": "Write a Fortran subroutine named thickness4 that computes the values of y, dy/dx, and d2y/dx2 at each point of x. It takes 2 input parameters of type real and real, dimension(:), and 3 output parameters of type real, dimension(:), real, dimension(:), optional, and real, dimension(:), optional.", "input": "", "output": "subroutine thickness4(toc,x,y,yp,ypp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the values of y, dy/dx, d2y/dx2 at each point of x\r\n\r\nimplicit none\r\n  real,intent(in):: toc\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: y\r\n  real,intent(out),dimension(:),optional:: yp\r\n  real,intent(out),dimension(:),optional:: ypp\r\n\r\n  real,parameter:: a0 =  0.2969\r\n  real,parameter:: a1 = -0.1260\r\n  real,parameter:: a2 = -0.3516, a22=a2+a2\r\n  real,parameter:: a3 =  0.2843, a33=a3+a3+a3\r\n  real,parameter:: a4 = -0.1015, a42=a4+a4, a44=a42+a42\r\n  integer:: k,n\r\n  real:: srx,xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  if (present(yp))  yp(1)=1e22\r\n  if (present(ypp)) ypp(1)=-1e22\r\n  do k=1,n    ! based on t/c=0.2\r\n    xx=x(k)\r\n    if (xx==0.0) then\r\n      y(k)=0.0\r\n      if (present(yp))   yp(k)=1e22\r\n      if (present(ypp)) ypp(k)=1e22\r\n    else\r\n      srx=sqrt(xx)\r\n      y(k)=a0*srx+xx*(a1+xx*(a2+xx*(a3+xx*a4)))\r\n      if (present(yp)) &\r\n        yp(k)=0.5*a0/srx + a1 + xx*(a22+xx*(a33+xx*a44))\r\n      if (present(ypp)) &\r\n        ypp(k)=-0.25*a0/(srx*srx*srx) + a22 + 6.0*xx*(a3+xx*a42)\r\n    end if\r\n  end do\r\n\r\n  y(1:n)=(5.0*toc)*y(1:n)       ! convert to correct t/c\r\n  if (present(yp)) yp(1:n)=(5.0*toc)*yp(1:n)\r\n  if (present(ypp)) ypp(1:n)=(5.0*toc)*ypp(1:n)\r\n\r\n  return\r\nend subroutine thickness4   ! --------------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named thickness4sharpte to compute the values of y, dy/dx, and d2y/dx2 at each point of x using an equation that generates an airfoil similar to the four-digit airfoil profile with a sharp trailing edge. The subroutine must take 2 input parameters of type real and real, dimension (:), and have 3 output parameters of type real, dimension (:), real, dimension (:), optional, and real, dimension (:), optional.", "input": "", "output": "subroutine thickness4sharpte(toc,x,y,yp,ypp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the values of y, dy/dx, d2y/dx2 at each point of x\r\n!   the equation used gives an airfoil that is very similar to the four digit\r\n!   airfoil profile, but has a sharp trailing edge.\r\n!  this airfoil does not have any naca blessing, so it is strictly unofficial.\r\n!  lots of folks want to compute a four-digit section, but are using a theory\r\n!  that assumes a zero trailing edge.\r\n\r\nimplicit none\r\n  real,intent(in):: toc\r\n  real,intent(in),dimension(:):: x\r\n  real,intent(out),dimension(:):: y\r\n  real,intent(out),dimension(:),optional:: yp\r\n  real,intent(out),dimension(:),optional:: ypp\r\n\r\n  real,parameter:: a0 =  0.2969\r\n  real,parameter:: a1 = -0.1260\r\n  real,parameter:: a2 = -0.3516, a22=a2+a2\r\n  real,parameter:: a3 =  0.2843, a33=a3+a3+a3\r\n  real,parameter:: a4 = -0.1036, a42=a4+a4, a44=a42+a42   ! slightly changed\r\n  integer:: k,n\r\n  real:: srx,xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  if (present(yp))  yp(1)=1e22\r\n  if (present(ypp)) ypp(1)=-1e22\r\n  do k=1,n    ! based on t/c=0.2\r\n    xx=x(k)\r\n    if (xx==0.0) then\r\n      y(k)=0.0\r\n      if (present(yp))   yp(k)=1e22\r\n      if (present(ypp)) ypp(k)=1e22\r\n    else\r\n      srx=sqrt(xx)\r\n      y(k)=a0*srx+xx*(a1+xx*(a2+xx*(a3+xx*a4)))\r\n      if (present(yp)) &\r\n        yp(k)=0.5*a0/srx + a1 + xx*(a22+xx*(a33+xx*a44))\r\n      if (present(ypp)) &\r\n        ypp(k)=-0.25*a0/(srx*srx*srx) + a22 + 6.0*xx*(a3+xx*a42)\r\n    end if\r\n  end do\r\n\r\n  y(1:n)=(5.0*toc)*y(1:n)       ! convert to correct t/c\r\n  if (present(yp)) yp(1:n)=(5.0*toc)*yp(1:n)\r\n  if (present(ypp)) ypp(1:n)=(5.0*toc)*ypp(1:n)\r\n\r\n  return\r\nend subroutine thickness4sharpte   ! -------------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_count to retrieve the count of global vectors based on the provided gvec_id and rank. The subroutine should have 2 input parameters of type integer (gvec_id and rank) and 1 output parameter of type integer (gvec_count).", "input": "", "output": "        subroutine sddk_get_gvec_count(gvec_id, rank, gvec_count)&\n            &bind(c, name=\"sddk_get_gvec_count\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(in)  :: rank\n            integer,                 intent(out) :: gvec_count\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_offset to retrieve the offset of a global vector given its ID and rank. The subroutine should have 2 input parameters of type integer, gvec_id and rank, and 1 output parameter of type integer, gvec_offset.", "input": "", "output": "        subroutine sddk_get_gvec_offset(gvec_id, rank, gvec_offset)&\n            &bind(c, name=\"sddk_get_gvec_offset\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(in)  :: rank\n            integer,                 intent(out) :: gvec_offset\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named num2ch that takes a real number as input and returns a character string representing the number. The input parameter is of type real, intent(in), and there is one output parameter of type character(len=*), intent(out).", "input": "", "output": "subroutine num2ch(r,ch)\n implicit none\n real, intent(in):: r\n character(len=*), intent(out):: ch\n integer:: i,n,n2,nl,nc,nzero\n\n ch='';  n=int(r+0.01)\n nc=3; if(n > 99) nc=3\n nl=10**(nc-1)\n nzero=ichar('0')\n do i=1,nc\n   n2=n/nl\n   ch(i:i)=char(nzero+n2)\n   n=n-n2*nl\n   nl=nl/10\n enddo\nend subroutine num2ch\n"}, {"instruction": "Create a Fortran subroutine named iargsort that takes 3 input parameters of type integer, and 1 output parameter of type integer. The subroutine returns the indices that would sort an array. The input array 'a' contains the numbers, and the output array 'b' contains the indices into the array 'a' that would sort it. The option parameter determines the sorting order: 0 for no action, 1 for ascending order with -1 at the end, and 2 for descending order with -1 pushed to the end.", "input": "", "output": "subroutine iargsort(n, a, b, option)\n    ! returns the indices that would sort an array.\n    integer, intent(in):: n, option\n    integer, intent(in) :: a(n)  ! array of numbers\n    integer, intent(out) :: b(n) ! indices into the array 'a' that sort it\n    !\n    ! example\n    ! iargsort([10, 9, 8, 7, 6])   ! returns [5, 4, 3, 2, 1]\n\n    integer :: i,imin                      ! indices: i, i of smallest\n    integer :: temp                        ! temporary\n    integer :: n1, a2(n), t(n), ic\n    a2 = a\n    do i = 1, n\n        b(i) = i\n    end do\n    do i = 1, n-1\n        ! find ith smallest in 'a'\n        imin = minloc(a2(i:),1) + i - 1\n\n        ! swap to position i in 'a' and 'b', if not already there\n        if (imin /= i) then\n            temp = a2(i)\n            a2(i) = a2(imin)\n            a2(imin) = temp\n            temp = b(i)\n            b(i) = b(imin)\n            b(imin) = temp\n        end if\n    end do\n    \n    ! 0: do nothing\n    ! 1: ascending & (-1 at end), 2: descending & (-1 pushed to end)\n    if (option .eq. 2) then\n        t(:) = b(:)\n        do i = 0,n-1\n            b(i+1) = t(n-i)\n        enddo\n    endif\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named ishare_node to check if any of the given edges share a common node. The subroutine takes 3 input parameters of type integer: nb, edge(2), edges(2,nb). It also has 1 output parameter of type logical: iok.", "input": "", "output": "subroutine ishare_node(edge, nb, edges, iok)\n    implicit none \n    integer, intent(in) :: nb\n    integer, intent(in) :: edge(2),edges(2,nb)\n    logical, intent(out) :: iok\n    integer :: e1,e2\n    e1 = edge(1)\n    e2 = edge(2)\n    iok = .false.\n    if ( any(edges.eq.e1) .or. any(edges.eq.e2) ) then\n        iok = .true.\n    endif\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named is_adjacent_edge to determine if an edge is adjacent to a given set of edges. The subroutine takes 5 input parameters of type integer: nb0, na, edge(2), edges(2,nb0), dsg(na,na), and produces 1 output parameter of type logical: iok.", "input": "", "output": "subroutine is_adjacent_edge(edge, nb0, edges, na, dsg, iok)\n    implicit none\n    integer, intent(in) :: nb0, na\n    integer, intent(in) :: edge(2), edges(2,nb0), dsg(na,na)\n    logical, intent(out) :: iok\n!   logical :: istat\n    integer :: ib,nb,i1,i2,j1,j2, dsi(4)\n    i1 = edge(1)\n    i2 = edge(2)\n    iok = .false.\n    nb = count(edges.gt.0)/2 !size(edges,2)\n    if (nb .eq. 0) stop \"#error: empty `edges?\"\n    !call ishare_node(edge,nb,edges,istat)\n    !if (.not. istat) then\n    do ib = 1,nb\n        j1 = edges(1,ib)\n        j2 = edges(2,ib)\n        dsi(1) = dsg(i1,j1)\n        dsi(2) = dsg(i2,j2)\n        dsi(3) = dsg(i1,j2)\n        dsi(4) = dsg(i2,j1)\n        if ( all(dsi.ge.1) .and. any(dsi.eq.1) ) then\n            iok = .true.\n            exit\n        endif\n    enddo\n    !endif\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named g2triu1d to convert a molecular graph represented as a square matrix 'g' of size 'n' to a one-dimensional upper triangular matrix 'gr' of size 'nr'. The subroutine takes 3 input arguments of type integer: 'n' (size of the square matrix), 'nr' (size of the upper triangular matrix), and 'g' (the square matrix representing the molecular graph). It produces 1 output argument of type integer: 'gr' (the one-dimensional upper triangular matrix).", "input": "", "output": "subroutine g2triu1d(n,g, nr,gr)\n    !\n    ! molecular graph to triu(g) concatenated to 1d\n    !\n    implicit none \n    integer, intent(in) :: n, nr\n    integer, intent(in) :: g(n,n)\n    integer, intent(out) :: gr(nr)\n    integer :: i,j,ic\n    ic = 0\n    do i = 1,n-1\n        do j = i+1,n\n            ic = ic + 1\n            gr(ic) = g(i,j)\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mindex that takes two input arrays of integers and one output array of integers.The number of input arguments is 2 and the test_data type is [integer, integer].The number of output arguments is 1 and the test_data type is [integer].The subroutine computes the multi-index from a single index based on the dimensions provided in the input arrays. If the output array is smaller than required, it is filled with -999.", "input": "", "output": " subroutine mindex(ind,n,i)\n  implicit none\n  integer,intent(in) :: ind, n(:)\n  integer,intent(out) :: i(:)\n  integer :: j\n  if(size(i).gt.size(n)+1)then;i=-999;return;endif\n  i(1)=ind-1\n  do j=2,size(i)\n   i(j)=i(j-1)/n(j-1)\n   i(j-1)=i(j-1)-i(j)*n(j-1)\n  enddo\n  i=i+1\n end subroutine\n"}, {"instruction": "Create a Fortran subroutine named h5md_lookup to perform a binary search on a sorted array. The subroutine takes 2 input parameters of type integer and an array of integers and 1 output parameter of type integer and 1 output parameter of type logical. The input array and the value to be searched for are the input parameters, and the index of the found element and a logical flag indicating success are the output parameters.", "input": "", "output": "  subroutine h5md_lookup(list, wish, idx, success)\n    implicit none\n    integer, intent(in) :: list(:), wish\n    integer, intent(out) :: idx\n    logical, intent(out) :: success\n\n    integer :: low, up, i\n    integer, allocatable :: order_check(:)    \n    \n    success = .false.\n\n    if (size(list) .eq. 1) then\n       if (list(1) .eq. wish) then\n          success = .true.\n          idx = 1\n       end if\n       return\n    end if\n\n    allocate(order_check(size(list)-1))\n    order_check = list(2:size(list))-list(1:size(list)-1)\n    low = minval(order_check)\n    deallocate(order_check)\n    if (low <= 0) then \n       write(*,*) 'nonordered or repeating list in lookup'\n       return\n    end if\n\n    if ( wish < list(1) .or. wish > list(size(list)) ) then\n       write(*,*) wish, ' out of range in lookup'\n       stop\n    end if\n\n    low = 1\n    up = size(list)\n    lookup_loop: do\n       \n       i = (low+up)/2\n       if (list(i) >= wish) then\n          up =i\n       else\n          low=i\n       end if\n       if ( up-low .eq. 1 ) then\n          if (list(up).eq.wish) i=up\n          if (list(low).eq.wish) i=low\n          exit lookup_loop\n       end if\n    end do lookup_loop\n  \n    if (list(i).eq.wish) success=.true.\n    idx = i\n    \n  end subroutine h5md_lookup\n"}, {"instruction": "Create a Fortran subroutine named count_etot to calculate the total energy. It takes 2 input parameters: an integer numl and a 2D integer array spin of size numl x numl. It has 1 output parameter of type real, which is the total energy etot.", "input": "", "output": "subroutine count_etot(numl,spin,etot)\nimplicit none\ninteger,intent(in)  :: numl\ninteger,dimension(numl,numl),intent(in)  :: spin\nreal,intent(out) :: etot\netot = sum(spin)\nend subroutine count_etot\n"}, {"instruction": "Create a Fortran subroutine named randint that generates an array of random integers. The subroutine takes 1 input parameter of type integer and returns an array of random integers with the same size as the input parameter. The input parameter should be specified using the intent(in) attribute and the output parameter using the intent(out) attribute.", "input": "", "output": "  subroutine randint(x,maxint)\n    implicit none\n    integer, intent(out) :: x(:)\n    integer, intent(in) :: maxint\n    real(8) :: r(size(x))\n    call random_number(r)\n    x = int(maxint*r)\n    return\n  end subroutine randint\n"}, {"instruction": "Create a Fortran subroutine named minmod_kolgan to calculate the minimum of two real(8) input parameters and store the result in a separate real(8) output parameter. The subroutine should have 2 input parameters of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine minmod_kolgan(a, b, c)\n  implicit none\n  real(8), intent(in) :: a, b\n  real(8), intent(out) :: c\n\n  if (a==0.0 .or. b==0.0) then\n    c = 0.0\n  else if (a>0.0 .and. b>0.0) then\n    c = min(a,b)\n  else if (a<0.0 .and. b<0.0) then\n    c = max(a,b)\n  else\n    c = 0.0\n  end if\n\nend subroutine minmod_kolgan\n"}, {"instruction": "Create a Fortran subroutine named linearperiodic to calculate the pressure at a given time based on periodic linear loading. The subroutine takes 3 input parameters of type real*8: time, dt, and loadpar. It also has 1 output parameter of type real*8: p.", "input": "", "output": "subroutine linearperiodic(p,time,dt,loadpar) ! periodic load, linear periodic\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t,pmax0, dpmax, pmin0, dpmin\n\t\n\treal*8 :: di, trel, p0, p1\n\tinteger :: i\n\t\n\tt = loadpar(1)\n\tpmax0 = loadpar(2)\n\tdpmax = loadpar(3)\n\tpmin0 = loadpar(4)\n\tdpmin = loadpar(5)\n\t\t\n\tdi = dint(time/t)\n\ttrel = time - di*t\n\ti = int(di)\n\t\n\tif(mod(i,2) == 0) then ! even number\n\t\tp0 = pmin0 + dpmin*di\n\t\tp1 = pmax0 + dpmax*(di+1.0d0)\n\telse ! odd number\n\t\tp0 = pmax0 + dpmax*di\n\t\tp1 = pmin0 + dpmin*(di+1.0d0)\n\tend if\n\t\t\n\tp = p0 + (p1 - p0)*trel/t\n\t\n\twrite(0,*) \"pressure=\", p\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linearpressure to calculate the pressure at a given time based on a flexible load condition. The subroutine takes 3 input parameters of type real*8: time, dt, and loadpar. It also has 1 output parameter of type real*8: p. The pressure is calculated based on the linear change in load between specified time intervals.", "input": "", "output": "subroutine linearpressure(p,time,dt,loadpar) ! flexible load\n\t! p(t0) = 0 , p(t1) = pmax, linearly\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t0,t1, pmax\n\t\n\tpmax = loadpar(1)\n\tt0 = loadpar(2)\n\tt1 = loadpar(3)\n\t\n\tif(time<t1) then\n\t\tp = (time-t0)*pmax/(t1-t0)\n\telse \n\t\tp = pmax\n\tend if\n\t\n\twrite(0,*) \"pressure=\", p\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named adaptative to calculate the value of p based on the input parameters time, dt, and loadpar. The input parameters are of type real*8 and intent(in), and the output parameter p is of type real*8 and intent(out).", "input": "", "output": "subroutine adaptative(p,time,dt,loadpar) \n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: tf,lf,tm,kmin,kini , den, a1, a2, a3\n\n\ttf = loadpar(1)\n\tlf = loadpar(2)\n\ttm = loadpar(3)\n\tkmin = loadpar(4)\n\tkini = loadpar(5)\n\t\n\tden = 3.0d0*(tm**2.0d0)*tf**2.0d0 - 2.0d0*tm*tf**3.0d0\n\ta2 = (3.0d0*(tm**2.0d0)*(lf-kini*tf) - (tf**3.0d0)*(kmin - kini))/den\n\ta3 = (-2.0d0*tm*(lf-kini*tf) + (tf**2.0d0)*(kmin - kini))/den\n\ta1 = kini\n\t\n\tp = a1*time + a2*time**2.0 + a3*time**3.0\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linearramppressure to calculate the pressure at a given time considering a linear variation over time. The subroutine should take 3 input parameters of type real*8 and output 1 parameter of type real*8. The input parameters represent time, time increment, and an array of load parameters, while the output parameter represents the calculated pressure.", "input": "", "output": "subroutine linearramppressure(p,time,dt,loadpar) ! flexible load\n\t! p(t0) = p0 , p(t1) = p1, linearly\n\timplicit none\n\treal*8 , intent(in) :: time,dt,loadpar(:)\n\treal*8 , intent(out) :: p\n\treal*8 :: t0,t1, p0, p1\n\t\n\tp0 = loadpar(1)\n\tp1 = loadpar(2)\n\tt0 = loadpar(3)\n\tt1 = loadpar(4)\n\n\tif(time<t0) then\n\t\tp = p0\t\n\telse if(time<t1) then\n\t\tp = p0 + (time-t0)*(p1-p0)/(t1-t0)\n\telse \n\t\tp = p1\n\tend if\n\t\n\twrite(0,*) \"pressure=\", p, p0, p1, t0, t1\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named count_lines to read a file and count the total number of lines and the number of non-comment lines. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "    subroutine count_lines( lun, lines, noncommentlines )\n    implicit none\n    integer, intent(in) :: lun\n    integer, intent(out) :: lines, noncommentlines\n    integer, parameter :: maxlines = 5000 !maximum number allowed\n    integer :: i\n    character(len=80) :: inline, shiftline\n    logical :: opened\n\n    intrinsic adjustl\n\n    !make sure the file is open\n    inquire( lun, opened=opened )\n    if (.not. opened) then\n        write(*,*) \"file is not open in count_lines\"\n        stop\n    endif\n\n    !now start reading\n    lines = 0\n    noncommentlines = 0\n    do i = 1, maxlines\n        read( lun, '(a)', err=2, end=100 ) inline\n        lines = lines + 1\n        shiftline = adjustl( inline )\n        if ( shiftline(1:1) .ne. '#' ) noncommentlines = noncommentlines+1\n    enddo\n    go to 100\n\n2   write(*,*) \"error reading input file in count_lines\"\n    stop\n\n100 rewind lun\n    end subroutine count_lines\n"}, {"instruction": "Create a Fortran subroutine named calcular_soluciones to read real numbers from a file and store them in an array. The subroutine takes 3 input parameters of types character (len=*), integer, and integer, and 1 output parameter of type real.\n", "input": "", "output": "subroutine calcular_soluciones(file, unit, n, canswer)\n   implicit none\n   \n   character (len=*), intent(in) :: file\n   integer, intent(in) :: unit, n\n   real, intent(out) :: canswer(n)\n\n   real :: num\n   integer :: i\n\n   open (unit=unit,file=file,status='old', form='formatted')\n\n   do i=1, n\n      read (unit=unit, fmt='(e11.6)' ) num\n      canswer(i) = num \n   end do\n\n   close(unit=unit)\nend subroutine calcular_soluciones\n"}, {"instruction": "Create a Fortran subroutine named calcular_nota to calculate the score based on the comparison of answers provided. The subroutine takes 3 input parameters of types real, character (len=500), and integer, and 1 output parameter of type character (len=2).", "input": "", "output": "subroutine calcular_nota(canswer, line, n, cnota)\n   implicit none\n   \n   real, intent(in) :: canswer(n)\n   character (len=500), intent(in) :: line\n   integer, intent(in) :: n\n   character (len=2), intent(out) :: cnota\n\n   integer :: nota, i, j\n   real :: answer(n)\n   character (len=7) :: mantisa(n)\n   integer :: nmantisa(n)\n   character (len=3) :: exponente(n)\n   integer :: nexponente(n)\n\n   nota = 0\n   cnota = ''\n   j = 40\n\n   do i=1, n\n      mantisa(i) = line(j+1:j+7) !respuesta1\n      mantisa(i) = trim(mantisa(i)) // '0000000'\n      read(mantisa(i),'(i7)') nmantisa(i)\n      \n      exponente(i) = line(j+8:j+10)\n      read(exponente(i),'(i3)') nexponente(i)\n         \n      answer(i) = real(nmantisa(i))*(10**real(nexponente(i)))/(10**5)\n         \n      j=j+10\n      \n      if(abs((answer(i) - canswer(i))/canswer(i)) < 10.**(-4.) ) then\n         nota = nota + 1 \n      else \n         nota = nota\n      end if\n   end do\n\n   write(cnota, '(i2)') nota\n\nend subroutine calcular_nota\n"}, {"instruction": "Write a Fortran subroutine named gvec_to_fft_index to convert a general vector to Fast Fourier Transform (FFT) index. The subroutine takes 2 input parameters of type integer, g(3) and nfft(3), and 1 output parameter of type integer, idx(3). The subroutine performs operations to adjust the indices based on the values in the input vectors g and nfft.", "input": "", "output": "  subroutine gvec_to_fft_index(g,idx,nfft)\n    integer, intent(in) :: g(3), nfft(3)\n    integer, intent(out) :: idx(3)\n    ! no push/pop since called too frequently.\n    idx(1:3) = g(1:3) + 1\n    if (g(1) < 0) idx(1) = nfft(1) + idx(1)\n    if (g(2) < 0) idx(2) = nfft(2) + idx(2)\n    if (g(3) < 0) idx(3) = nfft(3) + idx(3)\n    return\n  end subroutine gvec_to_fft_index\n"}, {"instruction": "Create a Fortran subroutine named ssm_title that takes an integer input and returns a 3-character zero-filled string. The input parameter is of type integer, and the output parameter is of type character with a length of 3.", "input": "", "output": "subroutine ssm_title(n,nchar)\n  ! returns integer as a 3-character zero-filled string\n  ! used to generate filenames for tables\n\n  implicit none\n  integer,intent(in)::n\n  character(len=3),intent(out)::nchar\n\n  character(len=1)::nchar1\n  character(len=2)::nchar2\n  character(len=3)::nchar3\n\n  if(n.ge.100)then\n     write(nchar3,'(i3)') n\n     nchar = nchar3\n  elseif(n.ge.10)then\n     write(nchar2,'(i2)') n\n     nchar = '0'//nchar2\n  else\n     write(nchar1,'(i1)') n\n     nchar = '00'//nchar1\n  endif\n\nend subroutine ssm_title\n"}, {"instruction": "Create a Fortran subroutine named \"untaggerxy_2d\" to compute an unstaggered grid using a given horizontally staggered grid. The subroutine should have 5 input parameters of type integer and real: vin, nx, ny, onx, and ony. It should have 1 output parameter of type real: vout. The subroutine should perform linear interpolation based on the input parameters and produce the unstaggered grid in vout. Use the provided code as a reference to implement the subroutine.", "input": "", "output": "subroutine untaggerxy_2d(vin,nx,ny,onx,ony,vout)\n\n!==========================================================\n!  this routine computes a unstagger grid \n!  using a given horizontal stagger grid \n!\n!  input:\n!\tvin:    stagger data prepare to unstagger \t\n!\tnx:\tnumber of stagger grid in x \n!\tny:     number of stagger grid in y\t\n!       onx:    x grid point number after unstagger\n!       ony:    y grid point number after unstagger  \n!\n!  output:\n!\tvout:   data after unstagger\t\n!\n!==========================================================\n\n  implicit none\n\n  integer, intent(in) :: nx,ny,onx,ony\n  real, intent(in) ::    vin(nx,ny)\n  real, intent(out) ::   vout(onx,ony)\n\n  ! local variables:\n    \n    integer :: i,j\n    real :: vinx(onx,ony),viny(onx,ony),vinyy(nx,ony)\n\n  ! linear interpolation:\n  \n    if(nx /= onx .and. ny /= ony) then \n\n          do i=1,nx\n             do j=2,ny\n                   vinyy(i,j) = &\n                   0.5*(vin(i,j-1)+ vin(i,j))\n             enddo\n             vinyy(i,1) = &\n                   1.5*vin(i,1)-&\n                   0.5*vin(i,2)\n             vinyy(i,ony) = &\n                   1.5*vin(i,ny)-&\n                   0.5*vin(i,ny-1)\n          enddo\n\n          do j=1,ony\n             do i=2,nx\n                vinx(i,j) = &\n                0.5*(vinyy(i-1,j)+ vinyy(i,j))\n             enddo\n             vinx(1,j) = &\n                1.5*vinyy(1,j)-&\n                0.5*vinyy(2,j)\n             vinx(onx,j) = &\n                1.5*vinyy(nx,j)-&\n                0.5*vinyy(nx-1,j)\n          enddo\n\n        vout(1:onx,1:ony) = vinx(1:onx,1:ony) \n      \n    elseif(nx /= onx .and. ny == ony) then\n\n          do j=1,ony\n             do i=2,nx\n                vinx(i,j) = &\n                0.5*(vin(i-1,j)+ vin(i,j))\n             enddo\n             vinx(1,j) = &\n                1.5*vin(1,j)-&\n                0.5*vin(2,j)\n             vinx(onx,j) = &\n                1.5*vin(nx,j)-&\n                0.5*vin(nx-1,j)\n          enddo\n\n        vout(1:onx,1:ony) = vinx(1:onx,1:ony)\n\n    elseif(nx == onx .and. ny /= ony) then\n\n          do i=1,onx\n             do j=2,ny\n                   viny(i,j) = &\n                   0.5*(vin(i,j-1)+ vin(i,j))\n             enddo\n             viny(i,1) = &\n                   1.5*vin(i,1)-&\n                   0.5*vin(i,2)\n             viny(i,ony) = &\n                   1.5*vin(i,ny)-&\n                   0.5*vin(i,ny-1)\n          enddo\n \n        vout(1:onx,1:ony) = viny(1:onx,1:ony)\n\n    endif\n \nend subroutine untaggerxy_2d \n"}, {"instruction": "Write a Fortran subroutine named extra_2_east to extrapolate 2 extra east (or north) points of a curve with Akima's 1D method. The subroutine takes 8 input parameters of type real(8): x1, x2, x3, x4, x5, y1, y2, and y3. It returns 2 output parameters of type real(8): y4 and y5.", "input": "", "output": "   subroutine extra_2_east(x1, x2, x3, x4, x5, y1, y2, y3, y4, y5)\n      !!\n      !!============================================================================\n      !!\n      !! extrapolates 2 extra east (or north) points of a curve with akima's 1d method\n      !!\n      !! input  : x1, x2, x3, x4, x5, y1, y2, y3\n      !! output : y4, y5\n      !!\n      !!                       author : laurent brodeau, 2007\n      !!============================================================================\n      !!\n      !!\n      real(8), intent(in)  :: x1, x2, x3, x4, x5, y1, y2, y3\n      real(8), intent(out) :: y4, y5\n      !!\n      !! local :\n      real(8) :: a, b, c, d, alf, bet\n      !!\n      !!\n      a    = x2 - x1\n      b    = x3 - x2\n      c    = x4 - x3\n      d    = x5 - x4\n      !!\n      alf  = y2 - y1\n      bet  = y3 - y2\n      !!\n      if ( (a == 0.).or.(b == 0.).or.(c == 0.) ) then\n         y4 = y3 ; y5 = y3\n      else\n         y4   = c*(2*bet/b - alf/a) + y3\n         y5   = y4 + y4*d/c + bet*d/b - alf*d/a - y3*d/c\n      end if\n      !!\n      !!\n   end subroutine extra_2_east\n"}, {"instruction": "Write a Fortran subroutine named \"locate_point\" that locates a point on a 2D grid. The subroutine takes 4 input parameters of type real(8), real(8), real(8), dimension(:,:), and real(8), dimension(:,:). It returns 2 output parameters of type integer. The subroutine should check the input point against the grid and return the indices of the grid where the point is located.", "input": "", "output": "   subroutine locate_point(rlon_p, rlat_p, xlon, xlat, jxfnd, jyfnd)\n\n      implicit none\n\n      !!===========================================================\n      !!\n      !! input :\n      !! rlon_p, rlat_p : point to be located\n      !! xlon, xlat : 2d arrays contening long. and lat.\n      !!\n      !! output :\n      !! jx, jy     : location\n      !!\n      !!\n      !! l. brodeau, 2005\n      !!===========================================================\n\n      real(8),                 intent(in)  :: rlon_p, rlat_p\n      real(8), dimension(:,:), intent(in)  :: xlon, xlat\n      integer,                 intent(out) :: jxfnd, jyfnd\n\n      !! local :\n      real(8), parameter :: dr = 30.    !! avoid problem at 0. -> 360. for lon\n      real(8), dimension(4) :: v4x, v4y\n      integer :: nx, ny, ji, jj\n      real(8) :: min_x, max_x, min_y, max_y\n\n      nx = size(xlon,1)\n      ny = size(xlon,2)\n\n      jxfnd = -1  ; jyfnd = -1\n\n      do jj=1, ny-1\n         do ji=1, nx-1\n\n            v4x   = (/ xlon(ji,jj) , xlon(ji+1,jj) , xlon(ji+1,jj+1) , xlon(ji,jj+1) /)\n            v4y   = (/ xlat(ji,jj) , xlat(ji+1,jj) , xlat(ji+1,jj+1) , xlat(ji,jj+1) /)\n\n            min_x = minval(v4x)  ;  max_x = maxval(v4x)\n            min_y = minval(v4y)  ;  max_y = maxval(v4y)\n\n            if ( ((rlon_p >= min_x).and.(rlon_p <= max_x)) .and. ( (max_x-min_x) < dr)  ) then\n               if ( (rlat_p >= min_y).and.(rlat_p <= max_y) ) then\n                  jxfnd = ji  ; jyfnd = jj\n               end if\n            end if\n\n         end do\n      end do\n\n   end subroutine locate_point\n"}, {"instruction": "Write a Fortran subroutine named find_mode_4d that takes 5 input parameters of type integer and integer arrays of dimensions naxis1, naxis2, naxis3, naxis4, and an output parameter of type integer array of dimensions naxis2, naxis3, naxis4. The subroutine reduces the first dimension of a four-dimensional array to the mode of that dimension for slices spanning that dimension at each point in the remaining dimensions.", "input": "", "output": "subroutine find_mode_4d(array_in,array_out,naxis1,naxis2,naxis3,naxis4)\n\n!reduces the first dimension of a four dimensional array to the mode of that\n!dimension for slices spanning that dimension at each point in the remaining dimensions\n\nimplicit none\n\n!variables with intent in\n!dimensions of the input array\ninteger, intent(in) :: naxis1, naxis2, naxis3, naxis4\n!input array\ninteger, intent(in), dimension(naxis1,naxis2,naxis3,naxis4) :: array_in\n\n!variables with intent out\n!output array\ninteger, intent(out), dimension(naxis2,naxis3,naxis4) :: array_out\n\n!local variables\n!list of counts of unique values found in a slice\ninteger, allocatable, dimension(:) :: unique_nums\n!highest number in the input array\ninteger :: max_num\n!counters\ninteger :: i,j,k,l\n    !assuming all values are non-negative this (+1) is the maximum number of elements\n    !the list of unique values requires\n    max_num = maxval(array_in)\n    !create a static list of counts of unique values and initialize to zero\n    allocate(unique_nums(max_num+1))\n    unique_nums = 0\n    !iterate over each point in all the dimensions other than the first\n    do l = 1,naxis4\n        do k = 1,naxis3\n            do j = 1,naxis2\n                !iterate over a slice of the first dimension\n                do i = 1,naxis1\n                    !ignore negative values\n                    if (array_in(i,j,k,l) < 0) cycle\n                    !increment count for this value of this element, add offset of 1 as count\n                    !of the value zero is held in position 1\n                    unique_nums(array_in(i,j,k,l) + 1) = unique_nums(array_in(i,j,k,l) + 1) + 1\n                end do\n                !allocate the value of this point in the output array as the highest count found\n                !in the list of unique values and then reset the array to 0 for the next cycle\n                array_out(j,k,l) = maxloc(unique_nums,1) - 1\n                unique_nums = 0\n            end do\n        end do\n    end do\n    deallocate(unique_nums)\nend subroutine find_mode_4d\n"}, {"instruction": "Create a Fortran subroutine named fstring_split to split a string into tokens based on given delimiters. The subroutine takes 2 input parameters of type character(*) and 1 output parameter of type character(*), which is allocatable.", "input": "", "output": "\tsubroutine fstring_split( str, tokens, delimiters )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(*), allocatable, intent(out) :: tokens(:)\n\t\tcharacter(*), intent(in) :: delimiters\n\t\t\n\t\tinteger, allocatable :: postokenbegin(:), postokenend(:)\n\t\tlogical :: isdelimiter, isdelimiterprev\n\t\tinteger :: ntokens\n\t\tinteger :: i, j\n\t\t\n\t\tif( allocated(tokens) ) then\n\t\t\tdeallocate(tokens)\n\t\tend if\n\t\t\n\t\tif( len(trim(str)) == 0 ) then\n\t\t\tallocate( tokens(1) )\n\t\t\ttokens(1) = str\n\t\t\treturn\n\t\tend if\n\t\t\n\t\t! en el peor de los casos todos los caracteres son separadores\n\t\tallocate( postokenbegin(len(str)) )\n\t\tallocate( postokenend(len(str)) )\n\t\t\n\t\tpostokenbegin = 0\n\t\tpostokenend = 0\n\t\t\n\t\t!! scan\n\t\tntokens = 1\n\t\tisdelimiterprev = .true.\n\t\tdo i=1,len(str)\n! \t\t\twrite(*,\"(3a)\",advance=\"no\") str(i:i)\n\t\t\t\n\t\t\tisdelimiter = .false.\n\t\t\tdo j=1,len(delimiters)\n\t\t\t\tif( str(i:i) == delimiters(j:j) ) then\n\t\t\t\t\tisdelimiter = .true.\n\t\t\t\t\texit\n\t\t\t\tend if\n\t\t\tend do\n\t\t\t\n\t\t\tif( isdelimiter .and. .not. isdelimiterprev ) then\n\t\t\t\tpostokenend( ntokens ) = i-1\n\t\t\t\tntokens = ntokens + 1\n! \t\t\t\twrite(*,*) \"    e\"\n\t\t\telse if( .not. isdelimiter .and. isdelimiterprev ) then\n\t\t\t\tpostokenbegin( ntokens ) = i\n! \t\t\t\twrite(*,*) \"    b\"\n! \t\t\telse\n! \t\t\t\twrite(*,*) \"\"\n\t\t\tend if\n\t\t\t\n\t\t\tisdelimiterprev = isdelimiter\n\t\tend do\n\t\t\n\t\tif( postokenend(ntokens) == 0 .and. .not. isdelimiter ) then\n\t\t\tpostokenend( ntokens ) = len( str )\n\t\telse\n\t\t\tntokens = ntokens - 1 \n\t\tend if\n\t\t\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"ntokens = \", ntokens\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"  begin = \", postokenbegin\n! \t\twrite(*,\"(a,<len(str)>i3)\") \"    end = \", postokenend\n\t\t\n\t\tallocate( tokens(ntokens) )\n\t\t\n\t\tdo i=1,ntokens\n\t\t\ttokens(i) = str( postokenbegin(i):postokenend(i) )\n\t\tend do\n\t\t\n\t\tdeallocate( postokenbegin )\n\t\tdeallocate( postokenend )\n\t\t\n\tend subroutine fstring_split\n"}, {"instruction": "Create a Fortran subroutine named calc_gammagas to calculate the ionization potential and ionization energy of a gas mixture based on the temperature of electrons and ions. The subroutine takes 2 input parameters of type real(8), dimension(:) for electron temperature (te) and ion temperature (ti), and 1 output parameter of type real(8), dimension(size(te)) for the ionization potential-energy ratio (gammagas).", "input": "", "output": "    subroutine calc_gammagas(te, ti, gammagas)\n        real(8), intent(in), dimension(:) :: te,ti\n        real(8), intent(out), dimension(size(te)) :: gammagas\n        real(8), dimension(size(te)) :: the, thi, dxe, dxi, lne,lni, ge, gi, tratio\n\n        the = te*1.68636949d-10  \n        thi = ti*9.1842553d-10 ! ac might need to account for non-hydrogen plasma eventually\n\n        dxe = 2.5*the\n        dxi = 2.5*thi\n        where(dxe.le.1d-8) ! ac hacky log1p function -- import better?\n           lne = dxe*(1d0-0.5*dxe + dxe*dxe/3.- 0.25*dxe*dxe*dxe)\n        elsewhere\n           lne = log(1d0+dxe)\n        end where\n\n        where(dxi.le.1d-8) ! ac hacky log1p function -- import better?\n           lni = dxi*(1d0-0.5*dxi + dxi*dxi/3. - 0.25*dxi*dxi*dxi)\n        elsewhere\n           lni = log(1d0+dxi)\n        end where\n\n        ge = 1 + the/(3*the - 0.6*lne)\n        gi = 1 + thi/(3*thi - 0.6*lni)\n\n        tratio = ti/te\n        gammagas = 1. + (1. + tratio) / (1./(ge-1.) + tratio/(gi-1.)) \n    end subroutine calc_gammagas\n"}, {"instruction": "Write a Fortran subroutine named jet2bl_r that takes an array of real numbers x1 as input, and returns an array of real numbers r as output. The input array x1 has an unspecified size and the output array r has the same size as x1. The subroutine computes the values of r using a specific mathematical formula involving the elements of x1.", "input": "", "output": "    subroutine jet2bl_r(x1, r) \n        real, intent(in), dimension(:) :: x1\n        real, intent(out), dimension(size(x1)) :: r\n        real, dimension(size(x1)) :: x1scl \n\n        !ac todo put in correct hyperexponential behavior for large-radius\n        if(rbrk.lt.rmax) then\n            write(6,*) 'current jetcoords code only supports grids with no hyperexponential (rbrk>=rmax)!'\n            call exit(-1)\n        end if\n        x1scl = x1min + x1*(x1max-x1min) ! scale from (0,1) range to (x1min,x1max) range\n        r = exp(dble(x1scl)) + r0 \n    end subroutine jet2bl_r\n"}, {"instruction": "Create a Fortran subroutine named best to identify the \"best\" element in an array of real numbers. The subroutine should take in an array of real numbers as input, with the test_data type ['real, target']. The subroutine should have one output parameter of type real, pointer, with the test_data type ['real, pointer'].", "input": "", "output": "  subroutine best(p, a)\n    real, pointer, intent(out) :: p\n    real, target, intent(in) :: a(:)\n    ! find the \"best\" element of a(i)\n    p => a(i)\n    return\n  end subroutine best\n"}, {"instruction": "Create a Fortran subroutine named fill_gaps, which fills gaps in time series data. The subroutine takes 7 input parameters of type double precision, double precision, double precision, integer*8, integer*8, double precision array of length ln, and double precision array of length ln. It also has 3 output parameters of type integer*8, double precision array of length ln+nmd*2, and double precision array of length ln+nmd*2.\n\nThe subroutine fills in time and data gaps based on specified time interval and tolerance. The counter variable keeps track of the number of gap-filled values.", "input": "", "output": "subroutine fill_gaps(time, dt, tol, ai, ln, nmd, fillval, tn, dn,counter)\n   double precision, intent(in) :: fillval, dt, tol\n   integer*8, intent(in) :: ln, nmd\n   integer*8, intent(out) :: counter\n   double precision, intent(in), dimension(ln) :: ai, time\n   double precision, intent(out), dimension(ln+nmd*2) :: tn, dn\n   integer*8 :: i\n   double precision :: del\n   counter = 0\n   do i=1,ln\n      del = time(i+1) - time(i)\n      if (abs(del-dt) <= tol) then\n         dn(counter) = ai(i)\n         tn(counter) = time(i)\n         counter = counter + 1\n      else\n         do while (abs(time(i+1) - tn(counter-1)) > dt+tol)\n            if (tn(counter-1)+dt > time(i+1)) then\n               exit\n            else\n               tn(counter) = tn(counter-1)+dt\n               dn(counter) = fillval\n               counter = counter + 1\n            endif\n         enddo\n      endif\n   enddo\nend subroutine fill_gaps\n"}, {"instruction": "Create a Fortran subroutine named factorial to calculate the factorial of a given integer. The subroutine should have 1 input parameter of type integer and 1 output parameter of type integer. The input parameter represents the integer for which the factorial is to be calculated, and the output parameter stores the result of the factorial calculation.", "input": "", "output": "recursive subroutine factorial(n, result)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: result\ninteger :: temp\n\nif (n >= 1) then\n  call factorial(n-1, temp)\n  result = n * temp\nelse\n  result = 1\nend if\nend subroutine factorial\n"}, {"instruction": "Write a Fortran subroutine named fillrotationmatrix that takes two input parameters of type real*8, denoted as ra and dec. It also has one output parameter of type real*8, with dimension (3,3), denoted as a. This subroutine is designed to compute and fill a 3x3 rotation matrix based on the input right ascension (ra) and declination (dec) values using trigonometric functions.", "input": "", "output": "    subroutine fillrotationmatrix(ra, dec, a)\n\n        real*8, intent(in) :: ra, &\n                              dec\n        real*8, dimension(3, 3), intent(out) :: a\n        a(1,1) = dcos(ra) * dcos(dec)  \n        a(2,1) = dsin(ra) * dcos(dec)  \n        a(3,1) = dsin(dec)        \n\n        a(1,2) = - dsin(ra)\n        a(2,2) = dcos(ra)\n        a(3,2) = 0.d0\n\n        a(1,3) = - dcos(ra)*dsin(dec)\n        a(2,3) = - dsin(ra)*dsin(dec)\n        a(3,3) = dcos(dec)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp_vec to calculate the squared exponential kernel function for vectors. The subroutine takes 4 input parameters: np (integer), ndim (integer), xa (real(8) array), xb (real(8) array), and produces 1 output parameter: out (real(8) array). The subroutine utilizes the features of Fortran and utilizes the imperative tone.", "input": "", "output": "subroutine kern_sqexp_vec(np, ndim, xa, xb, out)\n    integer, intent(in) :: np, ndim\n    real(8), intent(in) :: xa(np,ndim), xb(ndim)\n    real(8), intent(out) :: out(np)\n\n    integer :: ka\n\n    !$omp simd\n    do ka = 1, np\n        out(ka) = exp(-sum((xa(ka, :) - xb)**2/2d0))\n    end do\n\nend subroutine kern_sqexp_vec\n"}, {"instruction": "Write a Fortran subroutine named kern_sqexp_vec_t to calculate the squared exponential kernel between two sets of vectors. The subroutine takes 4 input parameters of types integer, integer, real(8) array, and real(8) array. It also has 1 output parameter of type real(8). The subroutine uses OpenMP SIMD directive for parallel execution.", "input": "", "output": "subroutine kern_sqexp_vec_t(np, ndim, xa, xb, out)\n  integer, intent(in) :: np, ndim\n  real(8), intent(in) :: xa(ndim, np), xb(ndim)\n  real(8), intent(out) :: out(np)\n\n  integer :: ka\n\n  !$omp simd\n  do ka = 1, np\n      out(ka) = exp(-sum((xa(:, ka) - xb)**2/2d0))\n  end do\n\nend subroutine kern_sqexp_vec_t\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp_1d to compute the squared exponential kernel for one-dimensional data. The subroutine should take 3 input parameters of types integer, real(8) array, and real(8), and 1 output parameter of type real(8) array.", "input": "", "output": "subroutine kern_sqexp_1d(np, xa, xb, out)\n    integer, intent(in) :: np\n    real(8), intent(in) :: xa(np), xb\n    real(8), intent(out) :: out(np)\n\n    out = exp(-(xa - xb)**2/2d0)\n\nend subroutine kern_sqexp_1d\n"}, {"instruction": "Create a Fortran subroutine named kern_one_1d that takes 3 input parameters: an integer np, an array of real(8) xa of length np, and a single real(8) value xb. It also has 1 output parameter, an array of real(8) out of length np. The subroutine initializes the out array to 1d0.", "input": "", "output": "subroutine kern_one_1d(np, xa, xb, out)\n  integer, intent(in) :: np\n  real(8), intent(in) :: xa(np), xb\n  real(8), intent(out) :: out(np)\n\n  out = 1d0\n\nend subroutine kern_one_1d\n"}, {"instruction": "Write a Fortran subroutine named kern_sqexp_vec2 to calculate the squared exponential kernel given two sets of input data. The number of input arguments is 4 and the test_data type is ['integer*4', 'integer*4', 'real*8, dimension(1:nd, 1:nx)', 'real*8, dimension(1:nd, 1:nx)']. The number of output arguments is 1 and the test_data type is ['real*8, dimension(1:nd, 1:nx)'].", "input": "", "output": "subroutine kern_sqexp_vec2(nd, nx, x0, x1, out)\nimplicit none\ninteger*4, intent(in) :: nd\ninteger*4, intent(in) :: nx\nreal*8, intent(in), dimension(1:nd, 1:nx) :: x0\nreal*8, intent(in), dimension(1:nd, 1:nx) :: x1\nreal*8, intent(out), dimension(1:nd, 1:nx) :: out\ninteger*4 :: kd\ninteger*4 :: kx\ndo kx = 1, nx\n   do kd = 1, nd\n      out(kd, kx) = exp(-0.5d0*(-x0(kd, kx) + x1(kd, kx))**2)\n   end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"mulkernel_loop32\" to perform matrix multiplication. The subroutine takes 2 input parameters of type real(8) and dimension (16,32) and real(8) and dimension (32,14). It has 1 output parameter of type real(8) and dimension (16,14). The subroutine multiplies and accumulates the elements of the input arrays to compute the elements of the output array.", "input": "", "output": "subroutine mulkernel_loop32(d, a, x)\n    real(8), dimension(16,32),  intent(in)  :: a\n    real(8), dimension(32,14),  intent(in)  :: x\n    real(8), dimension(16,14),  intent(out) :: d\n    integer                                 :: i\n\n    d(1:16,1)  = a(1:16,1) * x(1,1)\n    d(1:16,2)  = a(1:16,1) * x(1,2)\n    d(1:16,3)  = a(1:16,1) * x(1,3)\n    d(1:16,4)  = a(1:16,1) * x(1,4)\n    d(1:16,5)  = a(1:16,1) * x(1,5)\n    d(1:16,6)  = a(1:16,1) * x(1,6)\n    d(1:16,7)  = a(1:16,1) * x(1,7)\n    d(1:16,8)  = a(1:16,1) * x(1,8)\n    d(1:16,9)  = a(1:16,1) * x(1,9)\n    d(1:16,10) = a(1:16,1) * x(1,10)\n    d(1:16,11) = a(1:16,1) * x(1,11)\n    d(1:16,12) = a(1:16,1) * x(1,12)\n    d(1:16,13) = a(1:16,1) * x(1,13)\n    d(1:16,14) = a(1:16,1) * x(1,14)\n\n    do i = 2, 32\n        d(1:16,1)  = d(1:16,1)  + a(1:16,i) * x(i,1)\n        d(1:16,2)  = d(1:16,2)  + a(1:16,i) * x(i,2)\n        d(1:16,3)  = d(1:16,3)  + a(1:16,i) * x(i,3)\n        d(1:16,4)  = d(1:16,4)  + a(1:16,i) * x(i,4)\n        d(1:16,5)  = d(1:16,5)  + a(1:16,i) * x(i,5)\n        d(1:16,6)  = d(1:16,6)  + a(1:16,i) * x(i,6)\n        d(1:16,7)  = d(1:16,7)  + a(1:16,i) * x(i,7)\n        d(1:16,8)  = d(1:16,8)  + a(1:16,i) * x(i,8)\n        d(1:16,9)  = d(1:16,9)  + a(1:16,i) * x(i,9)\n        d(1:16,10) = d(1:16,10) + a(1:16,i) * x(i,10)\n        d(1:16,11) = d(1:16,11) + a(1:16,i) * x(i,11)\n        d(1:16,12) = d(1:16,12) + a(1:16,i) * x(i,12)\n        d(1:16,13) = d(1:16,13) + a(1:16,i) * x(i,13)\n        d(1:16,14) = d(1:16,14) + a(1:16,i) * x(i,14)\n    end do\n\nend subroutine mulkernel_loop32\n"}, {"instruction": "Create a Fortran subroutine named get_simsize that retrieves simulation size parameters and performs MPI sanity checks. The subroutine takes 1 input parameter of type integer, optional, and returns 3 output parameters of type integer. The subroutine is responsible for retrieving simulation size parameters from command line arguments and performing MPI sanity checks to ensure the input parameters are within valid ranges.", "input": "", "output": "subroutine get_simsize(lx1, lx2, lx3, nmpi)\n\ninteger, intent(out) :: lx1, lx2, lx3\ninteger, intent(in), optional :: nmpi\n\ninteger :: i, argc\ncharacter(9) :: buf\n\nlx1 = -1\nlx2 = -1\nlx3 = -1\n\nargc = command_argument_count()\nif(argc < 4) error stop \"must input at least: -lx lx1 lx2 lx3\"\n\ndo i = 1,argc-3\n\ncall get_command_argument(i, buf)\nselect case (buf)\n  case (\"-lx\")\n    call get_command_argument(i+1, buf)\n    read(buf, '(i9)') lx1\n    call get_command_argument(i+2, buf)\n    read(buf, '(i9)') lx2\n    call get_command_argument(i+3, buf)\n    read(buf, '(i9)') lx3\nend select\n\nend do\n\nif (any([lx1, lx2] < 1)) error stop \"must input -lx lx1 lx2 lx3\"\n\nif(.not.present(nmpi)) return\n\n!> mpi sanity check\nif (nmpi > lx2) error stop \"too many mpi workers\"\nif (modulo(lx2, nmpi) /= 0) error stop \"number of mpi workers must evenly divide problem size.\"\n\nend subroutine get_simsize\n"}, {"instruction": "Write a Fortran subroutine named set_displ to help in setting displacement and receive counts for an allgatherv operation for varying num. The subroutine takes 2 input parameters with test_data type ['integer', 'integer'] and 2 output parameters with test_data type ['integer, dimension(0:nprocs-1)', 'integer, dimension(0:nprocs-1)'].", "input": "", "output": "      subroutine set_displ(nprocs, num, rcnts, displ)\n!-----------------------------------------------------------------------\n!     helper function to set displacement and receive counts for an\n!     allgatherv operation for varying num\n!-----------------------------------------------------------------------\n      implicit none\n      integer, intent(in) :: nprocs, num\n      integer, dimension(0:nprocs-1), intent(out) :: displ, rcnts\n\n      integer :: n, offset\n\n      offset = 0 \n      do n = 0, nprocs-1\n         rcnts(n) = num\n         displ(n) = offset \n         offset = offset + num\n      end do\n\n      end subroutine set_displ\n"}, {"instruction": "Create a Fortran subroutine named insertionsort to sort an array of integers in ascending order. The subroutine takes 2 input parameters of type integer array and 1 output parameter of type integer array. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": " subroutine insertionsort( inarray, outarray, n )\n ! s/r insertionsort\n !\n !   sorts array from smallest to largest. \n ! =============================================================================================== !\n ! declarations\n   implicit none\n   integer, intent(in)  :: n\n   integer, intent(in)  :: inarray(1:n)\n   integer, intent(out) :: outarray(1:n)\n   ! local\n   integer :: i, j\n   integer :: temp\n\n    outarray = inarray\n\n    do i = 2,  n\n       j = i\n       do while( j > 1 .and. outarray(j-1) > outarray(j) )\n          !swap outarray(j) outarray(j-1)\n          temp          = outarray(j)\n          outarray(j)   = outarray(j-1)\n          outarray(j-1) = temp \n        \n          j = j-1\n       enddo\n    enddo\n\n end subroutine insertionsort\n"}, {"instruction": "Write a Fortran subroutine named modela_function to assign the value of an input real number to an output real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "subroutine modela_function(in_val, out_val)\n  real, intent(in) :: in_val\n  real, intent(out) :: out_val\n  out_val = in_val\n  print *, \"modela_function(\", in_val, \") = \", out_val\nend subroutine modela_function\n"}, {"instruction": "Create a Fortran subroutine named divvec. It takes 4 input parameters: neqns (integer), ndeg (integer), r (real(8) array), part (integer array). It also has 3 output parameters: r1 (real(8) array), r2 (real(8) array), rd (real(8) array). The subroutine divides the input vector r into three separate vectors r1, r2, and rd based on the values in the part array.", "input": "", "output": "subroutine divvec(neqns, ndeg, part, r, r1, r2, rd)\n\nimplicit none\n\ninteger, intent(in) :: neqns, ndeg\nreal(8), dimension(:), intent(in)  :: r    ! original right hand side vector\ninteger, dimension(:), intent(in)  :: part ! belonging of each element in large matrix\n\nreal(8), dimension(:), intent(out) :: r1\nreal(8), dimension(:), intent(out) :: r2\nreal(8), dimension(:), intent(out) :: rd\n\ninteger :: idx1, idx2, idxd, idxr\ninteger :: i\n\nidx1=1\nidx2=1\nidxd=1\nidxr=1\ndo i=1,neqns\n   if(part(i).eq.1) then\n     r1(idx1:idx1+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idx1=idx1+ndeg\n     idxr=idxr+ndeg\n   endif\n   if(part(i).eq.2) then\n     r2(idx2:idx2+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idx2=idx2+ndeg\n     idxr=idxr+ndeg\n   endif\n   if(part(i).eq.3) then\n     rd(idxd:idxd+ndeg-1)=r(idxr:idxr+ndeg-1)\n     idxd=idxd+ndeg\n     idxr=idxr+ndeg\n   endif\nend do\n\nend subroutine divvec\n"}, {"instruction": "Write a Fortran subroutine named inv_3x3 to compute the inverse of a 3x3 matrix. The input parameter is a 3x3 real*8 matrix, and the output parameter is the inverse 3x3 real*8 matrix.", "input": "", "output": "subroutine inv_3x3(a,ainv)\n  implicit none\n  real*8, intent(in)  :: a(3,3)\n  real*8, intent(out) :: ainv(3,3)\n  ! locals\n  real*8 :: det\n  det = a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1) + a(1,3)*a(2,1)*a(3,2) &\n      - a(3,1)*a(2,2)*a(1,3) - a(1,1)*a(3,2)*a(2,3) - a(2,1)*a(1,2)*a(3,3)\n  ainv(1,1) =(   a(2,2) * a(3,3) - a(2,3) * a(3,2) ) / det\n  ainv(1,2) =( - a(1,2) * a(3,3) + a(1,3) * a(3,2) ) / det\n  ainv(1,3) =(   a(1,2) * a(2,3) - a(1,3) * a(2,2) ) / det\n  ainv(2,1) =( - a(2,1) * a(3,3) + a(2,3) * a(3,1) ) / det\n  ainv(2,2) =(   a(1,1) * a(3,3) - a(1,3) * a(3,1) ) / det\n  ainv(2,3) =( - a(1,1) * a(2,3) + a(1,3) * a(2,1) ) / det\n  ainv(3,1) =(   a(2,1) * a(3,2) - a(2,2) * a(3,1) ) / det\n  ainv(3,2) =( - a(1,1) * a(3,2) + a(1,2) * a(3,1) ) / det\n  ainv(3,3) =(   a(1,1) * a(2,2) - a(1,2) * a(2,1) ) / det\n  return\nend subroutine inv_3x3\n"}, {"instruction": "Create a Fortran subroutine named \"wtt2ttt\" to interpolate a real field from a wtt-grid to a ttt-grid. The subroutine takes 2 input parameters of type real, with dimensions (imt, jmt, km), and outputs 1 parameter of type real with the same dimensions.", "input": "", "output": "subroutine wtt2ttt(w_field,dzt,t_field)\n!\n!     interpolated real field from wtt-grid to ttt-grid\n!     interpolating between two w-levels\n!     t-point is located exactly in the middle of two w-points\n!     t_field(i,j,k) = w_field(i,j,k) + ( w_field(i,j,k+1) -\n!     w_field(i,j,k) ) &\n!                                       / dz(k) * dz(k) / 2\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt,km), intent(in)  :: dzt\nreal,    dimension(imt,jmt,km), intent(in)  :: w_field ! wtt\nreal,    dimension(imt,jmt,km), intent(out) :: t_field ! ttt\nreal,    parameter                          :: p5=0.5, c0=0.0, c3=3.0\n\ndo k = 1,km-1\n  do j = 1,jmt\n    do i = 1,imt\n      if ( dzt(i,j,k).ne.c0 ) then\n        t_field(i,j,k) = p5 * ( w_field(i,j,k) + w_field(i,j,k+1) )\n      endif\n    enddo !i\n  enddo !j\nenddo !k\n\n! bottom level\ndo j = 1,jmt\n  do i = 1,imt\n    if ( dzt(i,j,km).ne.c0 ) then\n      ! extrapolating to last level with gradient between last two\n      ! w-levels\n      ! t_field(i,j,km) = w_field(i,j,km) \n      !                 + (w_field(i,j,km)-w_field(i,j,km-1)) / dz(k) *\n      !                 dz(k)/2\n      !t_field(i,j,km) = p5 * (c3*w_field(i,j,km) - w_field(i,j,km-1) )\n      t_field(i,j,km) = p5 * w_field(i,j,km)\n    endif\n  enddo !i\nenddo !j\n\n!do k = 1,km\n!  call surf_int(1,1,imt,jmt,w_field(:,:,:),tarea,dzt(:,:,k),a)\n!  call surf_int(1,1,imt,jmt,t_field(:,:,k),tarea,dzt(:,:,k),b)\n!  write (*,*) k, ' wtt2ttt orig', a\n!  write (*,*) k, ' wtt2ttt new ', b\n!  write (*,*) k, ' wtt2ttt factor      ', b/a\n!enddo !k\nend subroutine wtt2ttt\n"}, {"instruction": "Create a Fortran subroutine named \"uu2tt\" to interpolate a real 2D field from uu-grid to tt-grid on t-depth levels. The subroutine should have 5 input parameters of type real, each of dimension (imt, jmt). The output parameter should be of type real, with dimension (imt, jmt). The subroutine will use imperative tone to execute the interpolation process based on the input parameters.", "input": "", "output": "subroutine uu2tt(dzt_k,dzu_k,tarea,uarea,field_k,new_field_k)\n!\n!     interpolates real 2d field from uu-grid to tt-grid on t-depth\n!     levels\n!\nimplicit none\n\n! input/output variables\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dzu_k,dzt_k\nreal,    dimension(imt,jmt), intent(in)  :: tarea,uarea\nreal,    dimension(imt,jmt), intent(in)  :: field_k     ! (t)uu\nreal,    dimension(imt,jmt), intent(out) :: new_field_k ! (t)tt\nreal,    parameter                       :: c0=0.0\n! southernmost gridpoints (j=1) on ttt-grid must be 0,\n! as there would not be uu gridpoints south of it otherwise\ndo j = 2, jmt\n  ! westernmost gridpoints\n  if ( dzt_k(1,j).ne.c0 ) then\n    new_field_k(1,j) = 0.25                                                    &\n                  * ( field_k(1  ,j  ) * uarea(1  ,j  ) * dzu_k(1  ,j  )       &\n                    + field_k(imt,j  ) * uarea(imt,j  ) * dzu_k(imt,j  )       &\n                    + field_k(1  ,j-1) * uarea(1  ,j-1) * dzu_k(1  ,j-1)       &\n                    + field_k(imt,j-1) * uarea(imt,j-1) * dzu_k(imt,j-1))      &\n                  / tarea(1,j) / dzt_k(1,j)\n  endif\n  ! most of the ocean\n  do i = 2,imt\n    if ( dzt_k(i,j).ne.c0 ) then\n      new_field_k(i,j) = 0.25                                                  &\n                   * ( field_k(i  ,j  ) * uarea(i  ,j  ) * dzu_k(i  ,j  )      &\n                     + field_k(i-1,j  ) * uarea(i-1,j  ) * dzu_k(i-1,j  )      &\n                     + field_k(i  ,j-1) * uarea(i  ,j-1) * dzu_k(i  ,j-1)      &\n                     + field_k(i-1,j-1) * uarea(i-1,j-1) * dzu_k(i-1,j-1) )    &\n                   / tarea(i,j) / dzt_k(i,j)\n    endif\n  enddo !i\nenddo !j\n\nend subroutine uu2tt\n"}, {"instruction": "Create a Fortran subroutine named box2invbox to calculate the inverse of a box matrix for a specified number of frames. The subroutine takes 2 input parameters: an integer representing the number of frames and a 3D array of double precision representing the box matrix. It produces 1 output parameter, which is a 3D array of double precision representing the inverse box matrix.", "input": "", "output": "  subroutine box2invbox (box,invbox,nframes)\n  \n    implicit none\n    integer,intent(in)::nframes\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes,3,3),intent(out)::invbox\n  \n    invbox=0.0d0\n  \n    invbox(:,1,1)=1.0d0/box(:,1,1)\n    invbox(:,2,2)=1.0d0/box(:,2,2)\n    invbox(:,3,3)=1.0d0/box(:,3,3)\n  \n    invbox(:,2,1)=-box(:,2,1)/(box(:,1,1)*box(:,2,2))\n    invbox(:,3,1)=(box(:,2,1)*box(:,3,2)-box(:,3,1)*box(:,2,2))/(box(:,1,1)*box(:,2,2)*box(:,3,3))\n    invbox(:,3,2)=-box(:,3,2)/(box(:,2,2)*box(:,3,3))\n  \n  end subroutine box2invbox\n"}, {"instruction": "Create a Fortran subroutine named box2cell to perform a transformation from box vectors to unit cell vectors. The subroutine takes 2 input parameters: an integer nframes and a 3D array of double-precision values of dimension (nframes,3,3). It produces 3 output parameters: a 3D array of double-precision values of dimension (nframes,3,3), a 1D array of double-precision values of dimension (nframes), and an integer ortho.", "input": "", "output": "  subroutine box2cell (box,cell,volume,ortho,nframes)\n  \n    implicit none\n    integer,intent(in)::nframes\n    integer::ii\n    double precision,dimension(nframes,3,3),intent(out)::cell\n    double precision,dimension(nframes,3,3),intent(in)::box\n    double precision,dimension(nframes),intent(out)::volume\n    integer,intent(out)::ortho\n    double precision::x,y,z\n    double precision,parameter::fact_pi_div_180=1.745329251994329547437168059786927e-0002\n  \n    ortho=0\n    cell=0.0d0\n    volume=0.0d0\n  \n    do ii=1,nframes \n  \n      if ((box(ii,2,1)==0.0d0).and.(box(ii,3,1)==0.0d0).and.(box(ii,3,2)==0.0d0)) then\n         volume(ii)=box(ii,1,1)*box(ii,2,2)*box(ii,3,3)\n         cell(ii,1,1)=box(ii,1,1)\n         cell(ii,2,2)=box(ii,2,2)\n         cell(ii,3,3)=box(ii,3,3)\n         cell(ii,1,2)=90.0d0\n         cell(ii,1,3)=90.0d0\n         cell(ii,2,3)=90.0d0\n         ortho=1\n      else\n         volume(ii)=box(ii,1,1)*box(ii,2,2)*box(ii,3,3)\n         x=box(ii,1,1)\n         y=sqrt(box(ii,2,1)**2+box(ii,2,2)**2)\n         z=sqrt(box(ii,3,1)**2+box(ii,3,2)**2+box(ii,3,3)**2)\n         cell(ii,1,1)=x\n         cell(ii,2,2)=y\n         cell(ii,3,3)=z\n         cell(ii,2,3)=(acos(dot_product(box(ii,2,:),box(ii,1,:))/(x*y)))/fact_pi_div_180 ! gamma\n         cell(ii,1,3)=(acos(dot_product(box(ii,3,:),box(ii,1,:))/(x*z)))/fact_pi_div_180 ! beta\n         cell(ii,1,2)=(acos(dot_product(box(ii,3,:),box(ii,2,:))/(x*y)))/fact_pi_div_180 ! alpha\n      end if\n  \n    end do\n  \n  end subroutine box2cell\n"}, {"instruction": "Write a Fortran subroutine named suncor to calculate the solar declination, solar right ascension, and Greenwich Mean Sidereal Time (GST) based on the input parameters idate and ut. The number of input parameters is 2, and their data types are ['integer', 'real']. The subroutine has 3 output parameters, and their data types are ['real', 'real', 'real'].", "input": "", "output": "subroutine suncor (idate, ut, sdec, srasn, gst)\n\n  implicit none\n\n  integer,intent(in) :: idate\n  real,intent(in) :: ut\n  real,intent(out) :: sdec, srasn, gst\n\n  real,parameter :: pi=3.1415926536\n  real :: fday, dj, t, vl, g, slong, obliq, slp, sind, cosd\n  integer :: iyr, iday\n\n  fday=ut/86400.\n  iyr=idate/1000\n  iday=idate-iyr*1000\n\n! temporary y2k fix-up:\n! should work with either yyddd or yyyyddd format from 1950 to 2050.\n! note deteriorating accuracy after ~2050 anyway.\n! won't work after 2100 due to lack of a leap year.\n\n  if (iyr >= 1900) iyr=iyr-1900\n  if (iyr < 50) iyr=iyr+100\n\n  dj=365*iyr+(iyr-1)/4+iday+fday-0.5\n  t=dj/36525.\n  vl=amod(279.696678+.9856473354*dj,360.)\n  gst=amod(279.696678+.9856473354*dj+360.*fday+180.,360.) * pi/180.\n  g=amod(358.475845+.985600267*dj,360.) * pi/180.\n  slong=vl+(1.91946-.004789*t)*sin(g)+.020094*sin(2.*g)\n  obliq=(23.45229-0.0130125*t) *pi/180.\n  slp=(slong-.005686) * pi/180.\n  sind=sin(obliq)*sin(slp)\n  cosd=sqrt(1.-sind**2)\n  sdec=atan(sind/cosd)\n  srasn=pi-atan2(1./tan(obliq)*sind/cosd,-cos(slp)/cosd)\n\n  return\n\nend subroutine suncor\n"}, {"instruction": "Create a Fortran subroutine named get_vec_cross. The subroutine takes 3 input parameters: an integer m, an array of real numbers v1 with dimension m, and an array of real numbers v2 with dimension m. It has 1 output parameter: an array of real numbers cross with dimension m. The subroutine computes the cross product of the input vectors v1 and v2 and stores the result in the cross array.", "input": "", "output": "  subroutine get_vec_cross(v1, v2, m, cross)\n\n    integer,intent(in)::m\n    real(kind=4),intent(in),dimension(m)::v1,v2\n    real(kind=4),intent(out),dimension(m)::cross\n\n    cross(1)=v1(2)*v2(3)-v1(3)*v2(2)\n    cross(2)=v1(3)*v2(1)-v1(1)*v2(3)\n    cross(3)=v1(1)*v2(2)-v1(2)*v2(1)\n\n    return\n\n  end subroutine get_vec_cross\n"}, {"instruction": "Create a Fortran subroutine named get_vec_len to calculate the magnitude of a vector. The subroutine takes 2 input parameters: an integer m and a real array of dimension m. It has 1 output parameter of type real(kind=4) to store the calculated magnitude. Use the imperative tone to define the subroutine.", "input": "", "output": "  subroutine get_vec_len(vec,vec_len,m)\n\n    integer::i\n    integer,intent(in)::m\n    real(kind=4)::sum_value\n    real(kind=4),intent(in),dimension(m)::vec\n    real(kind=4),intent(out)::vec_len\n\n    sum_value=0.0\n    do i=1,m\n      sum_value=sum_value+vec(i)**2\n    end do\n    vec_len = sqrt(sum_value)\n\n    return\n\n  end subroutine get_vec_len\n"}, {"instruction": "Create a Fortran subroutine named norm_vec to normalize a vector by dividing each element by the Euclidean norm of the vector. The subroutine takes 2 input parameters: an integer m and a real array vec of dimension m. It also has 1 output parameter: a real array new_vec of dimension m.", "input": "", "output": "  subroutine norm_vec(vec,new_vec,m)\n\n    integer::i\n    integer,intent(in)::m\n    real(kind=4)::sum_value\n    real(kind=4),intent(in),dimension(m)::vec\n    real(kind=4),intent(out),dimension(m)::new_vec\n\n    sum_value = 0.0\n    do i=1,m\n      sum_value=sum_value+vec(i)**2\n    end do\n    do i=1,m\n      new_vec(i)=vec(i)/sqrt(sum_value)\n    end do\n\n    return\n\n  end subroutine norm_vec\n"}, {"instruction": "Create a Fortran subroutine named project_vec to compute the projection of vec_1 onto the basis of vec_2. The subroutine takes 3 input parameters: an integer m, a real array vec_1 of dimension m, and a real array vec_2 of dimension m. It returns 2 output parameters: a real value sign_value and a real array vec_1_proj_vec_2 of dimension m.", "input": "", "output": "  subroutine project_vec(vec_1,vec_2,m,vec_1_proj_vec_2,sign_value)\n  ! project vec_1 on the basis of vec_2\n\n    integer,intent(in)::m\n    real(kind=4)::a,b\n    real(kind=4),intent(out)::sign_value\n    real(kind=4),intent(in),dimension(m)::vec_1,vec_2\n    real(kind=4),intent(out),dimension(m)::vec_1_proj_vec_2\n\n    a=dot_product(vec_1,vec_2)\n    b=dot_product(vec_2,vec_2)\n    vec_1_proj_vec_2=a*vec_2/b\n\n    if ( a<0.0 ) then\n      sign_value=-1.0\n    else\n      sign_value=1.0\n    end if\n \n    return\n\n  end subroutine project_vec\n"}, {"instruction": "Create a Fortran subroutine named \"center_of_mass\" to calculate the center of mass of a system. The subroutine takes 4 input parameters: two integers (n and m), an array of real numbers of length n (mass), and a 2D array of real numbers with dimensions n and m (data_array). It outputs a single array of real numbers with length m (data_center).", "input": "", "output": "  subroutine center_of_mass(mass,data_array,data_center,n,m)\n\n    integer::i,j\n    integer,intent(in)::n,m\n    real(kind=4)::sum_value\n    real(kind=4)::sum_value_mass\n    real(kind=4),intent(in),dimension(n)::mass\n    real(kind=4),intent(in),dimension(n,m)::data_array\n    real(kind=4),intent(out),dimension(m)::data_center\n\n    sum_value_mass=0.0\n\n    do i=1,n\n      sum_value_mass=sum_value_mass+mass(i)\n    end do\n\n    do i=1,m\n      sum_value=0.0\n      do j=1,n\n        sum_value=sum_value+mass(j)*data_array(j,i)\n      end do\n      data_center(i)=sum_value/sum_value_mass\n    end do\n\n    return\n\n  end subroutine center_of_mass\n"}, {"instruction": "Create a Fortran subroutine named intersect to compare two arrays of integers of size 2 and return the result in an integer variable. The subroutine takes 2 input arguments of type integer, dimension(2), and 1 output argument of type integer.", "input": "", "output": "      subroutine intersect(a, b, i)\n        integer, dimension(2), intent(in) :: a, b\n        integer, intent(out) :: i\n\n        i = 1\n      end subroutine intersect\n"}, {"instruction": "Create a Fortran subroutine named log_check_file_exists to check if a file with the specified filename exists. The subroutine takes 1 input parameter of type character*76 and 1 output parameter of type integer. The subroutine uses the imperative tone to open the file and set the output parameter to indicate whether the file exists or not.", "input": "", "output": "subroutine log_check_file_exists(logfilename,fileexists)\n  integer, intent(out) :: fileexists\n  character*76, intent(in) :: logfilename\n  ! the status='old' keyword specifies that the file logfilename must\n  ! exist or iostat will return a code other than 0 (2 for absoft).\n  open(file=logfilename, unit=39, status='old', action='read', iostat=fileexists)\n  if ( fileexists == 0 ) then\n    ! the logfile already exists\n    close(39)\n  end if\nend subroutine log_check_file_exists\n"}, {"instruction": "Create a Fortran subroutine named log_create_file, which takes a character*76 input parameter logfilename and an integer output parameter createdfile. The subroutine opens a new log file using the provided filename and returns an integer indicating the status of the file creation. If the file is successfully created, it writes a log message with the filename, creation date, and time. If the file creation fails, it displays an error message.", "input": "", "output": "subroutine log_create_file(logfilename,createdfile)\n  integer, intent(out) :: createdfile\n  character*76, intent(in) :: logfilename\n  character*8               :: curr_date, curr_time\n  character*10              :: long_time, long_date\n\n  open(file=logfilename, unit=39, status='new', action='write', iostat=createdfile)\n  if ( createdfile == 0 ) then\n    call date_and_time(curr_date,long_time)\n    curr_time = long_time(1:2)//':'//long_time(3:4)//':'//long_time(5:6)\n    long_date = curr_date(5:6)//'/'//curr_date(7:8)//'/'//curr_date(1:4)\n    write (39,*) '# ', trim(logfilename), ' created on ', long_date, ' at ', trim(curr_time)\n    close(39)\n  else\n    print *,'[bestpred_log]: unable to create the log file ', logfilename\n  end if\nend subroutine log_create_file\n"}, {"instruction": "Create a Fortran subroutine named system_file_info to retrieve system information about a file. The subroutine takes 1 input parameter of type character*(*) for the file_name and 1 output parameter of type integer, which is optional, to store the file_size in bytes. If the file_size is not required or unknown, it defaults to 0.", "input": "", "output": "  subroutine system_file_info (file_name, file_size)\r\n\r\n    !-- get system information about a file.\r\n    !-- this version returns 0.\r\n    !-- 9 dec 92, richard maine.\r\n\r\n    !-------------------- interface.\r\n    character*(*), intent(in) :: file_name\r\n      !-- path name of the file.\r\n    integer, intent(out), optional :: file_size\r\n      !-- size of the file in bytes.\r\n      !-- 0 if unknown or if the file does not exist.\r\n\r\n    !-------------------- executable code.\r\n\r\n    if (present(file_size)) file_size = 0\r\n    return\r\n  end subroutine system_file_info\r\n"}, {"instruction": "Create a Fortran subroutine named decodehour to extract hour, minute, and second from a string representation of time. The subroutine takes 1 input parameter of type character(len=*) and returns 3 output parameters of type integer.", "input": "", "output": "    subroutine decodehour(stime, ihour, iminute, isecond)\n    \n        ! routine arguments\n        character(len=*), intent(in)    :: stime\n        integer, intent(out)            :: ihour\n        integer, intent(out)            :: iminute\n        integer, intent(out)            :: isecond\n        \n        ! locals\n        integer :: ilength\n        integer :: iretcode\n        \n        ! infer type of date from string length\n        ilength = len_trim(stime)\n        select case(ilength)\n        case(8)\n            ! hh:mm:ss\n            read(stime,\"(i2,1x,i2,1x,i2)\",iostat=iretcode) ihour, iminute, isecond\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            end if\n        case(5)\n            ! hh:mm\n            read(stime,\"(i2,1x,i2)\",iostat=iretcode) ihour, iminute\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            else\n                isecond = 0\n            end if\n        case(2)\n            ! hh\n            read(stime,\"(i2)\",iostat=iretcode) ihour\n            if(iretcode /= 0) then\n                ihour   = -9999\n                iminute = -9999\n                isecond = -9999\n            else\n                iminute = 0\n                isecond = 0\n            end if\n        case default\n            ihour   = -9999\n            iminute = -9999\n            isecond = -9999\n        end select\n        \n    end subroutine decodehour\n"}, {"instruction": "Create a Fortran subroutine named chartoascii that takes in an integer n, an array of characters chartxt, and outputs an array of integers inttxt. The subroutine converts each character in the input array to its corresponding ASCII value and stores it in the output array.", "input": "", "output": "  subroutine chartoascii(inttxt,chartxt,n)\n    implicit none\n    integer, intent(in) :: n !< dimension of integer and character array\n    integer, dimension(n), intent(out) :: inttxt !< integer array\n    character(len=n), intent(in) :: chartxt !< character array\n    ! locals\n    integer :: i\n\n    do i=1,n\n      inttxt(i) = ichar(chartxt(i:i))\n    enddo\n  end subroutine chartoascii\n"}, {"instruction": "Create a Fortran subroutine named get_size to read a file and retrieve the dimensions. The subroutine takes 1 input parameter of type character*255. It has 3 output parameters of type integer.", "input": "", "output": "    subroutine get_size(path,ncontrol, nintervals, nstates)\n        !define variables\n        character*255, intent(in) :: path    \n        integer,intent(out) :: nintervals, ncontrol, nstates\n        integer i, j\n        \n        !open first time just to get the dimensions\n        open(unit = 10, file = path, status = 'old', action = 'read')\n        read(10,*) ncontrol\n        read(10,*) nstates\n        read(10,*)\n        read(10,*) i, nintervals\n        close(10)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named get_data to read data from a file. The subroutine takes 4 input parameters of type character*255, integer, integer, and integer. It also has 2 output parameters of type integer and real. The subroutine opens a file specified by the input path, reads the control and data values, and assigns them to the output variables.", "input": "", "output": "    subroutine get_data(path,ncontrol, nintervals, nstates, control, data)\n        !define variables\n        character*255, intent(in) :: path \n        integer, intent(in) ::  nintervals, ncontrol, nstates\n        integer,intent(out) :: control(ncontrol)\n        real, intent(out) :: data(ncontrol,nstates,nintervals)\n        integer i, j,oe,z\n            \n        !open the file to read the data\n        open(unit = 10, file = path, status = 'old', action = 'read')\n        read(10,*) \n        read(10,*)     \n        do i =1,ncontrol\n            read(10,*)\n            read(10,*) control(i), oe\n            read(10,*) ((data(i,j,z), j = 1,nstates), z = 1,nintervals)        \n        enddo\n        close(10)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named parse_date to extract year, month, day, hour, minute, and second from a given date string. The number of input arguments is 1 and the test_data type is ['character (len=*)']. The number of output arguments is 6 and the test_data type is ['integer', 'integer', 'integer', 'integer', 'integer', 'integer'].", "input": "", "output": "    subroutine parse_date(date, year, month, day, hour, min, sec)\n      implicit none\n      character (len=*), intent(in) :: date\n      integer, intent(out) :: sec, min, hour, day, month, year\n\n      read(date(9:10),*) day\n      read(date(6:7),*) month\n      read(date(1:4),*) year\n      if(len_trim(date) <= 11) then\n         sec = 0\n         min = 0\n         hour = 0\n      else\n         read(date(18:19), *) sec\n         read(date(15:16), *) min\n         read(date(12:13), *) hour\n      endif\n    end subroutine parse_date\n"}, {"instruction": "Create a Fortran subroutine named calc_dxyz to calculate the grid cell volume at the drifter's location. The subroutine takes 9 input parameters of type integer, integer, integer, integer, integer, integer, real arrays of specified dimensions, and real(kind=8). The output is a single real(kind=8) value.\n\nThe subroutine uses the imperative tone and performs calculations based on the inputs to determine the volume of the drifter's grid cell. The volume is computed using the input grid space indices, time interpolation constant, grid index sizing constants, cell height, area of horizontal cell-walls, and time index parameters.\n\nEnsure the proper declaration and usage of the required input and output parameters within the subroutine.", "input": "", "output": "subroutine calc_dxyz(ib,jb,kb,rr,imt,jmt,km,dzt,dxdy,dxyz)\n!====================================================================\n! calculate the grid cell volume at the drifter's location\n!\n!  input:\n!    ib,jb,kb       : new position in grid space indices\n!    rr             : time interpolation constant between 0 and 1. controls how much\n!                   : of earlier time step is used in interpolation.\n!    imt,jmt,km     : grid index sizing constants in (x,y,z), are for \n!                     horizontal and vertical rho grid [scalar]\n!    dzt            : height of k-cells in 3 dim in meters on rho vertical grid. [imt,jmt,km]\n!    dxdy           : area of horizontal cell-walls [imt,jmt]\n!\n!  output:\n!    dxyz           : volume of drifter's grid cell\n!\n!  other parameters used in function:\n!    rg             : rg=1-rr for time interpolation between time steps. controls how much\n!                   : of later time step is used in interpolation.\n!    nsm=1,nsp=2    : time index. nsm picks out the earlier bounding time step and \n!                     nsp picks out the later bounding time step for interpolation.\n!\n!  notes:\n!    kmt: assuming zgrid3dt flag which includes free surface already, i think. other \n!         flags aren't set up in the allocations or in the input variables,\n!         for example, hs is not currently input since it is already included in \n!         the dzt.\n!====================================================================\n\nimplicit none\n\ninteger,        intent(in)                                      :: ib,jb,kb,km,jmt,imt\nreal(kind=8),   intent(in),     dimension(imt,jmt,km,2)         :: dzt\nreal(kind=8),   intent(in),     dimension(imt,jmt)              :: dxdy\nreal(kind=8),   intent(in)                                      :: rr\nreal(kind=8),   intent(out)                                     :: dxyz\nreal(kind=8)                                                    :: rg\ninteger                                                         :: nsm=1,nsp=2\n\n\nrg=1.d0-rr\n\n! t-box volume in m3\ndxyz=rg*dzt(ib,jb,kb,nsp)+rr*dzt(ib,jb,kb,nsm)\ndxyz=dxyz*dxdy(ib,jb)\n\nend subroutine calc_dxyz\n"}, {"instruction": "Write a Fortran subroutine named set_data_double that initializes an array with values equal to the rank of the array element. The subroutine takes 2 input parameters, both of type integer, and 1 output parameter of type double precision, with a dimension specified by the second input parameter.\n", "input": "", "output": "subroutine set_data_double ( data, rank, dim )\n!******************************************************************************\n!******************************************************************************\n\nimplicit none\n    integer, intent(in) :: rank, dim\n    double precision, dimension(dim), intent(out) :: data\n    integer i\n\n    do i = 1, dim\n       data(i) = rank \n    end do\n\n    return\n\nend subroutine set_data_double\n"}, {"instruction": "Create a Fortran subroutine named set_data_int that sets an array of integers to a specific value. The subroutine takes 2 input parameters of type integer and outputs an array of integers with a dimension specified by the second input parameter. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(dim)'].", "input": "", "output": "subroutine set_data_int ( data, rank, dim) \n!******************************************************************************\n!******************************************************************************\n\nimplicit none\n    integer, intent(in) :: rank, dim\n    integer, dimension(dim), intent(out) :: data\n    integer i\n\n    do i = 1, dim\n       data(i) = rank \n    end do\n\n    return\n\nend subroutine set_data_int\n"}, {"instruction": "Create a Fortran subroutine named model_pblhgt that takes 8 input parameters: 3 integers, 4 2D real arrays, and 1 3D real array. The output is a 2D real array. The subroutine's purpose is to generate planetary boundary layer heights using theta and surface temperature data in a terrain-following model coordinate system.", "input": "", "output": "subroutine model_pblhgt(theta,thsfc,psig,zsig,topo,nx,ny,nz,pblhgt)\n\n  !  coordinate model data.  adapted from the laps routine for \n  !  terrain-following model coordinates.\n\n  implicit none\n\n  integer, intent(in)   :: nx,ny,nz\n  real, intent(in)      :: theta(nx,ny,nz)\n  real, intent(in)      :: thsfc(nx,ny)\n  real, intent(in)      :: psig(nx,ny,nz)\n  real, intent(in)      :: zsig(nx,ny,nz)\n  real, intent(in)      :: topo(nx,ny)\n  real, intent(out)     :: pblhgt(nx,ny)\n\n  integer  :: i,j,k,ktop\n  real     :: thresh_k, topwgt, botwgt\n  logical  :: found_pbl_top\n  \n  print *, 'generating pbl height using theta and surface temp.'\n  loop_j:  do j = 1 , ny\n    loop_i:  do i = 1 , nx\n\n      ! compute threshold value that theta needs to exceed\n      ! to be above pbl.  we use surface theta plus an\n      ! additional 3k for slop.\n\n      thresh_k = thsfc(i,j) + 3.0  \n\n      ! now begin at the bottom and work our way up until\n      ! we find the first level with a theta exceeding the\n      ! threshold\n\n      found_pbl_top = .false.\n      loop_k: do k = 1 , nz\n \n        if (theta(i,j,k) .ge. thresh_k) then\n          ktop = k\n          found_pbl_top = .true.\n          exit loop_k\n        endif\n      enddo loop_k\n\n      ! if we did not find a good pbl, set pbl to first level\n      ! and print out some diagnostics\n      if (.not. found_pbl_top) then\n        print *, 'pbl height not found at i/j = ',i,j\n        print *, 'surface theta = ', thsfc(i,j)\n        print *, 'theta in the column:'\n        print *, 'pressure height  theta'\n        print *, '-------- ------- --------'\n        diag_loop: do k = 1,nz\n          print '(f8.0,f8.0,f8.2)',psig(i,j,k),zsig(i,j,k),theta(i,j,k)\n        enddo diag_loop\n        ktop = 1\n        pblhgt(i,j) = zsig(i,j,1) - topo(i,j)\n\n      else \n  \n        ! we found the top k-level bounding the pbl so interpolate\n        ! to the actual level\n \n        if (ktop .eq. 1) then\n          pblhgt(i,j) = zsig(i,j,1) - topo(i,j)\n        else\n          ! interpolate to get height at thresh_k\n          botwgt = ( (theta(i,j,ktop)-thresh_k) / &\n                     (theta(i,j,ktop)-theta(i,j,ktop-1)) )\n          topwgt = 1.0 - botwgt\n          pblhgt(i,j) = botwgt * zsig(i,j,ktop-1) + &\n                        topwgt * zsig(i,j,ktop) - topo(i,j)\n        endif\n      endif\n    enddo loop_i\n  enddo loop_j\n  return\nend subroutine model_pblhgt\n"}, {"instruction": "Create a Fortran subroutine named arr_distance that calculates the distances between a set of 3D points and a reference point. The subroutine takes 3 input parameters: an integer arr_length, a real array arr of dimensions (arr_length, 3), and a real array sc of dimension (3). It also has 1 output parameter: a real array dd of dimension (arr_length).", "input": "", "output": "subroutine arr_distance(sc, arr, arr_length, dd)\n\n  integer, intent(in) :: arr_length\n  real, dimension(arr_length, 3), intent(in) :: arr\n  real, dimension(3), intent(in) :: sc\n  real, dimension(arr_length), intent(out) :: dd\n  \n  dd = sqrt(sum((arr-spread(sc,1,arr_length))**2, 2))\n  \nend subroutine arr_distance\n"}, {"instruction": "Create a Fortran subroutine named set_from_string that takes two logical input parameters and one output parameter of type character(len=*). The input parameters are used to determine the value of the output string based on conditional statements.", "input": "", "output": "subroutine set_from_string(from_restart, single_file, from_string)\nlogical,          intent(in)  :: from_restart\nlogical,          intent(in)  :: single_file\ncharacter(len=*), intent(out) :: from_string\n\nif (from_restart) then\n   if (single_file) then\n      from_string = 'variable from input file'\n   else\n      from_string = 'restart file'\n   endif\nelse\n   from_string = 'from namelist'\nendif\n\nend subroutine set_from_string\n"}, {"instruction": "Write a Fortran subroutine named init_thread_topology to initialize the topology of a thread. The subroutine takes 4 input parameters of type integer: n, d, imore, and iless. It also has 1 output parameter of type integer: n3d. This subroutine computes the thread topology based on the input parameters and allocates the values to the output parameter n3d.", "input": "", "output": "  subroutine init_thread_topology(n, n3d, d, imore, iless)\n    implicit none\n    integer, intent(in) :: n, d, imore, iless\n    integer, intent(out) :: n3d(3)\n\n    integer, allocatable :: facs(:)\n    integer :: lfacs, f, nfac, rem, i, j, nmin, nmax\n    integer :: n2d(2)\n\n    if (d.eq.1) then\n       n3d = 1\n       n3d(imore) = n\n       return\n    end if\n\n    lfacs = int(log(dble(n))/log(2.d0))\n    allocate(facs(lfacs))\n    \n    nfac = 0\n    f = 2\n    rem = n\n    do while (rem .ne. 1)\n       if (mod(rem, f) .eq. 0) then\n          rem = rem/f\n          nfac = nfac+1\n          facs(nfac) = f\n       else\n          f = f + 1\n       end if\n    end do\n\n    if (d .eq. 3) then\n       n3d = 1\n       do i = nfac, 1, -1\n          j = minloc(n3d,1)\n          n3d(j) = n3d(j) * facs(i)\n       end do\n    else\n       n2d = 1\n       do i = nfac, 1, -1\n          j = minloc(n2d,1)\n          n2d(j) = n2d(j) * facs(i)\n       end do\n       n3d(1) = 1\n       n3d(2:3) = n2d\n    end if\n\n    nmin = minval(n3d)\n    nmax = maxval(n3d)\n\n    n3d = n / (nmin*nmax)\n    n3d(iless) = nmin\n    n3d(imore) = nmax\n\n    deallocate(facs)\n\n  end subroutine init_thread_topology\n"}, {"instruction": "Write a Fortran subroutine named split_domain to divide a given total size into n parts and calculate the size and start index for each part. The number of input parameters is 2 with test_data type ['integer', 'integer']. The number of output parameters is 2 with test_data type ['integer', 'integer'].", "input": "", "output": "  subroutine split_domain(totalsize, n, isize, start)\n    implicit none\n    integer, intent(in) :: totalsize, n\n    integer, intent(out) :: isize(n), start(n)\n    \n    integer :: i, iavg, ileft\n    \n    iavg = int(totalsize/n)\n    ileft = totalsize - iavg*n\n    \n    start(1) = 0\n    isize(1) = iavg\n    do i=2, n\n       start(i) = start(i-1) + isize(i-1)\n       if (ileft > 0) then\n          isize(i) = iavg + 1\n          ileft = ileft - 1\n       else\n          isize(i) = iavg\n       end if\n    end do\n    \n  end subroutine split_domain\n"}, {"instruction": "Create a Fortran subroutine named \"bkfilter\" to implement the Baxter and King (1999) band-pass filter. The subroutine takes 5 input parameters of type integer and real, and 2 output parameters of type real. The input parameters are n (length of data vector y), up (lower frequency), dn (higher frequency), k (number of leads and lags), and y (data vector). The output parameters are ybp (band pass filtered series) and yt (symmetric moving average representation of the band pass filter). Ensure the subroutine computes the band pass filter according to the provided algorithm.", "input": "", "output": "subroutine bkfilter(n, y, up, dn, k, ybp, yt)\r\n\r\n! aubhik 20.02.2005\r\n!\r\n! baxter and king (1999) band-pass filter\r\n!\r\n! y is a data vector of length n\r\n! ybp is the band pass filtered series, with 0.0 for the first and last k observations\r\n! n is the length of the data vector y\r\n! up is the lower frequency\r\n!\tfor example, the business cycle band will have up = 6 for quarterly data\r\n!\tand up = 1.5 for annual data\r\n! dn is the higher frequency\r\n!\tfor example, the business cycle band will have dn = 32 for quarterly data\r\n!\tand dn = 8 for annual data\r\n! k is the number of leads and lags used by the symmetric moving-average \r\n!\trepresentation of the band pass filter.  baxter and king (1999) find\r\n!\tthat k = 12 is a practical choice.\r\n! \r\n\n! bpf.m and filtk.m written by baxter and king (1999).  the band pass filter is \r\n! a moving average involving 2k+1 terms.  the weights are symmetric and calculated\r\n! in akvec.  \r\n\r\nimplicit none\r\n\r\ninteger n, up, dn, k\r\nreal y(n), ybp(n), yt(n)\r\n\r\ninteger j\r\nreal pi, omlbar, omubar, kr, kj, theta\r\nreal akvec(k+1), avec(2*k+1), tvec(2*k+1)\r\n\r\nintent(in):: n, up, dn, k, y\r\nintent(out):: ybp, yt\r\n\r\npi = 2.0*acos(0.0)\r\n\r\nomlbar = 2.0*pi/dble(dn)\r\nomubar = 2.0*pi/dble(up)\r\n\r\nakvec = 0.0\r\navec = 0.0\r\n\r\nkr = dble(k)\r\n\r\nakvec(1) = (omubar - omlbar)/pi\r\n\r\ndo j = 1, k\r\n    kj = dble(j)\r\n    akvec(j+1) = (dsin(dble(kj*omubar)) - dsin(dble(kj*omlbar)))/(kj*pi)\r\nend do\r\n\r\ntheta = akvec(1) + 2.0*sum(akvec(2:k+1))\r\ntheta = -1.0*(theta/(2.0*kr + 1.0))\r\n\r\nakvec = akvec + theta\r\n\r\navec(k+1) = akvec(1)\r\n\r\ndo j = 1, k\r\n    avec(k+1 - j) = akvec(j+1)\r\n    avec(k+1 + j) = akvec(j+1)\r\nend do\r\n\r\ndo j = 1, k*2+1\r\n    tvec(j) = 1.0 - avec(j)\r\nend do\r\n\r\nybp = 0.0\r\nyt = 0.0\r\n\r\ndo j = k + 1, n - k\r\n    ybp(j) = dot_product(avec, y(j - k: j + k))\r\n    yt(j) = dot_product(tvec, y(j - k: j + k))\r\nend do\r\n\r\nend subroutine bkfilter\r\n"}, {"instruction": "Create a Fortran subroutine named sph_cart to convert position vectors from spherical coordinates to cartesian coordinates. The input parameter is a 2D array of real numbers with kind=8 and dimensions defined by the size of the problem. The output parameter is also a 2D array of real numbers with kind=8 and dimensions defined by the size of the problem.", "input": "", "output": "subroutine sph_cart(r,x)\n\t!----------------------------------------------------------\n\t! switching from spherical to cartesian coordinates \n\t! calling sequence: call cart_sph(r,x)\n\t! input:  r: position vector in spherical coordinates\n\t!\t     (radial distance,azimuthal angle,polar angle)\t\n\t! output: x: position vector in cartesian coordinates \n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r\n\treal(kind=8), dimension(:,:), intent(out) :: x\n\n\tx(1,:) = r(1,:)*cos(r(3,:))*cos(r(2,:)) \n\tx(2,:) = r(1,:)*cos(r(3,:))*sin(r(2,:)) \n\tx(3,:) = r(1,:)*sin(r(3,:))\n\nend subroutine sph_cart\n"}, {"instruction": "Write a Fortran subroutine named cyl_cart to convert cylindrical coordinates to cartesian coordinates. The subroutine takes 1 input parameter of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8), dimension(:,:). The input parameter represents the position vector in cylindrical coordinates (radial distance, angular coordinate, altitude), and the output parameter represents the position vector in cartesian coordinates. Use the calling sequence call cyl_cart(r,x).", "input": "", "output": "subroutine cyl_cart(r,x)\n\t!----------------------------------------------------------\n\t! switching from cylindrical to cartesian coordinates\n\t! calling sequence: call cyl_cart(r,x)\n\t! input:  r: position vector in cylindrical coordinates \n\t!\t     (radial distance,angular coordinate,altitude)\n\t! output: x: position vector in cartesian coordinates \n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r\n\treal(kind=8), dimension(:,:), intent(out) :: x\n\n\tx(1,:) = r(1,:)*cos(r(2,:))\n\tx(2,:) = r(1,:)*sin(r(2,:)) \n\tx(3,:) = r(3,:)\n\nend subroutine cyl_cart\n"}, {"instruction": "Create a Fortran subroutine named cyl_cart_vect to convert a vector from cylindrical coordinates to Cartesian coordinates for a given position vector. The subroutine takes 2 input parameters of type real(kind=8), dimension(:,:), representing the vector and position in cylindrical coordinates, and 1 output parameter of type real(kind=8), dimension(:,:) representing the resulting vector in Cartesian coordinates. Use the calling sequence call cyl_cart_vect(vr,r,vx) to invoke the subroutine.", "input": "", "output": "subroutine cyl_cart_vect(vr,r,vx)\n\t!-------------------------------------------------------------------------------------\n\t! switching from cylindrical to cartesian coordinates for a vector at a point r\n\t! calling sequence: call cyl_cart_vect(vr,r,vx)\n\t! input: vr : vector in cylindrical coordinates\n\t!             (radial distance,angular coordinate,altitude)\n\t!         r : position vector in cylindrical coordinates\n\t!             (radial distance,angular coordinate,altitude)\n\t!\t\t\t\t\n\t! output: vx: vector in cartesian coordinates  (vx,vy,vz)\n\t!-------------------------------------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r,vr\n\treal(kind=8), dimension(:,:), intent(out) :: vx\n\t\n\tvx(1,:)=vr(1,:)*cos(r(2,:))-vr(2,:)*sin(r(2,:))\n\tvx(2,:)=vr(1,:)*sin(r(2,:))+vr(2,:)*cos(r(2,:))\n\tvx(3,:)=vr(3,:)\n\nend subroutine cyl_cart_vect\n"}, {"instruction": "Create a Fortran subroutine named \"weights_left_k8\" to compute weighted values. The subroutine takes 2 input parameters of type real(kind=8) and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine weights_left_k8(sigma, n, omega)\n\n    implicit none\n\n    real(kind=8), intent(in) :: sigma(n,0:7)\n    integer, intent(in) :: n\n    real(kind=8), intent(out) :: omega(n,1,0:7,2)\n    integer :: i\n    real(kind=8) :: accumulator\n\n    real(kind=8) :: omega0, omega1, omega2, omega3, omega4, omega5, omega6, omega7\n    do i=8, n-8\n       accumulator = 0.0\n       omega0 = +0.000155400155400155 / (1.e-36 + sigma(i,0)) / (1.e-36 + sigma(i,0))\n       accumulator = accumulator + omega0\n       omega1 = +0.0087024087024087 / (1.e-36 + sigma(i,1)) / (1.e-36 + sigma(i,1))\n       accumulator = accumulator + omega1\n       omega2 = +0.0913752913752914 / (1.e-36 + sigma(i,2)) / (1.e-36 + sigma(i,2))\n       accumulator = accumulator + omega2\n       omega3 = +0.304584304584305 / (1.e-36 + sigma(i,3)) / (1.e-36 + sigma(i,3))\n       accumulator = accumulator + omega3\n       omega4 = +0.380730380730381 / (1.e-36 + sigma(i,4)) / (1.e-36 + sigma(i,4))\n       accumulator = accumulator + omega4\n       omega5 = +0.182750582750583 / (1.e-36 + sigma(i,5)) / (1.e-36 + sigma(i,5))\n       accumulator = accumulator + omega5\n       omega6 = +0.0304584304584305 / (1.e-36 + sigma(i,6)) / (1.e-36 + sigma(i,6))\n       accumulator = accumulator + omega6\n       omega7 = +0.00124320124320124 / (1.e-36 + sigma(i,7)) / (1.e-36 + sigma(i,7))\n       accumulator = accumulator + omega7\n       omega0 = omega0 / accumulator\n       omega1 = omega1 / accumulator\n       omega2 = omega2 / accumulator\n       omega3 = omega3 / accumulator\n       omega4 = omega4 / accumulator\n       omega5 = omega5 / accumulator\n       omega6 = omega6 / accumulator\n       omega7 = omega7 / accumulator\n       omega(i,1,0,1) = omega0\n       omega(i,1,1,1) = omega1\n       omega(i,1,2,1) = omega2\n       omega(i,1,3,1) = omega3\n       omega(i,1,4,1) = omega4\n       omega(i,1,5,1) = omega5\n       omega(i,1,6,1) = omega6\n       omega(i,1,7,1) = omega7\n    end do\n  end subroutine weights_left_k8\n"}, {"instruction": "Create a Fortran subroutine named weights_left_k9 to calculate the omega values based on the given input sigma values. The subroutine should have 2 input parameters of type real(kind=8) and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine weights_left_k9(sigma, n, omega)\n\n    implicit none\n\n    real(kind=8), intent(in) :: sigma(n,0:8)\n    integer, intent(in) :: n\n    real(kind=8), intent(out) :: omega(n,1,0:8,2)\n    integer :: i\n    real(kind=8) :: accumulator\n\n    real(kind=8) :: omega0, omega1, omega2, omega3, omega4, omega5, omega6, omega7, omega8\n    do i=9, n-9\n       accumulator = 0.0\n       omega0 = +4.11353352529823e-05 / (1.e-36 + sigma(i,0)) / (1.e-36 + sigma(i,0))\n       accumulator = accumulator + omega0\n       omega1 = +0.00296174413821473 / (1.e-36 + sigma(i,1)) / (1.e-36 + sigma(i,1))\n       accumulator = accumulator + omega1\n       omega2 = +0.0414644179350062 / (1.e-36 + sigma(i,2)) / (1.e-36 + sigma(i,2))\n       accumulator = accumulator + omega2\n       omega3 = +0.193500617030029 / (1.e-36 + sigma(i,3)) / (1.e-36 + sigma(i,3))\n       accumulator = accumulator + omega3\n       omega4 = +0.362813656931304 / (1.e-36 + sigma(i,4)) / (1.e-36 + sigma(i,4))\n       accumulator = accumulator + omega4\n       omega5 = +0.290250925545043 / (1.e-36 + sigma(i,5)) / (1.e-36 + sigma(i,5))\n       accumulator = accumulator + omega5\n       omega6 = +0.0967503085150144 / (1.e-36 + sigma(i,6)) / (1.e-36 + sigma(i,6))\n       accumulator = accumulator + omega6\n       omega7 = +0.0118469765528589 / (1.e-36 + sigma(i,7)) / (1.e-36 + sigma(i,7))\n       accumulator = accumulator + omega7\n       omega8 = +0.000370218017276841 / (1.e-36 + sigma(i,8)) / (1.e-36 + sigma(i,8))\n       accumulator = accumulator + omega8\n       omega0 = omega0 / accumulator\n       omega1 = omega1 / accumulator\n       omega2 = omega2 / accumulator\n       omega3 = omega3 / accumulator\n       omega4 = omega4 / accumulator\n       omega5 = omega5 / accumulator\n       omega6 = omega6 / accumulator\n       omega7 = omega7 / accumulator\n       omega8 = omega8 / accumulator\n       omega(i,1,0,1) = omega0\n       omega(i,1,1,1) = omega1\n       omega(i,1,2,1) = omega2\n       omega(i,1,3,1) = omega3\n       omega(i,1,4,1) = omega4\n       omega(i,1,5,1) = omega5\n       omega(i,1,6,1) = omega6\n       omega(i,1,7,1) = omega7\n       omega(i,1,8,1) = omega8\n    end do\n  end subroutine weights_left_k9\n"}, {"instruction": "Create a Fortran subroutine named rotate that performs a rotation of a vector from the general Cartesian coordination system into a local one. The subroutine takes 2 input parameters of type real*8 (vector and rotmat) and 1 output parameter of type real*8 (rotvec).", "input": "", "output": "subroutine rotate(vector,rotmat,rotvec)\n  !                                                                       \n  !     rotate performs a rotation of the vector from the general         \n  !     cartesian coordination system into the  local one  of the         \n  !     jatom-th sphere.                                                  \n\n  !                                                                       \n  implicit none\n  real*8, intent(in) :: vector(3), rotmat(3,3)\n  real*8, intent(out):: rotvec(3)\n  !---------------------------------------------------------------------- \n  !\n  rotvec = matmul(rotmat,vector)\n  !do jcoord=1,3     ! 10                                                \n  !   dotpro=0.0d0                                                   \n  !   do j=1,3       ! 20\n  !      dotpro = dotpro + rotmat(jcoord,j)*vector(j)\n  !   enddo\n  !   rotvec(jcoord)=dotpro\n  !enddo !10   continue                                                          \n  return                                                            \nend subroutine rotate\n"}, {"instruction": "Create a Fortran subroutine named gasdv. It takes 5 input parameters with the test_data type of ['integer(4)', 'integer(8)', 'real(8)', 'real(8)', 'real(8)'], and 1 output parameter with the test_data type of ['real(8)']. The subroutine is used to perform a specific calculation related to gas dynamics using the provided input parameters and returns the result through the output parameter.", "input": "", "output": "     subroutine gasdv(numdim,eosinfo,eosparams,eosnondim,qin,dvin)\n       implicit none\n       integer(4), intent(in)  :: numdim\n       integer(8), intent(in)  :: eosinfo\n       real(8),    intent(in)  :: eosparams\n       real(8),    intent(in)  :: eosnondim\n       real(8),    intent(in)  :: qin\n       real(8),    intent(out) :: dvin\n     end subroutine gasdv\n"}, {"instruction": "Create a Fortran subroutine named get_temperature to receive a time value in days as input and return the corresponding temperature as output. The input parameter is of type real and intent(in), while the output parameter is of type real and intent(out).", "input": "", "output": "        subroutine get_temperature( time, temp )\r\n            implicit none\r\n            real, intent(in)  :: time  ! time in days\r\n            real, intent(out) :: temp  ! set temperature\r\n        end subroutine get_temperature\r\n"}, {"instruction": "Create a Fortran subroutine named room_program that takes in a real number as input to represent the time, and returns a real number as output to represent the room temperature. The input parameter should be marked as \"intent(in)\" and the output parameter should be marked as \"intent(out)\".", "input": "", "output": "subroutine room_program( time, temp )\r\n    real, intent(in)  :: time\r\n    real, intent(out) :: temp\r\n\r\n    real              :: tday\r\n\r\n    tday = 24.0 * mod(time, 1.0)  ! time of day\r\n\r\n    if ( tday < 7.0 .or. tday > 23.0 ) then\r\n        temp =  0.0 ! effectively no particular temperature set\r\n    else\r\n        temp = 19.0 ! keep the room temperature at an agreeable level\r\n    endif\r\nend subroutine room_program\r\n"}, {"instruction": "Write a Fortran subroutine named seasonal_temperature that takes a real input parameter time and returns a real output parameter temp. The subroutine calculates the temperature temp based on the input time using the formula temp = 15.0 - 15.0 * cos( time / 365.0 ).", "input": "", "output": "subroutine seasonal_temperature( time, temp )\r\n    real, intent(in)  :: time\r\n    real, intent(out) :: temp\r\n\r\n    real              :: tday\r\n\r\n    temp = 15.0 - 15.0 * cos( time / 365.0 )\r\nend subroutine seasonal_temperature\r\n"}, {"instruction": "Create a Fortran subroutine named matmult to perform matrix multiplication and back substitution. The subroutine takes 2 input parameters: an integer nvar and a 2D real array amat, and outputs a 1D real array rhs.", "input": "", "output": "  subroutine matmult(nvar, amat, rhs)\n    implicit none\n    integer, intent(in) :: nvar\n    real, intent(in) :: amat(:,:)\n    real, intent(out) :: rhs(:)\n\n    integer :: i, j\n\n    do i = 1, nvar-1\n       do j = i+1, nvar\n          rhs(j) = amat(i,i) * rhs(j) - amat(j,i) * rhs(i)\n       end do\n    end do\n\n    ! back substitution\n    rhs(nvar) = rhs(nvar) / amat(nvar,nvar)\n    do i = nvar-1, 1, -1\n       do j = i+1, nvar\n          rhs(i) = rhs(i) - amat(i,j) * rhs(j)\n       end do\n       rhs(i) = rhs(i) / amat(i,i)\n    end do\n  end subroutine matmult\n"}, {"instruction": "Create a Fortran subroutine named mpi_comm_size to retrieve the size of a specified communicator. The subroutine takes 1 input parameter of type integer and returns 2 output parameters, both of type integer.", "input": "", "output": "     subroutine mpi_comm_size(comm, size, ierror)\n       implicit none\n       integer, intent(in) :: comm\n       integer, intent(out) :: size\n       integer, intent(out) :: ierror\n     end subroutine mpi_comm_size\n"}, {"instruction": "Write a Fortran subroutine named linear_solver to find the root of the equation f(tau) = a * tau + b. The subroutine should have 2 input parameters of type double precision, denoted as a and b. It should also have 1 output parameter of type double precision, denoted as dtau.", "input": "", "output": "    subroutine linear_solver(a,b,dtau)\n!\n        !find the root of the equation\n        !f(tau) = a * tau + b\n!\n        implicit none\n!\n        double precision,intent(out)                :: dtau\n        double precision,intent(in)                 :: a,b\n!\n        if(a.eq.0.d0) then\n            dtau = huge(0.d0)\n        else\n            dtau = -b/a    \n        endif        \n!\n    end subroutine linear_solver\n"}, {"instruction": "Write a Fortran subroutine named init to initialize a 3D array with a given size and spacing. The subroutine takes 6 input parameters of type integer, integer, integer, real(kind=4), real(kind=4), real(kind=4) and 1 output parameter of type real(kind=4), dimension(:,:,:) to store the initialized 3D array.", "input": "", "output": "  subroutine init(nx, ny, nz, dx, dy, dz, f)\n    \n    integer,intent(in) :: nx, ny, nz\n    real(kind=4),intent(in) :: dx, dy, dz\n    real(kind=4),intent(out),dimension(:,:,:) :: f\n    real(kind=4) :: kx,ky,kz,x,y,z,pi\n    integer :: i,j,k\n\n    pi = acos(-1.0)\n    kx = 2.0*pi\n    ky = kx\n    kz = kx\n\n    do k = 1, nz\n       do j = 1, ny\n          do i = 1, nx\n\n             x = dx*(real(i-1) + 0.5)\n             y = dy*(real(j-1) + 0.5)\n             z = dz*(real(k-1) + 0.5)\n\n             f(i,j,k) = 0.125*(1.0 - cos(kx*x))*(1.0 - cos(ky*y))*(1.0 - cos(kz*z))\n\n          end do\n       end do\n    end do\n\n  end subroutine init\n"}, {"instruction": "Write a Fortran subroutine named read_2qgate_list to read data from a file. The subroutine takes 1 input argument of type character(*) and 4 output arguments of type integer. The allocatable integer array list_p is of size (:,:) and the other output integers are tq, nol, and nog. This subroutine reads data from the specified file and assigns values to the output parameters based on the data read.", "input": "", "output": "  subroutine read_2qgate_list(list_p,tq,nol,nog,ifile)\n    integer, allocatable, intent(out) :: list_p(:,:)\n    integer, intent(out) :: tq, nol, nog\n    character(*), intent(in) :: ifile\n    integer :: p1,p2,ln,i\n    open(10,file=ifile,action='read')\n    nog = 0\n    do \n       read(10,*,end=9) p1, p2, ln\n       nog = nog + 1\n    end do\n9   rewind(10)\n    allocate(list_p(3,nog))\n    do i = 1, nog\n       read(10,*) p1, p2, ln\n       list_p(1:3,i) = (/p1, p2, ln/)\n    end do \n    close(10)\n    nol = maxval(list_p(3,:))\n    tq = maxval(list_p(1:2,:))\n  end subroutine read_2qgate_list\n"}, {"instruction": "Create a Fortran subroutine named read_so4_theta_list to read data from a file and allocate memory to store the values. The subroutine has 2 input parameters of type integer and character(*), and 2 output parameters of type integer and real(8) array that is allocatable.", "input": "", "output": "  subroutine read_so4_theta_list(ths,noth,nol,ifile)\n    integer, intent(in) :: nol\n    character(*), intent(in) :: ifile\n    integer, intent(out) :: noth\n    real(8), allocatable, intent(out) :: ths(:,:)\n    real(8) :: th(6*nol)\n    integer :: i\n    open(10,file=ifile,action='read')\n    noth = 0\n    do \n       read(10,*,end=9) th\n       noth = noth + 1\n    end do\n9   rewind(10)\n    allocate(ths(6*nol,noth))\n    do i = 1, noth\n       read(10,*) th\n       ths(:,i) = th\n    end do \n    close(10)\n  end subroutine read_so4_theta_list\n"}, {"instruction": "Write a Fortran subroutine named triad that calculates the linear combination of two real arrays and a scalar value. The subroutine takes 3 input parameters of type real arrays and a single real scalar value. It produces 1 output parameter of a real array.", "input": "", "output": "    subroutine triad(a, b, scalar, c)\n    real, intent(in) :: a(:), b(:), scalar\n    real, intent(out) :: c(:)\n    integer :: n, i\n    n = size(a)\n    do concurrent (i = 1:n)\n        c(i) = a(i) + scalar * b(i)\n    end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calcenergy to calculate potential energy in a molecular system. The subroutine takes 6 input parameters: 3 integers, an array of real(8) with dimensions (0:natom-1, 0:dim-1), and 2 real(8) values. The output parameter is a single real(8) value. The subroutine uses the imperative tone to initialize variables, perform computations, and apply conditional checks to calculate potential energy based on the Lennard-Jones potential and harmonic bonding potential.", "input": "", "output": "subroutine calcenergy(pos, m, l, rc, penergy, dim, natom)\r\n    implicit none\r\n    integer, intent(in) :: m, dim, natom\r\n    real(8), intent(in), dimension(0:natom-1, 0:dim-1) :: pos\r\n    real(8), intent(in) :: l, rc\r\n    real(8), intent(out) :: penergy\r\n    real(8), parameter :: k = 3000., r0 = 1.\r\n    integer:: i, j\r\n    real(8) :: kfac, d2, sep, disp, shiftval, rc2, id6, id2, id12\r\n    real(8), dimension(dim) :: rij, posi\r\n    \r\n\r\n    !assign initially zeros to the force array and potential energy\r\n    penergy = 0.\r\n    rc2 = rc**2\r\n\r\n    !precompute constants such as lj shift value up here\r\n    kfac = k/2.\r\n    id6 = 1./rc**6\r\n    shiftval = 4*(id6**2 - id6)\r\n\r\n\r\n    do i=0, natom - 1\r\n        !store pos(i,:) in a temporary array for faster access in j looop\r\n        posi = pos(i,:)\r\n        do j = i+1, natom - 1\r\n            !compute initial rij\r\n            rij = pos(j,:) - posi\r\n            !apply minimum image convention\r\n            rij = rij - l*dnint(rij / l)\r\n\r\n            !do bonded calculation\r\n            if ( j == i+1 .and. mod(j, m)> 0) then\r\n                !compute scalar separation\r\n                sep = sqrt( sum( rij * rij ) )\r\n                !compute displacement relative to preferred separation\r\n                disp = sep - r0\r\n                !calculate energy\r\n                penergy = penergy + kfac * disp*disp\r\n            else   !do nonbonded calculation\r\n                !compute scalar distance\r\n                d2 = sum(rij*rij)\r\n                !check against cutoff\r\n                if ( d2 > rc2) then \r\n                    cycle\r\n                end if\r\n                id2 = 1./d2                 !inverse squared distance\r\n                id6 = id2 * id2 * id2       !inverse sixth distance\r\n                id12 = id6 * id6            !inverse twelfth distance\r\n                penergy = penergy + 4. * (id12 - id6) + shiftval\r\n\r\n                !end nonbonded calculation\r\n            endif\r\n        enddo\r\n    enddo\r\nend subroutine\r\n"}, {"instruction": "Write a Fortran subroutine named split_array to divide an array into segments for parallel processing. The subroutine takes 3 input parameters of type integer: numpoints, ncpu, and n. It returns 2 output parameters also of type integer: counts and displs. The subroutine calculates the counts and displacements for each segment based on the number of points, CPU count, and the segment index.", "input": "", "output": "      subroutine split_array(numpoints,n,ncpu,counts,displs)\n      implicit none\n      integer, intent(in) :: numpoints,ncpu,n\n      integer, intent(out) :: counts,displs\n\n      integer :: ratio, remainder, i\n\n      ratio = numpoints / ncpu\n      remainder = mod(numpoints,ncpu)\n\n      if(n < remainder) then\n         counts = ratio+1\n         displs = i*(ratio+1)\n      else\n         counts = ratio\n         displs = remainder*(ratio+1)+(i-remainder)*ratio\n      endif   \n      \n      end subroutine split_array\n"}, {"instruction": "Create a Fortran subroutine named polynomial_u_basis that generates powers of the input parameter u up to the power of n_g - 1. The subroutine takes 2 input parameters of type real and integer and returns 2 output parameters of type real and real (optional). If the optional output parameter dg_du is not provided, it will not be computed.", "input": "", "output": "subroutine polynomial_u_basis(u, n_g, g, dg_du)\n\n! generates powers of u, u**n where n ranges from 0 to n_g - 1\n\n\timplicit none\n\t\n\treal, intent(in) :: u\n\tinteger, intent(in) :: n_g\n\treal, intent(out) :: g(n_g)\n\treal, optional, intent(out) :: dg_du(n_g)\n\t\n\tinteger :: i\n\t\n\tg(1) = 1.\n\t\n\tdo i = 2, n_g\n\t\tg(i) = u * g(i-1)\n\tend do\n\t\n\tif (.not.present(dg_du))\treturn\n\t\n! derivatives\n\t\n\tdo i = 1, n_g\n\t\tdg_du(i) = (i-1) * g(i-1)\n\tend do\n\nend subroutine polynomial_u_basis\t\n"}, {"instruction": "Create a Fortran subroutine named cos_theta_basis to calculate the values of cos(n * theta) and its derivative with respect to theta. The subroutine takes 2 input parameters of type real and integer. The output consists of 2 parameters of type real and real (optional). If the optional output parameter is provided, the derivative of cos(n * theta) with respect to theta is also computed.", "input": "", "output": "subroutine cos_theta_basis(theta, n_cosn, cosn, dcosn_dtheta)\n\n! generates cos(n * theta) where n ranges from 0 to n_g-1\n\n\timplicit none\n\t\n\treal, intent(in) :: theta\n\tinteger, intent(in) :: n_cosn\n\treal, intent(out) :: cosn(n_cosn)\n\treal, optional, intent(out) :: dcosn_dtheta(n_cosn)\n\t\n\tinteger :: i\n\t\n\tcosn(1) = 1.\n\t\n\tdo i = 2, n_cosn\n\t\tcosn(i) = cos((i-1) * theta)\n\tend do\n\t\n\tif (.not.present(dcosn_dtheta))\treturn\n\t\n\tdcosn_dtheta(1) = 0.\n\t\n\tdo i = 2, n_cosn\n\t\tdcosn_dtheta(i) = -(i-1)*sin((i-1) * theta)\n\tend do\n\t\n\treturn\n\t\nend subroutine cos_theta_basis\t\n"}, {"instruction": "Write a Fortran subroutine named split_line to parse a line of text and extract the name and value separated by an equal sign. The input parameter is a character string (len=*), and the output parameters are two character strings (len=*) and an integer. The subroutine splits the input line into the name and value, and sets the status integer to 0 if successful, or 1 if no equal sign is found in the input line.", "input": "", "output": "    subroutine split_line(line, name, val, stat)\n        implicit none\n        character(len=*), intent(in) :: line\n        character(len=*), intent(out) :: name, val\n        integer, intent(out) :: stat\n        integer :: pos\n\n        pos = index(line, '=')\n        if (pos == 0) then\n            stat = 1\n        end if\n        name = line(:pos-1)\n        val = adjustl(line(pos+1:))\n        stat = 0\n    end subroutine split_line\n"}, {"instruction": "Create a Fortran subroutine named msh to generate a uniform mesh on the interval [0,1]. The subroutine should take 1 input parameter of type integer and produce 1 output parameter of type double precision.", "input": "", "output": "  subroutine msh(ntst,tm)\n\n! generates a uniform mesh on [0,1].\n\n    integer, intent(in) :: ntst\n    double precision, intent(out) :: tm(0:ntst)\n\n    integer j\n\n    do j=0,ntst\n       tm(j)=dble(j)/ntst\n    enddo\n\n  end subroutine msh\n"}, {"instruction": "Create a Fortran subroutine named cpnts to generate collocation points within the interval [0,1]. The subroutine takes 1 input parameter of type integer and outputs an array of double precision numbers.", "input": "", "output": "  subroutine cpnts(ncol,zm)\n\n! generates the collocation points with respect to [0,1].\n\n    integer, intent(in) :: ncol\n    double precision, intent(out) :: zm(ncol)\n\n    double precision, parameter :: &\n         c51 = .5d0*0.90617984593866399280d0, &\n         c52 = .5d0*0.53846931010568309104d0, &\n         c61 = .5d0*0.93246951420315202781d0, &\n         c62 = .5d0*0.66120938646626451366d0, &\n         c63 = .5d0*0.23861918608319690863d0, &\n         c71 = .5d0*0.949107991234275852452d0, &\n         c72 = .5d0*0.74153118559939443986d0, &\n         c73 = .5d0*0.40584515137739716690d0, &\n         r = 6.0d0/7.0d0\n\n    double precision c21,c31,c4,c41,c42\n\n    select case(ncol)\n       case(2)\n          c21 = .5d0/sqrt(3.0d0)\n          zm(1) = .5d0-c21\n          zm(2) = .5d0+c21\n       case(3)\n          c31 = .5d0*sqrt(0.6d0)\n          zm(1) = .5d0-c31\n          zm(2) = .5d0\n          zm(3) = .5d0+c31\n       case(4)\n          c4  = .5d0*sqrt(r**2-12.0d0/35.0d0)\n          c41 = .5d0*sqrt(3.0d0/7.0d0+c4)\n          c42 = .5d0*sqrt(3.0d0/7.0d0-c4)\n          zm(1) = .5d0-c41\n          zm(2) = .5d0-c42\n          zm(3) = .5d0+c42\n          zm(4) = .5d0+c41\n       case(5)\n          zm(:) = (/ .5d0-c51, .5d0-c52, .5d0, .5d0+c52, .5d0+c51 /)\n       case(6)\n          zm(:) = (/ .5d0-c61, .5d0-c62, .5d0-c63, &\n                     .5d0+c63, .5d0+c62, .5d0+c61 /)\n       case(7)\n          zm(:) = (/ .5d0-c71, .5d0-c72, .5d0-c73, .5d0, &\n                     .5d0+c73, .5d0+c72, .5d0+c71  /)\n    end select\n  end subroutine cpnts\n"}, {"instruction": "Create a Fortran subroutine named cntdif to generate the coefficients of the central difference formula for the nth derivative at uniformly spaced points. The subroutine takes 1 input parameter of type integer and outputs an array of integers. The input parameter represents the order of the derivative, and the output array stores the coefficients. Use the imperative tone to specify the subroutine name and its functionality.", "input": "", "output": "  subroutine cntdif(n,d)\n\n! generates the coefficients of the central difference formula for\n! nth derivative at uniformly spaced points\n!              0 = x  < x  < ... < x  = 1.\n!                   0    1          n\n    integer, intent(in) :: n\n    integer, intent(out) :: d(0:n)\n\n    integer i,k\n\n    d(0)=1\n    if(n.eq.0)return\n\n    do i=1,n\n       d(i)=0\n       do k=i,1,-1\n          d(k)=d(k-1)-d(k)\n       enddo\n       d(0)=-d(0)\n    enddo\n\n  end subroutine cntdif\n"}, {"instruction": "Create a Fortran subroutine named wint to generate weights for an integration formula based on polynomial interpolation at ncol+1 equally spaced points in the interval [0,1]. The subroutine takes 1 input argument of type integer and returns 1 output argument of type double precision.", "input": "", "output": "  subroutine wint(ncol,wi)\n\n! generates the weights for the integration formula based on polynomial\n! interpolation at ncol+1 equally spaced points in [0,1].\n\n    integer, intent(in) :: ncol\n    double precision, intent(out) :: wi(0:ncol)\n\n    double precision c\n\n    select case(ncol)\n    case(2)\n       c=1.d0/6.0d0\n       wi(0)=c\n       wi(1)=4.0d0*c\n       wi(2)=c\n    case(3)\n       c=1.d0/8.0d0\n       wi(0)=c\n       wi(1)=3.0d0*c\n       wi(2)=wi(1)\n       wi(3)=c\n    case(4)\n       c=1.d0/90.0d0\n       wi(0)=7.0d0*c\n       wi(1)=32.0d0*c\n       wi(2)=12.0d0*c\n       wi(3)=wi(1)\n       wi(4)=wi(0)\n    case(5)\n       wi(0)=19.0d0/288.0d0\n       wi(1)=25.0d0/96.0d0\n       wi(2)=25.0d0/144.0d0\n       wi(3)=wi(2)\n       wi(4)=wi(1)\n       wi(5)=wi(0)\n    case(6)\n       wi(0)=41.0d0/840.0d0\n       wi(1)=9.0d0/35.0d0\n       wi(2)=9.0d0/280.0d0\n       wi(3)=34.0d0/105.0d0\n       wi(4)=wi(2)\n       wi(5)=wi(1)\n       wi(6)=wi(0)\n    case(7)\n       wi(0)=751.0d0/17280.0d0\n       wi(1)=3577.0d0/17280.0d0\n       wi(2)=49.0d0/640.0d0\n       wi(3)=2989.0d0/17280.0d0\n       wi(4)=wi(3)\n       wi(5)=wi(2)\n       wi(6)=wi(1)\n       wi(7)=wi(0)\n    end select\n\n  end subroutine wint\n"}, {"instruction": "Please write a Fortran subroutine named intwts that generates weights for Lagrange interpolation. The subroutine takes 3 input parameters, which are an integer (n), a double precision number (z), and an array of double precision numbers (x) with a size of (0:n). The subroutine also has 1 output parameter, which is an array of double precision numbers (wts) with a size of (0:n). The purpose of this subroutine is to compute the weights that will be used in Lagrange interpolation. The weights are computed based on the given input values (n, z, and x) using nested loops and mathematical formulas.", "input": "", "output": "  subroutine intwts(n,z,x,wts)\n\n! generates weights for lagrange interpolation.\n\n    integer, intent(in) :: n\n    double precision, intent(in) :: z, x(0:n)\n    double precision, intent(out) :: wts(0:n)\n\n    integer ib,k\n    double precision p\n\n    do ib=0,n\n       p=1.d0\n       do k=0,n\n          if(k/=ib)then\n             p=p*( z-x(k) )/( x(ib)-x(k) )\n          endif\n       enddo\n       wts(ib)=p\n    enddo\n\n  end subroutine intwts\n"}, {"instruction": "Create a Fortran subroutine called cumtrapz that performs numerical integration using the trapezoidal rule on evenly spaced data. The subroutine takes in four input parameters: dx (real*8), z0 (real*8), n (integer), and y(n) (real*8 array). The output parameter is z(n) (real*8 array).\n\nTo use the subroutine, provide the desired spacing between data points (dx), the initial value for the cumulative integral (z0), the number of data points (n), and the array of data points (y). The subroutine will calculate the cumulative integral using the trapezoidal rule and store the result in the array z.\n\nEnsure that the input parameters dx, z0, and y(n) are of type real*8, and the input parameter n is of type integer. The output parameter z(n) should also be of type real*8.\n\nNote: The trapezoidal rule is a numerical integration method that approximates the integral of a function by dividing the area under the curve into trapezoids.", "input": "", "output": "subroutine cumtrapz(y,z,n,dx,z0) bind(c)\n! \u7b49\u95f4\u9694dx\u79bb\u6563\u6570\u636e\u68af\u5f62\u6cd5\u7d2f\u79ef\u6570\u503c\u79ef\u5206\uff0c\u7ed3\u679c\u4fdd\u5b58\u5728\u6570\u7ec4z\u4e2d\uff0c\u521d\u503c\u4e3az0\n\n    real*8, intent(in) :: dx, z0\n    integer, intent(in) :: n\n    real*8, intent(in) :: y(n)\n    real*8, intent(out) :: z(n)\n\n    integer :: i\n    real*8 :: r\n\n    z(1) = z0\n    r = 0.d0\n    do i = 2, n, 1\n        r = r + dx*(y(i)+y(i-1))*0.5\n        z(i) = z0 + r\n    end do\n    return\n\nend subroutine cumtrapz\n"}, {"instruction": "Write a Fortran subroutine named `fftfreqs` that calculates the frequency axis values for the discrete Fourier transform. The subroutine takes two input parameters: `nfft` of type integer, representing the size of the Fourier transform, and `fs` of type real(8), representing the sampling frequency. The subroutine also has one output parameter: `freqs` of type real(8) array, which stores the calculated frequency values.\n\nThe subroutine first calculates the Nyquist frequency (`fn`) by dividing the sampling frequency (`fs`) by 2. It then calculates the frequency resolution (`df`) by dividing the sampling frequency by the number of points in the Fourier transform (`nfft`). \n\nThe `freqs` array is initialized to zero. If the number of points in the Fourier transform is even, the subroutine computes the positive frequency values from 0 to `fn` and the negative frequency values from `-fn` to the second-to-last element of the `freqs` array. If the number of points in the Fourier transform is odd, the subroutine computes the positive frequency values from 0 to `fn` and the negative frequency values from `-fn` to the last element of the `freqs` array.\n\nThe subroutine returns the computed frequency values in the `freqs` array.", "input": "", "output": "subroutine fftfreqs(nfft,fs,freqs) bind(c)\n!dir$ attributes dllexport :: fftfreqs\n! \u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\u7684\u9891\u7387\u8f74\u523b\u5ea6\u503c\uff0cfs\u4e3a\u91c7\u6837\u9891\u7387\uff0c\u7ed3\u679c\u8bb0\u5f55\u5728\u6570\u7ec4freqs\u4e2d\n    integer, intent(in) :: nfft\n    real(8), intent(in) :: fs\n    real(8), intent(out) :: freqs(nfft)\n\n    real(8) :: fn, df\n    integer :: i, l\n\n    fn = 0.5d0*fs\n    df = fs/dble(nfft)\n    freqs = 0.0d0\n\n    if ( mod(nfft, 2) == 0 ) then\n        l = nfft/2-1\n        freqs(2:nfft/2) = [ ( (dble(i)*df), i=1,l ) ]\n        freqs(nfft/2+1:nfft) = [ ( -fn+(dble(i-1)*df), i=1,l+1 ) ]\n    else\n        l = (nfft+1)/2-1\n        freqs(2:(nfft+1)/2) = [ ( (dble(i)*df), i=1,l ) ]\n        freqs((nfft+1)/2+1:nfft) = [ ( -(dble(l-i+1)*df), i=1,l ) ]\n    end if\n\n    return\nend subroutine fftfreqs\n"}, {"instruction": "Write a Fortran subroutine named acc2vd that integrates acceleration to compute velocity and displacement. The subroutine takes 5 input parameters: dt (real(8)), v0 (real(8)), d0 (real(8)), n (integer(4)), and a (real(8) array of size n). It also has 2 output parameters: v (real(8) array of size n) and d (real(8) array of size n).\n\nInside the subroutine, the velocity and displacement are calculated using a numerical integration method. The initial velocity v0 and displacement d0 are assigned to the first elements of the v and d arrays. Then, a loop is executed from i=2 to n, where the velocity and displacement at each step are computed based on the previous values and the acceleration values in the a array.\n\nThe subroutine uses the midpoint rule to perform the integration, where the velocity (v) is updated by adding the average acceleration between two time steps multiplied by the time step (dt). Similarly, the displacement (d) is updated by adding the average velocity between two time steps multiplied by the time step (dt).\n\nFinally, the subroutine returns, and the updated velocity and displacement arrays are available for further processing.\n\nRemember to compile and link the subroutine accordingly to use it in your program.", "input": "", "output": "subroutine acc2vd(a,v,d,n,dt,v0,d0) bind(c)\n!dir$ attributes dllexport :: acc2vd\n! \u52a0\u901f\u5ea6\u79ef\u5206\u4e3a\u901f\u5ea6\u3001\u4f4d\u79fb\n    real(8), intent(in) :: dt,v0,d0\n    integer(4), intent(in) :: n\n    real(8), intent(in) :: a(n)\n    real(8), intent(out) :: v(n), d(n)\n\n    integer(4) :: i\n    real(8) :: vi, di\n\n    v(1) = v0\n    d(1) = d0\n\n    vi = 0.d0\n    di = 0.d0\n    do i = 2, n, 1\n        vi = vi + dt*(a(i)+a(i-1))*0.5\n        v(i) = v0 + vi\n        di = di + dt*(v(i)+v(i-1))*0.5\n        d(i) = d0 + di\n    end do\n    return\nend subroutine acc2vd\n"}, {"instruction": "Create a Fortran subroutine named error to calculate the relative errors between two arrays, y and y0, excluding the first and last elements. The number of input arguments is 3 with test_data types ['integer', 'real(8)', 'real(8)']. The number of output arguments is 2 with test_data types ['real(8)', 'real(8)'].", "input": "", "output": "subroutine error(y,y0,n,aerror,merror) bind(c)\n! \u8ba1\u7b97\u6570\u7ec4y\u548cy0\u7684\u76f8\u5bf9\u8bef\u5dee\uff08\u4e0d\u5305\u62ec\u9996\u5c3e\u5143\u7d20\uff09\uff0caerror \u4e3a\u5e73\u5747\u8bef\u5dee\uff0cmerror \u4e3a\u6700\u5927\u8bef\u5dee\n    integer, intent(in) :: n\n    real(8), intent(in) :: y(n), y0(n)\n    real(8), intent(out) :: aerror, merror\n\n    real(8), allocatable :: e(:)\n\n    allocate(e(n-2))\n\n    e = (y(2:n-1) - y0(2:n-1))/y0(2:n-1)\n\n    !aerror = sum(abs(e))/dble(n-2)\n    aerror = sqrt(sum(e*e)/dble(n-2))\n    merror = maxval(abs(e), dim=1)\n\n    deallocate(e)\n\nend subroutine error\n"}, {"instruction": "Create a Fortran subroutine named errora to calculate the relative errors between two arrays of real(8) numbers. The subroutine takes 3 input parameters of type integer, real(8) array, and real(8) array. It returns 2 output parameters of type real(8) for average error and maximum error.", "input": "", "output": "subroutine errora(y,y0,n,aerror,merror) bind(c)\n! \u8ba1\u7b97\u6570\u7ec4y\u548cy0\u7684\u76f8\u5bf9\u8bef\u5dee\uff08\u5305\u62ec\u6240\u6709\u5143\u7d20\uff09\uff0caerror \u4e3a\u5e73\u5747\u8bef\u5dee\uff0cmerror \u4e3a\u6700\u5927\u8bef\u5dee\n    integer, intent(in) :: n\n    real(8), intent(in) :: y(n), y0(n)\n    real(8), intent(out) :: aerror, merror\n\n    real(8), allocatable :: e(:)\n\n    allocate(e(n))\n\n    e = (y - y0)/y0\n\n    !aerror = sum(abs(e))/dble(n)\n    aerror = sqrt(sum(e*e)/dble(n))\n    merror = maxval(abs(e), dim=1)\n\n    deallocate(e)\n\nend subroutine errora\n"}, {"instruction": "Write a Fortran subroutine named fftpadding to perform zero-padding on a data sequence. The subroutine takes 3 input parameters of type integer, integer, and real*8, and 1 output parameter of type real*8. The input parameters represent the length of the input data, the desired length after padding, and the input data sequence. The output parameter represents the padded data sequence.", "input": "", "output": "subroutine fftpadding(in,out,n,nfft) bind(c)\n! \u6570\u636e\u5e8f\u5217\u540e\u8865\u96f6\n    integer, intent(in) :: n, nfft\n    real*8, intent(in) :: in(n)\n    real*8, intent(out) :: out(nfft)\n\n    out(1:n) = in(1:n)\n    out(n+1:nfft) = 0.d0\n\n    return\nend subroutine fftpadding\n"}, {"instruction": "Create a Fortran subroutine named \"newmark\" to perform Newmark's method for solving dynamic equilibrium equations. The subroutine should have 5 input parameters of types integer, real(8), real(8), real(8), and real(8), and 5 output parameters of types real(8), real(8), real(8), real(8), and integer. The subroutine computes and returns the values of \"spa\", \"spv\", \"spd\", \"spe\", and \"spi\" based on the input parameters \"acc\", \"n\", \"dt0\", \"zeta\", and \"p\".", "input": "", "output": "subroutine newmark(acc,n,dt0,zeta,p,spa,spi,spv,spd,spe) bind(c)\n\n    integer, intent(in) :: n\n    real(8), intent(in) :: dt0, zeta\n    real(8), intent(in) :: acc(n), p\n    real(8), intent(out) :: spa, spv, spd, spe\n    integer, intent(out) :: spi\n\n    real(8) :: rc(3),rl(3),ac,al,aa,ein,da\n    real(8) :: beta = 1.d0/4.d0, gamma = 0.5d0\n    real(8) :: k,c,w,keff,kinv,feff,dt,rvl\n    real(8) :: b1, b2, b3, b4, b5, b6, b7, b8\n    integer :: i,j,r\n\n    if ( dt0*mpr > p ) then\n        r  = ceiling(mpr*dt0/p)\n        dt = dt0/r\n    else\n        r = 1\n        dt = dt0\n    end if\n\n    b1 = 1.d0/(beta*dt*dt)\n    b2 = 1.d0/(beta*dt)\n    b3 = 1.d0/(beta*2.0d0)-1.d0\n    b4 = gamma/(beta*dt)\n    b5 = gamma/beta-1.d0\n    b6 = 0.5d0*dt*(gamma/beta-2.0d0)\n    b7 = dt*(1.0d0-gamma)\n    b8 = dt*gamma\n\n    w = two_pi/p\n    k = w**2.d0\n    c = 2.0d0*zeta*w\n    keff = k+b1+b4*c\n    kinv = 1.0d0/keff\n\n    !  initiation\n    rl = 0.d0\n    rc = 0.d0\n    spa = 0.0d0\n    spv = 0.0d0\n    spd = 0.0d0\n    spi = 0\n    ein = 0.0d0\n    al = 0.d0\n    rvl = 0.d0\n\n    !  computation of response\n    do i = 1,n,1\n\n        ac = acc(i)\n        da = (ac - al)/dble(r)\n\n        do j = 1, r, 1\n            ac = al + da*j\n            feff = ac+(b1*rl(1)+b2*rl(2)+b3*rl(3))&\n            +c*(b4*rl(1)+b5*rl(2)+b6*rl(3))\n            rc(1) = feff*kinv\n            rc(2) = b4*(rc(1)-rl(1))-b5*rl(2)-b6*rl(3)\n            rc(3) = ac-k*rc(1)-c*rc(2)\n            rl(1) = rc(1)\n            rl(2) = rc(2)\n            rl(3) = rc(3)\n        end do\n\n        ein = ein+0.5d0*dt0*(rvl*al+rc(2)*ac)\n        aa = -rc(3)+ac\n\n        if (abs(aa) > abs(spa)) then\n            spa=aa\n            spi=i\n        endif\n\n        if (abs(rc(2)) > abs(spv)) then\n            spv=rc(2)\n        endif\n\n        if (abs(rc(1)) > abs(spd)) then\n            spd=rc(1)\n        endif\n\n        al = ac\n        rvl = rc(2)\n\n    end do\n    spe = sqrt(2.d0*ein)\n    return\nend subroutine newmark\n"}, {"instruction": "Create a Fortran subroutine named rnmk with 5 input parameters of type integer, real(8), real(8), real(8), real(8) and 3 output parameters of type real(8), real(8), real(8). The subroutine computes the response of a dynamic system using the Newmark-beta method for structural dynamics. The input parameters represent acceleration, time step, damping ratio, load period, and load magnitude, while the output parameters represent the response acceleration, velocity, and displacement.", "input": "", "output": "subroutine rnmk(acc,n,dt0,zeta,p,ra,rv,rd) bind(c)\n!dir$ attributes dllexport :: rnmk\n    integer, intent(in) :: n\n    real(8), intent(in) :: dt0, zeta\n    real(8), intent(in) :: acc(n), p\n    real(8), intent(out) :: ra(n),rv(n),rd(n)\n\n    real(8) :: rc(3),rl(3),ac,al,aa,da\n    real(8) :: beta = 1.d0/4.d0, gamma = 0.5d0\n    real(8) :: k,c,w,keff,kinv,feff,dt,rvl\n    real(8) :: b1, b2, b3, b4, b5, b6, b7, b8\n    integer :: i,j,r\n\n    if ( dt0*mpr > p ) then\n        r  = ceiling(mpr*dt0/p)\n        dt = dt0/r\n    else\n        r = 1\n        dt = dt0\n    end if\n\n    b1 = 1.d0/(beta*dt*dt)\n    b2 = 1.d0/(beta*dt)\n    b3 = 1.d0/(beta*2.0d0)-1.d0\n    b4 = gamma/(beta*dt)\n    b5 = gamma/beta-1.d0\n    b6 = 0.5d0*dt*(gamma/beta-2.0d0)\n    b7 = dt*(1.0d0-gamma)\n    b8 = dt*gamma\n\n    w = two_pi/p\n    k = w**2.d0\n    c = 2.0d0*zeta*w\n    keff = k+b1+b4*c\n    kinv = 1.0d0/keff\n\n    !  initiation\n    rl = 0.d0\n    rc = 0.d0\n    ra = 0.d0\n    rv = 0.d0\n    rd = 0.d0\n    al = 0.d0\n\n    !  computation of response\n    do i = 1, n, 1\n\n        ac = acc(i)\n        da = (ac - al)/dble(r)\n\n        do j = 1, r, 1\n            ac = al + da*j\n            feff = ac+(b1*rl(1)+b2*rl(2)+b3*rl(3))&\n            +c*(b4*rl(1)+b5*rl(2)+b6*rl(3))\n            rc(1) = feff*kinv\n            rc(2) = b4*(rc(1)-rl(1))-b5*rl(2)-b6*rl(3)\n            rc(3) = ac-k*rc(1)-c*rc(2)\n            rl(1) = rc(1)\n            rl(2) = rc(2)\n            rl(3) = rc(3)\n        end do\n\n        ra(i) = -rc(3)+ac\n        rv(i) = -rc(2)\n        rd(i) = -rc(1)\n\n        al = ac\n\n    end do\n    return\nend subroutine rnmk\n"}, {"instruction": "Write a Fortran subroutine named energy that takes 9 input parameters of types integer and real(8) and 5 output parameters of type real(8). The input parameters are acc, n, dt, zeta, p, ra, rv, rd, and ku. The output parameters are ek, ez, es, eh, and ein. The subroutine calculates the energy values for a given system and updates the output parameters accordingly.", "input": "", "output": "subroutine energy(acc,n,dt,zeta,p,ra,rv,rd,ek,ez,es,eh,ein,ku) bind(c)\n!dir$ attributes dllexport :: energy\n    integer, intent(in) :: n\n    real(8), intent(in) :: acc(n), ra(n), rv(n), rd(n), ku(n)\n    real(8), intent(in) :: dt, zeta, p\n    real(8), intent(out) :: ek(n),ez(n),es(n),eh(n),ein(n)\n\n    integer :: i\n    real(8) :: w, fs(2), ea, c, ddsub(2)\n\n    w = two_pi/p\n    c = 2.d0*zeta*w\n\n    ek(1) = rv(1)*rv(1)*0.5d0\n    ez(1) = 0.5d0*dt*(0.d0+c*rv(1)*rv(1))\n    fs = [0.d0, -ra(1)-c*rv(1)]\n    ea = 0.5d0*dt*(0.d0+fs(2)*rv(1))\n    es(1) = fs(2)*fs(2)*0.5d0/(ku(1))\n    eh(1) = ea - es(1)\n    ein(1) = 0.5d0*dt*(0.d0-acc(1)*rv(1))\n!     bl(1) = ein(1) - ek(1) - ez(1) - ea\n\n    do i = 2, n, 1\n        ek(i) = rv(i)*rv(i)*0.5d0\n        ez(i) = ez(i-1) + 0.5d0*dt*c*(rv(i-1)*rv(i-1)+rv(i)*rv(i))\n\n        fs(1) = - ra(i-1) - c*rv(i-1)\n        fs(2) = - ra(i) - c*rv(i)\n        \n        if (fs(1)*fs(2)<0.d0) then\n            ddsub(1) = (0.d0-fs(1))/ku(i-1)\n            ddsub(2) = fs(2)/ku(i)\n            ea = ea + 0.5d0*ddsub(1)*(fs(1)+0.d0) + 0.5d0*ddsub(2)*(0.d0+fs(2))\n        else\n            ea = ea + 0.5d0*(rd(i)-rd(i-1))*(fs(1)+fs(2))\n        end if\n        \n        !ea = ea + 0.5d0*(rd(i)-rd(i-1))*(fs(1)+fs(2))\n        !ea = ea + 0.5d0*dt*(fs(1)*rv(i-1)+fs(2)*rv(i))\n        es(i) = fs(2)*fs(2)*0.5d0/(ku(i))\n        eh(i) = ea - es(i)\n\n        ein(i) = ein(i-1) - 0.5d0*dt*(acc(i-1)*rv(i-1)+acc(i)*rv(i))\n!         bl(i) = ein(i) - ek(i) - ez(i) - ea\n\n    end do\nend subroutine energy\n"}, {"instruction": "Write a Fortran subroutine named flat_double that takes a 2D array \"a\" of size n x m as input, and flattens it into a 1D array \"af\" of size n * m as output. The input parameters consist of two integers n and m, and a real(8) array a(n,m). The output parameter is a real(8) array af(n*m).", "input": "", "output": "subroutine flat_double(a,n,m,af)\n\n    integer, intent(in) :: n, m\n    real(8), intent(in) :: a(n,m)\n    real(8), intent(out) :: af(n*m)\n\n    integer :: i, j\n\n    do i = 1, n, 1\n        do j = 1, m, 1\n            af(n*(j-1)+i) = a(i,j)\n        end do\n    end do\n\nend subroutine flat_double\n"}, {"instruction": "Create a Fortran subroutine named repeat_double that takes in three input parameters: n and m of type integer, and a of type real(8). It also has one output parameter ar of type real(8). \n\nThe purpose of this subroutine is to repeat the elements of array a n times and store the result in array ar. The size of array ar is n*m. \n\nTo achieve this, iterate through the elements of a for m times and assign them to the corresponding positions in ar. The elements of a will be repeated n times in ar.\n\nProvide the required input and output parameters when calling this subroutine to perform the desired operation.", "input": "", "output": "subroutine repeat_double(a,n,m,ar)\n    integer, intent(in) :: n,m\n    real(8), intent(in) :: a(n)\n    real(8), intent(out) :: ar(n*m)\n\n    integer :: i\n\n    do i = 1, m, 1\n        ar((i-1)*n+1:(i-1)*n+n) = a\n    end do\n    \nend subroutine repeat_double\n"}, {"instruction": "Write a Fortran subroutine named \"wfunc\" that computes a waveform based on given parameters. The subroutine takes 5 input arguments of types ['integer', 'integer', 'real(8)', 'real(8)', 'real(8)'] and 1 output argument of type ['real(8)'].\n\nThe subroutine performs the following steps:\n1. Allocate memory for an array \"tmp2\" of size \"n\".\n2. Calculate the value of \"tm\" as the product of \"dt\" and \"itm-1\".\n3. Calculate the value of \"w\" as the quotient of \"two_pi\" and \"p\".\n4. Calculate the value of \"f\" as the reciprocal of \"p\".\n5. Calculate the value of \"tmp1\" as the square root of \"1.0\" minus the square of \"zeta\".\n6. Calculate the value of \"gamma\" using a formula involving \"f\" and \"tmp1\".\n7. Calculate the value of \"deltat\" as the arctangent of \"tmp1/zeta\" divided by the product of \"w\" and \"tmp1\".\n8. Fill the array \"tmp2\" with values calculated using a loop and store the results of the expression \"(dble(i-1)*dt-tm+deltat)\" for each index \"i\".\n9. Compute the waveform \"wf\" using the cosine and exponential functions applied to the array \"tmp2\".\n10. Deallocate the memory allocated for \"tmp2\".\n\nMake sure to include the necessary Fortran keywords and follow the specified data types for the input and output arguments.", "input": "", "output": "subroutine wfunc(n,dt,itm,p,zeta,wf) bind(c)\n\n    integer, intent(in) :: n, itm\n    real(8), intent(in) :: dt, p, zeta\n    real(8), intent(out) :: wf(n)\n\n    real(8) :: tm, w, f, tmp1, gamma, deltat\n    real(8), allocatable :: tmp2(:)\n    integer :: i\n\n    allocate(tmp2(n))\n\n    tm = dble(itm-1)*dt\n    w = two_pi/p\n    f = 1.d0/p\n\n    tmp1 = sqrt(1.d0-zeta**2)\n    gamma = 1.178d0*(f*tmp1)**(-0.93d0)\n    deltat = atan(tmp1/zeta)/(w*tmp1)\n\n    tmp2 = [ ( ( dble(i-1)*dt-tm+deltat ),i=1,n ) ]\n\n    wf = cos(w*tmp1*tmp2)*exp(-(tmp2/gamma)**2)\n\n    deallocate(tmp2)\n\n    return\nend subroutine wfunc\n"}, {"instruction": "Write a Fortran subroutine named num_to_g that takes two input arrays: num which is an array of integers and nf which is a 2D array of integers. The subroutine also has one output array named g, which is an array of integers. \n\nThe subroutine will perform a calculation where it assigns values to g based on the values in num and nf. The size of the arrays will be determined by the dimensions of num and nf. \n\nTo perform the calculation, the subroutine will iterate over the elements of num and for each element, it will use it to extract values from nf and assign them to consecutive elements of g. \n\nFinally, the subroutine will return the updated array g.", "input": "", "output": "subroutine num_to_g(num,nf,g)\r\n!\r\n\n!\r\n implicit none\r\n integer,intent(in)::num(:),nf(:,:)  \r\n integer,intent(out)::g(:)\r\n integer::i,k,nod,nodof \r\n nod=ubound(num,1) \r\n nodof=ubound(nf,1)\r\n do i=1,nod\r\n   k=i*nodof\r\n   g(k-nodof+1:k)=nf(:,num(i))\r\n end do\r\nreturn\r\nend subroutine num_to_g   \r\n"}, {"instruction": "Create a Fortran subroutine called selectedrealkind to calculate the value of a selected kind parameter for a real number. The subroutine takes two input arguments, both of type integer, and one output argument of type integer. The input arguments represent the precision and range values, while the output argument stores the calculated selected kind parameter.", "input": "", "output": "subroutine selectedrealkind(p, r, res)\n  implicit none\n\n  integer, intent(in) :: p, r\n  !f2py integer :: r=0\n  integer, intent(out) :: res\n  res = selected_real_kind(p, r)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named selectedintkind that takes an integer value as input and returns the corresponding kind value as output. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine selectedintkind(p, res)\n  implicit none\n\n  integer, intent(in) :: p\n  integer, intent(out) :: res\n  res = selected_int_kind(p)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"inarea\" that determines whether a given point (specified by its polar coordinates phi, rho, and z) lies within a specific integral area. The subroutine takes three input arguments of type real(8) - phi, rho, and z. It also has one output argument of type real(8) - h.\n\nTo determine if the point is within the integral area, the subroutine checks if the z-coordinate of the point lies between the lower and upper boundary of a cylindrical surface with a radius of 3. If z is within this range, h is set to 1. Otherwise, h is set to 0.\n\nEnsure that you specify the number and type of input and output parameters correctly in the instruction. The number of input parameters is 3, and their data types are real(8). The number of output parameters is 1, and its data type is real(8).", "input": "", "output": "subroutine inarea(phi, rho, z, h)\n    ! judge whether the dot is in the integral area\n    real(8), intent(in) :: phi, rho, z\n    real(8), intent(out) :: h\n\n    if ((z > -sqrt(9.d0 - rho**2)) .and. (z < sqrt(9.d0 - rho**2))) then\n        h = 1.d0\n    else\n        h = 0.d0\n    end if\nend subroutine inarea\n"}, {"instruction": "Write a Fortran subroutine named raz2 to perform a series of calculations based on the given input parameters. The number of input parameters is 10, and the test_data types are ['integer', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real, dimension(n)', 'real', 'real', 'real, optional']. The number of output parameters is 3, and the test_data types are ['real, dimension(n+1)', 'real, dimension(n+1)', 'real'].\n\nThe purpose of this subroutine is to compute values for the arrays e and t, as well as the scalar variable mu, based on the given input parameters. The subroutine follows the imperative style of programming and contains a do loop for iterative calculations. Additionally, it supports the optional input parameter p0.\n\nPlease refer to the code for further details on the calculations performed by the subroutine.", "input": "", "output": "  pure subroutine raz2(n, w, c, phi, u, alpha, b, h, f, e, t, mu, p0)\n    integer, intent(in) :: n\n    real, dimension(n), intent(in) :: w, c, phi, u, alpha, b\n    real, intent(in) :: h(n+1), f\n    real, dimension(n+1), intent(out) :: e, t\n    real, intent(out) :: mu\n    real, optional, intent(in) :: p0\n    integer :: i, j\n    real :: phim, tana, tana2\n\n    e = 0\n    t = 0\n    if(present(p0)) then\n      e(1) = p0\n      t(1) = p0\n    end if\n\n    do i = 2, n + 1\n      j = i - 1\n      tana = tan(alpha(j))\n      tana2 = tana**2\n      phim = tan(phi(j)) / f\n      e(i) = 2. * t(j) * (tana - phim) + e(j) * (1. + 2. * tana * phim - tana2)&\n           + w(j) * b(j) / 3. * (h(i) + 2. * h(j)) * (tana - phim)&\n           - b(j) * (1. + tana2) * (c(j) / f - u(j) * phim)\n      e(i) = e(i) / (1. + tana2)\n      t(i) = (e(i) + e(j)) * tana - t(j) + w(j) * b(j) / 6. * (h(i) - h(j))\n    end do\n    mu = 1. - e(n+1) / maxval(e)\n  end subroutine\n"}, {"instruction": "Provide a Fortran subroutine named \"k2_short\" that calculates the thermal conductivity coefficient \"k\" based on several input parameters. The subroutine takes 12 input arguments of various types, including an integer, arrays of real*8 values, and individual real*8 values. The output argument is a single real*8 value. \n\nThe purpose of the subroutine is to compute the thermal conductivity coefficient by performing a series of calculations using the input parameters. These calculations involve mathematical operations, array manipulations, and allocation and deallocation of arrays. The subroutine uses temporary arrays and intermediate variables to store intermediate results. Finally, the computed \"k\" value is assigned to the output argument.\n\nEnsure that the subroutine is called with appropriate input arguments and that the output argument receives the calculated thermal conductivity coefficient \"k\".", "input": "", "output": "subroutine k2_short(p,nz,t,tc,tab,ts0,tgamair,tgamself,tnair,tn0,nol,k,imax)\n\n    implicit none\n\n    integer,intent(in) :: imax\n    real*8,dimension(imax),intent(in) :: ts0,tc,tgamair,tgamself,tnair,tn0,tab\n    real*8,intent(in) :: nz,nol,t,p\n    real*8,intent(out) :: k\n    real*8,parameter :: tref = 296.0,kb = 1.3806488e-16,pi = 3.141592653589793238462643383279 !cgs\n    real*8, allocatable :: tgama(:),tflor(:),tk(:), tref2,tmp(:)\n    real*8,parameter :: rpi = 1/pi\n\n    allocate(tgama(imax),tflor(imax),tk(imax), tmp(imax))\n\n\n\n    tref2 = tref/t\n    tmp = (nol-tn0) ** 2\n\n\n\n    tgama = p*(tref2**tnair)*(tgamair*(1-tc*tab)+tgamself*tc*tab)\n\n\n\n    tflor = rpi*tgama/((tgama**2)+tmp)\n\n\n\n    tk  = ts0*tflor*tc\n\n    k = sum(tk)*nz\n\n    deallocate(tgama,tflor,tk,tmp)\n\nend subroutine k2_short\n"}, {"instruction": "Create a Fortran subroutine named \"esat\" to calculate the saturation vapor pressure and its derivative over water and ice based on the given temperature. The number of input parameters is 1 with the test_data type ['real'], and the number of output parameters is 4 with the test_data type ['real', 'real', 'real', 'real'].", "input": "", "output": "  subroutine esat(t, esw, esi, desw, desi)\n!---------------------------------------------------------------------------------------------------\n! use polynomials to calculate saturation vapor pressure and derivative with\n! respect to temperature: over water when t > 0 c and over ice when t <= 0 c\n  implicit none\n!---------------------------------------------------------------------------------------------------\n! in\n\n  real, intent(in)  :: t              !temperature\n\n!out\n\n  real, intent(out) :: esw            !saturation vapor pressure over water (pa)\n  real, intent(out) :: esi            !saturation vapor pressure over ice (pa)\n  real, intent(out) :: desw           !d(esat)/dt over water (pa/k)\n  real, intent(out) :: desi           !d(esat)/dt over ice (pa/k)\n\n! local\n\n  real :: a0,a1,a2,a3,a4,a5,a6  !coefficients for esat over water\n  real :: b0,b1,b2,b3,b4,b5,b6  !coefficients for esat over ice\n  real :: c0,c1,c2,c3,c4,c5,c6  !coefficients for dsat over water\n  real :: d0,d1,d2,d3,d4,d5,d6  !coefficients for dsat over ice\n\n  parameter (a0=6.107799961    , a1=4.436518521e-01,  &\n             a2=1.428945805e-02, a3=2.650648471e-04,  &\n             a4=3.031240396e-06, a5=2.034080948e-08,  &\n             a6=6.136820929e-11)\n\n  parameter (b0=6.109177956    , b1=5.034698970e-01,  &\n             b2=1.886013408e-02, b3=4.176223716e-04,  &\n             b4=5.824720280e-06, b5=4.838803174e-08,  &\n             b6=1.838826904e-10)\n\n  parameter (c0= 4.438099984e-01, c1=2.857002636e-02,  &\n             c2= 7.938054040e-04, c3=1.215215065e-05,  &\n             c4= 1.036561403e-07, c5=3.532421810e-10,  &\n             c6=-7.090244804e-13)\n\n  parameter (d0=5.030305237e-01, d1=3.773255020e-02,  &\n             d2=1.267995369e-03, d3=2.477563108e-05,  &\n             d4=3.005693132e-07, d5=2.158542548e-09,  &\n             d6=7.131097725e-12)\n\n  esw  = 100.*(a0+t*(a1+t*(a2+t*(a3+t*(a4+t*(a5+t*a6))))))\n  esi  = 100.*(b0+t*(b1+t*(b2+t*(b3+t*(b4+t*(b5+t*b6))))))\n  desw = 100.*(c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6))))))\n  desi = 100.*(d0+t*(d1+t*(d2+t*(d3+t*(d4+t*(d5+t*d6))))))\n\n  end subroutine esat\n"}, {"instruction": "Create a Fortran subroutine named readpotential to read potential data from a file and store it in a 2D array. The subroutine takes 4 input parameters of type ['character*200', 'integer', 'integer', 'integer'] and 1 output parameter of type ['real*8'].", "input": "", "output": "subroutine readpotential(vr, filename, maxnr, nr, nat)\n!!! reading potential\n  real*8, intent(out)       :: vr(maxnr,nat)\n  character*200, intent(in) :: filename\n  integer, intent(in)       :: nat, maxnr, nr(nat)\n  !! temporary\n  integer :: jtape, iscf, idummy, j, jatom\n  !\n  jtape=18\n  open(jtape,file=filename,status='old')\n  read(jtape, '(50x,i2,//)') iscf\n\n  do jatom=1,nat\n     read(jtape,1980)\n     read(jtape,2000) idummy\n     read(jtape,2031)\n     read(jtape,2022)(vr(j,jatom),j=1,nr(jatom))\n     read(jtape,2031)\n     read(jtape,2030)\n  enddo\n  \n  vr(:,:)=vr(:,:)/2.0d0  ! to hartree's?\n  close(jtape)\n2022 format(3x,4e19.12)\n2000 format(16x,i2//)\n1980 format(3x)\n2031 format(/)\n2030 format(///)\nend subroutine readpotential\n"}, {"instruction": "Create a Fortran subroutine named iterate to solve a 1D partial differential equation using the iterative method. The subroutine takes 4 input parameters: n (integer), iters (integer), u0 (real(kind=8), dimension(0:n+1)), f (real(kind=8), dimension(0:n+1)), and produces 1 output parameter: u (real(kind=8), dimension(0:n+1)).", "input": "", "output": "subroutine iterate(u0,iters,f,u,n)\n    implicit none\n    integer, intent(in) :: n, iters\n    real(kind=8), dimension(0:n+1), intent(in) :: u0, f\n    real(kind=8), dimension(0:n+1), intent(out) :: u\n\n    ! local variables:\n    real(kind=8), dimension(:), allocatable :: uold\n    real(kind=8) :: dx\n    integer :: i, iter\n\n    ! allocate storage for boundary points too:\n    allocate(uold(0:n+1))\n\n    ! grid spacing:\n    dx = 1.d0 / (n+1.d0)\n\n    uold = u0\n\n    ! initialize boundary values of u:\n    u(0) = u0(0)\n    u(n+1) = u0(n+1)\n\n    ! take the iterations requested:\n    do iter=1,iters\n        do i=1,n\n            u(i) = 0.5d0*(uold(i-1) + uold(i+1) + dx**2*f(i))\n            enddo\n        uold = u\n        enddo\n\nend subroutine iterate\n"}, {"instruction": "Write a Fortran subroutine named double to double the input integer and store the result in the output integer. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 1, and the test_data type is ['integer'].", "input": "", "output": "subroutine double(i,i2)\r\ninteger, intent(in)  :: i\r\ninteger, intent(out) :: i2\r\nprint*,\"entering double, i =\",i\r\ni2 = 2*i\r\nprint*,\"leaving double, i =\",i\r\nend subroutine double\r\n"}, {"instruction": "Create a Fortran subroutine named convert_c2s that converts Cartesian coordinates to spherical coordinates. The input parameter is a real*8 array xyz(3) representing (x, y, z) coordinates. The output parameter is a real*8 array rtp(3) representing (r, cos(t), phi) coordinates, where -pi<phi<pi.", "input": "", "output": "   subroutine convert_c2s(xyz,rtp)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!  convert cartesian to spherical coordinates\n!  input: xyz(3)=(x, y, z)\n!  output: rtp=(r, cos(t), phi), where -pi<phi<pi\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      real*8, intent(in) :: xyz(3)\n      real*8, intent(out):: rtp(3)\n\n      rtp=0d0\n  \n      rtp(1)=dsqrt(xyz(1)**2+xyz(2)**2+xyz(3)**2)\n      if(rtp(1) .eq. 0) return    \n      \n      rtp(2)=xyz(3)/rtp(1)\n      rtp(3)=datan2(xyz(2),xyz(1))\n\n   end subroutine convert_c2s\n"}, {"instruction": "Create a Fortran subroutine named \"shcilmtocindex\" that converts a 3D matrix of spherical harmonic coefficients into a 2D matrix indexed by a specific formula. The subroutine takes 2 input parameters of types real*8 and integer (optional) and produces 1 output parameter of type real*8. The input parameters are cilm and degmax, and the output parameter is cindex.", "input": "", "output": "subroutine shcilmtocindex(cilm, cindex, degmax)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis routine will convert a 3d matrix of spherical harmonics indexed as (i, l+1, m+1)\n!\tinto a 2d matrix that is indexed as (i, index) where index = l(l+1)/2+m+1.\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tcilm\tarray of spherical harmonic coefficients with dimensions \n!\t\t\t\t(2, lmax+1, lmax+1).\n!\t\tout\n!\t\t\tcindex\tarray of indexed spherical harmonic coefficnets with dimensions\n!\t\t\t\t(2, (lmax+1)*(lmax+2)/2).\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek 2004.\n!\n!\tcopyright (c) 2005-2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\treal*8, intent(in) :: cilm(:,:,:)\n\treal*8, intent(out) :: cindex(:,:)\n\tinteger, intent(in), optional ::\tdegmax\n\tinteger :: lmax, l, m, index\n\t\n\tif (present(degmax)) then\n\t\tlmax = degmax\n\t\tif (size(cilm(:,1,1)) < 2 .or. size(cilm(1,:,1)) < lmax + 1 .or. size(cilm(1,1,:)) < lmax+1 ) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cilm must be dimensioned as (2, degmax+1, degmax+1) where degmax is \", degmax\n\t\t\tprint*, \"input array is dimensioned \", size(cilm(:,1,1)), size(cilm(1,:,1)), size(cilm(1,1,:))\n\t\t\tstop\n\t\telseif (size(cindex(:,1)) < 2 .or. size(cindex(1,:)) < (lmax+1)*(lmax+2)/2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cindex must be dimensioned as (2, (degmax+1)*(degmax+2)/2) where degmax is \", degmax\n\t\t\tprint*, \"input array is dimensioned \", size(cindex(:,1)), size(cindex(1,:))\n\t\t\tstop\n\t\tendif\n\telse\n\t\tlmax = min(size(cilm(1,1,:)) - 1, size(cilm(1,:,1)) - 1)\n\t\tif (size(cilm(:,1,1)) < 2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cilm must be dimensioned as (2, *, *).\"\n\t\t\tprint*, \"input array is dimensioned \", size(cilm(:,1,1)), size(cilm(1,:,1)), size(cilm(1,1,:))\n\t\t\tstop\n\t\telseif (size(cindex(:,1)) < 2 .or. size(cindex(1,:)) <  (lmax+1)*(lmax+2)/2) then\n\t\t\tprint*, \"error --- shcilmtocindex\"\n\t\t\tprint*, \"cindex must be dimensioned as (2, (lmax+1)*(lmax+2)/2) where lmax is \", lmax\n\t\t\tstop\n\t\tendif\n\tendif\n\t\t\n\tdo l=0, lmax\n\t\tdo m=0, l\n\t\t\tindex = l*(l+1)/2+m+1\n\t\t\tcindex(1, index) = cilm(1,l+1,m+1)\n\t\t\tcindex(2, index) = cilm(2,l+1,m+1)\n\t\tenddo\n\tenddo\n\nend subroutine shcilmtocindex\n"}, {"instruction": "Write a Fortran subroutine named gaulegf to compute the abscissas and weights for the Gauss-Legendre quadrature. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and 2 output parameters of type real(8) arrays with dimension n.", "input": "", "output": "subroutine gaulegf(x1, x2, x, w, n)\n  integer, intent(in) :: n\n  real(8), intent(in) :: x1, x2\n  real(8), dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  real(8) :: p1, p2, p3, pp, xl, xm, z, z1\n  real(8), parameter :: eps=3.d-14\n\n  pp = 0.0d0\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.0\n    do while(abs(z-z1) .gt. eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\n\nend subroutine gaulegf\n"}, {"instruction": "Create a Fortran subroutine named random_walk_fast_2d to generate a random walk on a 2D grid. The subroutine takes 7 input parameters of types integer, real, and real, and 2 output parameters of type real. The input parameters include step_size, phi, box_size, x_start, y_start, periodic, and length. The output parameters are x and y, representing the coordinates of the random walk simulation. The subroutine enforces periodic boundary conditions based on the value of the periodic parameter.", "input": "", "output": "subroutine random_walk_fast_2d(step_size, phi, box_size, x_start, y_start, periodic, length, x, y)\n    ! generates a random walk on a 2d grid.\n    !\n    ! parameters\n    ! ----------\n    ! step_size : float\n    !    a set of input step size values.\n    ! phi : array\n    !    random angles.\n    ! box_size : float\n    !    box size parameters.\n    ! x_start, y_start : float\n    !    starting x & y coordinates.\n    ! periodic : {0, 1}, int\n    !    0 = does not enforce periodic boundary conditions.\n    !    1 = enforces periodic boundary conditions.\n    ! length : int\n    !    length of the x & y coordinates.\n    !\n    ! returns\n    ! -------\n    ! x, y : array\n    !    the coordinates of the random walk simulation.\n\n    implicit none\n\n    integer, intent(in) :: length\n    real, intent(in) :: step_size(length), phi(length)\n    real, intent(in) :: box_size, x_start, y_start\n    integer, intent(in) :: periodic\n    real, intent(out) :: x(length+1), y(length+1)\n    integer :: i\n    real :: delta_x, delta_y, x_current, y_current\n\n    x(1) = x_start\n    y(1) = y_start\n\n    x_current = x_start\n    y_current = y_start\n\n    do i = 2, length+1\n\n        delta_x = step_size(i-1)*cos(phi(i-1))\n        delta_y = step_size(i-1)*sin(phi(i-1))\n\n        x_current = x_current + delta_x\n        y_current = y_current + delta_y\n\n        if (periodic == 1) then\n\n            do while (x_current < 0. .or. x_current > box_size)\n                if (x_current < 0.) then\n                    x_current = x_current + box_size\n                else if (x_current > box_size) then\n                    x_current = x_current - box_size\n                end if\n            end do\n\n            do while (y_current < 0. .or. y_current > box_size)\n                if (y_current < 0.) then\n                    y_current = y_current + box_size\n                else if (y_current > box_size) then\n                    y_current = y_current - box_size\n                end if\n            end do\n\n        end if\n\n        x(i) = x_current\n        y(i) = y_current\n\n    end do\n\nend subroutine random_walk_fast_2d\n"}, {"instruction": "Create a Fortran subroutine named make_banded_matrix to generate a banded matrix from the given row vector and dimensions. The number of input parameters is 3, with test_data types ['integer', 'integer', 'real(sp), dimension(m)']. The number of output parameters is 1, with test_data type ['real(sp), dimension(m, n)'].", "input": "", "output": "    pure subroutine make_banded_matrix(n, m, row, mat)        \n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n, m\n        real(sp), intent(in), dimension(m) :: row\n        real(sp), intent(out), dimension(m, n) :: mat\n\n        integer :: j, k, l, r\n\n        k = (m - 1) / 2\n        l = k + 1\n        r = n - k\n\n        ! fill left triangle part of band\n        do j = 1, k\n            mat(k + 2 - j + 0:, j) = row(k + 2 - j:)\n            mat(:k + 2 - j - 1, j) = 0 ! can be removed\n        end do\n\n        ! fill body\n        do j = l, r\n            mat(:, j) = row(:)\n        end do\n\n        ! fill right triangle part of band\n        do j = 1, k\n            mat(:m - j + 0, n - k + j) = row(:m - j)\n            mat(m - j + 1:, n - k + j) = 0 ! can be removed\n        end do\n    end subroutine make_banded_matrix\n"}, {"instruction": "Create a Fortran subroutine named divide_derivative_on_radius that takes 3 input parameters of type integer, integer, and real(sp), and 1 output parameter of type real(sp) with dimensions m and n. The subroutine computes the derivative of l1 with respect to the radius and stores the result in the output parameter. Use the imperative tone in your instructions.", "input": "", "output": "    pure subroutine divide_derivative_on_radius(n, m, h, l1)\n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n\n        integer, intent(in) :: m\n        real(sp), intent(in) :: h\n        real(sp), intent(out), dimension(m, n) :: l1\n\n        integer :: i, j, row\n\n        ! row k = i + j - k0: k = 0,1,2,...,n - 1, where k0: m = 2 k0 - 3. cause is sum (i + j) is invarian of row.\n        do i = 1, m\n            do j = 1, n\n                row = i + j - (m + 3) / 2\n\n                if (row > 0) then\n                    l1(i, j) = l1(i, j) / (row * h)\n                end if\n            end do\n        end do\n    end subroutine divide_derivative_on_radius\n"}, {"instruction": "Write a Fortran subroutine named \"revervoir\" to calculate the reservoir response using the given parameters. The subroutine should have 4 input parameters of types integer, real(sp) arrays of dimension n, real(sp) arrays of dimension 23, and real(sp) arrays of dimension n, and 1 output parameter of type real(sp) array of dimension n.", "input": "", "output": "    subroutine revervoir(pumping, coeffs, u_sqr, r, n)\n        implicit none\n\n        integer, parameter :: sp = selected_real_kind(6, 37)\n        integer, intent(in) :: n\n        real(sp), intent(in), dimension(n) :: pumping\n        real(sp), intent(in), dimension(23) :: coeffs\n        real(sp), intent(in), dimension(n) :: u_sqr\n        real(sp), intent(out), dimension(n) :: r ! actually n(r)\n\n        r = coeffs(12) * pumping  / (coeffs(13) + coeffs(14) * u_sqr)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gridinterpol to implement linear interpolation and extrapolation of observed data to the model grid. The input parameters include 6 arguments: 2 integers, 2 real arrays, and 2 integers. The output parameter is a real array.", "input": "", "output": "subroutine gridinterpol(n,cols,obs_z,obs_prof,nlev_,model_z,model_prof)\n!\n! !description:\n!\n\n!  be given on an arbitrary, but structured grid, are linearly interpolated and\n!  extrapolated to the actual (moving) model grid.\n!\n! !uses:\n   implicit none\n!\n! !input parameters:\n   !n    : number of vertical layers in observation data\n   !cols : number of profiles in obs. data\n   integer,  intent(in)                :: n,cols\n   real,     intent(in)                :: obs_z(n),obs_prof(n,cols)\n   !nlev_: number of vertical layers in model\n   integer,  intent(in)                :: nlev_\n   real,     intent(in)                :: model_z(nlev_)\n!\n! !output parameters:\n   real,     intent(out)               :: model_prof(nlev_,cols)\n!\n! !revision history:\n!  original author(s): karsten bolding & hans burchard\n!\n!eop\n!\n! !local variables:\n   integer                   :: i,j,ii\n   real                      :: rat\n!-----------------------------------------------------------------------\n!boc\n   model_prof(:,:) = 0d0\n!  set surface values to uppermost input value\n   do i=nlev_,1,-1\n      if(model_z(i) .ge. obs_z(n)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(n,j)\n         end do\n      end if\n   end do\n\n!  set bottom values to lowest input value\n   do i=1,nlev_\n      if(model_z(i) .le. obs_z(1)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(1,j)\n         end do\n      end if\n   end do\n\n!  interpolate inner values linearly\n   do i=1, nlev_, 1\n!   do i= nlev_, 1, -1\n      if ((model_z(i) .lt. obs_z(n)) .and. (model_z(i) .gt. obs_z(1))) then\n         ii=0\n224      ii=ii+1\n         !write(6,*) 'model_z(',i,') = ',model_z(i)\n         !write(6,*) 'obs_z(',ii,') = ',obs_z(ii)\n         if (obs_z(ii) .le. model_z(i)) goto 224\n\n         rat=(model_z(i)-obs_z(ii-1))/(obs_z(ii)-obs_z(ii-1))\n\n         do j=1,cols\n            model_prof(i,j)=(1d0-rat)*obs_prof(ii-1,j)+rat*obs_prof(ii,j)\n         enddo\n      endif\n   enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mean_molecular_weight to calculate the mean molecular weight. The subroutine takes 4 input parameters of type integer, real(8), real(8), real(8), and returns 2 output parameters of type real(8) and character(len=1000).", "input": "", "output": "subroutine mean_molecular_weight(nq, usol_layer, mass, background_mu, mubar, err)\n  implicit none\n  \n  integer, intent(in) :: nq\n  real(8), intent(in) :: usol_layer(nq)\n  real(8), intent(in) :: mass(nq)\n  real(8), intent(in) :: background_mu\n  \n  real(8), intent(out) :: mubar\n  character(len=1000), intent(out) :: err\n  integer :: j\n  real(8) :: f_background\n  err = \"\"\n\n  mubar = 0.d0\n  do j = 1, nq\n    mubar = mubar + usol_layer(j) * mass(j)\n  enddo\n  f_background = 1 - sum(usol_layer)\n  \n  if (f_background < 0.d0) then\n    err = \"mixing ratios sum to > 1.0. atmosphere is probably in a run-away state.\"\n    return\n  endif\n  \n  mubar = mubar + f_background * background_mu\n  \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named caldat to convert a Julian date to Gregorian date. The subroutine takes 1 input parameter of type integer and returns 3 output parameters, all of type integer.", "input": "", "output": "subroutine caldat(julian,year,month,day)\n\ninteger, intent(in)                     :: julian\ninteger, intent(out)                    :: year,month,day\n\n! ... local variables\n! ...\ninteger, parameter                      :: igreg=2299161\ninteger ja,jalpha,jb,jc,jd,je\n\nif (julian.ge.igreg) then\n  jalpha = int(((julian-1867216)-0.25d0)/36524.25d0)\n  ja = julian+1+jalpha-int(0.25d0*jalpha)\nelse\n  ja = julian\nendif\n\njb = ja + 1524\njc = int(6680.d0+((jb-2439870)-122.1d0)/365.25d0)\njd = 365*jc + int(0.25d0*jc)\nje = int((jb-jd)/30.6001d0)\nday = jb - jd - int(30.6001d0*je)\nmonth = je - 1\nif (month.gt.12) month = month-12\nyear = jc - 4715\nif (month.gt.2) year = year-1\nif (year.le.0) year = year-1\n\nend subroutine caldat\n"}, {"instruction": "Create a Fortran subroutine named calc_hypotenuse to calculate the length of the hypotenuse of a right-angled triangle. The subroutine takes 2 input parameters of type real, representing the lengths of the two sides, and has 1 output parameter of type real representing the length of the hypotenuse. Use the imperative tone in the instructions.", "input": "", "output": "subroutine calc_hypotenuse(side_1, side_2, hypotenuse)\nimplicit none\n  real, intent(in) :: side_1, side_2\n  real, intent(out) :: hypotenuse\n  real :: temp\n\n  temp = side_1**2 + side_2**2\n  hypotenuse = sqrt(temp)\n\nend subroutine calc_hypotenuse\n"}, {"instruction": "Create a Fortran subroutine named vonmises_dvec to calculate the von Mises norm of deviatoric stress or deviatoric strain given in Voigt notation. The subroutine takes 3 input parameters of types real array, character, and integer array, and 2 output parameters of types real array and real.", "input": "", "output": "    subroutine vonmises_dvec(a, m, ma, vm, an)\r\n    ! von mises norm of deviatoric stress or dev strain given in voigt notation\r\n    ! masked array ma\r\n        real(kind=8)    ::  a(5), an(5), vm, fvm\r\n        integer         ::  i, ma(5)\r\n        character(6)    ::  m\r\n\r\n        intent(in)      ::  a, m, ma\r\n        intent(out)     ::  vm, an\r\n\r\n        if (m == 'strain') then\r\n            fvm = sqrt(2.d0/3.d0)\r\n        elseif (m == 'stress') then\r\n            fvm = sqrt(3.d0/2.d0)\r\n        end if\r\n\r\n        an = 0.d0\r\n        forall (i=1:5, ma(i)==1) an(i) = a(i)\r\n\r\n        vm = fvm*sqrt(an(1)**2 + an(2)**2 + (-an(1)-an(2))**2 + 2.d0*an(3)**2 + 2.d0*an(4)**2 + 2.d0*an(5)**2)\r\n\r\n        an = a\r\n        forall (i=1:5, ma(i)==1) an(i) = an(i)/vm\r\n\r\n    end subroutine vonmises_dvec\r\n"}, {"instruction": "Write a Fortran subroutine named \"throw\" to simulate throwing multiple dice and store the results in an array. The subroutine takes 2 input parameters of type integer: \"sides\" and \"ndice\". It also has 1 output parameter of type integer array with dimension 2: \"dice_arr\". Inside the subroutine, use a function \"die\" to generate random numbers representing the dice throws.", "input": "", "output": "subroutine throw(dice_arr, sides, ndice)\nimplicit none\ninteger, dimension(2), intent(out) :: dice_arr\ninteger, intent(in) :: sides, ndice\ninteger :: i\n\ndo i = 1, ndice\n  dice_arr(i) = die()\nend do\n\ncontains\n  integer function die()\n  die = ceiling(rand() * sides)\n  end function die\nend subroutine throw\n"}, {"instruction": "Create a Fortran subroutine named computeetfromgw_max to calculate the maximum evapotranspiration from groundwater. The subroutine takes 5 input parameters of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "  subroutine computeetfromgw_max(depthtogw,sy,rootdepth,capillaryrise,area,etfromgw_max)\n    real(8),intent(in)  :: depthtogw(:),sy(:),rootdepth(:),capillaryrise(:),area(:,:)\n    real(8),intent(out) :: etfromgw_max(:,:)\n    \n    !local variables\n    integer :: indxelem,indxlu,nlanduse\n    real(8) :: rdgw,rsy,rrz,rrise,rintersect\n    \n    !initialize\n    nlanduse = size(rootdepth)\n    \n    !compute\n    do indxelem=1,size(depthtogw)\n        rdgw  = depthtogw(indxelem)\n        rrise = capillaryrise(indxelem) \n        rsy   = sy(indxelem)\n        do indxlu=1,nlanduse\n            !no et from gw if land use area is zero\n            if (area(indxlu,indxelem) .eq. 0.0) then\n                etfromgw_max(indxlu,indxelem) = 0.0\n                cycle\n            end if\n            \n            !root depth\n            rrz = rootdepth(indxlu)\n            \n            !gw is below root zone\n            if (rdgw .gt. rrz) then\n                !capillary rise does not reach into root zone\n                if (rrise+rrz .le. rdgw) then\n                    etfromgw_max(indxlu,indxelem) = 0.0\n                    \n                !capillary rise extends into root zone \n                else\n                    !there is no capillary rise\n                    if (rrise .eq. 0.0) then\n                        etfromgw_max(indxlu,indxelem) = 0.0\n                       \n                    !capillary rise does not exceed land surface\n                    elseif (rdgw .gt. rrise) then\n                        rintersect = rrz - rdgw + rrise\n                        etfromgw_max(indxlu,indxelem) = 0.5 * rintersect * rintersect * rsy / rrise\n                    \n                    !capillary rise exceeds land surface\n                    else\n                        etfromgw_max(indxlu,indxelem) = rrz * rsy * (0.5 * rrz + rrise - rdgw) / rrise\n                    end if\n                end if\n                \n            !gw is above root zone\n            else\n                !capillary rise does not exceed land surface\n                if (rdgw .gt. rrise) then\n                    etfromgw_max(indxlu,indxelem) = 0.5 * rrise * rsy + rsy * (rrz - rdgw)\n                    \n                !capillary rise exceeds land surface\n                else\n                    if (rrise .eq. 0.0) then\n                        etfromgw_max(indxlu,indxelem) = rsy * (rrz - rdgw)\n                    else\n                        etfromgw_max(indxlu,indxelem) = 0.5 * rsy * (2.0 * rrise * rrz - rdgw * rdgw) / rrise\n                    end if\n                end if\n            end if\n            \n        end do\n    end do\n    \n  end subroutine computeetfromgw_max\n"}, {"instruction": "Create a Fortran subroutine named get_dayno_from_monthday to calculate the number of days since the beginning of the year based on the given month day. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine get_dayno_from_monthday(datumin,daysamount)\r\n\r\n    !argument declarations\r\n    integer, intent(in)  :: datumin       !<month day (mmdd): 31st of january = 0131\r\n    integer, intent(out) :: daysamount    !<corresponding amount of days since beginning of year\r\n    \r\n    !local variables\r\n    integer month          !current month\r\n    integer day,feb        !current day and number of days in february\r\n\r\n    month = datumin/100\r\n    day = datumin - 100*month\r\n    feb = 28  !since no year, no leap year is assumed\r\n    select case (month)\r\n    case (1)\r\n      daysamount = day\r\n    case (2)\r\n      daysamount = 31 + day\r\n    case (3)\r\n      daysamount = 31 + feb + day\r\n    case (4)\r\n      daysamount = 62 + feb + day\r\n    case (5)\r\n      daysamount = 92 + feb + day\r\n    case (6)\r\n      daysamount = 123 + feb + day\r\n    case (7)\r\n      daysamount = 153 + feb + day\r\n    case (8)\r\n      daysamount = 184 + feb + day\r\n    case (9)\r\n      daysamount = 215 + feb + day\r\n    case (10)\r\n      daysamount = 245 + feb + day\r\n    case (11)\r\n      daysamount = 276 + feb + day\r\n    case (12)\r\n      daysamount = 306 + feb + day\r\n    case default\r\n      daysamount = 0\r\n    end select\r\n\r\n  end subroutine get_dayno_from_monthday\r\n"}, {"instruction": "Create a Fortran subroutine named \"parselogical\" to parse a character input into a logical variable. The input parameter is a single character string. The output parameters are two logical variables, with the second one being optional.", "input": "", "output": "        subroutine parselogical(dummy,ll,ok)\n    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    !*      parse dummy into a logical variable.\n            character(len=*),intent(in)         ::      dummy\n            logical,intent(out)                 ::      ll\n            logical,intent(out),optional        ::      ok\n            if (len_trim(dummy)==0) then\n                ll = .false.\n                if (present(ok)) ok = .false.\n            end if\n            ll = ( (trim(dummy)==\"t\") .or. (trim(dummy)==\"true\") .or. (trim(dummy)==\".true.\")    &\n                  .or. (trim(dummy)==\"t\") .or. (trim(dummy)==\"true\") .or. (trim(dummy)==\".true.\") )\n            if (present(ok)) then\n                if (ll) then\n                    ok = .true.\n                else\n                    ok = ( (trim(dummy)==\"f\") .or. (trim(dummy)==\"false\") .or. (trim(dummy)==\".false.\")    &\n                          .or. (trim(dummy)==\"f\") .or. (trim(dummy)==\"false\") .or. (trim(dummy)==\".false.\") )\n                end if\n            end if\n\n            return\n        end subroutine parselogical\n"}, {"instruction": "Create a Fortran subroutine named calc_d2vec that takes two input parameters of type real(kind=8) and one output parameter of type real(kind=8). The input parameters represent a vector and its length, and the output parameter represents a second derivative matrix. The subroutine calculates the entries of the second derivative matrix using the input vector and its length, and applies a length prefactor before returning the result.", "input": "", "output": "subroutine calc_d2vec(d2_mat,v,len)\nimplicit none \n!     the normalized vector to be derivated \nreal(kind=8), intent(in) :: v(3)\n!     the length of the given vector \nreal(kind=8), intent(in) :: len\n!     the calculated second derivative matrix \nreal(kind=8), intent(out) :: d2_mat(3,3,3)\n\n!\n!     calculate entries of second derivative matrix \n!     --> the matrix is diagonal!\n!\n!     dv/dx^2\nd2_mat(1,1,1)=-3d0*v(1)*(v(2)**2+v(3)**2)\nd2_mat(1,1,2)=v(2)*(2d0*v(1)**2-v(3)**2-v(2)**2)\nd2_mat(1,1,3)=v(3)*(2d0*v(1)**2-v(2)**2-v(3)**2)\n!     dv/dxdy\nd2_mat(1,2,1)=-v(2)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,2,2)=-v(1)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(1,2,3)=3d0*v(1)*v(2)*v(3)\n!     dv/dxdz\nd2_mat(1,3,1)=-v(3)*(-2d0*v(1)**2+v(2)**2+v(3)**2)\nd2_mat(1,3,2)=3d0*v(1)*v(2)*v(3)\nd2_mat(1,3,3)=-v(1)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dydx\nd2_mat(2,1,:)=d2_mat(1,2,:)\n!     dv/dydy\nd2_mat(2,2,1)=v(1)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\nd2_mat(2,2,2)=-3d0*v(2)*(v(1)**2+v(3)**2)\nd2_mat(2,2,3)=v(3)*(-v(1)**2+2d0*v(2)**2-v(3)**2)\n!     dv/dydz\nd2_mat(2,3,1)=3d0*v(1)*v(2)*v(3)\nd2_mat(2,3,2)=-v(3)*(v(1)**2-2d0*v(2)**2+v(3)**2)\nd2_mat(2,3,3)=-v(2)*(v(1)**2+v(2)**2-2d0*v(3)**2)\n!     dv/dzdx\nd2_mat(3,1,:)=d2_mat(1,3,:)\n!     dv/dzdy\nd2_mat(3,2,:)=d2_mat(2,3,:)\n!     dv/dzdz\nd2_mat(3,3,1)=v(1)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,2)=v(2)*(-v(1)**2-v(2)**2+2d0*v(3)**2)\nd2_mat(3,3,3)=-3d0*v(3)*(v(1)**2+v(2)**2)\n!\n!     apply length prefactor \n!\nd2_mat=d2_mat/(len**5)\n\nreturn\nend subroutine calc_d2vec\n"}, {"instruction": "Create a Fortran subroutine named fcsr_ptrindices to generate pointer indices. The subroutine takes 3 input parameters of type integer: n, ndata, and an array xinds of size ndata. It produces 1 output parameter of type integer array of size n named ptr.", "input": "", "output": "subroutine fcsr_ptrindices(xinds,ptr,n,ndata)\n    implicit none\n    integer,intent(in) :: n,ndata\n    integer,intent(in),dimension(ndata) :: xinds\n    integer,intent(out),dimension(n) :: ptr\n    integer :: row,datai\n    \n    !f2py intent(in) :: n,ndata,xinds\n    !f2py intent(out) :: ptr\n    ptr(1)=0\n    datai=1\n    do row=2,n\n        if(xinds(datai)>=row-1) then\n            ptr(row)=datai-1\n        else\n            do while(xinds(datai)<row-1 .and. datai<=ndata)\n                datai=datai+1\n            enddo\n            ptr(row)=datai-1\n        endif\n    enddo\nend subroutine fcsr_ptrindices\n"}, {"instruction": "Create a Fortran subroutine named fget_tlu_seq1 with the following functionality:\n- Accepts 5 input parameters of types integer, integer, complex*16 array of size n, complex*16 array of size n-1, and complex*16 array of size n-1.\n- Returns 3 output parameters of types complex*16 array of size n-1, complex*16 array of size n-1, and complex*16 array of size n.\nThis subroutine performs a computation involving complex numbers and array manipulation based on the value of the \"which\" parameter.", "input": "", "output": "subroutine fget_tlu_seq1(al,bl,cl,ll,ul,hl,n,which)\n    implicit none\n    integer,intent(in) :: n,which\n    complex*16,intent(in),dimension(n) :: bl\n    complex*16,intent(in),dimension(n-1) :: al,cl\n    complex*16,intent(out),dimension(n-1) :: ll,ul\n    complex*16,intent(out),dimension(n) :: hl\n    complex*16 :: bi,hi,ui\n    integer :: i\n    \n    !f2py intent(in) :: n,p,which,al,bl,cl\n    !f2py intent(out) :: ll,ul,hl\n\n    select case(which)\n    case(1)\n        !sequence for i < j\n        ll=al\n        do i=1,n\n            bi=bl(i)\n            hi=bi\n            if(i/=1) then\n                hi=hi-ll(i-1)*ui\n            endif\n            hl(i)=hi\n            if(i/=n) then\n                ui=cl(i)/hi\n                ul(i)=ui\n            endif\n        enddo\n    case(2)\n        !sequence for i > j\n        ll=cl\n        do i=n,1,-1\n            hi=bl(i)\n            if(i/=n) then\n                hi=hi-ll(i)*ui\n            endif\n            hl(i)=hi\n            if(i/=1) then\n                ui=al(i-1)/hi\n                ul(i-1)=ui\n            endif\n        enddo\n    endselect\nend subroutine fget_tlu_seq1\n"}, {"instruction": "Create a Fortran subroutine named fget_uv that computes the values of ul and vl using complex arithmetic. It takes 4 input parameters: an integer n, and three complex arrays invdu, invdl, and cl of dimension n, n, and n-1 respectively. It returns two complex arrays ul and vl, both of dimension n.", "input": "", "output": "subroutine fget_uv(invdu,invdl,cl,ul,vl,n)\n    implicit none\n    integer,intent(in) :: n\n    complex*16,intent(in),dimension(n) :: invdu,invdl\n    complex*16,intent(in),dimension(n-1) :: cl\n    complex*16,intent(out),dimension(n) :: ul,vl\n    complex*16 :: ui,vi\n    integer :: i\n    \n    !f2py intent(in) :: n,invdu,invdl,cl\n    !f2py intent(out) :: ul,vl\n\n    !get vl\n    vi=1d0*invdu(1)\n    vl(1)=vi\n    do i=2,n\n        vi=-vi*cl(i-1)*invdu(i)\n        vl(i)=vi\n    enddo\n    !get ul\n    ui=invdl(n)/vl(n)\n    ul(n)=ui\n    do i=n-1,1,-1\n        ui=-ui*cl(i)*invdl(i)\n        ul(i)=ui\n    enddo\nend subroutine fget_uv\n"}, {"instruction": "Create a Fortran subroutine named pick_range to select a range of integers within a specified range. The subroutine takes 2 input parameters of type integer, and 2 output parameters of type integer. The input parameters are from and to, representing the range of integers to select from. The output parameters are start and finish, which represent the selected range of integers.", "input": "", "output": "subroutine pick_range(from,to,start,finish)\n  ! modified version of:\n  ! http://rosettacode.org/wiki/pick_random_element#fortran\n  integer, intent(in)  :: from, to\n  integer, intent(out) :: start, finish\n  integer, allocatable :: a(:)\n  integer :: k\n  real*8  :: r\n  allocate(a(to-from))\n  do k=1, to-from\n    a(k) = k+from\n  end do!k\n  call random_number(r)\n  start = a(int(r*(size(a))) + 1)\n  do\n    call random_number(r)\n    k = a(int(r*(size(a))) + 1)\n    if (k>start) then\n      finish = k\n      exit\n    elseif (k<start) then\n      finish = start\n      start = k\n      exit\n    end if\n  end do\nend subroutine pick_range\n"}, {"instruction": "Create a Fortran subroutine named roulettewheelselection to randomly select a parent from a population based on their fitness levels. The subroutine should take an array of real*8 values representing fitness levels as input and output an integer representing the selected parent.", "input": "", "output": "subroutine roulettewheelselection(fitnesses,p1)\n! chooses parent from the population by the fitness and weighting by the fitness it randomly chooses a parent.\n  real*8,  intent(in) :: fitnesses(:)\n  integer, intent(out):: p1\n  real*8 :: r, total, pick\n  integer :: popno, i\n  popno = size(fitnesses,1)\n  total = sum(fitnesses)\n  call random_number(r)\n  r=r*total\n  pick = 0.d0\n  do i=1,popno\n    pick = pick + fitnesses(i)\n    if (pick > r)  then\n      p1=i\n      goto 11\n    endif\n  end do!i\n11 continue\n  ! todo check\nend subroutine roulettewheelselection\n"}, {"instruction": "Write a Fortran subroutine named kurtosis that calculates the kurtosis of a three-dimensional array. The subroutine accepts 4 input parameters: 3 integers (nx, ny, nz) and a double precision array of dimension (nx, ny, nz). It returns 1 output parameter of type double precision.", "input": "", "output": "subroutine kurtosis(a,nx,ny,nz,krt)\n   integer, intent(in) :: nx, ny, nz\n   double precision, intent(out):: krt\n   double precision, dimension(nx,ny,nz), intent(in) :: a\n!f2py intent (in) nx,ny,nz\n!f2py intent (in) a\n!f2py intent (out) krt\n   double precision, dimension(nx,ny,nz) :: temp\n   double precision :: tmp, norm\n   norm=nx*ny*nz\n   tmp=sum(a)/norm; temp=a-tmp\n   tmp=sum(temp**2)/norm\n   krt=sum(temp**4)/(norm*tmp**2)\nend subroutine kurtosis\n"}, {"instruction": "Write a Fortran subroutine named roll_idx that takes 3 input parameters of type integer (x, nx, inc) and returns 1 output parameter of type integer (xx). The subroutine computes the value of xx based on the conditions specified in the code.", "input": "", "output": "subroutine roll_idx(x,nx,inc,xx)\n   integer, intent(in) :: x,nx,inc\n   integer, intent(out):: xx\n!f2py intent (in) x,nx,inc\n!f2py intent (out) xx\n   xx = merge(x+inc, x-nx+inc+1, (x .lt. nx-inc))\n!  if (x .lt. nx-inc) then \n!     xx=x+inc \n!  else \n!     xx=x-nx+inc+1\n!  endif\nend subroutine roll_idx\n"}, {"instruction": "Write a Fortran subroutine named read_obs to read observation data. The subroutine takes 3 input parameters of type integer and 5 output parameters consisting of 4 integers and an array of real numbers.", "input": "", "output": "      subroutine read_obs(n_count,un,nmax,yyyy,mm,dd,hh,vector)\n!\n\n!\n! **********************************************************************\n      implicit none\n\n!     global declarations:\n      integer, intent(in)  :: n_count\n      integer, intent(in)  :: un\n      integer, intent(in)  :: nmax\n      integer, intent(out) :: yyyy\n      integer, intent(out) :: mm\n      integer, intent(out) :: dd\n      integer, intent(out) :: hh\n      real,    intent(out) :: vector(nmax)\n\n!     local declarations:\n\n      character (len=256) :: heading\n\n!     content of routine:\n\n      vector = 0.0\n\n      if(n_count == 1)then\n        read(un,*) heading\n        read(un,*) yyyy,mm,dd,hh,vector\n      else\n        read(un,*) yyyy,mm,dd,hh,vector\n      end if !(n_count == 1)\n\n\n      end subroutine read_obs\n"}, {"instruction": "Write a Fortran subroutine named process that takes an array of real numbers a, an integer n, and outputs an array of real numbers b. The subroutine computes the exponential of the sine of each element in array a and stores the result in array b.", "input": "", "output": "subroutine process(a, b, n)\n\nreal, intent(in) :: a(:)\nreal, intent(out) :: b(:)\ninteger, intent(in) :: n\ninteger :: i\n\n!$acc parallel loop\ndo i = 1, n\n  b(i) = exp(sin(a(i)))\nenddo\n\nend subroutine process\n"}, {"instruction": "Write a Fortran subroutine named irand to generate an array of random integers. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer array.", "input": "", "output": " subroutine irand(maxi,ix)\n  integer,intent(in)  :: maxi\n  integer,intent(out) :: ix(:)\n  integer :: i,n\n  double precision,allocatable :: d(:)\n  n=size(ix)\n  allocate(d(n))\n  call random_number(d)\n  ix=int(d*maxi)+1\n  deallocate(d)\n return\n end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rep_char to replicate a single character c for n times and store the result in the variable out. The number of input parameters is 2, of type ['character(len=1)', 'integer'], and the number of output parameters is 1, of type ['character(len=n)'].", "input": "", "output": "    subroutine rep_char(c, n, out)\n        character(len=1), intent(in)  :: c\n        integer,          intent(in)  :: n\n        character(len=n), intent(out) :: out\n        integer                       :: i\n\n        do i = 1, n\n            out(i:i) = c(1:1)\n        end do\n    end subroutine rep_char\n"}, {"instruction": "Create a Fortran subroutine named trimw that removes leading whitespace from a given string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*). The output parameter contains the input string with leading whitespace removed.", "input": "", "output": "    subroutine trimw(str, out)\n        character(len=*), intent(in)  :: str\n        character(len=*), intent(out) :: out\n        integer                       :: i\n\n        do i = 1, len(str)\n            if (str(i:i) == ' ') then\n                cycle\n            else\n                exit\n            end if\n        end do\n\n        out = str(i:)\n    end subroutine trimw\n"}, {"instruction": "Create a Fortran subroutine named calc_fits to perform calculations for fitting a model to a set of images. The subroutine takes 8 input parameters of type integer and real, including arrays of various dimensions. It also has 2 output parameters, both of type real and with specific dimensions. The subroutine performs nested loops to compute the best fit for each pixel in the images based on the model and parameter values provided.", "input": "", "output": "subroutine calc_fits(images, model, parvals, n_vals, n_wlens, x, y, n_pars, results, all_fit)\n\nimplicit none\ninteger, intent(in) :: n_vals, n_wlens, x, y, n_pars\nreal, dimension(n_vals, n_pars), intent(in) :: parvals\nreal, dimension(n_vals, n_wlens), intent(in) :: model\nreal, dimension(n_wlens, x, y), intent(in) :: images\nreal, dimension(x, y, n_pars+1), intent(out) :: results\nreal, dimension(x, y, n_vals), intent(out) :: all_fit\n!real, dimension(n_vals), intent(out) :: all_fit\ninteger :: i, j, t, w\nreal :: error, total_error, this_fit, best_fit\n\n!print*, 'wtfishappening'\ndo j = 1, y\n  do i = 1, x\n    best_fit = 1e38 ! arbitrarily large number\n    do t = 1, n_vals\n      total_error = 0.0\n      do w = 1, n_wlens\n        error = abs(images(w,i,j) - model(t, w))\n        total_error = total_error + error\n      end do\n      this_fit = total_error / real(n_wlens)\n      all_fit(i, j, t) = this_fit\n      !if (j == 14 .and. i == 56) then\n      !!if (j == 14 .and. i == 186) then\n      !!if (j == 14 .and. i == 251) then\n      !  !print*, i, j, t, this_fit\n      !  all_fit(t) = this_fit\n      !end if\n      if (this_fit < best_fit) then\n        best_fit = this_fit\n        results(i, j, 1:n_pars) = parvals(t, :)\n        results(i, j, n_pars+1) = this_fit\n      end if\n    end do\n  end do\nend do\n\nend subroutine calc_fits\n"}, {"instruction": "Create a Fortran subroutine named chi2 to calculate the chi-squared value between the data and a sinusoidal model. The subroutine takes 5 input parameters of type double precision: t, y, err, t_ref, and max_pwr, and 1 output parameter of type double precision: chi2_out.", "input": "", "output": "subroutine chi2(t, y, err, t_ref, max_pwr, chi2_out)\n!   computes chi2 between data and a*coswt + b*sinwt c model\n    double precision, intent(in) :: t(:), y(:), err(:)\n    double precision, intent(in) :: max_pwr(5), t_ref\n    double precision, intent(out) :: chi2_out\n    double precision :: a, b, c, per, pi\n    integer :: i, n_pts\n    !pi def.\n    pi = acos(-1.0d0)\n    n_pts = size(t)\n    !model parameters\n    per = max_pwr(1)\n    a = max_pwr(3)\n    b = max_pwr(4)\n    c = max_pwr(5)\n\n    chi2_out = 0.0\n    do 97 i = 1, n_pts\n        chi2_out = chi2_out + &\n                  (1.0/(err(i)*err(i)))*(y(i) - (a*cos(2.0*pi*(t(i)-t_ref)/per) +  &\n                  b*sin(2.0*pi*(t(i)-t_ref)/per) + c))**2.0\n97  continue\n\nend subroutine chi2\n"}, {"instruction": "Create a Fortran subroutine named my_func, which takes an array of 3 complex numbers as input and returns an array of 2 complex numbers as output. The subroutine calculates the natural logarithm of the ratio of each input number to the complex expression (0d0,1d0) plus the square of the cosine of the next input number. Use the imperative tone when writing the instructions.", "input": "", "output": "    subroutine my_func(x, y)\n        implicit none\n        complex(kind=kind(0d0)), dimension(3), intent(in) :: x\n        complex(kind=kind(0d0)), dimension(2), intent(out) :: y\n\n        integer :: j\n        do j = 1, 2\n            y(j) = log(x(j) / ((0d0,1d0) + cos(x(j+1))**2))\n        end do\n    end subroutine my_func\n"}, {"instruction": "Write a Fortran subroutine named splint to perform cubic spline interpolation. The subroutine takes 5 input parameters of type integer, real, real array of dimension n, real array of dimension n, and real array of dimension n. The output parameter is of type real.", "input": "", "output": "  subroutine splint(xa,ya,y2a,n,x,y)\n\n    implicit none\n    integer, intent(in) :: n\n    real, intent(in) :: x\n    real, intent(in), dimension(n) :: xa, y2a, ya\n    real, intent(out) :: y\n    integer :: k,khi,klo\n    real :: a,b,h\n    \n    klo=1\n    khi=n\n    do\n       k=(khi+klo)/2\n       if(xa(k)>x)then\n          khi=k\n       else\n          klo=k\n       endif\n       if (khi-klo<=1) exit\n    end do\n    h=xa(khi)-xa(klo)\n    if (h==0.) then\n       write(*,*) 'bad xa input in splint'\n       stop\n    endif\n    a=(xa(khi)-x)/h\n    b=(x-xa(klo))/h\n    y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.\n    \n  end subroutine splint\n"}, {"instruction": "Create a Fortran subroutine named initialize_centroids to initialize the centroids for a clustering algorithm. The subroutine takes 4 input parameters: n_samples (integer), n_clusters (integer), n_features (integer), samples (real, 2D array). It has 1 output parameter: centroids (real, 2D array, dynamically allocated).", "input": "", "output": "    subroutine initialize_centroids(samples, centroids, n_samples, n_clusters, n_features)\n        integer, intent(in) :: n_samples, n_clusters, n_features\n        real, dimension(:, :), intent(in) :: samples\n        real, dimension(:, :), allocatable, intent(out) :: centroids\n        real, dimension(n_features) :: mini, maxi\n        integer :: current_centroid, current_feature\n        real :: random_num\n\n        allocate(centroids(n_clusters, n_features))\n\n        do current_feature = 1, n_features\n            mini(current_feature) = minval(samples(:, current_feature))\n            maxi(current_feature) = maxval(samples(:, current_feature))\n        end do\n\n        do current_centroid = 1, n_clusters\n            do current_feature = 1, n_features\n                call random_number(random_num)\n                centroids(current_centroid, current_feature) = &\n                    mini(current_feature) + (maxi(current_feature) + 1 - mini(current_feature)) * random_num\n            end do\n        end do\n    end subroutine initialize_centroids\n"}, {"instruction": "Create a Fortran subroutine named grid_radar to process radar data and compute the eth_out values for a given set of input parameters. The subroutine takes 10 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'integer(kind=4)', 'real(kind=8)', 'real(kind=8), dimension(nx)', 'real(kind=8), dimension(ny)', 'real(kind=8), dimension(nyrad, nxrad)', 'real(kind=8), dimension(nyrad, nxrad)', 'real(kind=8), dimension(nyrad, nxrad)'] and outputs a single parameter of type ['real(kind=8), dimension(ny, nx)'].", "input": "", "output": "subroutine grid_radar(cloudtop, eth_out, xgrid, ygrid, xradar, yradar, theta3db, nx, ny, nxrad, nyrad)\n    implicit none\n    ! input variables\n    integer(kind=4), intent(in) :: nx, ny, nxrad, nyrad\n    real(kind=8), intent(in) :: theta3db\n    real(kind=8), intent(in), dimension(nx) :: xgrid\n    real(kind=8), intent(in), dimension(ny) :: ygrid\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: xradar\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: yradar\n    real(kind=8), intent(in), dimension(nyrad, nxrad) :: cloudtop\n    ! output variables\n    real(kind=8), intent(out), dimension(ny, nx) :: eth_out\n    \n    ! parameters\n    integer(kind=4) :: cnt\n    integer(kind=4) :: i, j, k, l\n    integer(kind=4) :: stx, sty, edx, edy\n    real(kind=8) :: xi, yi, xr, yr\n    real(kind=8) :: width, rmax\n    real(kind=8) :: zmax\n    \n    rmax = maxval(xradar)\n    \n    do i = 1, nx\n        do j = 1, ny\n            cnt = 0\n            zmax = 0.0\n            xi = xgrid(i)\n            yi = ygrid(j)                        \n            \n            if (xi ** 2 + yi ** 2 > rmax ** 2) then\n                continue\n            endif\n            \n            width = 0.5 * (sqrt(xi ** 2 + yi ** 2) * theta3db * 3.14 / 180.0)            \n      \n            do k = 1, nxrad\n                do l = 1, nyrad\n                    xr = xradar(l, k)\n                    yr = yradar(l, k)\n                    \n                    if ((xr >= xi - width).and.(xr < xi + width).and.(yr >= yi - width).and.(yr < yi + width)) then\n                        if (cloudtop(l, k) > 0) then\n                            zmax = zmax + cloudtop(l, k)\n                            cnt = cnt + 1\n                        endif\n                        continue\n                    endif\n                enddo\n            enddo\n            \n            eth_out(j, i) = zmax / cnt\n        enddo\n    enddo\n    \n    return\n    \nend subroutine grid_radar\n"}, {"instruction": "Write a Fortran subroutine named periodic_tdma_solver to solve a tridiagonal matrix equation of the form Ax = d where A is a tridiagonal matrix and d is a known vector. The number of input arguments is 5 with the test_data type as ['integer', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)', 'double precision, dimension(1:n)']. The number of output arguments is 1 with the test_data type as ['double precision, dimension(1:n)'].", "input": "", "output": "subroutine periodic_tdma_solver(a,b,c,d,x,n)\n\timplicit none\n\tinteger, intent(in)::n\n\tdouble precision, intent(in), dimension(1:n)::a,b,c,d\n\tdouble precision, intent(out),dimension(1:n)::x\n\tdouble precision, allocatable,dimension(:) :: p , q , r , w , u , x1 \t\n\tinteger :: i,j\n\tdouble precision::sum1=0.0d0,maxerror\n\tcharacter(80)::str\n\tdouble precision, allocatable, dimension(:)::error\n\n\tallocate(p(2:n),q(1:n),r(1:n-2),w(1:n-2),u(1:n-1),x1(1:n),error(1:n))\n\n\tq(1) = b(1) \n\tw(1) = a(1) / b(1) \n\tu(1) = c(1) / b(1) \n\tr(1) = c(n) \n\tsum1 = r(1) * w(1) \n\n\tdo i = 2 , n-2\n\t  p(i) = a(i)                    \n\t  q(i) = b(i) - p(i) * u(i-1)    \n\t  u(i) = c(i) / q(i)             \n\t  w(i) = - p(i) * w(i-1) / q(i)  \n\t  r(i) = - r(i-1) * u(i-1)       \n\t  sum1  = sum1 + r(i) * w(i)       \n\tenddo\n\n\ti = n-1 \n\tp(i) = a(i) \n\tq(i) = b(i) - p(i) * u(i-1) \n\tu(i) = (c(i) - p(i) * w(i-1)) / q(i) \n\tp(n) = a(n) - r(n-2) * u(n-2) \n\tq(n) = b(n) - sum1 - p(n) * u(n-1) \n\tx1(1) = d(1) / q(1)  \n!  \n\tdo i = 2 , n-1\n\t  x1(i) = (d(i) - p(i) * x1(i-1)) / q(i)    \n\tenddo\n\tsum1 = 0.0d0 \n\tdo i = 1 , n-2 \n\t  sum1 = sum1 + r(i) * x1(i)    \n\tenddo \n\tx1(n) = (d(n) - sum1 - p(n) * x1(n-1)) / q(n)\n\tx(n) = x1(n)\n\t\n\tx(n-1) = x1(n-1) - u(n-1) * x(n)\n\n\tdo i = n-2 , 1 , -1\n\t  x(i) = x1(i) - u(i) * x(i+1) - w(i) * x(n)    \n\tenddo  \n\n\tdeallocate(x1,p,q,u,w,r,error)\n\nend subroutine periodic_tdma_solver\n"}, {"instruction": "Write a Fortran subroutine named adt_sphere to calculate the extinction efficiency, absorption efficiency, scattering efficiency, and asymmetry parameter of a spherical particle. The subroutine should have 2 input parameters of type real and complex, and 4 output parameters of type real.", "input": "", "output": "subroutine adt_sphere(xx, crefin, qext, qabs, qsca, g)\n  implicit none\n  real, intent(in) :: xx\n  complex, intent(in) :: crefin\n  real, intent(out) :: qext, qabs, qsca, g\n  complex rho\n  real rho1, rho2, beta, rr\n  !\n  rho = 2.0 * xx * (crefin - 1.0)\n  rr = abs(rho)\n  rho1 = real(rho)\n  rho2 = aimag(rho)\n  !\n  if (rr .le. 1e-3) then\n    qext = 2.0\n    qabs = 4.0/3.0 * rho2\n    qsca = qext - qabs\n    g = 1.0\n  else\n    !\n    beta = atan2(rho2, rho1)\n    !\n    qext = 2.0 + 4.0/(rr*rr) * &\n      (cos(2.0*beta) - &\n       exp(-rho2) * &\n       (cos(rho1-2.0*beta) - rr*sin(rho1-beta)))\n    qabs = 1.0 + (exp(-2.0*rho2)*(2.0*rho2+1.0) - 1.0) / (2.0*rho2*rho2)\n    qsca = qext - qabs\n    g = 1.0\n  end if\nend subroutine adt_sphere\n"}, {"instruction": "Create a Fortran subroutine named crossproduct to calculate the cross product of two 3D vectors. The subroutine should have 2 input parameters of type real*8, named a and b, and 1 output parameter of type real*8, named ans. The calculation should be performed as follows: ans(1) = a(2)*b(3) - a(3)*b(2), ans(2) = -a(1)*b(3) + a(3)*b(1), ans(3) = a(1)*b(2) - a(2)*b(1).", "input": "", "output": "  subroutine crossproduct( a,b,ans )\n    implicit none\n    real*8, intent(in) :: a(3),b(3)\n    real*8, intent(out) :: ans(3)\n    ans(1) = a(2)*b(3)-a(3)*b(2)\n    ans(2) = -a(1)*b(3)+a(3)*b(1)\n    ans(3) = a(1)*b(2)-a(2)*b(1)\n  end subroutine crossproduct\n"}, {"instruction": "Create a Fortran subroutine named vecmat to perform the multiplication of a vector with a matrix. The subroutine takes 4 input parameters: ndim1 (integer), ndim2 (integer), vec1 (double precision array), xmat (double precision 2D array), and 1 output parameter: vec2 (double precision array). The subroutine computes the elements of vec2 using the formula vec2(i) = vec1(j) * xmat(j,i) and sums over j.", "input": "", "output": "subroutine vecmat(vec1, ndim1, xmat, ndim2, vec2)\n  !***********************************************************************\n  !\n  ! multiplication vector * matrix\n  !\n  !\n  !    vec2(i)  =  vec1(j) * xmat(j,i) sum over j\n  !\n  !\n  !***********************************************************************\n  implicit none\n\n  integer, intent(in)           :: ndim1, ndim2\n  double precision, intent(in)  :: vec1(ndim1), xmat(ndim2,ndim1)\n  double precision, intent(out) :: vec2(ndim2)\n\n  integer :: i, j\n\n  vec2 = 0.d0\n\n  do i = 1, ndim1\n     do j = 1, ndim2\n\n        vec2(j) = vec2(j) + vec1(i) * xmat(j,i)\n\n     enddo\n  enddo\n\n  return\n  \nend subroutine vecmat\n"}, {"instruction": "Create a Fortran subroutine named qcheck to determine whether the sum of squares of the elements in a 4-element real array is greater than 1. The subroutine should take 1 input parameter of type real, dimension(4) and provide 1 output parameter of type logical. If the sum of squares is greater than 1, the output parameter should be set to false; otherwise, it should be set to true.", "input": "", "output": "  subroutine qcheck(ret, q)\n    logical, intent(out) :: ret\n    real, dimension(4), intent(in) :: q\n    real :: qout\n    qout = q(1)**2 + q(2)**2 + q(3)**2 + q(4)**2\n    if (qout > 1.0) then\n       ret = .false.\n    else\n       ret = .true.\n    end if\n  end subroutine qcheck\n"}, {"instruction": "Create a Fortran subroutine named symmetric_jaccard_kernel to calculate the symmetric Jaccard kernel matrix for a given set of vectors. The subroutine takes 2 input parameters of type integer and integer array, and 1 output parameter of type double precision array with dimensions n_items x n_items.", "input": "", "output": "subroutine symmetric_jaccard_kernel(n_items, vec1, kernel)\n\n    ! lengths = np.sum(vectors, axis=1)\n    ! shape = lengths.shape[0]\n    ! lengths = lengths.reshape((shape, 1))\n    !\n    ! kernel = np.dot(vectors, vectors.t)\n    ! kernel = kernel / (lengths + lengths.t - kernel)\n\n    implicit none\n\n    integer, intent(in) :: n_items\n    integer, intent(in), dimension(:,:) :: vec1\n    double precision, intent(out), dimension(n_items,n_items) :: kernel\n    integer :: i, j\n    double precision :: dp\n    integer, dimension(:), allocatable :: lengths\n\n    allocate(lengths(n_items))\n\n    !$omp parallel do\n    do i = 1, n_items\n        lengths(i) = sum(vec1(:,i))\n    end do\n    !$omp end parallel do\n\n    !$omp parallel do private(dp) schedule(dynamic)\n    do i = 1, n_items\n        do j = i, n_items\n\n            dp = dot_product(vec1(:,i), vec1(:,j))\n\n            kernel(i,j) = dp / (lengths(i) + lengths(j) - dp)\n            kernel(j,i) = kernel(i,j)\n\n        end do\n    end do\n    !$omp end parallel do\n\n    deallocate(lengths)\n\nend subroutine symmetric_jaccard_kernel\n"}, {"instruction": "Create a Fortran subroutine named getrunidfromschemid to extract the run ID from the given scheme ID. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "subroutine getrunidfromschemid(schemid, runid)\n    implicit none\n    !\n    ! arguments\n    character(*), intent(in)  :: schemid\n    character(*), intent(out) :: runid\n    !\n    ! locals\n    integer :: dotloc\n    integer :: slashloc\n    !\n    ! body\n    slashloc = max(  index(schemid, '/', back=.true.), &\n                   & index(schemid, '\\', back=.true.)   ) \n    dotloc   = index(schemid(slashloc+1:), '.mdf', back=.true.)\n    if (dotloc == 0) then\n       runid = trim(schemid(slashloc+1:))\n    else\n       runid = schemid(slashloc+1:slashloc+dotloc-1)\n    endif\nend subroutine getrunidfromschemid\n"}, {"instruction": "Write a Fortran subroutine named get_location_id_and_quantity_id that takes an integer exchange_item_id as input and returns two integers, location_id and quantity_id, as output. The exchange_item_id is divided by 1000 to obtain the location_id, and the quantity_id is obtained by taking the modulo of exchange_item_id with 1000. Use the imperative tone.", "input": "", "output": "subroutine get_location_id_and_quantity_id(exchange_item_id, location_id,quantity_id) \n    !arguments\n    integer, intent(in) :: exchange_item_id\n    integer, intent(out) :: location_id, quantity_id\n    \n    location_id  = exchange_item_id / 1000\n    quantity_id = mod(exchange_item_id, 1000)\n\nend subroutine get_location_id_and_quantity_id\n"}, {"instruction": "Create a Fortran subroutine named sistub to solve a system of linear equations using the forward substitution method. The subroutine takes 2 input parameters: a is a real, two-dimensional array and b is a real, one-dimensional array. It also has 1 output parameter: u, which is a real, one-dimensional array.", "input": "", "output": "subroutine sistub(a, b, u)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: u\n\ninteger :: n, i, j\n\nn = size(b)\n\nu = b\n\ndo i = n, 1, -1\n  u(i) = u(i)/a(i,i)\n  u(1:i-1) = u(1:i-1) - a(1:i-1, i)*u(i)\nend do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named initialize with 5 input parameters of types integer, integer, real*8, real*8, and real*8. The 4 output parameters are of type real*8, with dimensions nx and ny. The subroutine sets initial conditions for the variables u, v1, v2, and v3 based on the given mesh points and initial conditions.", "input": "", "output": "subroutine initialize(u,v1,v2,v3,c,dx,dy,nx,ny)\n  !===============================================================\n  ! description: \n  !    sets the initial conditions into u, v1, v2, v3.\n  !===============================================================\n  ! inclusions\n  implicit none\n\n  ! declarations\n  integer, intent(in)  :: nx, ny\n  real*8,  intent(in)  :: c, dx, dy\n  real*8, dimension(nx,ny), intent(out) :: u, v1, v2, v3\n  real*8 :: xspan_c(nx), xspan_h(nx), yspan_c(ny), yspan_h(ny)\n  real*8 :: x_c, x_h, y_c, y_h\n  integer :: i, j\n  \n  ! internals\n  \n  ! set mesh points\n  do i=1,nx\n     xspan_c(i) = dx/2.d0 + (i-1)*dx\n     xspan_h(i) = (i-1)*dx\n  end do\n\n  do j=1,ny\n     yspan_c(j) = dy/2.d0 + (j-1)*dy\n     yspan_h(j) = (j-1)*dy\n  end do\n\n\n  ! set initial condition for solution and derivatives\n  do j=1,ny\n\n     ! y locations\n     y_c = yspan_c(j)\n     y_h = yspan_h(j)\n\n     do i=1,nx\n\n        ! x locations\n        x_c = xspan_c(i)\n        x_h = xspan_h(i)\n\n        ! set initial conditions on u_x, u_y [gaussian blob]\n        !    u(0,x,y) = exp(-100*((x-1/3)^2+(y-1/2)^2))\n        !    c*u_x(0,x,y) = -200*c*(x-1/3)*exp(-100*((x-1/3)^2+(y-1/2)^2))\n        !    c*u_y(0,x,y) = -200*c*(y-1/2)*exp(-100*((x-1/3)^2+(y-1/2)^2))\n        u(i,j) = exp(-1.d2*((x_c-1.d0/3.d0)**2+(y_c-0.5d0)**2))\n        v1(i,j) = 0.d0\n        v2(i,j) = -2.d2*c*(x_h-1.d0/3.d0)*exp(-1.d2*((x_h-1.d0/3.d0)**2+(y_c-0.5d0)**2))\n        v3(i,j) = -2.d2*c*(y_h-0.5d0)*exp(-1.d2*((x_c-1.d0/3.d0)**2+(y_h-0.5d0)**2))\n\n     end do\n  end do\n  \n  return\n\n  ! end program\nend subroutine initialize\n"}, {"instruction": "Write a Fortran subroutine named find_varname to search for a variable name within a list of declarations. The subroutine takes 3 input parameters of type ['character(len=*), dimension(:)', 'character(len=*)', 'integer'] and 2 output parameters of type ['integer', 'integer']. The subroutine searches for the variable name within the declarations and returns the line index and decoration index where the variable is found.", "input": "", "output": "subroutine find_varname( declarations, varname, start, line_index, decoration_index )\n\n    character(len=*), dimension(:),intent(in) :: declarations\n    character(len=*), intent(in)              :: varname\n    integer, intent(in)                       :: start\n    integer, intent(out)                      :: line_index\n    integer, intent(out)                      :: decoration_index\n\n    integer :: i\n    integer :: j\n    integer :: k\n\n    line_index       = -1\n    decoration_index = -1\n\n\n    do i = start,size(declarations)\n        j = index( declarations(i), '::' )\n        do\n            k = index( declarations(i)(j:), trim(varname) )\n            if ( k > 0 ) then\n                j = j + k - 1\n                k = j + len_trim(varname)\n                if ( index( ',:',  declarations(i)(j-1:j-1) ) > 0 .and. &\n                     index( ',*( ', declarations(i)(k:k) )    > 0 ) then\n                    line_index       = i\n                    decoration_index = k\n                    if ( index( '*(', declarations(i)(k:k) ) <= 0 ) then\n                        decoration_index = -1 ! no particular decoration\n                    endif\n                    exit\n                else\n                    j = k + 1\n                endif\n            else\n                exit\n            endif\n        enddo\n        if ( line_index > 0 ) then\n            exit ! we are done\n        endif\n    enddo\nend subroutine find_varname\n"}, {"instruction": "Create a Fortran subroutine named tokenize to parse a text containing dimensions in the format \"length x width x height\". The subroutine takes 1 input parameter of type character(*) and returns 3 output parameters of type integer, representing the length, width, and height parsed from the input text.", "input": "", "output": "subroutine tokenize(text, length, width, height)\n    implicit none\n\n    character(*), intent(in) :: text\n    integer, intent(out) :: length, width, height\n    character(10) :: values(3)\n    integer :: pos1, pos2, n, i\n\n    pos1 = 1\n    pos2 = 0\n    n = 0\n\n    do\n        pos2 = index(text(pos1:), 'x')\n\n        if (pos2 == 0) then\n            n = n + 1\n            values(n) = text(pos1:)\n            exit\n        end if\n\n        n = n + 1\n        values(n) = text(pos1:pos1 + pos2 - 2)\n        pos1 = pos2 + pos1\n    end do\n\n    read (values(1), '(i10)') length\n    read (values(2), '(i10)') width\n    read (values(3), '(i10)') height\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named twosmallest to find the two smallest values among three input integers. The subroutine should take 3 input parameters of type integer and provide 2 output parameters of type integer.", "input": "", "output": "subroutine twosmallest(val1, val2, val3, small1, small2)\n    implicit none\n\n    integer, intent(in) :: val1, val2, val3\n    integer, intent(out) :: small1, small2\n    integer :: big\n\n    ! warning: ugly hack\n\n    big = max(val1, val2, val3)\n\n    if (big == val1) then\n        small1 = val2\n        small2 = val3\n    elseif (big == val2) then\n        small1 = val1\n        small2 = val3\n    else\n        small1 = val1\n        small2 = val2\n    end if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named significant_length to determine the length of the first word in a given character string. The subroutine takes 1 input parameter of type character(len = *) and produces 1 output parameter of type integer.", "input": "", "output": "      subroutine significant_length( str, n )\n\n        character(len = *), intent(in) :: str\n        integer, intent(out) :: n\n\n        integer :: i, l\n\n        n = 0\n        l = len(str)\n\n        do i = 1, l, 1\n            if( str(i:i) .eq. ' ' ) then\n                exit\n            endif\n            n = n + 1\n        end do\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named str2int to convert a given character string to an integer. The subroutine takes 1 input parameter of type character(len=*) and 2 output parameters of type integer.", "input": "", "output": "          elemental subroutine str2int(str,int,stat)\n          implicit none\n          ! arguments\n          character(len=*),intent(in) :: str\n          integer,intent(out)         :: int\n          integer,intent(out)         :: stat\n    \n          read(str,*,iostat=stat)  int\n          end subroutine str2int\n"}, {"instruction": "Create a Fortran subroutine named phase_space_avg to compute the mean of the phase-space. The subroutine takes 8 input parameters: 3 integers (ndim0, nx, ny), and 5 arrays of real numbers (xin, yin, arr, xout, yout). It also has 1 output parameter, which is a 2D array of real numbers (phase).", "input": "", "output": "subroutine phase_space_avg(xin, yin, arr, xout, yout, ndim0, nx, ny, phase)\n    ! compute the mean of the phase-space\n    implicit none\n    ! input vars\n    integer(kind=4), intent(in) :: ndim0, nx, ny  ! arrays dimension\n    real(kind=8), intent(in), dimension(ndim0) :: xin\n    real(kind=8), intent(in), dimension(ndim0) :: yin\n    real(kind=8), intent(in), dimension(ndim0) :: arr\n    real(kind=8), intent(in), dimension(nx) :: xout\n    real(kind=8), intent(in), dimension(ny) :: yout\n\n    ! output vars\n    real(kind=8), intent(out), dimension(ny, nx) :: phase\n\n    ! parameters\n    integer(kind=4) :: i, j, cnt\n    real(kind=8) :: dx, dy, total\n\n    dx = abs(xout(2) - xout(1)) / 2.0\n    dy = abs(yout(2) - yout(1)) / 2.0\n\n    do j = 1, ny\n        do i = 1, nx\n             cnt = count((xin >= xout(i) - dx).and. &\n                         (xin < xout(i) + dx).and. &\n                         (yin >= yout(j) - dy).and. &\n                         (yin < yout(j) + dy))\n\n            if (cnt.eq.0) then\n                continue\n            endif\n\n            total = sum(arr, mask=((xin >= xout(i) - dx).and. &\n                                   (xin < xout(i) + dx).and. &\n                                   (yin >= yout(j) - dy).and. &\n                                   (yin < yout(j) + dy)))\n\n            phase(j, i) = total / cnt\n       enddo\n    enddo\n    return\nend subroutine phase_space_avg\n"}, {"instruction": "Create a Fortran subroutine named intersection to find the intersection of two 2-dimensional integer arrays. The subroutine should have 2 input parameters of type integer, dimension(2) and intent(in), and 1 output parameter of type integer, dimension(2) and intent(out). The subroutine should use the imperative tone to perform the intersection operation.", "input": "", "output": "    pure subroutine intersection( a, b, c )\n    \n        integer, dimension(2), intent(in) :: a, b\n        integer, dimension(2), intent(out) :: c\n        \n        c(1) = max(a(1),b(1))\n        c(2) = min(a(2),b(2))\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named union to compare two arrays of two integers each and store the element-wise minimum and maximum of the input arrays into an output array. The number of input parameters is 2 with test_data types ['integer, dimension(2)', 'integer, dimension(2)'], and the number of output parameters is 1 with test_data type ['integer, dimension(2)'].", "input": "", "output": "    pure subroutine union( a, b, c ) \n    \n        integer, dimension(2), intent(in) :: a, b\n        integer, dimension(2), intent(out) :: c\n        \n        c(1) = min(a(1),b(1))\n        c(2) = max(a(2),b(2))\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named proma3 that evaluates a matrix-vector product adding over a. The subroutine takes 5 input parameters of types integer (kind=4), integer (kind=4), real (kind=8), real (kind=8), and logical(kind=4), and 1 output parameter of type real (kind=8).", "input": "", "output": "      subroutine proma3(a,b,c,n1,n3,zeros)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix-vector product adding over a\r\n!\r\n!           a(i) = b(i,k) * c(k)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n3\r\n      real (kind=8),intent(in) :: b(n1,n3), c(n3)\r\n      real (kind=8),intent(out) :: a(n1)\r\n      logical(kind=4),intent(in) :: zeros\r\n\r\n      if (zeros) then\r\n        a = matmul(b,c)\r\n      else\r\n        a = a + matmul(b,c)\r\n      end if\r\n      return\r\n\r\n      end subroutine proma3\r\n"}, {"instruction": "Create a Fortran subroutine named \"interp3\" to perform trilinear interpolation on a 3D array. The subroutine should have 10 input parameters with the test_data type ['integer', 'real', 'real'] and 1 output parameter with the test_data type ['real']. The input parameters are nx, ny, nz, a(nx, ny, nz), ix, iy, iz, dxi, dyi, dzi, and the output parameter is b. The subroutine should use the imperative tone and provide a brief summary of the trilinear interpolation process.", "input": "", "output": "pure subroutine interp3(a, ix, iy, iz, dxi, dyi, dzi, b, nx, ny, nz)\n  implicit none\n\n  integer, intent(in) :: nx, ny, nz\n  real, intent(in) :: a(nx, ny, nz)\n  integer, intent(in) :: ix, iy, iz\n  real, intent(in) :: dxi, dyi, dzi\n  real, intent(out) :: b\n  real :: x00, x01, x10, x11, y0, y1\n\n  x00 = a(ix, iy    , iz    ) + dxi * (a(ix + 1, iy    , iz    ) - a(ix, iy    , iz    ))\n  x10 = a(ix, iy + 1, iz    ) + dxi * (a(ix + 1, iy + 1, iz    ) - a(ix, iy + 1, iz    ))\n  x01 = a(ix, iy    , iz + 1) + dxi * (a(ix + 1, iy    , iz + 1) - a(ix, iy    , iz + 1))\n  x11 = a(ix, iy + 1, iz + 1) + dxi * (a(ix + 1, iy + 1, iz + 1) - a(ix, iy + 1, iz + 1))\n  y0 = x00 + dyi * (x10 - x00)\n  y1 = x01 + dyi * (x11 - x01)\n  b = y0 + dzi * (y1 - y0)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named xtoz to convert x coordinates to z coordinates on the discretized space. The subroutine takes 5 input parameters: nd (integer), x (real, dimension (1 : nd)), h (real, dimension (1 : nd)), lb (real, dimension (1 : nd)), ub (real, dimension (1 : nd)), and produces 1 output parameter: z (integer, dimension (1 : nd)).", "input": "", "output": "subroutine xtoz(z, x, h, lb, ub, nd)\n!------------------------------------------------------------------\n!\txtoz converts x coordinates to z coordinates on the discretized space\n!\tinput:\n!\t\t\tx\t\tthe coordinates of the point to be converted\n!\t\t\th\t\tthe space grid size\n!\t\t\tlb\t\tthe lower bound of the space\n!\t\t\tub\t\tthe upper bound of the space\n!\t\t\tnd\t\tthe dimension of apace\n!\toutput:\n!\t\t\tz\t\tthe z coordinates of the point\n!\tby: yousef naranjani-mar 30 2016\n!------------------------------------------------------------------\n\timplicit none\n\tinteger, intent(in)::nd\n\treal, dimension (1 : nd), intent(in):: x, h, lb, ub\n\tinteger, dimension (1 : nd), intent(out):: z\n\tinteger:: i\n\tdo i = 1, nd\n\t\tif ((x(i) < lb(i)).or.(x(i) > ub(i))) then\n!\t\t\terror stop \"xtoz: the x coordinate was out of bound\"\n\t\t\tz = -1\n\t\t\texit\n\t\telse if (x(i) == ub(i)) then\n\t\t\tz(i) = floor((ub(i)-lb(i))/h(i))\n\t\telse\n\t\t\tz(i) = floor((x(i)-lb(i))/h(i)) + 1\n\t\tend if\n\tend do\nend subroutine xtoz\n"}, {"instruction": "Create a Fortran subroutine named formatter that takes three input parameters of type character(*), integer, and integer, and one output parameter of type real*8. The subroutine reads data from a file specified by the filename and stores it in the arraydata with dimensions ny by nx.", "input": "", "output": "subroutine formatter(filename, nx, ny, arraydata)\n    implicit none\n    ! arguments\n    character(*), intent(in) :: filename\n    integer, intent(in) :: nx, ny\n    real*8, intent(out) :: arraydata(ny,nx)\n    ! local variables\n    integer ::i,j\n\n    ! read\n    open(11, file=trim(filename), status='old', action='read')\n    read(11,101) ((arraydata(i,j:j+9), j=1,nx,10), i=ny,1,-1)\n    close(11)\n101 format(10f8.2)\n    return\nend subroutine formatter\n"}, {"instruction": "Write a Fortran subroutine named \"fdiff\" to calculate the difference between two real numbers. The subroutine should take 2 input parameters of type real and 1 output parameter of type real. When using the subroutine, provide two real numbers as input, and the subroutine will return the difference as the output.", "input": "", "output": "    subroutine fdiff(a, b, res)\n        implicit none\n        real, intent(in)  :: a\n        real, intent(in)  :: b\n        real, intent(out) :: res\n        res = a - b\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named splinederiv to calculate the derivative of a given function using cubic spline interpolation. The subroutine takes 3 input parameters of type integer and real(kind=8), and one output parameter of type real(kind=8).", "input": "", "output": "subroutine splinederiv(x,s,dxds,n)\n\n  implicit none\n\n  ! input/output\n  integer ,intent(in) :: n\n  real(kind=8)   ,intent(in) :: x(n)\n  real(kind=8)   ,intent(in) :: s(n)\n  real(kind=8)   ,intent(out) :: dxds(n)\n\n  ! local\n  integer            :: i\n  \n  ! functions\n  real(kind=8)  :: alpha\n  alpha(i) = (s(i)-s(i-1))/(s(i+1) - s(i-1))\n\n  dxds(1) = 2*(x(2)-x(1)) - ( (1-alpha(2))*(x(2)-x(1)) + alpha(2)*(x(3)-x(2))*(s(2)-s(1))/(s(3)-s(2)))\n  dxds(n) = 2*(x(n)-x(n-1)) - (  (1-alpha(n-1))*(x(n-1)-x(n-2))*(s(n)-s(n-1))/(s(n-1)-s(n-2)) +alpha(n-1)*(x(n)-x(n-1)))\n\n  do i=2,n-1\n     dxds(i) = alpha(i)*(x(i+1)-x(i))+ (1-alpha(i))*(x(i)-x(i-1))\n  end do\n\n!dxds = 0\nend subroutine splinederiv\n"}, {"instruction": "Write a Fortran subroutine named set_optional that initializes an output integer value based on the input parameters. The subroutine takes 2 input parameters, one mandatory integer (idef) and one optional integer (iopt). The output is a single integer value. If the optional input (iopt) is provided, the output integer is set to the value of iopt; otherwise, it is set to the value of idef.", "input": "", "output": "elemental subroutine set_optional(i,idef,iopt)\n  integer, intent(out) :: i\n  integer, intent(in) :: idef\n  integer, intent(in), optional :: iopt\n  if (present(iopt)) then\n    i = iopt\n  else\n    i = idef\n  end if\n  end subroutine set_optional\n"}, {"instruction": "Write a Fortran subroutine named computeq to compute the value of q using the input arrays c and normal, and the integer ndime. The number of input arguments is 3 and the test_data type is [real*8, real*8, integer]. The number of output arguments is 1 and the test_data type is [real*8].", "input": "", "output": "subroutine computeq(q,c,normal,ndime)\n\treal*8 , intent(out) :: q(ndime,ndime)\n\treal*8 , intent(in) :: c(ndime,ndime,ndime,ndime), normal(ndime)\n\tinteger , intent(in) :: ndime\n\tinteger :: i,j,k,l\n\t\n\tq = 0.0d0\n\tdo i = 1 , ndime\n\tdo j = 1 , ndime\n\tdo k = 1 , ndime\n\tdo l = 1 , ndime\n\t\tq(i,k) = q(i,k) + c(i,j,k,l)*normal(j)*normal(l) \n\tend do\n\tend do\n\tend do\n\tend do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named herlang_mstep that calculates the alpha and rate values based on the given input data. The subroutine takes 5 input parameters of types integer, integer, double precision, double precision, and double precision. It also returns 2 output parameters of type double precision.", "input": "", "output": "  subroutine herlang_mstep(n, etotal, eb, ew, alpha, nshape, rate)\n    integer, intent(in) :: n\n    integer, intent(in) :: nshape(1:n)\n    double precision, intent(in) :: etotal, eb(1:n), ew(1:n)\n    double precision, intent(out) :: alpha(1:n), rate(1:n)\n\n    alpha(1:n) = eb(1:n) / etotal\n    rate(1:n) = nshape(1:n) * eb(1:n) / ew(1:n)\n\n  end subroutine herlang_mstep\n"}, {"instruction": "Create a Fortran subroutine named diis_b to compute the matrix b of the DIIS (Direct Inversion in the Iterative Subspace) algorithm. The subroutine takes 3 input parameters: two integers kf and steps, and a 2D real*8 array elist with dimensions (steps,kf*kf). It produces 1 output parameter: a 2D real*8 array b with dimensions (steps+1,steps+1).", "input": "", "output": "    subroutine diis_b(kf,elist,steps,b)\n        ! ----------------------------------------\n        ! compute matrix b of diis algorithm.\n        ! ----------------------------------------\n        !\n        ! source:\n        !   t. helgaker, p. j\u00f8rgensen and j. olsen\n        !   molecular electronic-structure theory\n        !   wiley\n        !   2000\n        !\n        ! ----------------------------------------\n\n        implicit none\n\n        ! input\n        integer, intent(in) :: kf                               ! basis set size\n        integer, intent(in) :: steps                            ! current scf iteration\n        real*8, dimension(steps,kf*kf), intent(in) :: elist     ! list of errors\n\n        ! intermediate variables\n        integer :: i, j\n\n        ! output\n        real*8, dimension(steps+1,steps+1), intent(out) :: b     ! matrix b\n\n        !call print_real_matrix(steps,kf*kf,elist)\n\n        do i = 1, steps ! rows of b\n            do j = 1, steps ! cols of b\n\n                b(i,j) = dot_product(elist(i,:),elist(j,:))\n\n            end do\n        end do\n\n        b(:,steps+1) = -1.0d0\n\n        b(steps+1,:) = -1.0d0\n\n        b(steps+1,steps+1) = 0.0d0\n\n    end subroutine diis_b\n"}, {"instruction": "Write a Fortran subroutine named iorderp to reorder an array of integers based on their values in ascending order. The subroutine takes 2 input parameters of type integer and 1 output parameter of type integer. The input parameters are arrays with the same number of elements, and the output parameter stores the reordered indices of the input array elements.", "input": "", "output": "   subroutine iorderp(pnt, iarr, n)\n\n      implicit none\n\n      integer, intent(in)  :: n\n      integer, intent(out) :: pnt(1:n)\n      integer, intent(in)  :: iarr(1:n)\n      integer                :: i, j, k\n\n      do i = 1, n\n         pnt(i) = i\n         do j = 1, i - 1\n            if (iarr(pnt(j)) > iarr(i)) then\n               do k = i, j + 1, -1\n                  pnt(k) = pnt(k - 1)\n               end do\n               pnt(j) = i\n               exit\n            end if\n         end do\n      end do\n\n   end subroutine iorderp\n"}, {"instruction": "Create a Fortran subroutine named \"rorderp\" that takes two input parameters: an integer \"n\" and a real array \"rarr\" of size \"n\". It also has one output parameter, an integer array \"pnt\" of size \"n\". The subroutine sorts the input real array \"rarr\" and returns the corresponding permutation indices in the \"pnt\" array.", "input": "", "output": "   subroutine rorderp(pnt, rarr, n)\n\n      implicit none\n\n      integer, intent(in)  :: n\n      integer, intent(out) :: pnt(1:n)\n      real, intent(in)  :: rarr(1:n)\n      integer                :: i, j, k\n\n      do i = 1, n\n         pnt(i) = i\n         do j = 1, i - 1\n            if (rarr(pnt(j)) > rarr(i)) then\n               do k = i, j + 1, -1\n                  pnt(k) = pnt(k - 1)\n               end do\n               pnt(j) = i\n               exit\n            end if\n         end do\n      end do\n\n   end subroutine rorderp\n"}, {"instruction": "Create a Fortran subroutine named \"maskactiv\" to calculate cloud activation based on the given input parameters. The subroutine should have 7 input parameters of types integer, integer, integer, real, real (optional), real (optional), and integer, and 1 output parameter of type logical.", "input": "", "output": "  subroutine maskactiv(act_mask,nx,ny,nz,mode,rh,rc,w)\n    implicit none\n    \n    integer, intent(in) :: nx,ny,nz\n    real, intent(in)    :: rh(nz,nx,ny)\n    real, optional, intent(in) :: rc(nz,nx,ny),w(nz,nx,ny)\n    \n    integer, intent(in) :: mode ! 1 = initialization; 2 = normal timestepping\n    \n    logical, intent(out) :: act_mask(nz,nx,ny)\n    \n    logical :: actmask_newcloud(nz,nx,ny)\n    logical :: actmask_oldcloud(nz,nx,ny)\n    logical :: cldmask(nz,nx,ny)\n    logical :: cldm1(nz,nx,ny),   & !inverse cloud mask offset downwards by one grid level\n         cldp1(nz,nx,ny),   & !inverse cloud mask offset upwards by one grid level\n         cldpm(nz,nx,ny)\n    \n    logical :: notused(nx,ny)\n    \n    integer :: k\n    \n    actmask_newcloud = .false.\n    actmask_oldcloud = .false.\n    cldm1 = .true.\n    cldp1 = .true.\n    cldpm = .true.\n    act_mask = .false.\n    \n    select case(mode)\n    case(1)\n       ! calculate cloud activation in all cloudy grid points for initialization\n       ! i.e. points with rh >= threshold\n       !zrh = rv/rs\n       act_mask = ( rh >= 1.000 )\n       \n    case(2)\n       \n       ! normal opperation\n       \n       if ( .not. (present(rc) )) stop 'maskactiv: invalid arguments'\n       \n       ! mask grid points just below cloud or where new cloud is expected to form\n       !\n       \n       cldmask(:,:,:) = ( rc(:,:,:) >= 1.e-5 )\n       \n       \n       ! check for the lowest point where rh > 1.\n       cldpm(:,:,:) = .false.\n       cldpm(1:nz-1,:,:) = ( rh(2:nz,:,:) > 1.000 )\n       \n       cldp1(:,:,:) = .true.\n       cldp1(2:nz,:,:) = ( .not. cldpm(1:nz-1,:,:) )\n       actmask_newcloud(:,:,:) = ( cldpm(:,:,:) .and. cldp1(:,:,:) ) .and. ( w(:,:,:) > 0. ) &\n            .and. (rc(:,:,:) < 5.e-5)\n       \n       ! base of existing cloud\n       cldpm(:,:,:) = .false.\n       cldpm(1:nz-1,:,:) = cldmask(2:nz,:,:)\n       \n       cldp1(:,:,:) = .true.\n       cldp1(2:nz,:,:) = ( .not. cldpm(1:nz-1,:,:) )\n       \n       ! take the lowest level of the two cases\n       \n       notused = .true.\n       do k = 2, nz-1\n          ! new cloud + no old cloud\n          act_mask(k,:,:) = merge( (actmask_oldcloud(k,:,:) .or. actmask_newcloud(k,:,:))  &\n               .and. cldp1(k,:,:), .false., notused(:,:))\n          notused(:,:) = notused(:,:) .and. .not. act_mask(k,:,:)\n          notused(:,:) = (rh(k,:,:) < 0.99 .or. notused(:,:))\n       end do\n       \n    end select\n    \n  end subroutine maskactiv\n"}, {"instruction": "Create a Fortran subroutine named getbinmassarray to obtain the mass array for a specific bin. It takes 4 input parameters of type integer, integer, integer, and real. The output parameter is of type real.", "input": "", "output": "  subroutine getbinmassarray(nb,ns,ib,mass,binmass)\n    implicit none\n    ! --------------------------------------------------\n    ! get the mass array for a specific bin (length ns)\n    ! --------------------------------------------------\n    integer, intent(in) :: ns,nb  ! number of species, number of bins\n    integer, intent(in) :: ib     ! target bin\n    real, intent(in) :: mass(ns*nb)\n    \n    real, intent(out) :: binmass(ns)\n    \n    binmass(:) = 0.\n    binmass(1:ns) = mass(ib:(ns-1)*nb+ib:nb)\n    \n  end subroutine getbinmassarray\n"}, {"instruction": "Write a Fortran subroutine named getbintotalmass to calculate the total mass inside a bin. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The function sums the mass inside the specified bin and returns the total mass.", "input": "", "output": "  subroutine getbintotalmass(nb,ns,ib,mass,totmass)\n    implicit none\n    ! ------------------------------------------------\n    ! get the total mass inside a bin, simply a sum\n    ! ------------------------------------------------\n    integer, intent(in) :: ns,nb   ! number of species, number of bins\n    integer, intent(in) :: ib      ! target bin\n    real, intent(in) :: mass(ns*nb)\n    \n    real, intent(out) :: totmass\n    \n    totmass = 0.\n    totmass = sum(mass(ib:(ns-1)*nb+ib:nb))\n    \n  end subroutine getbintotalmass\n"}, {"instruction": "Create a Fortran subroutine named simpletest to generate an n x n array filled with the value 1. The subroutine takes 3 input parameters of type integer (n, n2, n4) and has 1 output parameter of type real(8) with a dimension of n x n.", "input": "", "output": "subroutine simpletest(a,n, n2, n4)\n    ! testing out the f2py funcitonality\n    ! 1. create an nxn array and return it\n    ! 2. iterate on the array using update\n\n    implicit none\n    integer, intent(in) :: n, n2, n4\n    real(8), intent(out), dimension(n,n) :: a\n\n    a = 1\n    return\n    end subroutine simpletest\n"}, {"instruction": "Create a Fortran subroutine named \"func_zener\" that calculates the Zener function for a given set of input data. The subroutine takes 4 input parameters: an integer \"n\", a double precision \"x\", a double precision \"qref\", and a double precision array \"point\" of size n. It produces 1 output parameter, a double precision array \"afunc\" of size n.", "input": "", "output": "subroutine func_zener(x,afunc,n,qref,point)\n\n  implicit none\n\n  integer, intent(in) :: n\n  double precision, intent(in) :: x,qref\n  double precision, dimension(1:n), intent(in) :: point\n  double precision, dimension(1:n), intent(out) :: afunc\n\n  integer k\n  double precision num,deno\n\n  do k = 1,n\n    num  = x * (point(k) - x / qref)\n    deno = point(k) * point(k) + x * x\n    afunc(k) = num / deno\n  enddo\n\nend subroutine func_zener\n"}, {"instruction": "Create a Fortran subroutine named func_objective to calculate a numerical result based on input parameters. This subroutine takes 5 input parameters: n and nopt of type integer, freq and qref of type double precision, and x of type double precision array of dimension 1:nopt. The output parameter is res of type double precision. The subroutine performs a series of calculations using the input parameters to update the value of res.", "input": "", "output": "subroutine func_objective(x,res,freq,qref,n,nopt)\n\n  implicit none\n\n  integer, intent(in) :: n,nopt\n  double precision, intent(in) :: freq,qref\n  double precision, intent(out) :: res\n  double precision, dimension(1:nopt), intent(in) :: x\n\n  integer i\n  double precision num,deno\n\n  res = 0.d0\n  do i=1,n\n    num = x(n+i)*x(n+i)*freq*qref*(x(i)*x(i) - freq/qref)\n    deno = (x(i) ** 4.) + freq*freq\n    res = res + num/deno\n  enddo\n\nend subroutine func_objective\n"}, {"instruction": "Create a Fortran subroutine named poly_sizeof to determine the size in bytes of the elements in the input array. The input parameter should be of type class(*) and intent(in), while the output parameter should be of type integer and intent(out). The subroutine takes 1 input argument with the test_data type ['class(*)'] and produces 1 output argument with the test_data type ['integer'].", "input": "", "output": "  subroutine poly_sizeof(arg1,arg2)\n    class(*), intent(in) :: arg1(:,:)\n    integer, intent(out) :: arg2\n    arg2 = sizeof(arg1(1,1))\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named simplex_hilo to identify the highest, next highest, and lowest elements in an array, along with checking for convergence. The subroutine has 3 input parameters of types integer, double precision array, and double precision. It also has 4 output parameters of types integer, integer, integer, and logical.", "input": "", "output": "  subroutine simplex_hilo(ndim, y, ftol, ihi, inhi, ilo, conv)\n\n    implicit none\n\n    integer,                             intent(in)  :: ndim\n    double precision, dimension(ndim+1), intent(in)  :: y\n    double precision,                    intent(in)  :: ftol\n    integer,                             intent(out) :: ihi, inhi, ilo\n    logical,                             intent(out) :: conv\n\n    double precision                                 :: rtol\n    integer          :: i\n   \n    ilo = 1\n    if (y(1) > y(2)) then\n       ihi  = 1\n       inhi = 2\n    else\n       ihi  = 2\n       inhi = 1\n    end if\n    do i = 1, ndim + 1\n       if(y(i) <= y(ilo)) ilo = i\n       if(y(i) >  y(ihi)) then\n          inhi = ihi\n          ihi  = i\n       else if(y(i) > y(inhi)) then\n          if(i /= ihi) inhi = i\n       end if\n    end do\n    \n    ! check for convergence:\n!    rtol = 2.0d0*abs(y(ihi) - y(ilo))/( abs(y(ihi)) + abs(y(ilo)) )\n    rtol = abs(y(ihi) - y(ilo))\n    if (rtol <= ftol) then\n       conv = .true.\n    else\n       conv = .false.\n    end if\n\n  end subroutine simplex_hilo\n"}, {"instruction": "Write a Fortran subroutine named \"glob_to_axial\" that takes two input arrays of real numbers with kind \"iwp\" and one output real number with kind \"iwp\". The input arrays are named \"global\" and \"coord\", and the output variable is named \"axial\".", "input": "", "output": "subroutine glob_to_axial(axial,global,coord)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::global(:),coord(:,:)\r\n real(iwp),intent(out)::axial\r\nend subroutine glob_to_axial\r\n"}, {"instruction": "Create a Fortran subroutine named \"mocouf\" that takes 5 input parameters of type real(iwp) and returns 1 output parameter of type real(iwp). The inputs are phi, c, sigm, dsbar, and theta, while the output parameter is f.", "input": "", "output": "subroutine mocouf(phi,c,sigm,dsbar,theta,f)\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::phi,c,sigm,dsbar,theta\r\n real(iwp),intent(out)::f\r\nend subroutine mocouf\r\n"}, {"instruction": "Create a Fortran subroutine named open_mm5v3 to open an mm5v3 file. It takes 1 input parameter of type character(len=255) and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine open_mm5v3 (fname, lun, status)\n    \n    ! opens an mm5v3 file\n\n    implicit none\n   \n    ! arguments\n\n    character(len=255),intent(in)          :: fname\n    integer, intent(out)                   :: lun\n    integer, intent(out)                   :: status\n\n    ! local variables\n\n    integer                                :: i\n    logical                                :: used\n\n    status = 0\n    \n    lun = -1\n    ! find an available unit number\n    find_lun: do i = 7,1023\n      inquire (unit=i, opened=used)\n      if(used) then\n        cycle find_lun\n      else\n        lun = i\n        exit find_lun\n      endif\n    enddo find_lun\n    if (lun .lt. 0) then\n      print '(a)', 'no available unit numbers!'\n      status = 1\n    else\n      open ( file=trim(fname), unit=lun, access='sequential', &\n             form='unformatted', status='unknown', iostat=status, &\n             position='rewind')\n    endif\n  end subroutine open_mm5v3\n"}, {"instruction": "Create a Fortran subroutine named make_terrain_file_name to generate a file name based on the MM5 data root and the domain number string. The subroutine takes 2 input parameters of type character(len=255) and character(len=1), and returns 1 output parameter of type character(len=255).", "input": "", "output": "   subroutine make_terrain_file_name(mm5_data_root, domain_num_str,file_name)\n    implicit none\n    character(len=255),intent(in)    :: mm5_data_root\n    character(len=1),intent(in)      :: domain_num_str\n    character(len=255),intent(out)   :: file_name\n\n    file_name = trim(mm5_data_root)//'/static/terrain_domain'//domain_num_str\n    return\n  end subroutine make_terrain_file_name\n"}, {"instruction": "Create a Fortran subroutine named \"get_opacities\" to calculate opacities. The subroutine should have 6 input parameters of types [logical, logical, double precision, double precision, double precision, double precision], and 2 output parameters of type [double precision, double precision].", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: const_kappa_p = 0.33d-4\n    double precision, parameter :: kappa_p_exp_m = 1.0d0\n    double precision, parameter :: kappa_p_exp_n = 0.0d0\n    double precision, parameter :: kappa_p_exp_p = 0.0d0\n    double precision, parameter :: const_kappa_r = 0.33d0\n    double precision, parameter :: kappa_r_exp_m = 1.0d0\n    double precision, parameter :: kappa_r_exp_n = 0.0d0\n    double precision, parameter :: kappa_r_exp_p = 0.0d0\n    double precision, parameter :: tiny = 1.d-50\n    double precision, parameter :: tfloor = 0.d0\n    double precision, parameter :: kfloor = 0.d0\n\n    double precision :: teff, nup_kpp, nup_kpr\n\n    nup_kpp = nu**kappa_p_exp_p\n    nup_kpr = nu**kappa_r_exp_p\n\n    teff = max(temp, tiny)\n    teff = teff + tfloor * exp(-teff / (tfloor + tiny))\n\n    if (get_planck_mean) then\n       kp = const_kappa_p * (rho**kappa_p_exp_m) * (teff**(-kappa_p_exp_n)) * nup_kpp\n    end if\n\n    if (get_rosseland_mean) then\n       kr = const_kappa_r * (rho**kappa_r_exp_m) * (teff**(-kappa_r_exp_n)) * nup_kpr\n       kr = max(kr, kfloor)\n    end if\n\n  end subroutine get_opacities\n"}, {"instruction": "Create a Fortran subroutine named prep_opacity. This subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer, double precision, and double precision respectively. The function of the code is to initialize the output parameters inu, er, and der to -1, 0.0, and 0.0 respectively.", "input": "", "output": "  subroutine prep_opacity(g, inu, er, der)\n    implicit none\n    integer, intent(in) :: g\n    integer, intent(out) :: inu\n    double precision, intent(out) :: er, der\n    inu = -1\n    er = 0.d0\n    der = 0.d0\n  end subroutine prep_opacity\n"}, {"instruction": "Create a Fortran subroutine named ranmean3 to compute the mean vector of an ensemble. The subroutine takes 3 input parameters of type integer, integer, and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine ranmean3(ens,ave,n_var,n_ens)\r\n! return ensemble mean vector\r\n!\r\n  implicit none \r\n  integer             :: j\r\n  integer,intent(in)  :: n_var,n_ens\r\n  real(8),intent(in)  :: ens(n_var,n_ens)\r\n  real(8),intent(out) :: ave(n_var)\r\n!\r\n  ave(:)=ens(:,1)\r\n  do j=2,n_ens\r\n    ave(:)=ave(:)+ens(:,j)\r\n  enddo\r\n  ave(:)=ave(:)/dble(n_ens)\r\n!\r\nend subroutine ranmean3\r\n"}, {"instruction": "Create a Fortran subroutine named make_weights to calculate the values of an array f based on the input azimuth and array m. The number of input arguments is 2, with the test_data type ['real', 'real, dimension(:)']. The number of output arguments is 1, with the test_data type ['real, dimension(:)']. Use sin and cos functions to compute intermediate values, and assign computed values to the elements of array f based on specific calculations.", "input": "", "output": "    pure subroutine make_weights( azimuth, m, f )\n    \n        real, intent(in) :: azimuth\n        real, intent(in), dimension(:) :: m    ! (6)\n        real, intent(out), dimension(:) :: f   ! (6)\n        \n        real :: sa, ca, s2a, c2a\n        \n        sa = sin(azimuth)\n        ca = cos(azimuth)\n        s2a = sin(2.*azimuth)\n        c2a = cos(2.*azimuth)\n        \n        f(1) = m(1)*ca**2 + m(2)*sa**2 + m(4)*s2a\n        f(2) = m(5)*ca + m(6)*sa\n        f(3) = m(3)\n        f(4) = 0.5*(m(2)-m(1))*s2a + m(4)*c2a\n        f(5) = m(6)*ca - m(5)*sa\n        f(6) = m(1)*sa**2 + m(2)*ca**2 - m(4)*s2a   ! needed by near field terms\n    \n    end subroutine \n"}, {"instruction": "Create a Fortran subroutine named gettrueij_periodictripole to compute the true indices for a periodic map based on the input indices and periodicity. The subroutine takes 4 input parameters of type integer: i, j, nx, and ny. It also has 2 output parameters of type integer: true_i and true_j.", "input": "", "output": " subroutine gettrueij_periodictripole( i, j, nx, ny, true_i, true_j )\n   implicit none\n   integer, intent(in)  :: i, j, nx, ny\n   integer, intent(out) :: true_i, true_j\n   ! local\n   integer :: dj\n\n      if( j > ny )then\n   \n         dj = j - ny\n         true_j = ny - (dj-1)\n         if( i == 0 .or. i == nx+1 )then\n            true_i = i\n         else \n            true_i = nx-(i-1)\n         endif\n   \n      else\n   \n         true_j = j\n          \n         ! taking care of the x-periodicity in the map\n         if( i < 1 )then\n            true_i = nx + i\n         elseif( i > nx )then\n            true_i = i-nx\n         else\n            true_i = i\n         endif\n   \n      endif\n   \n end subroutine gettrueij_periodictripole\n"}, {"instruction": "Create a Fortran subroutine named razero that initializes an array of double precision numbers with zeros. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type double precision array with dimension n.", "input": "", "output": "subroutine razero(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  double precision, dimension(n), intent(out) :: x\n  !local variables\n  integer :: i\n!$ logical :: within_openmp,omp_in_parallel,omp_get_nested\n\n!$    within_openmp=omp_in_parallel() .or. omp_get_nested()\n\n!$omp parallel if (.not. within_openmp .and. n > 128) shared(x,n) private(i)\n!$omp do\n      do i=1,n\n      x(i)=0.d0\n      end do\n!$omp enddo\n!$omp end parallel\n\nend subroutine razero\n"}, {"instruction": "Create a Fortran subroutine named razero_simple that sets all elements of an input real array to zero. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real(kind=4) array. The input parameter specifies the length of the array, and the output parameter stores the zeroed array.", "input": "", "output": "subroutine razero_simple(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  real(kind=4), intent(out) :: x(n)\n  !local variables\n  integer :: i,m\n  !!do i=1,n\n  !!   x(i)=0.e0\n  !!end do\n  m=mod(n,7)\n  if (m/=0) then\n      do i=1,m\n          x(i)=0.e0\n      end do\n      if (n<7) return\n  end if\n  m=m+1\n  do i=m,n,7\n      x(i+0)=0.e0\n      x(i+1)=0.e0\n      x(i+2)=0.e0\n      x(i+3)=0.e0\n      x(i+4)=0.e0\n      x(i+5)=0.e0\n      x(i+6)=0.e0\n  end do\nend subroutine razero_simple\n"}, {"instruction": "Create a Fortran subroutine named razero_integer to fill an integer array with zeros. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer array with the dimension specified by the input parameter.", "input": "", "output": "subroutine razero_integer(n,x)\n  implicit none\n  !arguments\n  integer, intent(in) :: n\n  integer, dimension(n), intent(out) :: x\n  !local variables\n  integer :: i,m\n  !!do i=1,n\n  !!   x(i)=0\n  !!end do\n  m=mod(n,7)\n  if (m/=0) then\n      do i=1,m\n          x(i)=0\n      end do\n      if (n<7) return\n  end if\n  m=m+1\n  do i=m,n,7\n      x(i+0)=0\n      x(i+1)=0\n      x(i+2)=0\n      x(i+3)=0\n      x(i+4)=0\n      x(i+5)=0\n      x(i+6)=0\n  end do\nend subroutine razero_integer\n"}, {"instruction": "Create a Fortran subroutine named dscopy that performs a scaling operation on a vector. The subroutine takes 4 input parameters: n (integer), incx (integer), incy (integer), dx (real(kind=8), dimension(*)), and 1 output parameter: dy (real(kind=4), dimension(*)). This subroutine copies the scaled elements of vector dx to vector dy with specified increments incx and incy.", "input": "", "output": "subroutine dscopy(n,dx,incx,dy,incy)\n  implicit none\n  integer, intent(in) :: n,incx,incy\n  real(kind=8), dimension(*), intent(in) :: dx\n  real(kind=4), dimension(*), intent(out) :: dy\n  !local variables\n  integer :: i,ix,iy\n  \n  ix=1\n  iy=1\n  do i=1,n\n     dy(iy)=real(dx(ix),kind=4)\n     ix=ix+incx\n     iy=iy+incy\n  end do\n\nend subroutine dscopy\n"}, {"instruction": "Write a Fortran subroutine named nsymgauss to perform Gaussian elimination for solving a system of linear equations. The subroutine takes 4 input parameters of types integer, integer, real,dimension(neq,ib), and real,dimension(neq), and 1 output parameter of type real,dimension(neq). The subroutine uses forward elimination and backward substitution to solve the system of linear equations.", "input": "", "output": "subroutine nsymgauss(y,a,f,neq,ib)\n  implicit none\n  integer :: idiag,i,j,k,jend,kbgn,kend,ikc,jkc,iback,jc,kc\n  real :: fac\n  integer, intent(in) :: neq,ib\n  real,dimension(neq,ib) :: aa\n  real,dimension(neq) :: ff\n  real,dimension(neq,ib),intent(in) :: a\n  real,dimension(neq),intent(in) :: f\n  real,dimension(neq),intent(out) :: y\n\n! initialize matrices to overwrite\n  do i = 1,neq\n     do j = 1,ib\n        aa(i,j) = a(i,j)\n     end do\n     ff(i) = f(i)\n  end do\n\n! forward elimination\n  idiag = ((ib - 1)/2) + 1\n  do i = 1,neq-1\n     jend = neq\n     if (jend > (i+idiag-1)) jend = i+idiag-1\n     do j = i+1,jend\n        kc   = idiag - (j-i)\n        fac  = -aa(j,kc)/aa(i,idiag)\n        kbgn = i\n        kend = jend\n        do k = kbgn,kend\n           ikc = idiag + (k-i)\n           jkc = idiag + (k-j)\n           aa(j,jkc) = aa(j,jkc) + fac*aa(i,ikc)\n        end do\n        ff(j) = ff(j) + fac*ff(i)\n     end do\n  end do\n\n! backward substitution\n  y(neq) = ff(neq)/aa(neq,idiag)\n  do iback = 2,neq\n     i    = neq - iback + 1\n     jend = neq\n     if (jend > (i+(idiag-1))) jend = i+(idiag-1)\n     do j = i+1,jend\n        jc    = idiag + (j-i) \n        ff(i) = ff(i) - aa(i,jc)*y(j)\n     end do\n     y(i) = ff(i)/aa(i,idiag)\n  end do\nend subroutine nsymgauss\n"}, {"instruction": "Create a Fortran subroutine named coeff2 to calculate coefficient values based on input parameters. The subroutine takes 2 input parameters of type real and 2 output parameters of type real. The input parameters are u0 and b(4,3), and the output parameters are a(2,2,2) and d(4). The subroutine performs specific calculations involving the input parameters to compute the values of the output parameters. Use the imperative tone to write the instruction for this subroutine.", "input": "", "output": "      subroutine coeff2 ( u0,b,a,d )\n      implicit none\n      real, intent(in) :: u0\n      real, intent(in) :: b(4,3)\n      real, intent(out) :: a(2,2,2), d(4)\n      real :: fw1, fw2, fw3, fw4\n      fw1 = b(1,1) * b(1,2)\n      fw2 = b(2,1) * b(3,2)\n      fw3 = b(3,1) * b(2,2)\n      fw4 = b(4,1) * b(4,2)\n      a(2,2,1) = fw1 + fw2\n      a(2,1,1) = b(1,1) * b(2,2) + b(2,1) * b(4,2)\n      a(1,2,1) = b(3,1) * b(1,2) + b(4,1) * b(3,2)\n      a(1,1,1) = fw3 + fw4\n      a(2,2,2) = fw1 + fw3\n      a(2,1,2) = b(1,2) * b(2,1) + b(2,2) * b(4,1)\n      a(1,2,2) = b(3,2) * b(1,1) + b(4,2) * b(3,1)\n      a(1,1,2) = fw2 + fw4\n      d(1) = b(3,2) * b(4,3) + b(4,2) * b(3,3) + b(2,3) / u0\n      d(2) = b(1,2) * b(4,3) + b(2,2) * b(3,3) + b(1,3) / u0\n      d(3) = b(3,1) * b(1,3) + b(4,1) * b(2,3) + b(3,3) / u0\n      d(4) = b(1,1) * b(1,3) + b(2,1) * b(2,3) + b(4,3) / u0\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sec2time that converts the input number of seconds into hours, minutes, and seconds. The input parameter is of type integer. There are three output parameters, all of type integer, representing hours, minutes, and seconds, respectively.", "input": "", "output": "subroutine sec2time (isecs,hour,minute,second)\n\ninteger, intent(in)                      :: isecs\ninteger, intent(out)                     :: hour,minute,second\n\n! ... local variables\n! ...\ninteger irest\n\nsecond = mod(isecs,60)\nirest = (isecs-second)/60\nminute = mod(irest,60)\nhour = (irest-minute)/60\n\nend subroutine sec2time\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_coulomb_matrix to generate a Coulomb matrix based on the atomic charges and coordinates. The subroutine takes 3 input parameters of type double precision, dimension(:), double precision, dimension(:,:), and integer. It returns 1 output parameter of type double precision, dimension(((nmax + 1) * nmax) / 2).", "input": "", "output": "subroutine fgenerate_coulomb_matrix(atomic_charges, coordinates, nmax, cm)\n    \n    implicit none\n\n    double precision, dimension(:), intent(in) :: atomic_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n\n    integer, intent(in) :: nmax\n\n    double precision, dimension(((nmax + 1) * nmax) / 2), intent(out):: cm\n\n    double precision, allocatable, dimension(:) :: row_norms\n    double precision :: pair_norm\n    double precision :: huge_double\n\n    integer, allocatable, dimension(:) :: sorted_atoms\n\n    double precision, allocatable, dimension(:,:) :: pair_distance_matrix\n\n    integer :: i, j, m, n, idx\n    integer :: natoms\n\n    if (size(coordinates, dim=1) /= size(atomic_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(atomic_charges, dim=1), \"atom_types!\"\n        stop\n    else\n        natoms = size(atomic_charges, dim=1)\n    endif\n\n    ! allocate temporary\n    allocate(pair_distance_matrix(natoms,natoms))\n    allocate(row_norms(natoms))\n    allocate(sorted_atoms(natoms))\n\n    huge_double = huge(row_norms(1))\n\n    ! calculate row-2-norms and store pair-distances in pair_distance_matrix\n    row_norms = 0.0d0\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        pair_norm = 0.5d0 * atomic_charges(i) ** 2.4d0\n        row_norms(i) = row_norms(i) + pair_norm * pair_norm\n        pair_distance_matrix(i, i) = pair_norm\n    enddo\n    !$omp end parallel do\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        do j = i+1, natoms\n            pair_norm = atomic_charges(i) * atomic_charges(j) &\n                & / sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n\n            pair_distance_matrix(i, j) = pair_norm\n            pair_distance_matrix(j, i) = pair_norm\n            pair_norm = pair_norm * pair_norm\n            row_norms(j) = row_norms(j) + pair_norm\n            row_norms(i) = row_norms(i) + pair_norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    !generate sorted list of atom ids by row_norms - not really (easily) parallelizable\n    do i = 1, natoms\n        j = minloc(row_norms, dim=1)\n        sorted_atoms(natoms - i + 1) = j\n        row_norms(j) = huge_double\n    enddo\n\n    ! fill coulomb matrix according to sorted row-2-norms\n    cm = 0.0d0\n    !$omp parallel do private(idx, i, j)\n    do m = 1, natoms\n        i = sorted_atoms(m)\n        idx = (m*m+m)/2 - m\n        do n = 1, m\n            j = sorted_atoms(n)\n            cm(idx+n) = pair_distance_matrix(i, j)\n        enddo\n    enddo\n    !$omp end parallel do\n\n    ! clean up\n    deallocate(pair_distance_matrix)\n    deallocate(row_norms)\n    deallocate(sorted_atoms)\nend subroutine fgenerate_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named \"domaindecomp\" to perform domain decomposition on a mesh. The subroutine takes 2 input parameters of type integer: \"nelems\" and \"ndomains\". It also has 1 output parameter of type integer array with size (0:ndomains) named \"offsetelem\". The subroutine uses the imperative tone and implements the domain decomposition algorithm as described in the provided reference.", "input": "", "output": "  subroutine domaindecomp(nelems,ndomains,offsetelem)\n    ! from https://www.hopr-project.org/externals/meshformat.pdf, algorithm 4\n    implicit none\n    integer,intent(in) :: nelems\n    integer,intent(in) :: ndomains\n    integer,intent(out) :: offsetelem(0:ndomains)\n    ! local\n    integer :: nlocalelems\n    integer :: remainelems\n    integer :: idom\n\n    nlocalelems = nelems/ndomains\n    remainelems = nelems - nlocalelems*ndomains\n    do idom = 0,ndomains - 1\n      offsetelem(idom) = idom*nlocalelems + min(idom,remainelems)\n    end do\n    offsetelem(ndomains) = nelems\n\n  end subroutine domaindecomp\n"}, {"instruction": "Create a Fortran subroutine named elemtorank to find the domain containing a given element index. The subroutine takes 3 input parameters of type integer: ndomains, offsetelem(0:ndomains), elemid, and has 1 output parameter of type integer: domain.", "input": "", "output": "  subroutine elemtorank(ndomains,offsetelem,elemid,domain)\n    ! from https://www.hopr-project.org/externals/meshformat.pdf, algorithm 7\n    !   \"find domain containing element index\"\n    !\n    implicit none\n    integer,intent(in) :: ndomains\n    integer,intent(in) :: offsetelem(0:ndomains)\n    integer,intent(in) :: elemid\n    integer,intent(out) :: domain\n    ! local\n    integer :: maxsteps\n    integer :: low,up,mid\n    integer :: i\n\n    domain = 0\n    maxsteps = int(log10(real(ndomains))/log10(2.0)) + 1\n    low = 0\n    up = ndomains - 1\n\n    if (offsetelem(low) < elemid .and. elemid <= offsetelem(low + 1)) then\n      domain = low\n    elseif (offsetelem(up) < elemid .and. elemid <= offsetelem(up + 1)) then\n      domain = up\n    else\n      do i = 1,maxsteps\n        mid = (up - low)/2 + low\n        if (offsetelem(mid) < elemid .and. elemid <= offsetelem(mid + 1)) then\n          domain = mid\n          return\n        elseif (elemid > offsetelem(mid + 1)) then\n          low = mid + 1\n        else\n          up = mid\n        end if\n      end do\n    end if\n\n  end subroutine elemtorank\n"}, {"instruction": "Create a Fortran subroutine named initialize, which initializes two 2D arrays of real numbers with the specified dimensions. The subroutine takes 2 input parameters of type integer, 'm' and 'n', and provides 2 output parameters of type real(fp_kind),allocatable, 'a' and 'anew'. The subroutine allocates memory for the arrays based on the input dimensions and initializes them with specific values.", "input": "", "output": "    subroutine initialize(a, anew, m, n)\n      integer, parameter :: fp_kind=kind(1.0d0)\n      real(fp_kind),allocatable,intent(out)   :: a(:,:)\n      real(fp_kind),allocatable,intent(out)   :: anew(:,:)\n      integer,intent(in)          :: m, n\n\n      allocate ( a(0:n-1,0:m-1), anew(0:n-1,0:m-1) )\n\n      a    = 0.0_fp_kind\n      anew = 0.0_fp_kind\n\n      a(0,:)    = 1.0_fp_kind\n      anew(0,:) = 1.0_fp_kind\n    end subroutine initialize\n"}, {"instruction": "Create a Fortran subroutine named sum_across_tasks_int4 to store the value of the input integer as the output integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine sum_across_tasks_int4(addend, sum)\n integer, intent(in) :: addend\n integer, intent(out) :: sum\n\nsum = addend\n\nend subroutine sum_across_tasks_int4\n"}, {"instruction": "Create a Fortran subroutine named tallykey that takes a string as input and outputs an array of integers to count the occurrences of each character in the input string. The number of input parameters is 1 with the test_data type ['character(len=*)'], and the number of output parameters is 1 with the test_data type ['integer, dimension(256)'].", "input": "", "output": "  subroutine tallykey(s, counts)\n    character(len=*), intent(in) :: s\n    integer, dimension(256), intent(out) :: counts\n    integer :: i, j\n    counts = 0\n    do i=1,len(s)\n      j = iachar(s(i:i))\n      counts(j) = counts(j) + 1\n    end do\n  end subroutine tallykey\n"}, {"instruction": "Create a Fortran subroutine named \"mlf_initordefault_bool\" that initializes a logical variable based on the provided default value and an optional override value. The subroutine takes 2 input parameters of type logical and optional logical, and returns 1 output parameter of type logical.", "input": "", "output": "  pure subroutine mlf_initordefault_bool(var, def, opt)\n    logical, intent(out) :: var\n    logical, intent(in) :: def\n    logical, intent(in), optional :: opt\n    if(present(opt)) then\n      var = opt\n    else\n      var = def\n    endif\n  end subroutine mlf_initordefault_bool\n"}, {"instruction": "Create a Fortran subroutine named countfrequencyshape to calculate the count and maximum frequency, as well as a shape parameter. The subroutine should take 2 input parameters of type real*8 and integer, and return 3 output parameters of type integer, integer, and real*8.", "input": "", "output": "subroutine countfrequencyshape(n0_om, nom_max, beta, omega, nomega)\n  implicit none\n  integer, intent(out):: n0_om, nom_max\n  real*8,  intent(out):: beta\n  real*8,  intent(in) :: omega(nomega)\n  integer, intent(in) :: nomega\n  !\n  integer :: iom\n  real*8  :: pi\n  pi=acos(-1.0d0)\n  beta = pi/omega(1)\n  do iom=1,nomega\n     if (abs((omega(iom)*beta/pi+1)/2. - iom).gt.1e-1) exit\n  enddo\n  n0_om = iom-1\n  if (n0_om.eq.0) n0_om=1\n  nom_max = nint((omega(nomega)*beta/pi+1)/2.)\n\nend subroutine countfrequencyshape\n"}, {"instruction": "Create a Fortran subroutine named occ_mask_to_vec to convert a logical mask array into a vector of integers. The subroutine takes 1 input parameter of type logical and 1 output parameter of type integer, which is allocatable.", "input": "", "output": "    subroutine occ_mask_to_vec(omask, ovec)\n        logical, intent(in) :: omask(:, :)\n        integer, allocatable, intent(out) :: ovec(:)\n\n        if (allocated(ovec)) deallocate(ovec)\n        allocate(ovec(size(omask, 1)), source = 0)\n        where (omask(:, 1)) ovec = ovec + 1\n        where (omask(:, 2)) ovec = ovec + 2\n    end subroutine occ_mask_to_vec\n"}, {"instruction": "Create a Fortran subroutine named para_range that takes four input parameters of type integer(kind=4) and returns two output parameters of the same type. The input parameters are n1, n2, nprocs, and myrank. The output parameters are ista and iend. The subroutine calculates the range of indices to be processed by each processor in a parallel computation.", "input": "", "output": "subroutine para_range(n1, n2, nprocs, myrank, ista, iend)\n\n    implicit none\n\n    integer(kind=4), intent(in)     :: n1, n2, nprocs, myrank\n    integer(kind=4), intent(out)    :: ista, iend\n    integer(kind=4) :: iwork1, iwork2\n\n    iwork1 = (n2 - n1 + 1) / nprocs\n    iwork2 = mod(n2 - n1 + 1, nprocs)\n    ista = myrank * iwork1 + n1 + min(myrank, iwork2)\n    iend = ista + iwork1 - 1\n    if (iwork2 > myrank) iend = iend + 1\n\nend subroutine para_range\n"}, {"instruction": "Create a Fortran subroutine named \"bar\" that calculates the sum of squares of all elements in a 2D array. The subroutine should take 1 input parameter of type real, dimension(:,:), and 1 output parameter of type real.", "input": "", "output": "  subroutine bar(a,x)\n    real, dimension(:,:), intent(in) :: a\n    real, intent(out) :: x\n    integer :: i,j\n\n    x = 0\n    do j=1,ubound(a,2)\n       do i=1,ubound(a,1)\n          x = x + a(i,j)**2\n       end do\n    end do\n  end subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named def_ic that calculates the initial condition for a given value of x. The subroutine takes 1 input parameter of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameter represents the value of x. The output parameter represents the calculated initial condition u0. The subroutine uses the Fortran features such as implicit none, intent(in), and intent(out). The subroutine computes the initial condition using the equation u0 = (8.0d0/(dsqrt(2.0d0*pi)))*dexp(-x**2.0/2.0) where pi is a predefined constant.", "input": "", "output": "  subroutine def_ic(x,u0)\n    implicit none\n    real(kind=8), intent(in) :: x\n    real(kind=8), intent(out) :: u0\n    real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)\n\n    u0 = (8.0d0/(dsqrt(2.0d0*pi)))*dexp(-x**2.0/2.0)\n  end subroutine def_ic\n"}, {"instruction": "Write a Fortran subroutine named \"get_remap_pix_len\" that calculates the length of pixel mapping indices and weights. The subroutine takes six input parameters: two integers (grid1 and grid2), and four real numbers (x1min, x1max, x2min, x2max). The output parameter is an integer named \"pixlen\". \n\nHere's what the subroutine does:\n1. It calculates the box size for grid1 and grid2 by subtracting x1min from x1max, and x2min from x2max, respectively.\n2. It calculates the step size for grid1 and grid2 by dividing the box size by the number of grid points in each grid.\n3. It computes the length of pixel mapping indices and weights (pixlen) by dividing the step size of grid2 by the step size of grid1 and adding 2.\n\nYour task is to implement the subroutine \"get_remap_pix_len\" in Fortran.", "input": "", "output": "subroutine get_remap_pix_len(x1min, x1max, grid1, x2min, x2max, grid2, pixlen)\n  ! find pixel weight length.\n  !\n  ! parameters\n  ! ----------\n  ! x1min : float\n  !   minimum in grid 1.\n  ! x1max : float\n  !   maximum in grid 1.\n  ! grid1 : int\n  !   number of grid points in grid 1.\n  ! x2min : float\n  !   minimum in grid 2.\n  ! x2max : float\n  !   maximum in grid 2.\n  ! grid2 : int\n  !   number of grid points in grid 2\n  !\n  ! returns\n  ! -------\n  ! pixlen : int\n  !   length of pixel mapping indices and weights.\n\n  implicit none\n\n  ! parameter declarations\n\n  integer, parameter :: dp = kind(1.d0)\n\n  integer, intent(in) :: grid1, grid2\n  real(kind=dp), intent(in) :: x1min, x1max, x2min, x2max\n\n  real(kind=dp) :: boxsize1, boxsize2, dx1, dx2\n\n  integer, intent(out) :: pixlen\n\n  ! function\n\n  boxsize1 = x1max - x1min\n  boxsize2 = x2max - x2min\n\n  dx1 = boxsize1 / real(grid1)\n  dx2 = boxsize2 / real(grid2)\n\n  pixlen = int(floor(dx2/dx1)) + 2\n\nend subroutine get_remap_pix_len\n"}, {"instruction": "Write a Fortran subroutine named \"which_pix\" that determines the pixel corresponding to a given point on a grid. The subroutine takes three input parameters of type real(kind=dp): \"xmin\" represents the minimum value along the grid, \"dx\" is the pixel width, and \"x\" is the point for which we want to determine the pixel. The subroutine has one output parameter of type integer, named \"pix\", which represents the pixel the point corresponds to.", "input": "", "output": "subroutine which_pix(xmin, dx, x, pix)\n\n  ! find pixel along a defined grid.\n  !\n  ! parameters\n  ! ----------\n  ! xmin : float\n  !   minimum along the grid.\n  ! dx : float\n  !   pixel width.\n  ! x : float\n  !   a point for which we would like to determine\n  !\n  ! returns\n  ! -------\n  ! pix : int\n  !   the pixel the point corresponds to.\n\n  implicit none\n\n  ! parameter declarations\n\n  integer, parameter :: dp = kind(1.d0)\n\n  real(kind=dp), intent(in) :: xmin, dx, x\n  integer, intent(out) :: pix\n\n  ! function\n\n  pix = int(floor((x-xmin)/dx))\n\nend subroutine which_pix\n"}, {"instruction": "Write a Fortran subroutine named \"pix1dto2d\" that maps the pixel indices along the x and y axes onto a 2D grid. The subroutine takes in five input parameters: \"xpix\" and \"ypix\" (integer arrays representing the pixel indices along the x and y axes), \"xlen\" and \"ylen\" (integers representing the size of the xpix and ypix arrays), and \"ygrid\" (an integer representing the length of the y axis grid). The subroutine returns one output parameter \"pix\" (an integer array representing the 2D grid pixels). The purpose of the subroutine is to assign the appropriate values to the \"pix\" array based on the given x and y pixel indices. The subroutine uses nested do-loops to iterate over the x and y pixel indices and assigns the values to the \"pix\" array based on certain conditions.", "input": "", "output": "subroutine pix1dto2d(xpix, ypix, xlen, ylen, ygrid, pix)\n\n  ! maps pixels given along a single axis in x and y onto a 2d grid flattened.\n  !\n  ! parameters\n  ! ----------\n  ! xpix : int\n  !   pixel indices along the x axis grid.\n  ! ypix : int\n  !   pixel indices along the y axis grid.\n  ! xlen : int\n  !   size of the xpix.\n  ! ylen : int\n  !   size of the ypix.\n  ! ygrid : int\n  !   length of y axis grid.\n  !\n  ! returns\n  ! -------\n  ! pix : int\n  !   2d grid pixel.\n\n  implicit none\n\n  integer, intent(in) :: xlen, ylen, ygrid\n  integer, intent(in) :: xpix(xlen), ypix(ylen)\n  integer, intent(out) :: pix(xlen*ylen)\n\n  integer :: i, j, ii\n\n  ii = 1\n\n  do i = 1, xlen\n    do j = 1, ylen\n      if ((xpix(i) .ne. -1) .and. (ypix(j) .ne. -1)) then\n        pix(ii) = ypix(j) + ygrid*xpix(i)\n      else\n        pix(ii) = -1\n      end if\n      ii = ii + 1\n    end do\n  end do\n\nend subroutine pix1dto2d\n"}, {"instruction": "Create a Fortran subroutine named kpspl3 to calculate the values of a cubic spline at a given point. The subroutine takes 1 input parameter of type real(4) and produces 1 output parameter of type real(4). The input parameter 'kp' is an input value for the calculation, and the output parameter 'kpterms' is an array containing the computed spline values.", "input": "", "output": "subroutine kpspl3(kp, kpterms)\n\n    implicit none\n\n    real(4), intent(in)       :: kp\n    real(4), intent(out)      :: kpterms(0:2)\n\n    integer(4)                :: i, j\n    real(4)                   :: x, kpspl(0:6)\n    real(4), parameter        :: node(0:7)=(/-10., -8., 0., 2., 5., 8., 18., 20./)\n\n    x = max(kp, 0.0)\n    x = min(x,  8.0)\n\n    kpterms(0:2) = 0.0\n    do i = 0, 6\n      kpspl(i) = 0.0\n      if ((x .ge. node(i)) .and. (x .lt. node(i+1))) kpspl(i) = 1.0\n    enddo\n    do j = 2,3\n      do i = 0, 8-j-1\n        kpspl(i) = kpspl(i)   * (x - node(i))   / (node(i+j-1) - node(i)) &\n                 + kpspl(i+1) * (node(i+j) - x) / (node(i+j)   - node(i+1))\n      enddo\n    enddo\n    kpterms(0) = kpspl(0) + kpspl(1)\n    kpterms(1) = kpspl(2)\n    kpterms(2) = kpspl(3) + kpspl(4)\n\n    return\n\nend subroutine kpspl3\n"}, {"instruction": "Create a Fortran subroutine named extract3_6x1_t2f to extract a 3x3 matrix from a 6x1 vector. The input parameter is a real(8) array vfvec with 6 elements, and the output parameter is a real(8) array res with dimensions 3x3.", "input": "", "output": "      subroutine extract3_6x1_t2f (res, vfvec)\n      ! extracts a 6x1 vector: res(3x3) = vfvec(6) [3rd dimension]\n      !     vfvec          vector; dimension (6)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (3,3)\n         real(8), intent(in)  :: vfvec (6)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1,1) = vfvec(1)\n         res(2,1) = vfvec(4)\n         res(3,1) = vfvec(6)\n         \n         res(1,2) = vfvec(4)\n         res(2,2) = vfvec(2)\n         res(3,2) = vfvec(5)\n         \n         res(1,3) = vfvec(6)\n         res(2,3) = vfvec(5)\n         res(3,3) = vfvec(3)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named contract3_t2f_6x1 to contract a 3x3 tensor and store the result in an array. The subroutine takes one input parameter of type real(8) and outputs another parameter of the same type. The input parameter represents a 3x3 tensor, and the output parameter is an array of size 6. The code calculates the contracted elements of the tensor and assigns them to the output array.", "input": "", "output": "      subroutine contract3_t2f_6x1 (res, t2f)\n      ! contracts a 3x3 tensor: res(6) = t2f(3x3) [3rd dimension]\n      !     t2f            tensor 2nd order; dimension (dimxdim)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (6)\n         real(8), intent(in)  :: t2f (3,3)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1) = t2f(1,1)\n         res(2) = t2f(2,2)\n         res(3) = t2f(3,3)\n         res(4) = t2f(1,2)\n         res(5) = t2f(2,3)\n         res(6) = t2f(3,1)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named contract3_t4f_6x6 to contract a 3x3x3x3 tensor into a 6x6 result matrix. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type real(8).", "input": "", "output": "      subroutine contract3_t4f_6x6 (res, t4f)\n      ! contracts a 3x3x3x3 tensor: res(6x6) = t2f(3x3x3x3) [3rd dimension]\n      !     t4f            tensor 4th order; dimension (dimxdimxdimxdim)\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         real(8), intent(out) :: res (6,6)\n         real(8), intent(in)  :: t4f (3,3,3,3)\n         \n         !### var ###!\n         \n         !### code ###!\n         res(1,1) = t4f(1,1,1,1)\n         res(2,1) = t4f(2,2,1,1)\n         res(3,1) = t4f(3,3,1,1)\n         res(4,1) = t4f(1,2,1,1)\n         res(5,1) = t4f(2,3,1,1)\n         res(6,1) = t4f(3,1,1,1)\n         \n         res(1,2) = t4f(1,1,2,2)\n         res(2,2) = t4f(2,2,2,2)\n         res(3,2) = t4f(3,3,2,2)\n         res(4,2) = t4f(1,2,2,2)\n         res(5,2) = t4f(2,3,2,2)\n         res(6,2) = t4f(3,1,2,2)\n         \n         res(1,3) = t4f(1,1,3,3)\n         res(2,3) = t4f(2,2,3,3)\n         res(3,3) = t4f(3,3,3,3)\n         res(4,3) = t4f(1,2,3,3)\n         res(5,3) = t4f(2,3,3,3)\n         res(6,3) = t4f(3,1,3,3)\n         \n         res(1,4) = t4f(1,1,1,2)\n         res(2,4) = t4f(2,2,1,2)\n         res(3,4) = t4f(3,3,1,2)\n         res(4,4) = t4f(1,2,1,2)\n         res(5,4) = t4f(2,3,1,2)\n         res(6,4) = t4f(3,1,1,2)\n         \n         res(1,5) = t4f(1,1,2,3)\n         res(2,5) = t4f(2,2,2,3)\n         res(3,5) = t4f(3,3,2,3)\n         res(4,5) = t4f(1,2,2,3)\n         res(5,5) = t4f(2,3,2,3)\n         res(6,5) = t4f(3,1,2,3)\n         \n         res(1,6) = t4f(1,1,3,1)\n         res(2,6) = t4f(2,2,3,1)\n         res(3,6) = t4f(3,3,3,1)\n         res(4,6) = t4f(1,2,3,1)\n         res(5,6) = t4f(2,3,3,1)\n         res(6,6) = t4f(3,1,3,1)\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"in1_ord21\" to calculate the first inner product of two matrices. The subroutine takes 3 input parameters: an integer \"idm\", a double precision array \"t2f_a\" of dimension \"idm x idm\", and a double precision array \"t1f_b\" of dimension \"idm\". It returns 1 output parameter, a double precision array \"res\" of dimension \"idm\".", "input": "", "output": "      subroutine in1_ord21 (res, t2f_a, t1f_b, idm)\n      ! returns the first inner product of a and b\n      ! res_i = a_ij * b_j\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t1f_b (idm)\n      \n         !### var ###!\n         integer  :: i,jj\n         real(8)  :: fsum\n         \n         !### code ###!\n         do i = 1,idm\n            \n            fsum = 0.0d0\n            do jj = 1,idm\n               fsum = fsum + t2f_a(i,jj) * t1f_b(jj)\n            enddo\n            res(i) = fsum\n            \n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named in1_ord22 to calculate the first inner product of two matrices. The subroutine takes 3 input parameters: an integer (idm), and two real(8) matrices (t2f_a and t2f_b), and returns a single real(8) matrix (res) as the output. The subroutine computes the inner product according to the formula res_ij = a_ik * b_kj using nested do-loops.", "input": "", "output": "      subroutine in1_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the first inner product of a and b\n      ! res_ij = a_ik * b_kj\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n      \n         !### var ###!\n         integer  :: i,j,kk\n         real(8)  :: fsum\n         \n         !### code ###!\n         do j = 1,idm\n            do i = 1,idm\n               \n               fsum = 0.0d0\n               do kk = 1,idm\n                  fsum = fsum + t2f_a(i,kk) * t2f_b(kk,j)\n               enddo\n               res(i,j) = fsum\n               \n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named in2_ord22 to calculate the second inner product of two matrices.The subroutine takes 3 input parameters of type integer, real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "      subroutine in2_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the second inner product of a and b\n      ! res = a_ij * b_ij\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n      \n         !### var ###!\n         integer  :: ii,jj\n         \n         !### code ###!\n         res = 0.0d0\n         do jj = 1,idm\n            do ii = 1,idm\n               res = res + t2f_a(ii,jj) * t2f_b(ii,jj)\n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named in2_ord24 that calculates the second inner product of two matrices. The number of input arguments is 3, where the first argument is an integer (idm), the second argument is a 2-dimensional real array (t2f_a) and the third argument is a 4-dimensional real array (t4f_b). The number of output arguments is 1, which is a 2-dimensional real array (res). \n\nThe subroutine computes the second inner product by multiplying corresponding elements from the two matrices and summing them up. The result is stored in the res array. The size of the matrices is determined by the idm input parameter.\n\nUse the provided code as a reference to implement the subroutine.", "input": "", "output": "      subroutine in2_ord24 (res, t2f_a, t4f_b, idm)\n      ! returns the second inner product of a and b\n      ! res_ij = a_kl * b_klij\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t4f_b (idm,idm,idm,idm)\n      \n         !### var ###!\n         integer  :: i,j,kk,ll\n         real(8)  :: fsum\n         \n         !### code ###!\n         do j = 1,idm\n            do i = 1,idm\n               \n               fsum = 0.0d0\n               do ll = 1,idm\n                  do kk = 1,idm\n                     fsum = fsum + t2f_a(kk,ll) * t4f_b(kk,ll,i,j)\n                  enddo\n               enddo\n               res(i,j) = fsum\n               \n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"dyad_ord22\" that calculates the outer/dyadic product of two matrices. The number of input arguments is 3 and the test_data types are ['integer', 'real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)']. This subroutine takes in two matrices, \"t2f_a\" and \"t2f_b\", with dimensions \"idm\" by \"idm\", and computes the outer product of these matrices, storing the result in the \"res\" matrix with dimensions \"idm\" by \"idm\" by \"idm\" by \"idm\".", "input": "", "output": "      subroutine dyad_ord22 (res, t2f_a, t2f_b, idm)\n      ! returns the outer/dyadic product of a and b\n      ! res_ijkl = a_ij * b_kl\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res (idm,idm,idm,idm)\n         real(8), intent(in)  :: t2f_a (idm,idm)\n         real(8), intent(in)  :: t2f_b (idm,idm)\n         \n         !### var ###!\n         integer  :: i,j,k,l\n         \n         !### code ###!\n         do l = 1,idm\n            do k = 1,idm\n               do j = 1,idm\n                  do i = 1,idm\n                     res(i,j,k,l) = t2f_a(i,j) * t2f_b(k,l)\n                  enddo\n               enddo\n            enddo\n         enddo\n      \n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named get_basis that takes an array of integers as input. The number of input arguments is 1 and the test_data type is ['integer']. It also has three output parameters, all of which are integer arrays that are dynamically allocated. The test_data type for these output parameters is ['integer, allocatable', 'integer, allocatable', 'integer, allocatable'].\n\nThe purpose of this subroutine is to calculate the basis for a given set of functions. It iterates over the input array and computes the total number of basis functions based on the values in the array. It then allocates memory for the three output arrays based on the calculated number of basis functions. \n\nInside the subroutine, it iterates over the input array again to populate the output arrays with the corresponding values. The 'nlist' array stores the index of the basis function, the 'llist' array stores the value of the angular momentum, and the 'mlist' array stores the value of the magnetic quantum number. \n\nMake sure to allocate memory for the output arrays before populating them and deallocate the memory after using the arrays to avoid memory leaks.", "input": "", "output": "subroutine get_basis(nbfl, nlist, llist, mlist)\ninteger, intent(in) :: nbfl(0:)\ninteger, allocatable, intent(out) :: nlist(:), llist(:), mlist(:)\ninteger :: i, n, l, m, a\na = 0\ndo l = 0, ubound(nbfl, 1)\n    a = a + nbfl(l) * (2*l+1)\nend do\nallocate(nlist(a), llist(a), mlist(a))\ni = 1\ndo l = 0, ubound(nbfl, 1)\n    do n = 1, nbfl(l)\n        do m = -l, l\n            nlist(i) = n\n            llist(i) = l\n            mlist(i) = m\n            i = i + 1\n        end do\n    end do\nend do\nend subroutine\n"}, {"instruction": "Provide a Fortran subroutine named readfirstpart_of_in1 to read and extract parameters from an input file. The number of input parameters is 2, both of type integer. The number of output parameters is 7, including three logical variables, two real*8 variables, and two integer variables. The purpose of this subroutine is to read and extract output-format parameters and other variables from the input file. The extracted values will be stored in the output variables for further processing in the program.", "input": "", "output": "subroutine readfirstpart_of_in1(prntwf, sprswf, wftape, efermi, nt, rkm, lnsmax, nslmax, lmax)\n  !        read output-format parameters\n  implicit none\n  logical, intent(out) :: prntwf, sprswf, wftape\n  real*8, intent(out)  :: efermi, rkm\n  integer, intent(out) :: lnsmax, nt\n  integer, intent(in)  :: nslmax, lmax\n  ! locals\n  character   :: line*80\n  character*5 :: modus\n  integer     :: nt1, i\n  read(5,'(a)') line\n  read(line,'(a5)') modus    ! beginning of case.in1\n  if (modus .eq. 'wfpri') then\n     prntwf = .true.\n     sprswf = .false.\n     wftape = .true.\n  elseif (modus .eq. 'wffil') then  ! default\n     prntwf = .false.\n     sprswf = .false.\n     wftape = .true.\n  elseif (modus .eq. 'enfil') then\n     prntwf = .false.\n     sprswf = .true.\n     wftape = .false.\n  else\n     prntwf = .false.\n     sprswf = .true.\n     wftape = .false.\n  endif\n  ! from the first line of case.in1 extracts the fermi energy\n  efermi=0.5d0\n  do i=6,70\n     if(line(i:i+1).eq.'ef') then\n        read(line(i+3:80),*,err=1234) efermi\n     endif\n  enddo\n1234 continue\n  !\n  !        read in r-mt times k-max (used to check convergence)\n  !\n  read(5,*) rkm, nt1, lnsmax   ! rkm==r-mt*k-max; nt1==max l in wf; lnsmax==v-nmt\n  if (lnsmax .eq. 0) lnsmax = 2\n  if (lnsmax .ge. nslmax) lnsmax = nslmax - 1  ! can not be larger than nslmax=5\n  if (nt1 .gt. 0)    nt = nt1 + 1\n  if (nt  .gt. lmax) nt = lmax                 ! can not be greated that lmax=13\n  ! nt is lmax+1 but updated to be compatible with case.in1 specified maximum l.\nend subroutine readfirstpart_of_in1\n"}, {"instruction": "Create a Fortran subroutine named \"radial_basis\" to calculate the basis functions for a given set of parameters. The number of input arguments is 5 and their types are ['integer', 'double precision', 'integer', 'integer', 'double precision']. The number of output arguments is 2 and their types are ['double precision', 'integer'].\n\nThe subroutine takes an integer value \"l\", a double precision value \"alpha\", an integer value \"n_b\", an integer value \"n_r\", and an array \"r_grid\" of double precision values with length \"n_r\" as input. It also outputs an array \"basis\" of double precision values with dimensions \"n_r\" by \"n_b\", and an integer value \"status\".\n\nThe subroutine first checks if the input arguments are valid and sets the \"status\" variable accordingly. If any of the conditions are not met, \"status\" is set to 1 and the subroutine returns.\n\nNext, the subroutine calculates the normalization constants for the basis functions using a recurrence relation and stores them in the array \"norm\".\n\nThen, an array \"alpha_grid\" is created by multiplying the values of \"alpha\" with the elements of \"r_grid\".\n\nThe basis functions are then calculated using another recurrence relation, and the results are stored in the array \"basis\".\n\nFinally, the basis functions are scaled by the corresponding normalization constants.\n\nOverall, the \"radial_basis\" subroutine calculates the basis functions for a given set of parameters using recurrence relations and normalization constants, and outputs the results in the \"basis\" array and the status of the calculation in the \"status\" variable.", "input": "", "output": "  subroutine radial_basis (l, alpha, n_b, n_r, r_grid, basis, status)\n    integer , intent(in) :: l\n    double precision , intent(in) :: alpha\n    integer , intent(in) :: n_b\n    integer , intent(in) :: n_r\n    double precision , intent(in) :: r_grid(n_r)\n    double precision , intent(out) :: basis(n_r, n_b)\n    integer , intent(out) :: status\n    double precision :: norm(n_b)\n    double precision :: alpha_grid(n_r)\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1) .or. (n_r < 1)) then\n      status = 1\n      return\n    end if\n\n    ! recurrence relation for basis normalisation constants\n    norm(1) = sqrt(alpha / dble((l + 1d0) * gamma(dble((2d0 * l) + 2d0))))\n\n    if (n_b >= 2) then\n      do kk = 2, n_b\n        norm(kk) = norm(kk-1) * sqrt(dble((kk - 1d0) * (kk - 1d0 + l)) / &\n            dble((kk + l) * (kk + (2d0 * l))))\n      end do\n    end if\n\n    ! in-lined array since r_grid(:) on its own is never used\n    alpha_grid(:) = alpha * r_grid(:)\n\n    ! recurrence relation for basis functions\n    basis(:, 1) = ((2.0d0 * alpha_grid(:)) ** (l + 1)) * &\n        exp(-alpha_grid(:))\n\n    if (n_b >= 2) then\n      basis(:, 2) = 2.0d0 * (dble(l + 1d0) - alpha_grid(:)) * basis(:, 1)\n    end if\n\n    if (n_b >= 3) then\n      do kk = 3, n_b\n        basis(:, kk) = &\n            ((2.0d0 * (dble(kk - 1d0 + l) - alpha_grid(:)) * basis(:, kk-1)) &\n            - dble(kk + (2d0 * l) - 1d0) * basis(:, kk-2)) / dble(kk - 1)\n      end do\n    end if\n\n    ! scaling basis functions by normalisation constants\n    do kk = 1, n_b\n      basis(:, kk) = basis(:, kk) * norm(kk)\n    end do\n\n  end subroutine radial_basis\n"}, {"instruction": "Write a Fortran subroutine named \"overlap_matrix\" that calculates the overlap matrix for a given size \"l\" and number of basis functions \"n_b\". The subroutine takes two input parameters of type integer, \"l\" and \"n_b\", and two output parameters of type double precision and integer, \"b\" and \"status\", respectively.\n\nThe subroutine first checks if the input arguments are valid. If either \"l\" is negative or \"n_b\" is less than 1, the \"status\" is set to 1 and the subroutine returns.\n\nNext, the subroutine initializes a square matrix \"b\" of size \"n_b\" by \"n_b\" to zero.\n\nThen, the subroutine calculates the elements of the tri-diagonal overlap matrix using a loop. The diagonal elements are set to 1, and the off-diagonal elements are computed based on a formula involving \"l\". The elements are symmetric, so the subroutine sets both the upper and lower triangular elements simultaneously.\n\nFinally, the subroutine sets the last element of the matrix to 1, which is not covered by the loop.\n\nOverall, the \"overlap_matrix\" subroutine takes two integer input parameters, \"l\" and \"n_b\", and outputs a double precision matrix \"b\" and an integer \"status\".", "input": "", "output": "  subroutine overlap_matrix(l, n_b, b, status)\n    integer , intent(in) :: l\n    integer , intent(in) :: n_b\n    double precision , intent(out) :: b(n_b, n_b)\n    integer , intent(out) :: status\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1)) then\n      status = 1\n      return\n    end if\n\n    ! initialise overlap matrix to zero\n    b(:, :) = 0.0d0\n\n    ! determine tri-diagonal overlap matrix elements\n    do kk = 1, n_b-1\n      b(kk, kk) = 1.0d0\n\n      b(kk, kk+1) = - 0.5d0 * sqrt(1 - &\n          (dble(l * (l + 1)) / dble((kk + l) * (kk + l + 1))))\n\n      b(kk+1, kk) = b(kk, kk+1)\n    end do\n\n    ! last term (not covered by loop)\n    b(n_b, n_b) = 1.0d0\n\n  end subroutine overlap_matrix\n"}, {"instruction": "Create a Fortran subroutine named potential_matrix to calculate the potential matrix for a given set of input parameters. The subroutine takes 3 input parameters of type integer, integer, and double precision, and 2 output parameters of type double precision and integer.", "input": "", "output": "  subroutine potential_matrix(l, alpha, n_b, v, status)\n    integer , intent(in) :: l\n    integer , intent(in) :: n_b\n    double precision , intent(in) :: alpha\n    double precision , intent(out) :: v(n_b, n_b)\n    integer , intent(out) :: status\n    integer :: kk\n\n    ! check if arguments are valid\n    status = 0\n\n    if ((l < 0) .or. (n_b < 1)) then\n      status = 1\n      return\n    end if\n\n    ! initialise coulomb matrix to zero\n    v(:, :) = 0.0d0\n\n    ! determine diagonal coulomb matrix elements\n    do kk = 1, n_b\n      v(kk, kk) = - alpha / dble(kk + l)\n    end do\n\n  end subroutine potential_matrix\n"}, {"instruction": "Create a Fortran subroutine named primarypsf to calculate the point spread function for a given optical system. The subroutine takes 11 input parameters of types integer, integer, integer, real*8 arrays, real*8, and complex*16, and outputs a real*8 array.", "input": "", "output": "subroutine primarypsf(distortion,xdim,ydim,z,length,x0,n,wave,primfoc,r0,graze,psf)\n  !declarations\n  implicit none\n  integer, intent(in) :: xdim,ydim,n\n  real*8, intent(in), dimension(xdim,ydim) :: distortion\n  real*8, intent(in), dimension(ydim) :: z\n  real*8, intent(in), dimension(n) :: x0\n  real*8, intent(in), dimension(xdim) :: length\n  real*8, intent(in) :: wave,primfoc,r0,graze\n  complex*16 :: j,integrand\n  real*8, intent(out), dimension(n) :: psf\n  integer :: i,xi,yi\n  real*8 :: d2,lengthsum,dz,dummy,pi\n\n  !constants\n  j = (0.,1.)\n  lengthsum = sum(length)\n  dz = abs(z(2)-z(1))\n  pi = acos(-1.)\n\n  do i = 1,n\n    psf(i) = 0.\n    do xi = 1,xdim\n      !compute integral over axial dimension\n      integrand = 0.\n      !$omp parallel do reduction(+:integrand) private(d2)\n      do yi = 1,ydim\n        if (isnan(distortion(xi,yi)) .eqv. .false.) then\n          d2 = sqrt((distortion(xi,yi)-x0(i))**2 + (z(yi)+primfoc)**2)\n          integrand = integrand + exp(-2*j*pi*(d2-z(yi))/wave)*sqrt(distortion(xi,yi)/d2)\n          !print *, distortion(xi,yi), z(yi), d2, integrand\n          !read *, dummy\n        end if\n      end do\n      !$omp end parallel do\n      !add weighted integral to relevant observation point\n      !print *, integrand,abs(integrand)**2,x0(i)\n      psf(i) = psf(i) + abs(integrand)**2*sin(graze)*dz**2/wave/r0/lengthsum\n      !print *, psf(i)\n      !read *, dummy\n    end do\n\n  end do\n\nend subroutine primarypsf\n"}, {"instruction": "Create a Fortran subroutine named scatter_matrix that takes 4 input arguments of type integer, integer, integer, real(8) and 1 output argument of type real(8).The input parameters represent the dimensions of matrices and the matrices themselves, while the output parameter represents the scattered matrix. The subroutine initializes the output matrix to zero and then scatters the input matrix values into the appropriate locations within the output matrix based on the specified dimensions.", "input": "", "output": "subroutine scatter_matrix(a, b, ndim, n, m)\n    implicit none\n    integer, intent(in) :: n, m, ndim\n    real(8), intent(in) :: a(m, n)\n    real(8), intent(out) :: b(ndim*m, ndim*n)\n    integer i, j, k\n\n!    initialization to zero; otherwise random stuff is there...\n    b(:,:) = 0.0\n! looping style like in python:\n    do i=0,m-1\n        do j=0,n-1\n            do k=0,ndim-1\n                b(ndim*i+k+1,ndim*j+k+1) = a(i+1,j+1)\n            end do\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine called invert_3_by_3_matrix to invert a 3x3 matrix and compute its determinant. The subroutine takes 1 input parameter of type real(8) representing the 3x3 matrix, and provides 2 output parameters of type real(8) representing the inverted matrix and determinant, respectively.", "input": "", "output": "subroutine invert_3_by_3_matrix(a, a_inv, det)\n    ! invert the matrix a and compute the determinant\n    implicit none\n\n    real(8), intent(in) :: a(3,3)\n    real(8), intent(out) :: a_inv(3,3), det\n    real(8) :: a11, a12, a13, a21, a22, a23, a31, a32, a33\n    a11 = a(1,1)\n    a12 = a(1,2)\n    a13 = a(1,3)\n    a21 = a(2,1)\n    a22 = a(2,2)\n    a23 = a(2,3)\n    a31 = a(3,1)\n    a32 = a(3,2)\n    a33 = a(3,3)\n    det = a11*a22*a33 - a11*a23*a32 - a12*a21*a33 + a12*a23*a31 + a13*a21*a32 - a13*a22*a31\n    a_inv = reshape((/ a22*a33 - a23*a32, -a21*a33 + a23*a31, &\n                       a21*a32 - a22*a31, -a12*a33 + a13*a32, &\n                       a11*a33 - a13*a31, -a11*a32 + a12*a31, &\n                       a12*a23 - a13*a22, -a11*a23 + a13*a21, &\n                       a11*a22 - a12*a21 /), (/3,3/)) / det\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linip_arr to perform linear interpolation of time-dependent profiles. The subroutine takes 5 input parameters, which are of type integer, integer, real*8, real*8, and real*8, and 1 output parameter of type real*8. The purpose of the subroutine is to interpolate profiles at a chosen time based on the input time vector and ordinate values. The output interpolated profiles are computed and stored in the variable y.", "input": "", "output": "subroutine linip_arr(m, n, ts, ys, t, y)\n!\n!     linear interpolation of time dependent profiles.\n!     for times which are outside the bounds the profile is set to the last/first present time.\n!\n\n!     we don't care about whether a profile has previously been interpolated or not.\n!\n!     inputs:\n!     m                       number of ts-vector elements\n!     n                        number of used rho-vector elements\n!     ts\t                the time vector. values must be monotonically increasing.\n!     ys(rho, ts)          array of ordinate values.\n!     t\t                the time for which the ordinates shall be interpolated\n!\n!     output:\n!     y(rho)                 interpolated profiles at the chosen time\n!\n  implicit none\n\n  integer, intent(in)                 :: m\n  integer, intent(in)                 :: n\n  real*8, intent(in)                   :: ts(m)\n  real*8, intent(in)                   :: ys(n, m)\n\n  real*8, intent(in)                   :: t\n  real*8, intent(out)                :: y(n)\n\n  integer :: k, i\n\n  real*8 ::  ff\n\n  ! if only one time point has been given, then return the same/only value\n  if (m.eq.1) then\n     do i=1,n\n        y(i) = ys(i,1)\n     enddo\n     return\n  endif\n\n  ! if the requested time is greater than the maximum time provided, then use the last time\n  if (t.ge.ts(m)) then\n     do i=1,n\n        y(i) = ys(i,m)\n     enddo\n     return\n  endif\n\n  ! if the requested time is smaller than the minimum time provided, then use the first time\n  if (t.lt.ts(1)) then\n     do i=1,n\n        y(i) = ys(i,1)\n     enddo\n     return\n  endif\n\n  ! find time point in \"ts\" vector that is marginally larger than the requested \"t\"\n  k=0\n  do k=1,m+1\n     if (t < ts(k+1)) then\n        exit\n     endif\n  enddo\n\n  ff = (t - ts(k))/(ts(k+1) - ts(k))\n  do i=1,n\n     y(i) = ys(i,k)*(1.0d0 - ff) + ys(i,k+1)*ff\n  enddo\n\nend subroutine linip_arr\n"}, {"instruction": "Create a Fortran subroutine named heap_peek to access the k-th node of the heap. This subroutine takes 5 input parameters of type integer (kind=4) and one output parameter of type integer (kind=4), dimension(0:1). The input parameters are 'entr', 'cap', 'heap_length', 'heap', and 'indx', and the output parameter is 'node'.", "input": "", "output": "subroutine heap_peek( heap, indx,cap,heap_length,entr,node)\n  ! access the k-th node of the heap\n\n  integer (kind=4), intent(in) :: entr, cap\n  integer (kind=4), intent(in) :: heap_length\n  integer (kind=4), intent(in), dimension(0:1,0:cap-1) :: heap\n  integer (kind=4), intent(in), dimension(0:cap-1) :: indx\n  integer (kind=4), intent(out), dimension(0:1) :: node\n  if (entr < 0 .or. entr >= heap_length .or. heap_length > cap) then\n      write(*,*) \"error in peek\"\n      return\n  endif\n  node = heap(:,indx(entr))\nend subroutine heap_peek\n"}, {"instruction": "Create a Fortran subroutine named evaluate_dudt_vort to calculate the vorticity term of the given grid data. The subroutine takes 9 input parameters of type double precision and integer: dudt_vort, v, zeta, fu, xlow, xhigh, ylow, yhigh, layers, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine evaluate_dudt_vort(dudt_vort, v, zeta, fu, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dudt_vort(i, j) is evaluated at the centre of the left edge of the grid\n    ! box, the same place as u(i, j).\n    double precision, intent(out) :: dudt_vort(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: v(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: zeta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: fu(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dudt_vort = 0d0\n\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dudt_vort(i,j,k) = 0.25d0*(fu(i,j)+0.5d0*(zeta(i,j,k)+zeta(i,j+1,k))) &\n                *(v(i-1,j,k)+v(i,j,k)+v(i-1,j+1,k)+v(i,j+1,k)) ! vorticity term\n        end do\n      end do\n    end do\n\n    return\n  end subroutine evaluate_dudt_vort\n"}, {"instruction": "Write a Fortran subroutine named evaluate_dudt_bp to calculate the discrete derivative of a given variable and store the result in an output array. The input parameters include two 3D arrays of double precision type, and six integer variables, representing the boundaries and layers of the grid. The output is a 3D array of double precision type.", "input": "", "output": "  subroutine evaluate_dudt_bp(dudt_bp, b, dx, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dudt_bp(i, j) is evaluated at the centre of the left edge of the grid\n    ! box, the same place as u(i, j).\n    double precision, intent(out) :: dudt_bp(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: b(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: dx\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dudt_bp = 0d0\n\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dudt_bp(i,j,k) = - (b(i,j,k) - b(i-1,j,k))/dx ! bernoulli potential term\n        end do\n      end do\n    end do\n\n    return\n  end subroutine evaluate_dudt_bp\n"}, {"instruction": "Write a Fortran subroutine named evaluate_dvdt_vort to compute the vorticity tendency at the center of the bottom edge of a grid box. The subroutine takes 9 input parameters of type double precision and integer, and provides 1 output parameter of type double precision. The input parameters are u, zeta, fv, xlow, xhigh, ylow, yhigh, layers, and ol.", "input": "", "output": "  subroutine evaluate_dvdt_vort(dvdt_vort, u, zeta, fv, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    ! dvdt_vort(i, j) is evaluated at the centre of the bottom edge of the\n    ! grid box, the same place as v(i, j)\n    double precision, intent(out) :: dvdt_vort(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: u(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: zeta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: fv(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    integer,          intent(in)  :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer :: i, j, k\n\n    dvdt_vort = 0d0\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol-1\n          dvdt_vort(i,j,k) = &\n              - 0.25d0*(fv(i,j)+0.5d0*(zeta(i,j,k)+zeta(i+1,j,k))) &\n                *(u(i,j-1,k)+u(i,j,k)+u(i+1,j-1,k)+u(i+1,j,k)) !vorticity term\n        end do\n      end do\n    end do\n\n\n    return\n  end subroutine evaluate_dvdt_vort\n"}, {"instruction": "Create a Fortran subroutine named array_sqrt to calculate the square root of each element in an input array and store the results in an output array. The subroutine takes 2 input parameters: an integer n and a real array of dimension n. It has 1 output parameter, a real array of dimension n.", "input": "", "output": "subroutine array_sqrt(n, a_in, a_out)\n\n  implicit none\n  integer, intent(in) :: n\n  real, dimension(n), intent(in)  :: a_in\n  real, dimension(n), intent(out) :: a_out\n\n  integer :: i\n\n  do i = 1, n\n     a_out(i) = sqrt(a_in(i))\n  end do\n\n  return\n\nend subroutine array_sqrt\n"}, {"instruction": "Create a Fortran subroutine named dinterp2dxy to perform bilinear interpolation of a three-dimensional array onto a two-dimensional array. The subroutine takes 6 input parameters of types integer, integer, integer, integer, real(kind=8) array with dimensions (nx,ny,nz), and real(kind=8) array with dimensions (2,nxy). It also has 1 output parameter of type real(kind=8) array with dimensions (nxy,nz). The subroutine uses parallel processing for the interpolation computation.", "input": "", "output": "subroutine dinterp2dxy(v3d, v2d, xy, nx, ny, nz, nxy)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: v2d\n\n    integer, intent(in) :: nx, ny, nz, nxy\n    real(kind=8), dimension(nx,ny,nz), intent(in) :: v3d\n    real(kind=8), dimension(nxy,nz), intent(out) :: v2d\n    real(kind=8), dimension(2,nxy), intent(in) :: xy\n\n! nclend\n\n    integer :: i, j, k, ij\n    real(kind=8) :: w11, w12, w21, w22, wx, wy\n\n    !$omp parallel do private(i,j,k,ij,w11,w12,w21,w22,wx,wy) &\n    !$omp schedule(runtime)\n    do ij = 1,nxy\n        i = max(1,min(nx-1,int(xy(1,ij)+1)))\n        j = max(1,min(ny-1,int(xy(2,ij)+1)))\n        wx = dble(i+1) - (xy(1,ij)+1)\n        wy = dble(j+1) - (xy(2,ij)+1)\n        w11 = wx*wy\n        w21 = (1.d0-wx)*wy\n        w12 = wx*(1.d0-wy)\n        w22 = (1.d0-wx)* (1.d0-wy)\n        do k = 1,nz\n            v2d(ij,k) = w11*v3d(i,j,k) + w21*v3d(i+1,j,k) + &\n            w12*v3d(i,j+1,k) + w22*v3d(i+1,j+1,k)\n        end do\n    end do\n    !$omp end parallel do\n\n    return\n\nend subroutine dinterp2dxy\n"}, {"instruction": "Create a Fortran subroutine named dinterp1d that performs one-dimensional interpolation. It takes 6 input parameters of types: integer, integer, real(kind=8) array of size nz_in, real(kind=8) array of size nz_in, real(kind=8) array of size nz_out, and real(kind=8). It returns 1 output parameter of type real(kind=8) array of size nz_out.", "input": "", "output": "subroutine dinterp1d(v_in, v_out, z_in, z_out, vmsg, nz_in, nz_out)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: v_out\n\n    integer, intent(in) :: nz_in, nz_out\n    real(kind=8), dimension(nz_in), intent(in) :: v_in, z_in\n    real(kind=8), dimension(nz_out), intent(in) :: z_out\n    real(kind=8), dimension(nz_out), intent(out) :: v_out\n    real(kind=8), intent(in) :: vmsg\n\n! nclend\n\n    integer :: kp,k,im,ip\n    logical :: interp\n    real(kind=8) :: height,w1,w2\n\n    ! does vertical coordinate increase of decrease with increasing k?\n    ! set offset appropriately\n\n    ip = 0\n    im = 1\n    if (z_in(1) .gt. z_in(nz_in)) then\n        ip = 1\n        im = 0\n    end if\n\n    !$omp parallel do private(kp, k, interp, height, w1, w2) &\n    !$omp firstprivate(ip, im) schedule(runtime)\n    do k = 1,nz_out\n        v_out(k) = vmsg\n\n        interp = .false.\n        kp = nz_in\n        height = z_out(k)\n\n        do while ((.not. interp) .and. (kp .ge. 2))\n            if (((z_in(kp-im) .le. height) .and. (z_in(kp-ip) .gt. height))) then\n                w2 = (height - z_in(kp-im))/(z_in(kp-ip) - z_in(kp-im))\n                w1 = 1.d0 - w2\n                v_out(k) = w1*v_in(kp-im) + w2*v_in(kp-ip)\n                interp = .true.\n            end if\n            kp = kp - 1\n        end do\n    end do\n    !$omp end parallel do\n\n    return\n\nend subroutine dinterp1d\n"}, {"instruction": "Create a Fortran subroutine named determinant that calculates the determinant of a 3x3 matrix. The subroutine takes 1 input parameter of type real(16), dimension(3, 3) and outputs 1 parameter of type real(16).", "input": "", "output": "subroutine determinant(face, deter_value)\n    real(16), dimension(3, 3), intent(in) :: face\n    real(16), intent(out) :: deter_value\n    deter_value=(face(1,1)*face(2,2)*face(3,3)+face(1,2)*face(2,3)*face(3,1)&\n            +face(1,3)*face(2,1)*face(3,2)&\n            -face(3,1)*face(2,2)*face(1,3)-face(2,1)*face(1,2)*face(3,3)&\n            -face(1,1)*face(3,2)*face(2,3))\n    return\nend subroutine determinant\n"}, {"instruction": "Create a Fortran subroutine named ricker_t that generates a Ricker wavelet in the time domain. The subroutine takes two input parameters of type real, f0 and dt, and one output parameter of type real, s.", "input": "", "output": "subroutine ricker_t(s, f0, dt)  ! ricker in time domain, peak freq f0 hz\n! fill the time trace s w/ ricker wavelet from time 0+\nreal, intent(out) :: s(:)\nreal, intent(in)  :: f0, dt\ninteger :: np, i, l\nreal, allocatable :: t(:), env(:)\nreal  ::  sm_ric,  sm_env\nnp = min(ceiling(1.23456789/(f0*dt)),  (size(s)-1)/2)\nl  = 2*np+1 \nallocate(t(l), env(l))\nt  = (/ (i, i=-np, np) /)\nt  = (t * (pi *f0 *dt) )**2\nenv     = exp(-t)   ! envelope\nsm_env  = sum(env)\ns(1:l)  = (1. - 2.*t)*env\nsm_ric  = sum(s(1:l))\ns(1:l)  = s(1:l) - sm_ric/sm_env * env ! 0-mean\ns(l+1:) = 0.\n#ifdef debug\n  write(*,*) 'lengths of source & ricker:', size(s), l\n#endif\ndeallocate(t, env)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_binfile_b2 to read binary data from a file. The subroutine takes 2 input parameters: filename of type character(len=*), and recn of type integer, which is optional. It has 1 output parameter, data, of type integer(1) array. The subroutine uses direct access to open, read, and close the file, and handles the case when the optional recn is not present. If an error occurs during reading, it stops and outputs a specific error message.", "input": "", "output": "subroutine read_binfile_b2(filename, data, recn)\ncharacter(len=*), intent(in) :: filename\ninteger(1), intent(out) :: data(:,:)\ninteger, intent(in), optional :: recn\ninteger  :: n\nn = 1\nif(present(recn))  n = recn\nif (n<=0)    n = 1\nopen(10, file=filename, access='direct', err=20, recl=size(data))\nread(10, rec=1) data\nclose(10)\nreturn\n20 stop '  read error read_binfile_b2'\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_binfile_i3 to read integer data from a binary file. The subroutine takes 1 input parameter of type character(len=*) for the filename and 1 output parameter of type integer array. Use the \"intent\" attribute to specify the input and output parameters. Inside the subroutine, open the file using direct access mode, read the data into the integer array, and then close the file. If there is a read error, stop the program with an error message.", "input": "", "output": "subroutine read_binfile_i3(filename, data)\ncharacter(len=*), intent(in) :: filename\ninteger, intent(out) :: data(:,:,:)\nopen(10, file=filename, access='direct', err=20, recl=i4*size(data))\nread(10, rec=1) data\nclose(10)\nreturn\n20 stop '  read error read_binfile_i3'\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_tex_i1 to read integer data from a formatted file and store it in an allocatable integer array. The subroutine takes 2 input parameters: a character array with unspecified length (fname) and an optional integer (n). It returns 1 output parameter, an allocatable integer array (a). If the optional parameter n is provided, the subroutine reads n rows from the file; otherwise, it determines the number of rows in the file.", "input": "", "output": "subroutine read_tex_i1(a, fname, n)\n integer,  allocatable,intent(out) :: a(:)\n character(len=*),     intent(in)  :: fname\n integer,  optional,   intent(in)  :: n\n integer               :: i, nr\n \n open(10, file=fname, form='formatted')\n ! determine # rows\n if (present(n)) then\n   nr = n\n else\n\t nr = 0\n\t do \n\t  read(10,*,end=99) i\n\t  nr = nr + 1\n\t end do\n\t 99  continue\n\t rewind(10)\n end if\n \n if (allocated(a)) then\n   i = size(a)\n   if (i /= nr) then\n     deallocate(a)\n\t allocate(a(nr))\n   end if\n else\n   allocate(a(nr))\n end if\n \n ! read in to a\n do i = 1, nr\n   read(10,*) a(i)\n end do\n close(10)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_fs_pendula to calculate the force on a pendulum. The subroutine takes 8 input parameters of types integer, integer, integer, real array, real, real array, real array, and real array. It also has 1 output parameter of type real array.", "input": "", "output": "    subroutine calc_fs_pendula(bc_flag, lowerbound, upperbound, u, g, m, k, l, fs)\n\n    implicit none\n\n    !! data dictionary\n    integer, intent(in) :: bc_flag\n    integer, intent(in) :: lowerbound\n    integer, intent(in) :: upperbound\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in) :: g\n    real, intent(in), dimension(2) :: m\n    real, intent(in), dimension(1) :: k\n    real, intent(in), dimension(1) :: l\n    real, intent(out), dimension(1) :: fs\n\n    if (bc_flag == 100) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) - k(1)*u(-1) + 2*k(1)*u(0) - k(1)*u(1)) \n    else if (bc_flag == 110) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) + k(1)*(u(0) - u(1)))\n    else if (bc_flag == 120) then\n        fs(1) = (g*l(1)*m(2)*sin(u(0)) - k(1)*u(-1) + k(1)*u(0))\n    else if (bc_flag == 121) then\n        fs(1) = 0.\n    end if\n\n    end subroutine calc_fs_pendula\n"}, {"instruction": "Create a Fortran subroutine named calc_fs_phi4 to compute the value of fs based on different boundary conditions. The subroutine should have 5 input parameters of types integer, integer, integer, real array, and real array, and 1 output parameter of type real array.", "input": "", "output": "    subroutine calc_fs_phi4(bc_flag, lowerbound, upperbound, u, k, fs)\n\n    implicit none\n\n    ! data dictionary:\n    integer, intent(in) :: bc_flag ! boundary condition\n    integer, intent(in) :: lowerbound !\n    integer, intent(in) :: upperbound !\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in), dimension(5) :: k !\n    real, intent(out), dimension(1) :: fs !\n\n    ! calculation for fs\n    if (bc_flag == 100) then ! baseline, periodic\n        fs(1) = k(2) - k(1)*u(-1) + (2*k(1) + 2*k(3))*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3 - k(1)*u(1)\n    else if (bc_flag == 110) then ! baseline, left end free\n        fs(1) = k(2) + k(1)*u(0) + 2*k(3)*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3 - k(1)*u(1) \n    else if (bc_flag == 120) then ! baseline, right end free\n        fs(1) = k(2) - k(1)*u(-1) + (k(1) + 2*k(3))*u(0) + 3*k(4)*u(0)**2 + 4*k(5)*u(0)**3\n    end if\n\n    end subroutine calc_fs_phi4\n"}, {"instruction": "Create a Fortran subroutine named calc_kthat_phi4 to calculate the kthat values for a specific physics problem. The subroutine takes 6 input parameters of types integer, integer, integer, real array, real array, and real scalar, and 1 output parameter of type real array. This subroutine computes the kthat values based on the provided boundary conditions, input parameters, and calculations using the given physics model.", "input": "", "output": "    subroutine calc_kthat_phi4(bc_flag, lowerbound, upperbound, u, k, a, kthat)\n\n    implicit none\n\n    ! data dictionary:\n    integer, intent(in) :: bc_flag ! boundary condition\n    integer, intent(in) :: lowerbound !\n    integer, intent(in) :: upperbound !\n    real, intent(in), dimension(lowerbound:upperbound) :: u !\n    real, intent(in), dimension(5) :: k !\n    real, intent(in), dimension(1) :: a\n    real, intent(out), dimension(3) :: kthat !\n\n    kthat = 0.\n    if (bc_flag == 100) then ! baseline, periodic\n        kthat(1) = -k(1)\n        kthat(2) = 2*k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = -k(1)\n    else if (bc_flag == 110) then ! baseline, left end free\n        kthat(1) = 0.\n        kthat(2) = k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = -k(1)\n    else if (bc_flag == 120) then ! baseline, right end free\n        kthat(1) = -k(1)\n        kthat(2) = k(1) + 2*k(3) + 6*k(4)*u(0) + 12*k(5)*u(0)**2\n        kthat(3) = 0.\n    end if\n\n    kthat(2) = kthat(2) + a(1)\n\n    end subroutine calc_kthat_phi4\n"}, {"instruction": "Write a Fortran subroutine named get_opacities that computes the opacities kp and kr based on the input parameters. The subroutine takes 6 input parameters of types logical, logical, double precision, double precision, double precision, and double precision. It also has 2 output parameters of type double precision. The subroutine calculates the opacities based on the values of get_planck_mean and get_rosseland_mean flags and the input values of rho, temp, rhoye, and nu.", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    double precision, parameter :: ksc = 0.4d0 ! thomson scattering \n    double precision, parameter :: fac = 1.d-4 ! planck mean is assumed to be fac*ksc\n\n    if (get_planck_mean) then\n       kp = rhoye*ksc * fac\n    end if\n\n    if (get_rosseland_mean) then\n       kr = rhoye*ksc\n    end if\n\n  end subroutine get_opacities\n"}, {"instruction": "Create a Fortran subroutine named \"lennardjones\" to calculate the Lennard-Jones potential between two particles. The subroutine should take 1 input parameter of type real and provide 1 output parameter of type real. The input parameter represents the distance between the particles, and the output parameter represents the computed potential energy.", "input": "", "output": "  subroutine lennardjones(r,pot)\n\n    !---- compute lj potential:\n    ! \n    !                   r(eq)^p     p   r(eq)^q\n    !     pot = epl ( ---------- - --- ---------- )\n    !                  r(m,n)^p     q   r(m,n)^q\n    !     where\n    !          epl    : strength of lj potential\n    !          r_eq   : equilibrium center-to-center distance\n    !          r(m,n) : center distance between m and n\n    !          r_cof  : cut-off center-to-center distance\n\n    integer p,q\n    real epl, pq, radius,r_eq,r_mn,r_cof,pot_cof\n    real, intent(in) :: r\n    real, intent(out) :: pot\n\n\n    p = 18\n    q = 6\n    epl = 3.\n    pq = p*1./(q*1.)\n\n    radius = lz/6.\n    r_eq = 2.*radius + 3.5*dz\n    r_mn = 2.*radius + r\n    r_cof = 2.*radius + 6.*dz\n\n    pot_cof = epl*( r_eq**p/r_cof**p - pq* r_eq**q/r_cof**q) !potential at cut-off\n    pot = epl*( r_eq**p/r_mn**p - pq* r_eq**q/r_mn**q) - pot_cof !make potential zero at cut-off\n    if (r_mn .gt. r_cof) pot = 0. !make potential zero after cut-off\n\n\n    return\n  end subroutine lennardjones\n"}, {"instruction": "Write a Fortran subroutine named version_parse to extract the major, minor, and patch numbers from a version string with the format \"i.j.k\". The subroutine should have 1 input parameter with the test_data type ['character(*)'], and 4 output parameters with the test_data type ['integer', 'integer', 'integer', 'integer'].", "input": "", "output": "  subroutine version_parse(str, major, minor, patch, ierr)\n    !--------------------------------------------------------------------------\n    !   \n    ! determine the major, minor and patch numbers from \n    ! a version string with the fmt \"i.j.k\"\n    ! \n    ! the ierr variable assumes the following values\n    !\n    ! ierr < 0     emtpy string\n    ! ierr = 0     no problem\n    ! ierr > 0     fatal error\n    !   \n    implicit none\n    character(*),     intent(in)    :: str \n    integer,          intent(out)   :: major, minor, patch, ierr\n    !\n    integer       :: i1, i2, length\n    integer       :: ierrtot\n    character(10) :: num(3)\n\n    !\n    major = 0\n    minor = 0\n    patch = 0\n\n    length = len_trim( str )\n    !\n    if ( length == 0 ) then\n       !\n       ierr = -1\n       return\n       !\n    endif\n\n    i1 = scan( str, \".\")\n    i2 = scan( str, \".\", back=.true.)\n    !\n    if ( i1 == 0 .or. i2 == 0 .or. i1 == i2 ) then\n       !\n       ierr = 1\n       return\n       !\n    endif\n    !\n    num(1) = str(    1 : i1-1 )\n    num(2) = str( i1+1 : i2-1 )\n    num(3) = str( i2+1 : )\n    !\n    ierrtot = 0\n    !\n    read( num(1), *, iostat=ierr ) major\n    if (ierr/=0) return\n    !\n    read( num(2), *, iostat=ierr ) minor\n    if (ierr/=0) return\n    !\n    read( num(3), *, iostat=ierr ) patch\n    if (ierr/=0) return\n    !\n  end subroutine version_parse\n"}, {"instruction": "Create a Fortran subroutine named print_occurences to calculate the occurrences of each integer in a 2D array of nuclear charges. The subroutine takes 1 input parameter of type integer, dimension(:,:) and produces 1 output parameter of type integer, dimension(120).", "input": "", "output": "subroutine print_occurences(nuclear_charges, occurences)\n\n    implicit none\n\n\n    integer, dimension(:,:), intent(in) :: nuclear_charges\n\n\n    integer, dimension(120), intent(out) :: occurences\n    integer, dimension(120) :: occurences_local\n\n    integer :: a, i\n\n    integer :: nm\n    integer :: na\n\n    integer :: q\n\n    occurences(:) = 0\n\n    na = size(nuclear_charges, dim=1)\n    nm = size(nuclear_charges, dim=2)\n\n    ! write (*,*) nm\n\n    do a = 1, nm\n\n        occurences_local = 0\n        do i = 1, na\n\n            q = nuclear_charges(i,a)\n\n            if (q < 1) then\n                exit\n            endif\n\n            occurences_local(q) = occurences_local(q) + 1\n\n        enddo\n        do i = 1, size(occurences)\n            occurences(i) = max(occurences(i), occurences_local(i))\n        enddo\n\n    enddo\n\n    ! do i = 1, size(occurences) \n\n    !     if (occurences(i) > 0) write (*,*) i, occurences(i)\n\n    ! enddo\n\n\n\nend subroutine print_occurences \n"}, {"instruction": "Create a Fortran subroutine named weight. It takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8). The subroutine computes the value of the standard normal probability density function at the input value x and assigns the result to the output parameter p.", "input": "", "output": "subroutine weight(x,p)\n    implicit none\n    real(8), parameter :: pi = acos(-1.d0)\n    real(8), intent(in) :: x\n    real(8), intent(out) :: p\n\n    p = exp(-x**2 / 2.d0) / sqrt(2.d0 * pi)\nend subroutine weight\n"}, {"instruction": "Create a Fortran subroutine named convertnmltojson that takes a character string filename as input and produces a dynamic character string output as output. The subroutine reads the namelist file specified by the filename and generates a JSON representation in the output string.", "input": "", "output": "  subroutine convertnmltojson(filename, output)\n    !> the name of the namelist file to read in.\n    character(len=*), intent(in) :: filename\n    !> the string representation of the json.\n    character(len=:), allocatable, intent(out) :: output\n\n    allocate(character(len=12) :: output)\n    output = '{\"value\": 3.0}'\n  end subroutine convertnmltojson\n"}, {"instruction": "Create a Fortran subroutine named bessj to calculate the regular Bessel functions of the first kind and their derivatives. The subroutine should take 2 input parameters of type real(8) and integer, and return 2 output parameters of type real(8). The subroutine uses Steed's method to compute the Bessel functions and their derivatives for positive x and for 1 \u2264 l \u2264 nl+1.", "input": "", "output": "subroutine bessj(x,nl,rj,rjp)\n  !returns the regular bessel functions of first kind\n  !$\\texttt{rj(l)}=j_{l-\\frac{1}{2}}$ and their derivatives\n  !$\\texttt{rjp(l)}=j'_{l-\\frac{1}{2}}$, for positive \\texttt{x} and for\n  !$1\\le l \\le nl+1$, using steed's method.\n  implicit none\n  real(8), intent(in) :: x\n  integer, intent(in) :: nl\n  real(8), intent(out) :: rj(*)            \n  real(8), intent(out) :: rjp(*)            \n  !    \n  integer :: i, isign, l \n  real(8) :: xnu, b, c, d, del, f, fact, gam, h, p, q, rjl, rjl1, rjmu, rjp1, rjpl, rjtemp, w, xi, xi2, xmu, xmu2\n  integer, parameter :: maxit=10000\n  real(8), parameter :: eps=1.e-16\n  real(8), parameter :: fpmin=1.e-30\n  real(8), parameter :: pi=3.141592653589793d+0\n\n  if(x.le.0..or.nl.lt.0) stop 'bad arguments in bessj'\n  xnu=dble(nl)+0.5d0\n  xmu=0.5d0\n  xmu2=xmu*xmu\n  xi=1.d0/x\n  xi2=2.d0*xi\n  !     the wronskian\n  w=xi2/pi\n  !     evaluate the continued fraction expansion for j'_(nl-1/2)/j_(nl-1/2)\n  !     by the modified lentz's method. isign keeps track of sign changes in\n  !     the denominator\n  isign=1\n  h=xnu*xi\n  if(h.lt.fpmin)h=fpmin\n  b=xi2*xnu\n  d=0.d0\n  c=h\n  do i=1,maxit\n     b=b+xi2\n     d=b-d\n     if(abs(d).lt.fpmin) d=fpmin\n     c=b-1.d0/c\n     if(abs(c).lt.fpmin) c=fpmin\n     d=1.d0/d\n     del=c*d\n     h=del*h\n     if(d.lt.0.d0) isign=-isign\n     if(abs(del-1.d0).lt.eps) goto 1\n  enddo\n!11   continue\n  stop 'x too large in bessjy; try asymptotic expansion'\n1 continue\n  !     initialize j and j' for downward recurrence\n  rjl=isign*fpmin\n  rjpl=h*rjl\n  !     store values for later rescaling      \n  rjl1=rjl\n  rjp1=rjpl\n  !     downward recurrence (unnormalized)\n  fact=xnu*xi\n  do l=nl,0,-1\n     rjtemp=fact*rjl+rjpl\n     fact=fact-xi\n     rjpl=fact*rjtemp-rjl\n     rjl=rjtemp\n  enddo\n  if(rjl.eq.0.d0)rjl=eps\n  f=rjpl/rjl\n  !     equation 6.7.3 numerical recipies in fortran\n  p=-.5d0*xi\n  q=1.d0\n  !     equation 6.7.6 numerical recipies in fortran\n  gam=(p-f)/q\n  !     equation 6.7.7 numerical recipies in fortran\n  rjmu=sqrt(w/((p-f)*gam+q))\n  rjmu=sign(rjmu,rjl)\n  !     scale original j and j'\n  fact=rjmu/rjl\n  rj(nl+1)=rjl1*fact\n  rjp(nl+1)=rjp1*fact\n  fact=xnu*xi\n  !     downward recurence\n  do l=nl,1,-1\n     rj(l)=fact*rj(l+1)+rjp(l+1)\n     fact=fact-xi\n     rjp(l)=fact*rj(l)-rj(l+1)\n  enddo ! l\nend subroutine bessj\n"}, {"instruction": "Create a Fortran subroutine named get_bottom_data to extract data from the lowest model level. The subroutine takes 3 input parameters of type real, dimension(:,:,:) named a and b, and an optional input parameter of type integer, dimension(:,:). It returns 2 output parameters of type real, dimension(:,:) named a_bot and b_bot. If the optional parameter k_bot is provided, it is used to determine the lowest model level; otherwise, the default lowest level is used.", "input": "", "output": " subroutine get_bottom_data ( a, b, a_bot, b_bot, k_bot ) \n\n!-------- extract data from the lowest model level ---------\n! a, b     = 3-d data fields\n! a_bot,\n!    b_bot = 2-d data fields containing data at lowest level\n! k_bot    = index of lowest model level (optional)\n!-----------------------------------------------------------\n\n  real   , intent(in) , dimension(:,:,:) :: a    , b\n  real   , intent(out), dimension(:,:)   :: a_bot, b_bot\n  integer, intent(in) , dimension(:,:), optional :: k_bot\n\n! returns the lowest level data (a_bot,b_bot) from 3d fields (a,b)\n\n  integer :: i, j, kb, kb_min\n    \n                      kb_min = size(a,3)\n  if (present(k_bot)) kb_min = minval (k_bot) \n\n  if ( kb_min == size(a,3) ) then\n          a_bot = a(:,:,kb_min)\n          b_bot = b(:,:,kb_min)\n  else\n       do j = 1, size(a,2)\n       do i = 1, size(a,1)\n          kb = k_bot(i,j)\n          a_bot(i,j) = a(i,j,kb)\n          b_bot(i,j) = b(i,j,kb)\n       enddo   \n       enddo   \n  endif\n\n end subroutine get_bottom_data\n"}, {"instruction": "Create a Fortran subroutine named create_output_filename that takes a character input parameter l2bname and returns a character output parameter ofname. The subroutine replaces the long extension in the l2b filename with 'obs_seq_out'.", "input": "", "output": "subroutine create_output_filename(l2bname, ofname)\n!-------------------------------------------------\n! the l2b filenames have a very long extension that\n! records when the data was published - not very interesting\n! for our purposes. replace with something dart-y.\ncharacter(len=*), intent(in)  :: l2bname\ncharacter(len=*), intent(out) :: ofname\n\ninteger :: i, strlen, extstart\n\nstrlen = len_trim(l2bname)\n\ndotloop : do i = strlen,1,-1\n   if (l2bname(i:i) == '.' ) then\n      extstart = i\n      exit dotloop\n   endif\nenddo dotloop\n\nofname = l2bname(1:extstart)//'obs_seq_out'\n\nend subroutine create_output_filename\n"}, {"instruction": "Write a Fortran subroutine named toy_vals to perform calculations related to toy values. The subroutine takes 3 input parameters of type real(kind=8), real(kind=8) array, and real(kind=8) array, and returns 2 output parameters of type real(kind=8) array and real(kind=8) array, all of size equal to the size of the array r.", "input": "", "output": "    subroutine toy_vals(a,mu,r,n,l)\n      real(kind=8), intent(in) :: a\n      real(kind=8), dimension(:), intent(in) :: r,mu\n      real(kind=8), dimension(size(r)), intent(out) :: n,l\n      real(kind=8), dimension(size(r)) :: rcyl,z,dist\n      real(kind=8) :: q\n      q=0.5\n      rcyl = r*sqrt(1.-mu**2.)\n      l=toy_l0/(1.+rcyl)*rcyl**(1.+q)\n      z=toy_h*mu\n!      l=0.; z=0.\n      dist=((r/10.)**2.+z**2.)\n      where(dist.lt.20.)\n         n=toy_n0*exp(-dist/2.)\n      elsewhere\n         n=0.\n      endwhere\n!      toy_omega = 1./(toy_r**(3./2.)+toy_a)\n     end subroutine toy_vals\n"}, {"instruction": "Create a Fortran subroutine named \"enexpr\" with 1 input parameter of type \"character (len = 6)\" to represent a term, and 1 output parameter of type \"logical\" to indicate if the operation is done.", "input": "", "output": "        subroutine enexpr (term, done)\n        integer nod, nwfd\n        parameter (nod = 220)\n        parameter (nwfd = 20)\n        character (len = 6), intent(in) :: term\n        logical, intent(out) :: done\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named search to assign a value to the output parameter nj of type integer. The subroutine takes one input parameter i of type integer.", "input": "", "output": "        subroutine search (nj, i)\n        integer nodi, nwfd\n        parameter (nod = 220)\n        parameter (nwfd = 20)\n        integer, intent(out) :: nj\n        integer, intent(in) :: i\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_particle_header to read the header information from a particle file. The subroutine takes 1 input parameter of type character(len=*) for the filename, and has 3 output parameters of type integer for nparts, ndim, and tmp_unit. Inside the subroutine, open the file specified by the filename, read the number of dimensions (ndim), the number of particles (nparts), and assign a new unit number to tmp_unit for reading the file.", "input": "", "output": "  subroutine read_particle_header (filename, ndim, nparts, tmp_unit)\n    character(len=*), intent(in) :: filename\n    integer, intent(out)         :: nparts, ndim, tmp_unit\n    open(newunit = tmp_unit, file=filename, status='old', form='unformatted')\n    read(tmp_unit) !ncpu\n    read(tmp_unit) ndim\n    read(tmp_unit) nparts\n  end subroutine read_particle_header\n"}, {"instruction": "Create a Fortran subroutine named read_particle_data to read particle data from a file and store it in the specified variables. The subroutine has 3 input parameters of type integer, and 6 output parameters consisting of arrays of various dimensions and data types. The input parameters are ndim, nparts, and tmp_unit, all of type integer. The output parameters are pos, vel, nstar, ids, m, and birth_date, with their respective data types and dimensions specified.", "input": "", "output": "  subroutine read_particle_data (ndim, nparts, tmp_unit, nstar, pos, vel, m, ids, birth_date)\n    integer, intent(in)                          :: ndim, nparts, tmp_unit\n    real(kind=8), dimension(ndim, nparts), intent(out) :: pos, vel\n    integer, intent(out)                         :: nstar\n    integer,      dimension(nparts), intent(out) :: ids\n    real(kind=8), dimension(nparts), intent(out) :: m\n    real(kind=4), dimension(nparts), intent(out) :: birth_date\n\n    real(kind=8), dimension(nparts) :: tmp\n\n    read(tmp_unit) ! ?\n    read(tmp_unit) nstar\n    read(tmp_unit) ! ?\n    read(tmp_unit) ! ?\n    read(tmp_unit) ! ?\n\n    read(tmp_unit) tmp\n    pos(1,:) = tmp\n    read(tmp_unit) tmp\n    pos(2,:) = tmp\n    read(tmp_unit) tmp\n    pos(3,:) = tmp\n    read(tmp_unit) tmp\n    vel(1,:) = tmp\n    read(tmp_unit) tmp\n    vel(2,:) = tmp\n    read(tmp_unit) tmp\n    vel(3,:) = tmp\n\n    read(tmp_unit) m\n\n    read(tmp_unit) ids\n\n    read(tmp_unit) birth_date\n    close(tmp_unit)\n  end subroutine read_particle_data\n"}, {"instruction": "Write a Fortran subroutine named read_list_header to read the header information from a file. The subroutine takes 1 input parameter of type character(len=*) and returns 3 output parameters of type integer.", "input": "", "output": "  subroutine read_list_header(filename, unit, lines, columns)\n    character(len=*), intent(in) :: filename\n    integer, intent(out)         :: unit, lines, columns\n\n    open(newunit=unit, file=filename, form='unformatted')\n    read(unit) lines, columns\n\n  end subroutine read_list_header\n"}, {"instruction": "Create a Fortran subroutine named \"rectangles\" that generates an array of real numbers representing the midpoints of rectangles. The subroutine should take 2 input arguments of type real * 8 and 1 output argument of type real * 8, dimension(:).", "input": "", "output": "  subroutine rectangles(x,x_min,dr)\n\t\timplicit none\n\t  real * 8, intent(out), dimension(:) :: x\n    real * 8, intent(in) :: dr,x_min\n    integer :: i1\n\t  do i1=1, size(x)\n      x(i1) = x_min + i1 * dr\n    end do\n\t  return\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"fmacat\" to perform matrix operations. The subroutine takes 1 input parameter of type real(iwp) and produces 1 output parameter of type real(iwp). The subroutine calculates the result by performing matrix multiplication and subtraction.", "input": "", "output": "subroutine fmacat(vmfl,acat)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::vmfl(:)\r\n real(iwp),intent(out)::acat(:,:)\r\n real(iwp)::temp(4,4),zero=0.0_iwp,pt5=0.5_iwp,one=1.0_iwp,three=3.0_iwp\r\n integer::i,j\r\n temp=zero\r\n temp(1,1)=one\r\n temp(1,2)=-pt5\r\n temp(1,4)=-pt5\r\n temp(2,1)=-pt5\r\n temp(2,2)=one\r\n temp(2,4)=-pt5\r\n temp(3,3)=three\r\n temp(4,1)=-pt5\r\n temp(4,2)=-pt5\r\n temp(4,4)=one\r\n do i=1,4\r\n   do j=1,4\r\n     acat(i,j)=vmfl(i)*vmfl(j)\r\n   end do\r\n end do\r\n acat=temp-acat\r\nreturn \r\nend subroutine fmacat\r\n"}, {"instruction": "Create a Fortran subroutine named autgetarg to retrieve a command-line argument based on the specified index. The subroutine takes 1 input argument of type integer and returns 1 output argument of type character with varying length.", "input": "", "output": "  subroutine autgetarg(number,value)\n    integer, intent(in) :: number\n    character(len=*), intent(out) :: value\n    call getarg(number,value)\n  end subroutine autgetarg\n"}, {"instruction": "Create a Fortran subroutine named coeffs that takes 7 input parameters of type double precision and value. The input parameters are mbh, mdot, r, alpha, rho, t, and h. It returns 2 output parameters of type double precision, a(3,1) and m(3,3).", "input": "", "output": "subroutine coeffs(mbh,mdot,r,alpha,rho,t,h,a,m) bind(c)\nimplicit none\ndouble precision, intent(in), value :: mbh,mdot,r,alpha,rho,t,h\ndouble precision, intent(out) :: a(3,1), m(3,3)\na(1, 1) = 902184.7d0*h**3*alpha*rho*sqrt(1/(mbh**2*r**3)) - 1.975034d+18 &\n      *mbh*mdot*(-1.732051d0*sqrt(1.0/r) + 1.0d0)\na(2, 1) = 2.081514d+14*h**4*alpha*rho**2*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0) - 0.0002268204d0*t**4\na(3, 1) = -5.154318d+9*h**2*rho*(1/(mbh**2*r**3))**1.0d0 + 2.521972d-15* &\n      t**4 + 1.650222d+8*t*rho\nm(1, 1) = 902184.7d0*h**3*alpha*sqrt(1/(mbh**2*r**3))\nm(2, 1) = 1.275968d+37*h**4*t**(-3.5d0)*alpha*rho**2*(1/(mbh**2*r**3))** &\n      1.5d0 + 4.163028d+14*h**4*alpha*rho*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0)\nm(3, 1) = -5.154318d+9*h**2*(1/(mbh**2*r**3))**1.0d0 + 1.650222d+8*t\nm(1, 2) = 0\nm(2, 2) = -4.465888d+37*h**4*t**(-4.5d0)*alpha*rho**3*(1/(mbh**2*r**3)) &\n      **1.5d0 - 0.0009072817d0*t**3\nm(3, 2) = 1.008789d-14*t**3 + 1.650222d+8*rho\nm(1, 3) = 2706554.0d0*h**2*alpha*rho*sqrt(1/(mbh**2*r**3))\nm(2, 3) = 8.326056d+14*h**3*alpha*rho**2*(1/(mbh**2*r**3))**1.5d0*( &\n      6.13d+22*t**(-3.5d0)*rho + 0.3379305d0)\nm(3, 3) = -1.030864d+10*h*rho*(1/(mbh**2*r**3))**1.0d0\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_data to read data from a file. The subroutine takes 2 input parameters of type character(*) and integer. The input parameters are file_name and how_many. The subroutine has 1 output parameter.", "input": "", "output": "    subroutine read_data(file_name, raw_data, how_many)\n        implicit none\n\n        character(*), intent(in) :: file_name\n        integer, intent(in) :: how_many\n        real, dimension(:), allocatable, &\n            intent(out) :: raw_data\n        integer :: i\n\n        allocate(raw_data(how_many))\n        open(1,file=file_name,status='old')\n        do i = 1, how_many\n            read(1,*) raw_data(i)\n        end do\n        close(1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named test_do_loop_variable_trip_count to calculate the sum of integers from 1 to a given number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine test_do_loop_variable_trip_count(ret, n)\n  integer, intent(out) :: ret\n  integer, intent(in) :: n\n  ret = 0\n  do i=1, n\n    ret = ret + i\n  end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_comment to read a file until it finds an uncommented line. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer, which is optional. The input parameter represents the file unit to be read. If present, the optional output parameter will store any error that occurs during reading. Any commented lines in the file, which are either blank or start with '#', will be skipped during the reading process.", "input": "", "output": "    subroutine read_comment(funit, ierr)\n      ! read file until it finds uncommented line\n      ! commented lines are blank (empty) lines or lines whose first non-blank character is '#'\n      integer, intent(in):: funit\n      integer, intent(out), optional:: ierr\n      character(len=1):: line\n\n      line = '#'\n\n      if (present(ierr)) then\n\n        ! read until finding uncommented line or error is raised\n        ierr = 0\n        do while (line=='#' .and. ierr==0)\n          read(unit=funit, fmt=*, iostat=ierr) line\n        end do\n\n        ! if no error raised, get back to the previous record (in that case, the previous line)\n        if (ierr==0) then\n          backspace(unit=funit)\n        end if\n\n      else\n\n        ! read until finding uncommented line\n        do while (line=='#')\n          read(unit=funit, fmt=*) line\n        end do\n\n        ! get back to the previous record (in that case, the previous line)\n        backspace(unit=funit)\n\n      end if\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sd_to_hms\" that takes two input parameters of type integer: \"sd_day\" and \"sd_sec\". It should have three output parameters of type integer: \"hms_hour\", \"hms_min\", and \"hms_sec\". The subroutine should calculate and convert the input values representing a duration in days and seconds to the equivalent duration in hours, minutes, and seconds.", "input": "", "output": " subroutine sd_to_hms(sd_day, sd_sec, hms_hour, hms_min, hms_sec)\n    integer, intent(in)  :: sd_day\n    integer, intent(in)  :: sd_sec\n    integer, intent(out) :: hms_hour\n    integer, intent(out) :: hms_min\n    integer, intent(out) :: hms_sec\n\n    integer :: residual_secs\n    \n    residual_secs = (sd_day * day_to_sec) + sd_sec\n\n    ! note integer division\n    hms_hour      = residual_secs / hr_to_sec\n    residual_secs = residual_secs - (hms_hour * hr_to_sec)\n    hms_min       = residual_secs / min_to_sec\n    residual_secs = residual_secs - (hms_min * min_to_sec)\n    hms_sec       = residual_secs\n  end subroutine sd_to_hms\n"}, {"instruction": "Create a Fortran subroutine named setwordpositions to find the positions of a specific character within a given string. The subroutine takes 2 input parameters of type character(len=*) and character, and 1 output parameter of type integer, dimension(:,:). The input parameters are ['bigstring', 'solo'], and the output parameter is ['positions'].", "input": "", "output": "subroutine setwordpositions( bigstring, solo, positions )\ncharacter(len=*),        intent(in)  :: bigstring\ncharacter,               intent(in)  :: solo\ninteger, dimension(:,:), intent(out) :: positions\n\ninteger :: nwords\ninteger :: i, iword\n\nnwords = size(positions,1)\n\niword = 1 \npositions(iword,1) = 1\n\n! first, simply count up the number of delimiters \ndo i = 1,len_trim(bigstring)\n   if (bigstring(i:i) == solo) then\n      positions(iword,2) = i-1\n      iword = iword + 1\n      positions(iword,1) = i+1\n   endif\nenddo\npositions(iword,2) = len_trim(bigstring)\n\nif ( 0 == 99 ) then  ! test. passes with gfortran compiler\n   write(*,*)'there are ',nwords,' in this line: '\n   write(*,*)'[',trim(bigstring),']'\n   do i = 1,nwords\n      write(*,*)'word ',i,' is [',bigstring(positions(i,1):positions(i,2)),']'\n   enddo\nendif\n\nend subroutine setwordpositions\n"}, {"instruction": "Write a Fortran subroutine named copy_vec to copy the elements of one real array to another real array. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone in the instructions.", "input": "", "output": "  subroutine copy_vec(to, from)\n    real, intent(out) :: to(:)\n    real, intent(in) :: from(size(to))\n\n    integer :: i\n    do i = 1, size(to)\n      to(i) = from(i)\n    end do\n  end subroutine copy_vec\n"}, {"instruction": "Create a Fortran subroutine named dboard to simulate dart throwing. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type double precision. The input parameter represents the number of darts thrown, and the output parameter holds the estimated value of \u03c0 based on the darts landing within a unit circle.", "input": "", "output": "subroutine dboard(darts, dartsscore)\n  integer, intent(in)                    :: darts\n  double precision, intent(out)          :: dartsscore\n  double precision                       :: x_coord, y_coord\n  integer                                :: score, n\n\nscore = 0\ndo n = 1, darts\n  call random_number(x_coord)\n  call random_number(y_coord)\n\n  if ((x_coord**2 + y_coord**2) <= 1.0d0) then\n  score = score + 1\n  end if\nend do\n\ndartsscore = 4.0d0*score/darts\n\nend subroutine dboard\n"}, {"instruction": "Create a Fortran subroutine named qc_tit to perform quality control on brightness temperatures. The subroutine takes 5 input parameters of type integer, integer, real, real, and real, and 1 output parameter of type real. The function calculates the difference between tbb15m and tbb and assigns the result to the output parameter tit.", "input": "", "output": "      subroutine qc_tit(nlongitude,nlatitude,tbb,tbb15m,tit,missing_r)\n   ! ------------qc: step 4 ----\n   ! 11.2(zhuge and zou, jamc, 2016) for ahi chan14\n   ! cirrus water vapor test for ahi using ch14, ch14min before\n   ! ch12, ch12 for agri\n   implicit none\n    integer, intent(in):: nlongitude,nlatitude\n   real, intent(in) :: tbb(nlongitude,nlatitude)\n   real, intent(in) :: tbb15m(nlongitude,nlatitude)\n   real, intent(in) :: missing_r\n   real, intent(out) :: tit(nlongitude,nlatitude)\n   integer :: nstar, nend\n   integer :: i, j, ij, m \n\n   tit=tbb15m-tbb\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"areacal\" to calculate the area of a polygon given the vertices' coordinates (xc, yc). Define 2 input parameters of type real(8) for xc and yc, and 1 output parameter of type real(8) for the area.", "input": "", "output": " subroutine areacal(xc,yc,area)   \n  !area calculation of a polygon\n  !with given vextices (xc,yc)\n  real(8),intent(in) ::xc(:),yc(:)\n  real(8),intent(out)::area\n  real(8)::xvec(2),yvec(2)\n  integer(4)::npol,k\n  npol = size(xc)\n  area = 0\n  xvec(1)=xc(2)-xc(1)\n  yvec(1)=yc(2)-yc(1)\n  do k=3,npol\n    xvec(2) = xc(k)-xc(1)\n    yvec(2) = yc(k)-yc(1)\n    area = area+0.5*abs( xvec(1)*yvec(2)-xvec(2)*yvec(1))\n    xvec(1)=xvec(2)\n    yvec(1)=yvec(2)\n  enddo\n end subroutine\n"}, {"instruction": "Write a Fortran subroutine named add1 that takes two integer input parameters and one integer output parameter. The input parameters are of type integer and are marked with \"intent(in)\" while the output parameter is of type integer and is marked with \"intent(out)\". The subroutine computes the sum of the two input integers and assigns the result to the output parameter.", "input": "", "output": "subroutine add1(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + y\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add2 to calculate the value of z using the formula z = x + 2 * y. The subroutine should have 2 input parameters of type integer and intent(in), and 1 output parameter of type integer and intent(out). The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine add2(x, y, z)\n  integer, intent(in) :: x, y\n  integer, intent(out) :: z\n  z = x + 2 * y\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named random_int that generates a random integer between 0 and n-1. The number of input parameters is 1, with the test_data type ['integer'], and the number of output parameters is 1, with the test_data type ['integer']. Use the imperative tone to specify these requirements.", "input": "", "output": "subroutine random_int(n,choice)\nimplicit none\ninteger, intent(in) :: n\ninteger, intent(out) :: choice\n\nreal*8 r\ncall random_number(r)\nchoice = floor(n*r)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named msd to compute the mean squared displacement (msd) of a trajectory. The subroutine takes 5 input parameters of type real*8, dimension(0:2,0:runs-1,0:n-1), integer, integer, integer, and integer, and 1 output parameter of type real*8, dimension(0:2, 0:window). The subroutine uses imperative tone to compute and accumulate the msd by iterating through the trajectory and normalizes the result by the number of counts.", "input": "", "output": "subroutine msd(traj,runs,n,rsq,window,every)\nimplicit none\nreal*8, intent(in), dimension(0:2,0:runs-1,0:n-1) :: traj\ninteger, intent(in) :: runs,n\nreal*8, intent(out), dimension(0:2, 0:window) :: rsq\ninteger, intent(in) :: window,every\n\n! internal variables for computing and accumulating the msd\nreal*8, dimension(0:2) :: r0,dr\ninteger i,t0,dt,ax\ninteger, dimension(0:window) :: counts\n\n! compute msd by iterating through trajectory\nrsq = 0.\ncounts = 0\ndo i = 0,n-1\n    do t0 = 0,runs-2,every\n        r0 = traj(:,t0,i)\n        do dt = 1,min(window,runs-1-t0)\n            dr = traj(:,t0+dt,i) - r0\n            do ax = 0,2\n                rsq(ax,dt) = rsq(ax,dt) + dr(ax)*dr(ax)\n            enddo\n            counts(dt) = counts(dt) + 1\n        enddo\n    enddo\nenddo\n\n! normalize by number of counts\ndo t0 = 0,window\n    if (counts(t0) > 0) then\n        rsq(:,t0) = rsq(:,t0) / counts(t0)\n    endif\nenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named msd_binned to calculate the mean squared displacement (MSD) for binned trajectory data. The subroutine takes 9 input parameters of types ['real*8, dimension(0:2,0:runs-1,0:n-1)', 'integer', 'integer', 'integer', 'integer', 'real*8', 'real*8', 'integer', 'integer'], and has 1 output parameter of type ['real*8, dimension(0:2,0:window,0:bins-1)'].", "input": "", "output": "subroutine msd_binned(traj,runs,n,axis,bins,lo,hi,rsq,window,every)\nimplicit none\nreal*8, intent(in), dimension(0:2,0:runs-1,0:n-1) :: traj\ninteger, intent(in) :: runs,n,axis,bins\nreal*8, intent(in) :: lo,hi\nreal*8, intent(out), dimension(0:2,0:window,0:bins-1) :: rsq\ninteger, intent(in) :: window,every\n\n! internal variables for computing and accumulating the msd\nreal*8 inv_bin_width\ninteger bin0\nreal*8, dimension(0:2) :: r0,dr\ninteger i,t0,dt,ax\ninteger, dimension(0:window,0:bins-1) :: counts\n\n! compute msd by iterating through trajectory\ninv_bin_width = bins/(hi-lo)\nrsq = 0.\ncounts = 0\ndo i = 0,n-1\n    do t0 = 0,runs-2,every\n        r0 = traj(:,t0,i)\n        bin0 = floor((r0(axis)-lo)*inv_bin_width)\n\n        ! silently ignore particles starting out of bin range\n        if (bin0 >= 0 .and. bin0 < bins) then\n            do dt = 1,min(window,runs-1-t0)\n                dr = traj(:,t0+dt,i) - r0\n                do ax = 0,2\n                    rsq(ax,dt,bin0) = rsq(ax,dt,bin0) + dr(ax)*dr(ax)\n                enddo\n                counts(dt,bin0) = counts(dt,bin0) + 1\n            enddo\n        endif\n    enddo\nenddo\n\n! normalize by number of counts\ndo i = 0,bins-1\n    do t0 = 0,window\n        if (counts(t0,i) > 0) then\n            rsq(:,t0,i) = rsq(:,t0,i) / counts(t0,i)\n        endif\n    enddo\nenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"csnow\" to calculate the snow conductivity based on the input snow density. The subroutine should have 1 input parameter of type real and intent(in), and 1 output parameter of type real and intent(out). The input parameter is dsnow of type real, and the output parameter is sncond of type real. The snow conductivity is computed using a mathematical formula and assigned to the output parameter sncond.", "input": "", "output": "      subroutine csnow (sncond,dsnow)\n      implicit none\n      real, intent(in) :: dsnow\n      real, intent(out):: sncond\n      real :: c\n      real, parameter :: unit = 0.11631\n      c = 0.328*10** (2.25* dsnow)\n      sncond = 2.0 * unit * c\n  end subroutine csnow\n"}, {"instruction": "Create a Fortran subroutine named snowz0 to calculate the effective roughness length for snow-covered surfaces. The subroutine takes 3 input parameters of real type ['real', 'real', 'real'] and returns 1 output parameter of real type ['real'].", "input": "", "output": "      subroutine snowz0 (sncovr,z0, z0brd, snowh)\n      implicit none\n      real, intent(in) :: sncovr, z0brd\n      real, intent(out) :: z0\n      real, parameter :: z0s=0.001\n      real, intent(in) :: snowh\n      real :: burial\n      real :: z0eff\n      burial = 7.0*z0brd - snowh\n      if(burial.le.0.0007) then\n        z0eff = z0s\n      else\n        z0eff = burial/7.0\n      endif\n      z0 = (1.- sncovr)* z0brd + sncovr * z0eff\n  end subroutine snowz0\n"}, {"instruction": "Write a Fortran subroutine named easter to calculate the date for Easter given a year. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine easter(year, dat)\nimplicit none\n\n! ident_29=\"@(#)m_time::easter(3f): calculate date for easter given a year\"\n\ninteger,intent(in)    :: year\ninteger,intent(out)   :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond\ninteger               :: day, month\ninteger               :: c, i, j, k, l, n\n\n   c = year / 100\n   n = year - 19 * ( year / 19 )\n   k = ( c - 17 ) / 25\n   i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15\n   i = i - 30 * ( i / 30 )\n   i = i - (i / 28) * (1 - (i / 28) * (29 / (i + 1 )) * ( (21 - n) / 11) )\n   j = year + year / 4 + i + 2 - c + c / 4\n   j = j - 7 * ( j / 7 )\n   l = i - j\n   month = 3 + ( l + 40 ) / 44\n   day = l + 28 - 31 * ( month / 4 )\n\n   ! fill out a date_and_time array\n   call date_and_time(values=dat)  ! get current year\n   dat=[year,month,day,dat(4),12,0,0,0]\n\nend subroutine easter\n"}, {"instruction": "Create a Fortran subroutine named saxpy that implements the SAXPY operation (single-precision A X Plus Y) for parallel computation. The subroutine takes 4 input parameters: an integer n, real numbers a, y, and an array x of size n. It returns a real array z of size n as the output. The subroutine uses OpenMP to parallelize the SAXPY computation.", "input": "", "output": "    subroutine saxpy(z, x, y, a, n)\n        use omp_lib\n        implicit none\n        integer             :: iter\n        integer, intent(in) :: n\n        real, intent(in)    :: a, y, x(n)\n        real, intent(out)   ::  z(n)\n\n        !$omp parallel do private(iter) ! in fortran, all index of interation (i.e. iter) are implicitly private by default\n            do iter = 1, n\n                z(iter) = a * x(iter) + y\n            end do\n        !$omp end parallel do\n    end subroutine saxpy\n"}, {"instruction": "Create a Fortran subroutine named \"cudaclaw5_setaux\" to initialize auxiliary arrays. The subroutine should accept 8 input parameters of types (integer, integer, integer, integer, real(kind=8), real(kind=8), real(kind=8), real(kind=8)) and 1 output parameter of type real(kind=8). This subroutine is called at the start of computation to set the values of the auxiliary arrays aux(1:maux, 1-mbc:mx+mbc, 1-mbc:my+mbc), where mbc, mx, my, and maux are integers, and xlower, ylower, dx, and dy are real numbers. The subroutine should be used to initialize the auxiliary arrays before calling qinit, and when amr is used, it should also be called every time a new grid patch is created. If the aux arrays are used by the riemann solver(s), ghost cell values may need to be set. The default version of this subroutine does nothing.", "input": "", "output": "subroutine cudaclaw5_setaux(mbc,mx,my,xlower,ylower,dx,dy,maux,aux)\n\n    ! called at start of computation before calling qinit, and\n    ! when amr is used, also called every time a new grid patch is created.\n    ! use to set auxiliary arrays aux(1:maux, 1-mbc:mx+mbc, 1-mbc:my+mbc).\n    ! note that ghost cell values may need to be set if the aux arrays\n    ! are used by the riemann solver(s).\n    !\n    ! this default version does nothing.\n\n    implicit none\n    integer, intent(in) :: mbc,mx,my,maux\n    real(kind=8), intent(in) :: xlower,ylower,dx,dy\n    real(kind=8), intent(out) ::  aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)\n\n  end subroutine cudaclaw5_setaux\n"}, {"instruction": "Write a Fortran subroutine named buffer_to_string that takes a single input parameter of type character(len=20) and returns a single output parameter of type character(len=:), which is allocatable. The subroutine trims and adjusts the input buffer to remove leading and trailing white spaces, assigning the result to the stringvalue variable. Additionally, it checks if the resulting string is empty and prints an error message if it is.", "input": "", "output": "      subroutine buffer_to_string(buffer, stringvalue)\r\n      implicit none\r\n      character(len=20)            , intent(in)  :: buffer\r\n      character(len=:), allocatable, intent(out) :: stringvalue\r\n\r\n      stringvalue = trim(adjustl(buffer))\r\n      \r\n      if (stringvalue.eq.'') then\r\n        write(*,*) 'error: command line argument empty.'\r\n        stop\r\n      endif\r\n      \r\n      end subroutine buffer_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named distribute_m_in_ncells to calculate all possible distributions of m particles in n different cells. Ensure that the value of m is less than or equal to 7. The subroutine takes 3 input parameters of type integer: m, n, and dmax. It also has 2 output parameters: d of type integer, and distribution of type integer array with dimensions (1:n, 1:dmax).", "input": "", "output": "   subroutine distribute_m_in_ncells(m,n,d,dmax,distribution)\n   !--------------------------------------------------------------------------------------------------------------------\n   ! returns all possible distributions of m particle in n different cells. in this version, the value of m must be m <= 7.\n   !--------------------------------------------------------------------------------------------------------------------\n      !\n      integer, intent(in)  :: m, n, dmax\n      integer, intent(out) :: d\n      integer, dimension(1:n,1:dmax), intent(out) :: distribution\n      !\n      integer :: i1, i2, i3, i4, i5, i6, i7\n      !\n      do  d = 1,dmax;   do  i1 = 1,n\n         distribution(i1,d) = 0\n      end do;   end do\n      !\n      d = 0\n      !\n      select case(m)\n      case(1)\n         do  i1 = 1,n\n            d = d + 1\n            distribution(i1,d) = 1\n         end do\n      case(2)\n         do  i1 = 1,n-1;   do  i2 = i1+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1\n         end do;   end do\n      case(3)\n         do  i1 = 1,n-2;   do  i2 = i1+1,n-1;   do  i3 = i2+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;   distribution(i3,d) = 1\n         end do;   end do;   end do\n      case(4)\n         do  i1 = 1,n-3;   do  i2 = i1+1,n-2;   do  i3 = i2+1,n-1;  do  i4 = i3+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n         end do;   end do;   end do;   end do\n      case(5)\n         do  i1 = 1,n-4;     do  i2 = i1+1,n-3;   do  i3 = i2+1,n-2;   do  i4 = i3+1,n-1;  do  i5 = i4+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1\n         end do;   end do;   end do;   end do;   end do\n      case(6)\n         do  i1 = 1,n-5;     do  i2 = i1+1,n-4;   do  i3 = i2+1,n-3;   do  i4 = i3+1,n-2;  do  i5 = i4+1,n-1\n         do  i6 = i5+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;  distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1;   distribution(i6,d) = 1\n         end do;   end do;   end do;   end do;   end do;   end do\n      case(7)\n         do  i1 = 1,n-6;     do  i2 = i1+1,n-5;   do  i3 = i2+1,n-4;   do  i4 = i3+1,n-3;  do  i5 = i4+1,n-2\n         do  i6 = i5+1,n-1;  do  i7 = i6+1,n\n            d = d + 1\n            distribution(i1,d) = 1;   distribution(i2,d) = 1;   distribution(i3,d) = 1;   distribution(i4,d) = 1\n            distribution(i5,d) = 1;   distribution(i6,d) = 1;   distribution(i7,d) = 1\n         end do;   end do;   end do;   end do;   end do;   end do;   end do\n      case default\n         print *, \"distribute_m_in_ncells(): program stop a.\"\n         stop\n      end select\n      !\n   end subroutine distribute_m_in_ncells\n"}, {"instruction": "Provide a Fortran subroutine named kopp1 to convert integer arrays into a character string. The subroutine takes 4 input parameters of type integer and produces 1 output parameter of type character.", "input": "", "output": "      subroutine kopp1(pos, rad2, j, s, antko)\n!...translated by pacific-sierra research 77to90  4.3e  14:44:54  12/27/06\n!...switches:\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(in) :: pos\n      character , intent(out) :: rad2*200\n      integer , intent(in) :: j(20)\n      integer , intent(in) :: s(20)\n      integer , intent(in) :: antko(20)\n!-----------------------------------------------\n!   l o c a l   v a r i a b l e s\n!-----------------------------------------------\n      integer :: i, k, tal\n!-----------------------------------------------\n      do i = 1, 200\n         rad2(i:i) = ' '\n      end do\n      do i = 1, pos\n         k = 9*i\n         if (j(i) == 2*(j(i)/2)) then\n            if (.not.(j(i)==0 .and. antko(i)==1)) then\n               if (s(i) /= (-1)) then\n                  rad2(k-4:k-4) = ';'\n                  rad2(k-5:k-5) = char(48 + s(i))\n               endif\n               tal = j(i)/20\n               if (tal /= 0) then\n!gg                  rad2(k:k) = char(48 + tal)\n                  rad2(k-1:k-1) = char(48+tal)\n               end if\n               tal = j(i)/2 - tal*10\n               rad2(k:k) = char(48 + tal)\n            endif\n         else\n            if (s(i) /= (-1)) then\n               rad2(k-4:k-4) = ';'\n               rad2(k-5:k-5) = char(48 + s(i))\n            endif\n            tal = j(i)/10\n            if (tal /= 0) rad2(k-3:k-3) = char(48 + tal)\n            tal = j(i) - tal*10\n            rad2(k-2:k-2) = char(48 + tal)\n            rad2(k-1:k) = '/2'\n         endif\n      end do\n      return\n      end subroutine kopp1\n"}, {"instruction": "Create a Fortran subroutine named eval3 to evaluate a third-order polynomial of the form: result = a + b*x + c*x**2 + d*x**3. The subroutine should have 1 input parameter of type real and 1 output parameter of type real.", "input": "", "output": "   subroutine eval3 ( x, result )\r\n   !\r\n   !     evaluates a third order polynomial of the form:\r\n   !        result = a + b*x + c*x**2 + d*x**3\r\n   !\r\n   ! declare calling arguments\r\n   real, intent(in) :: x\r\n   real, intent(out) :: result\r\n   \r\n   ! calculate result\r\n   result = a + b**x + c*x**2 + d*x**3 \r\n   \r\n   end subroutine eval3\r\n"}, {"instruction": "Write a Fortran subroutine named rotate_euler_3d to perform a 3D Euler rotation. The subroutine takes 6 input arguments of type double precision: alpha, beta, gamma, srcx, srcy, and srcz. It provides 3 output arguments of type double precision: destx, desty, and destz.", "input": "", "output": "subroutine rotate_euler_3d(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(alpha)*dsin(beta) + srcy*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = -(srcz*dcos(alpha)*dsin(beta)) + srcx*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) + srcy*dcos(gamma)*dsin(beta) + srcx*dsin(beta)*dsin(gamma)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rotate_euler_3d_inv to calculate the inverse rotation of a 3D point using Euler angles. The subroutine should have 6 input parameters of type double precision (alpha, beta, gamma, srcx, srcy, srcz) and 3 output parameters of type double precision (destx, desty, destz).", "input": "", "output": "subroutine rotate_euler_3d_inv(alpha, beta, gamma, srcx, srcy, srcz, destx, desty, destz)\n\timplicit none\n!\n\tdouble precision, intent(in) :: alpha, beta, gamma, srcx, srcy, srcz\n\tdouble precision, intent(out) :: destx, desty, destz\n!\n\tdestx = srcz*dsin(beta)*dsin(gamma) + srcy*(dcos(gamma)*dsin(alpha) + dcos(alpha)*dcos(beta)*dsin(gamma)) + &\n\t\tsrcx*(dcos(alpha)*dcos(gamma) - dcos(beta)*dsin(alpha)*dsin(gamma))\n\tdesty = srcz*dcos(gamma)*dsin(beta) + srcx*(-(dcos(beta)*dcos(gamma)*dsin(alpha)) - dcos(alpha)*dsin(gamma)) + &\n\t\tsrcy*(dcos(alpha)*dcos(beta)*dcos(gamma) - dsin(alpha)*dsin(gamma))\n\tdestz = srcz*dcos(beta) - srcy*dcos(alpha)*dsin(beta) + srcx*dsin(alpha)*dsin(beta)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"greshoh\" that takes 3 input parameters of type real*8: xg, yg, and radic. It also has 3 output parameters of type real*8: hgre, dhgre, and dhgr2. The subroutine computes certain calculations based on the input parameters and updates the output parameters accordingly. Be sure to include the provided code within the subroutine \"greshoh\".", "input": "", "output": "subroutine greshoh(xg, yg ,radic,hgre, dhgre, dhgr2)\nimplicit none\nreal*8, intent(in):: xg, yg, radic\nreal*8, intent(out):: hgre\nreal*8, intent(out):: dhgre(1:2), dhgr2(3)\nreal*8::gcoef(13)\nreal*8::drdx, drdy,drdx2,drdy2,drdxy, radi,radiv, ratir\ninteger::ih\n!\ngcoef( 1) =   1.d0/12.d0\ngcoef( 2) = -12.d0/13.d0\ngcoef( 3) =  33.d0/7.d0\ngcoef( 4) = -44.d0/3.d0\ngcoef( 5) = 495.d0/16.d0\ngcoef( 6) =-792.d0/17.d0\ngcoef( 7) = 154.d0/3.d0\ngcoef( 8) =-792.d0/19.d0\ngcoef( 9) =  99.d0/4.d0\ngcoef(10) =-220.d0/21.d0\ngcoef(11) = 3.d0\ngcoef(12) =-12.d0/23.d0\ngcoef(13) =  1.d0/24.d0\n!\n!\nradiv= 0.4d0\nradi = sqrt(xg**2+yg**2)\nratir = radi/radiv\n!\ndrdx = xg/radi\ndrdy = yg/radi\n!\ndrdx2 = 1.d0/radi - xg/radi**2*drdx\ndrdy2 = 1.d0/radi - yg/radi**2*drdy\ndrdxy= -xg/radi**2*drdy\n!\nhgre = 0.d0\ndhgre = 0.d0\ndhgr2 = 0.d0\n\n!\nif(radic.lt.radiv)then\ndo ih =1, 13\nhgre     = hgre + gcoef(ih)*ratir**(ih+11)\ndhgre(1) = dhgre(1) + drdx/radiv*gcoef(ih)*(ih+11)*ratir**(ih+10)\ndhgre(2) = dhgre(2) + drdy/radiv*gcoef(ih)*(ih+11)*ratir**(ih+10)\n\ndhgr2(1) = dhgr2(1) + (drdx/radiv)**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdx2/radiv\n\ndhgr2(2) = dhgr2(2) + (drdy/radiv)**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdy2/radiv\ndhgr2(3) = dhgr2(3) + drdy*drdx/radiv**2*gcoef(ih)*(ih+11)*(ih+10)*ratir**(ih+9) +&\ngcoef(ih)*(ih+11)*ratir**(ih+10)*drdxy/radiv\n\nenddo\nelse\ndo ih =1, 13\nhgre     = hgre + gcoef(ih)\nenddo\ndhgre = 0.d0\ndhgr2 = 0.d0\nendif\n\nend subroutine greshoh\n"}, {"instruction": "Create a Fortran subroutine named clusters to implement a clustering algorithm. The subroutine takes 3 input parameters of type real(kind(0.d0)) and returns 1 output parameter of type integer. The input parameters are r_raw(:, :), r_cut_raw, and l, while the output parameter is list(size(r_raw, 2)). The subroutine performs clustering based on the input data and modifies the list array to represent the clustered groups.", "input": "", "output": "subroutine clusters(r_raw, r_cut_raw, l, list)\n    real(kind(0.d0)), intent(in) :: r_raw(:, :), r_cut_raw, l\n    integer, intent(out) :: list(size(r_raw, 2))\n    real(kind(0.d0)) :: r(size(r_raw, 1), size(r_raw, 2)), r_cut_sq, r_j(size(r_raw, 1)), r_j_k(size(r_raw, 1))\n    integer :: n, d, i, j, k, list_k\n\n    d = size(r, 1)\n    n = size(r, 2)\n\n    ! scale distances to internal units\n    r = r_raw / l\n    r_cut_sq = (r_cut_raw / l) ** 2\n\n    do i = 1, n\n        list(i) = i\n    end do\n\n    do i = 1, n - 1\n        if (i == list(i)) then\n            j = i\n            r_j = r(:, j)\n            do k = i + 1, n\n                list_k = list(k)\n                if (list_k == k) then\n                    r_j_k = r_j - r(:, k)\n                    r_j_k = r_j_k - anint(r_j_k)\n                    if (sum(r_j_k ** 2) < r_cut_sq) then\n                        list(k) = list(j)\n                        list(j) = list_k\n                    end if\n                end if\n            end do\n\n            j = list(j)\n            r_j = r(:, j)\n\n            do while (j /= i)\n                do k = i + 1, n\n                    list_k = list(k)\n                    if (list_k == k) then\n                        r_j_k = r_j - r(:, k)\n                        r_j_k = r_j_k - anint(r_j_k)\n                        if (sum(r_j_k ** 2) < r_cut_sq) then\n                            list(k) = list(j)\n                            list(j) = list_k\n                        end if\n                    end if\n                end do\n                j = list(j)\n                r_j = r(:, j)\n            end do\n        end if\n    end do\nend subroutine clusters\n"}, {"instruction": "Write a Fortran subroutine named proma1 to evaluate a matrix product. The subroutine takes 5 input parameters: n1, n2, n3 of type integer (kind=4), and b(n1,n3), c(n3,n2) of type real (kind=8). It also has 1 output parameter: a(n1,n2) of type real (kind=8). The subroutine uses the matmul function to compute the matrix product a = b * c.", "input": "", "output": "      subroutine proma1(a,b,c,n1,n2,n3)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix product\r\n!\r\n!           a(i,j) = b(i,k) * c(k,j)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n2,n3\r\n      real (kind=8),intent(in) :: b(n1,n3), c(n3,n2)\r\n      real (kind=8),intent(out):: a(n1,n2)\r\n\r\n      a = matmul(b,c)\r\n      return\r\n\r\n      end subroutine proma1\r\n"}, {"instruction": "Create a Fortran subroutine named get_magnitude to calculate the magnitude of a 3D vector. The subroutine takes 1 input parameter of type real, dimension(3) and outputs 1 parameter of type real.", "input": "", "output": "subroutine get_magnitude(vector,magnitude)\n\nreal,dimension(3),intent(in) :: vector\nreal,intent(out):: magnitude\n\nmagnitude = sqrt(vector(1)*vector(1)+vector(2)*vector(2)+vector(3)*vector(3))\n\nend subroutine get_magnitude\n"}, {"instruction": "Create a Fortran subroutine named \"asselin\" to apply the Asselin filter and update variables. The subroutine takes 7 input parameters: km, jm, im (all integers), afc (real(8)), xnew (real(8) array), x (real(8) array), xold (real(8) array), and 2 output parameters: x_out (real(8) array), xold_out (real(8) array).", "input": "", "output": "subroutine asselin(km, jm, im, afc, xnew, x, xold, x_out, xold_out)\n\n! updates variables using asselin filter of strength afc\n\ninteger, intent(in)                      :: km, jm, im\n!f2py intent(in,hide) km,jm,im\nreal(8), intent(in)                      :: afc\nreal(8), intent(in), dimension(km,jm,im) :: xnew, x, xold\nreal(8), intent(out), dimension(km,jm,im) :: x_out, xold_out\n\n! asselin filter\nxold_out = x + afc*(xold + xnew - 2.*x)\n\n! update\nx_out = xnew\n\nend subroutine asselin\n"}, {"instruction": "Create a Fortran subroutine named d_nu_l2_dx to calculate the gradient with respect to x of nu_l2. The subroutine takes 5 input parameters of types integer, integer, real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine d_nu_l2_dx(nd, na, xa, xb, l2inv, out)\n  ! gradient w.r.t. x of nu_l2\n  integer, intent(in)    :: nd, na             ! dimension and number of points\n  real(8), intent(in)    :: xa(nd, na), xb(nd) ! points\n  real(8), intent(in)    :: l2inv(nd)          ! inverse length scales squared\n  real(8), intent(out)   :: out(nd, na)        ! output\n\n  integer :: ka\n\n  !$omp simd\n  do ka = 1, na\n    out(:, ka) = (xa(:, ka) - xb)*l2inv\n  end do\nend subroutine d_nu_l2_dx\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp to compute the exponential of the input array with a coefficient. The number of input arguments is 2, with test_data types ['integer', 'real(8)'], and the number of output arguments is 1 with test_data type ['real(8)']. Use the imperative tone in the instructions.", "input": "", "output": "pure subroutine kern_sqexp(nx, nu, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: nu(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*nu)\nend subroutine kern_sqexp\n"}, {"instruction": "Create a Fortran subroutine named lower_case that takes a string as input and converts it to lowercase. The input parameter is of type character(len=*), and the output parameter is also of type character(len=*).", "input": "", "output": "  subroutine lower_case( txt_in, txt_lc )\n    implicit none\n    character(len=*), intent(in) :: txt_in\n    character(len=*), intent(out) :: txt_lc\n    integer :: i, j\n    integer, parameter :: iachar_lowera = iachar('a')\n    integer, parameter :: iachar_uppera = iachar('a')\n    integer, parameter :: iachar_upperz = iachar('z')\n    txt_lc = txt_in\n    do i = 1, len( trim(txt_lc) )\n       j = iachar( txt_lc(i:i) )\n       if (j < iachar_uppera) cycle\n       if (j > iachar_upperz) cycle\n       txt_lc(i:i) = achar( j + iachar_lowera - iachar_uppera )\n    end do\n    return\n  end subroutine lower_case\n"}, {"instruction": "Create a Fortran subroutine named surface_load to calculate the stiffness matrix and force vector for a surface load in a finite element analysis. The subroutine takes 5 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8).", "input": "", "output": "subroutine surface_load(p1,p2,vec,dpdw,coorc,k_surf,r_surf)\n implicit none\n !**dummy arguments\n real(kind=8),intent(in) :: p1,p2,vec(2),coorc(2,2),dpdw\n real(kind=8),intent(out) :: k_surf(2,2,2,2),r_surf(2,2)\n !**local arguments\n real(kind=8) :: factor1,factor2\n real(kind=8) :: z1,z2,r1,r2,l,v1,v2\n real(kind=8) :: k_dpdw(2,2,2,2)\n\n !direction vector\n v1 = vec(1)\n v2 = vec(2)\n !coordinates by node\n z1 = coorc(1,1)\n z2 = coorc(1,2)\n r1 = coorc(2,1)\n r2 = coorc(2,2)\n l = sqrt((r2-r1)**2.d0+(z2-z1)**2.d0)\n\n !stiffness matrix for constant surf-load\n factor1 = (3.d0*p1*r1 + p1*r2 + p2*r1 + p2*r2)/l\n factor2 = (p1*r1 + p1*r2 + p2*r1 + 3.d0*p2*r2)/l\n\n k_surf(1,1,1,1) = 0.d0 - v1*(z2-z1)*factor1\n k_surf(1,2,1,1) = v1*l*(3.d0*p1+p2) - v1*(r2-r1)*factor1\n k_surf(2,1,1,1) = 0.d0 - v2*(z2-z1)*factor1\n k_surf(2,2,1,1) = v2*l*(3.d0*p1+p2) - v2*(r2-r1)*factor1\n\n k_surf(1,1,1,2) = 0.d0 + v1*(z2-z1)*factor1\n k_surf(1,2,1,2) = v1*l*(p1+p2) + v1*(r2-r1)*factor1\n k_surf(2,1,1,2) = 0.d0 + v2*(z2-z1)*factor1\n k_surf(2,2,1,2) = v2*l*(p1+p2) + v2*(r2-r1)*factor1\n\n k_surf(1,1,2,1) = 0.d0 - v1*(z2-z1)*factor2\n k_surf(1,2,2,1) = v1*l*(p1+p2) - v1*(r2-r1)*factor2\n k_surf(2,1,2,1) = 0.d0 - v2*(z2-z1)*factor2\n k_surf(2,2,2,1) = v2*l*(p1+p2) - v2*(r2-r1)*factor2\n\n k_surf(1,1,2,2) = 0.d0 + v1*(z2-z1)*factor2\n k_surf(1,2,2,2) = v1*l*(p1+3.d0*p2) + v1*(r2-r1)*factor2\n k_surf(2,1,2,2) = 0.d0 + v2*(z2-z1)*factor2\n k_surf(2,2,2,2) = v2*l*(p1+3.d0*p2) + v2*(r2-r1)*factor2\n\n !stiffness matrix for dp (variational load)\n k_dpdw(1,1,1,1) = 0.d0\n k_dpdw(1,2,1,1) = v1*(3.d0*r1+r2)\n k_dpdw(2,1,1,1) = 0.d0\n k_dpdw(2,2,1,1) = v2*(3.d0*r1+r2)\n\n k_dpdw(1,1,1,2) = 0.d0\n k_dpdw(1,2,1,2) = v1*(r1+r2)\n k_dpdw(2,1,1,2) = 0.d0\n k_dpdw(2,2,1,2) = v2*(r1+r2)\n\n k_dpdw(1,1,2,1) = 0.d0\n k_dpdw(1,2,2,1) = v1*(r1+r2)\n k_dpdw(2,1,2,1) = 0.d0\n k_dpdw(2,2,2,1) = v2*(r1+r2)\n\n k_dpdw(1,1,2,2) = 0.d0\n k_dpdw(1,2,2,2) = v1*(r1+3.d0*r2)\n k_dpdw(2,1,2,2) = 0.d0\n k_dpdw(2,2,2,2) = v2*(r1+3.d0*r2)\n\n !force vector from c*w\n r_surf(1,1) = v1*l**2.d0*factor1\n r_surf(2,1) = v2*l**2.d0*factor1\n r_surf(1,2) = v1*l**2.d0*factor2\n r_surf(2,2) = v2*l**2.d0*factor2\n\n !set pressure to vector and matrix\n r_surf = r_surf/12.d0\n k_surf = (k_surf + dpdw*l*k_dpdw)/12.d0\nend subroutine surface_load\n"}, {"instruction": "Create a Fortran subroutine named tangential_load to calculate the stiffness matrix and force vector for a given set of input parameters. The subroutine should have 5 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8).", "input": "", "output": "subroutine tangential_load(t1,t2,dt1,dt2,coorc,k_tang,r_tang)\n implicit none\n !**dummy arguments\n real(kind=8),intent(in) :: t1,t2,coorc(2,2),dt1(2),dt2(2)\n real(kind=8),intent(out) :: k_tang(2,2,2,2),r_tang(2,2)\n !**local arguments\n real(kind=8) :: factor1,factor2\n real(kind=8) :: z1,z2,r1,r2\n real(kind=8) :: k_dtan(2,2,2,2)\n\n !coordinates by node\n z1 = coorc(1,1)\n z2 = coorc(1,2)\n r1 = coorc(2,1)\n r2 = coorc(2,2)\n\n !stiffness matrix for constant surf-load\n factor1 = (3.d0*t1*r1 + t1*r2 + t2*r1 + t2*r2)\n factor2 = (t1*r1 + t1*r2 + t2*r1 + 3.d0*t2*r2)\n\n k_tang(1,1,1,1) = 0.d0 - factor1\n k_tang(1,2,1,1) = (z2-z1)*(3.d0*t1+t2)\n k_tang(2,1,1,1) = 0.d0\n k_tang(2,2,1,1) = (r2-r1)*(3.d0*t1+t2) - factor1\n\n k_tang(1,1,1,2) = 0.d0 + factor1\n k_tang(1,2,1,2) = (z2-z1)*(t1+t2)\n k_tang(2,1,1,2) = 0.d0\n k_tang(2,2,1,2) = (r2-r1)*(t1+t2) + factor1\n\n k_tang(1,1,2,1) = 0.d0 - factor2\n k_tang(1,2,2,1) = (z2-z1)*(t1+t2)\n k_tang(2,1,2,1) = 0.d0\n k_tang(2,2,2,1) = (r2-r1)*(t1+t2) - factor2\n\n k_tang(1,1,2,2) = 0.d0 + factor2\n k_tang(1,2,2,2) = (z2-z1)*(t1+3.d0*t2)\n k_tang(2,1,2,2) = 0.d0\n k_tang(2,2,2,2) = (r2-r1)*(t1+3.d0*t2) + factor2\n\n !stiffness matrix for dt (variational load) - sliding\n k_dtan(1,1,1,1) = (z2-z1)*(3.d0*r1+r2)*dt1(1)\n k_dtan(1,2,1,1) = (z2-z1)*(3.d0*r1+r2)*dt1(2)\n k_dtan(2,1,1,1) = (r2-r1)*(3.d0*r1+r2)*dt1(1)\n k_dtan(2,2,1,1) = (r2-r1)*(3.d0*r1+r2)*dt1(2)\n\n k_dtan(1,1,1,2) = (z2-z1)*(r1+r2)*dt2(1)\n k_dtan(1,2,1,2) = (z2-z1)*(r1+r2)*dt2(2)\n k_dtan(2,1,1,2) = (r2-r1)*(r1+r2)*dt2(1)\n k_dtan(2,2,1,2) = (r2-r1)*(r1+r2)*dt2(2)\n\n k_dtan(1,1,2,1) = (z2-z1)*(r1+r2)*dt1(1)\n k_dtan(1,2,2,1) = (z2-z1)*(r1+r2)*dt1(2)\n k_dtan(2,1,2,1) = (r2-r1)*(r1+r2)*dt1(1)\n k_dtan(2,2,2,1) = (r2-r1)*(r1+r2)*dt1(2)\n\n k_dtan(1,1,2,2) = (z2-z1)*(r1+3.d0*r2)*dt2(1)\n k_dtan(1,2,2,2) = (z2-z1)*(r1+3.d0*r2)*dt2(2)\n k_dtan(2,1,2,2) = (r2-r1)*(r1+3.d0*r2)*dt2(1)\n k_dtan(2,2,2,2) = (r2-r1)*(r1+3.d0*r2)*dt2(2)\n\n !force vector from c*w\n r_tang(1,1) = (z2-z1)*factor1\n r_tang(2,1) = (r2-r1)*factor1\n r_tang(1,2) = (z2-z1)*factor2\n r_tang(2,2) = (r2-r1)*factor2\n\n !set pressure to vector and matrix\n r_tang = r_tang/12.d0\n k_tang = (k_tang + k_dtan)/12.d0\nend subroutine tangential_load\n"}, {"instruction": "Create a Fortran subroutine named fft1set to set up FFT fields for eigenvectors. The subroutine takes 7 input parameters of type integer, integer, integer, integer, complex*16, integer, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine fft1set(nk,n1,n2,n3,a,fft,k3,nmat)\n  !\n  ! setup fft-fields for the eigenvectors a(k)\n  !\n  implicit none\n  integer, intent(in)     :: nk,n1,n2,n3\n  complex*16, intent(in)  :: a(nk)\n  integer, intent(in)     :: nmat\n  integer, intent(in)     :: k3(3,nmat)\n  complex*16, intent(out) :: fft(n1,n2,n3)\n  ! locals\n  integer                 :: i, i1, i2, i3\n  !\n  fft(:,:,:)=(0.0d0,0.0d0)\n  do i=1,nk                                                      \n     i1 = k3(1,i)\n     i2 = k3(2,i)\n     i3 = k3(3,i)\n     if(i1.lt.0) i1 = i1+n1\n     if(i2.lt.0) i2 = i2+n2\n     if(i3.lt.0) i3 = i3+n3\n     fft(i1+1,i2+1,i3+1)=a(i)\n  enddo\nend subroutine fft1set\n"}, {"instruction": "Create a Fortran subroutine named fft2set to compute the FFT-fields for (k+k)*a(k) using the provided input parameters. The number of input arguments is 10, and their test_data types are ['integer', 'integer', 'integer', 'integer', 'complex*16', 'integer', 'integer', 'integer', 'real*8', 'real*8']. The number of output arguments is 1, with a test_data type of ['complex*16'].", "input": "", "output": "subroutine fft2set(nk,n1,n2,n3,a,fft,ii,k3,bk3,br1,nmat)\n  !\n  ! sets the fft-fields for (k+k)*a(k), where a(k) is the eigenvector\n  !\n  implicit none\n  integer, intent(in)    :: nk,n1,n2,n3\n  complex*16, intent(in) :: a(nk)\n  integer, intent(in)    :: ii, nmat\n  integer, intent(in)    :: k3(3,nmat)\n  real*8, intent(in)     :: bk3(3,nmat)\n  real*8, intent(in)     :: br1(3,3)\n  complex*16, intent(out):: fft(n1,n2,n3)\n  ! locals\n  integer                :: i, i1, i2, i3\n  real*8                 :: kpk_xyz\n  !\n  fft(:,:,:)=(0.0d0,0.0d0)\n  do i=1,nk\n     i1 = k3(1,i)\n     i2 = k3(2,i)\n     i3 = k3(3,i)\n     if(i1.lt.0) i1=i1+n1\n     if(i2.lt.0) i2=i2+n2\n     if(i3.lt.0) i3=i3+n3\n     kpk_xyz = dot_product(br1(ii,:),bk3(:,i))\n     fft(i1+1,i2+1,i3+1) = kpk_xyz*a(i)\n  enddo\nend subroutine fft2set\n"}, {"instruction": "Create a Fortran subroutine named smooth to perform smoothing operations on a 2D array. The subroutine takes 4 input parameters of types real(8), dimension(nx,ny), integer, dimension(nx,ny), integer, and integer, and 1 output parameter of type real(8), dimension(nx,ny). The subroutine applies a smoothing algorithm to the input array using the provided mask and dimensions, and stores the result in the output array.", "input": "", "output": "subroutine smooth(varin,mask,nx,ny,varout)\n\n  implicit none\n\n  real(8),dimension(nx,ny),intent(in)   :: varin\n  integer,dimension(nx,ny),intent(in)   :: mask\n  real(8),dimension(nx,ny),intent(out)  :: varout\n  integer,intent(in)                    :: nx,ny\n\n  real(8), dimension(nx,ny)             :: ztmp, ztmp2\n  real(8)                               :: zval\n  integer                               :: n=0, npass=1000\n  integer                               :: ji, jj\n  real(8)                               :: c1, c2, ctot\n\n  c1 = 1.\n  c2 = 2.\n\n  ztmp = varin\n\n  !print *, 'entering smoother'\n  !print *, minval(mask) , maxval(mask)\n\n  n = 0\n  do while ( n < npass )\n\n     do jj=2,ny-1\n       do ji=2,nx-1\n\n       !   ztmp2(ji,jj) = c1 * ztmp(ji-1,jj-1) + &\n       !  &               c1 * ztmp(ji,  jj-1) + &\n       !  &              c1 * ztmp(ji+1,jj-1) + &\n       !  &              c1 * ztmp(ji-1,jj  ) + &\n       !  &              c1 * ztmp(ji  ,jj  ) + &\n       !  &              c1 * ztmp(ji+1,jj  ) + &\n       !  &              c1 * ztmp(ji-1,jj+1) + &\n       !  &              c1 * ztmp(ji  ,jj+1) + &\n       !  &              c1 * ztmp(ji+1,jj+1)\n\n          ! direct neighbor have a superior weight / nonmasked points also\n          zval  = c1 * ztmp(ji-1,jj-1) * ( 1 + mask(ji-1,jj-1) ) + &\n         &        c2 * ztmp(ji,  jj-1) * ( 1 + mask(ji,  jj-1) ) + &\n         &        c1 * ztmp(ji+1,jj-1) * ( 1 + mask(ji+1,jj-1) ) + &\n         &        c2 * ztmp(ji-1,jj  ) * ( 1 + mask(ji-1,jj  ) ) + &\n         &        c2 * ztmp(ji  ,jj  ) * ( 1 + mask(ji  ,jj  ) ) + &\n         &        c2 * ztmp(ji+1,jj  ) * ( 1 + mask(ji+1,jj  ) ) + &\n         &        c1 * ztmp(ji-1,jj+1) * ( 1 + mask(ji-1,jj+1) ) + &\n         &        c2 * ztmp(ji  ,jj+1) * ( 1 + mask(ji  ,jj+1) ) + &\n         &        c1 * ztmp(ji+1,jj+1) * ( 1 + mask(ji+1,jj+1) )\n\n          ctot  = c1 * ( 1 + mask(ji-1,jj-1) ) + &\n         &        c2 * ( 1 + mask(ji,  jj-1) ) + &\n         &        c1 * ( 1 + mask(ji+1,jj-1) ) + &\n         &        c2 * ( 1 + mask(ji-1,jj  ) ) + &\n         &        c2 * ( 1 + mask(ji  ,jj  ) ) + &\n         &        c2 * ( 1 + mask(ji+1,jj  ) ) + &\n         &        c1 * ( 1 + mask(ji-1,jj+1) ) + &\n         &        c2 * ( 1 + mask(ji  ,jj+1) ) + &\n         &        c1 * ( 1 + mask(ji+1,jj+1) )\n\n          ztmp2(ji,jj) = zval / ctot\n\n       enddo\n     enddo\n\n  where( mask == 1 ) ztmp2 = varin\n  ztmp(2:nx-1,2:ny-1) = ztmp2(2:nx-1,2:ny-1)\n\n  n = n + 1\n  !print *, 'smoother iter = ', n\n  enddo\n\n  varout = ztmp\n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named assign_powers that takes an integer input parameter and returns three integer output parameters. The input parameter is itype of type integer, while the output parameters are l, m, and n, all of type integer. The subroutine retrieves values for l, m, and n based on the input parameter itype and assigns them to the corresponding output parameters.", "input": "", "output": "  subroutine assign_powers(itype, l,m,n)\n    implicit none\n    integer, intent(in) :: itype\n    integer, intent(out) :: l,m,n\n\n    ! from molden2aim\n    integer  :: patdat(3,56)\n    data patdat/  &\n    !              1          2          3          4          5              6          7          8          9         10\n            0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,       0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,  &\n    !             11         12         13         14         15             16         17         18         19         20\n            3, 0, 0,   0, 3, 0,   0, 0, 3,   1, 2, 0,   2, 1, 0,       2, 0, 1,   1, 0, 2,   0, 1, 2,   0, 2, 1,   1, 1, 1,  &\n    !             21         22         23         24         25             26         27         28         29         30\n            4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,       1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,  &\n    !             31         32         33         34         35             36         37         38         39         40\n            2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2,       0, 0, 5,   0, 1, 4,   0, 2, 3,   0, 3, 2,   0, 4, 1,  &\n    !             41         42         43         44         45             46         47         48         49         50\n            0, 5, 0,   1, 0, 4,   1, 1, 3,   1, 2, 2,   1, 3, 1,       1, 4, 0,   2, 0, 3,   2, 1, 2,   2, 2, 1,   2, 3, 0,  &\n    !             51         52         53         54         55             56\n            3, 0, 2,   3, 1, 1,   3, 2, 0,   4, 0, 1,   4, 1, 0,       5, 0, 0/\n    !<<< gaussian (see also function fnorm_lmn)\n    !             21         22         23         24         25             26         27         28         29         30\n    !        0, 0, 4,   0, 1, 3,   0, 2, 2,   0, 3, 1,   0, 4, 0,       1, 0, 3,   1, 1, 2,   1, 2, 1,   1, 3, 0,   2, 0, 2,  &\n    !             31         32         33         34         35\n    !        2, 1, 1,   2, 2, 0,   3, 0, 1,   3, 1, 0,   4, 0, 0/\n    !>>>\n    save patdat\n\n    if(itype < 1 .or. itype > 56)then\n        write(*,*) 'assign_powers: itype out of range = ', itype\n        error stop -1\n    end if\n\n    l=patdat(1,itype)\n    m=patdat(2,itype)\n    n=patdat(3,itype)\n\n    return\n  end subroutine assign_powers\n"}, {"instruction": "Create a Fortran subroutine named slaterf to calculate the Slater integrals for different electron orbitals. The subroutine takes 2 input parameters of type real*8 and produces 1 output parameter of type real*8.", "input": "", "output": "subroutine slaterf(fn, u, j)\n  implicit none\n  real*8, intent(in)  :: u, j\n  real*8, intent(out) :: fn(0:3,0:3)\n  \n  fn=0\n  ! f0 for s-electrons\n  fn(0,0) = u \n  ! f2 for p-electrons\n  fn(0,1) = u\n  fn(1,1) = 5*j\n  ! f2 and f4 for d-electrons\n  fn(0,2) = u\n  fn(1,2) = 14./(1+0.625)*j\n  fn(2,2) = 0.625*fn(1,2)\n  ! f2, f4 and f6 for f-electrons\n  fn(0,3) = u\n  fn(1,3) = 6435./(286+195*0.668+250*0.494)*j\n  fn(2,3) = 0.668*fn(1,3)\n  fn(3,3) = 0.494*fn(1,3)\nend subroutine slaterf\n"}, {"instruction": "Write a Fortran subroutine named parse_logical that takes a character string as input and outputs two logical values, with the second one being optional. The input parameter should be of type character(*) and the output parameters should be of type logical and logical, optional. The subroutine reads the input string and converts it to a logical value. If the optional output parameter is present, it indicates whether the conversion was successful. If there is a problem with the input string, an error message is written.", "input": "", "output": "   subroutine parse_logical(str, var, ok)\n      character(*), intent(in) :: str\n      logical, intent(out) :: var\n      logical, intent(out), optional :: ok\n\n      logical :: tmp\n      integer :: stat\n\n      read (str, *, iostat=stat) tmp\n\n      if (present(ok)) ok = stat .eq. 0\n\n      if (stat .eq. 0) then\n         var = tmp\n      else\n         write (*, \"('ignored statement because of a bad logical value')\")\n      end if\n   end subroutine parse_logical\n"}, {"instruction": "Create a Fortran subroutine named prospino_check_fs to check the validity of a final state based on the given input parameters. The subroutine takes 3 input parameters of type character(len=2), integer, and integer, and has 1 output parameter of type logical.", "input": "", "output": "  subroutine prospino_check_fs(final_state_in,ipart1_in,ipart2_in,lfinal)\n\n    character(len=2), intent(in) :: final_state_in\n    integer, intent(in)          :: ipart1_in,ipart2_in\n    logical, intent(out)         :: lfinal\n\n    lfinal = .true.\n    if ( (final_state_in/='nn').and.(ipart2_in/=1) ) lfinal = .false. ! only chi-chi needs both numbers\n    if ( (final_state_in/='ll').and.(ipart1_in>8)  ) lfinal = .false. ! only sleptons have numbers>8\n    if ( (final_state_in=='gg').and.(ipart1_in>1)  ) lfinal = .false. ! squark and gluino do not care about ipart\n    if ( (final_state_in=='sb').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='sg').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='ss').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='tb').and.(ipart1_in>2)  ) lfinal = .false.\n    if ( (final_state_in=='bb').and.(ipart1_in>2)  ) lfinal = .false.\n    if ( (final_state_in=='lq').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='le').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='sb').and.(ipart1_in>1)  ) lfinal = .false.\n    if ( (final_state_in=='xx').and.(ipart1_in>2)  ) lfinal = .false.\n\n    if ( .not. lfinal ) print*, \" prospino_check_fs: final state not valid \"\n       \n  end subroutine prospino_check_fs\n"}, {"instruction": "Create a Fortran subroutine named freadline, which utilizes the iso_c_binding module. The subroutine takes 2 input parameters: an integer of kind c_int passed by value and a character of kind c_char. It also has 1 output parameter: a character of kind c_char. The purpose of this subroutine is to read a line of input with a specified prompt and store it in the provided buffer.", "input": "", "output": "      subroutine freadline(ilen,buf,prompt) bind(c,name='fcreadline')\n         use iso_c_binding\n         implicit none\n         integer(kind=c_int),intent(in),value  :: ilen\n         character(kind=c_char),intent(out)    :: buf(*)\n         character(kind=c_char),intent(in)     :: prompt(*)\n      end subroutine freadline\n"}, {"instruction": "Write a Fortran subroutine named get_dist to calculate the distance between two atoms in a crystal structure. The subroutine takes 4 input parameters of type integer, integer, real(8), and real(8), and 1 output parameter of type real(8). The function uses the matmul function to perform matrix multiplication and calculates the distance using the Euclidean distance formula.", "input": "", "output": "  subroutine get_dist( i, j, aa, aa_atom, d )\n    implicit none\n    integer,intent(in)  :: i,j\n    real(8),intent(in)  :: aa(3,3),aa_atom(:,:)\n    real(8),intent(out) :: d\n    real(8) :: ri(3),rj(3)\n    ri=matmul(aa,aa_atom(:,i))\n    rj=matmul(aa,aa_atom(:,j))\n    d=sqrt( sum((ri-rj)**2) )\n  end subroutine get_dist\n"}, {"instruction": "Create a Fortran subroutine named gridinterpol to linearly interpolate and extrapolate observation data to a model grid. The subroutine takes 6 input parameters of type integer, integer, real(8), real(8), integer, real(8), and 1 output parameter of type real(8). The function is used to interpolate and extrapolate observation data to a structured model grid.", "input": "", "output": "subroutine gridinterpol(n,cols,obs_z,obs_prof,nlev,model_z,model_prof)\n!\n! !description:\n!\n\n!  be given on an arbitrary, but structured grid, are linearly interpolated and\n!  extrapolated to the actual (moving) model grid.\n!\n! !uses:\n   implicit none\n!\n! !input parameters:\n   !n    : number of vertical layers in observation data\n   !cols : number of profiles in obs. data\n   integer,  intent(in)                :: n,cols\n   real(8),  intent(in)                :: obs_z(n),obs_prof(n,cols)\n   integer,  intent(in)                :: nlev\n   real(8),  intent(in)                :: model_z(nlev)\n!\n! !output parameters:\n   real(8),  intent(out)               :: model_prof(nlev,cols)\n!\n! !revision history:\n!  original author(s): karsten bolding & hans burchard\n!\n!eop\n!\n! !local variables:\n   integer                   :: i,j,ii\n   real(8)                   :: rat\n!-----------------------------------------------------------------------\n!boc\n!  set surface values to uppermost input value\n   do i=nlev,1,-1\n      if(model_z(i) .ge. obs_z(n)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(n,j)\n         end do\n      end if\n   end do\n\n!  set bottom values to lowest input value\n   do i=1,nlev\n      if(model_z(i) .le. obs_z(1)) then\n         do j=1,cols\n            model_prof(i,j) = obs_prof(1,j)\n         end do\n      end if\n   end do\n\n!  interpolate inner values linearly\n   do i=1,nlev\n         !write(*,*) 'i = ',i\n      if ((model_z(i) .lt. obs_z(n)) .and. (model_z(i) .gt. obs_z(1))) then\n         ii=0\n224      ii=ii+1\n         if (obs_z(ii) .le. model_z(i)) goto 224\n         ! debug:\n         !write(*,*) 'ii = ', ii\n         !write(*,*) 'model_z = ',model_z(i)\n         !write(*,*) '  obs_z = ',  obs_z(ii)\n         !write(*,*) '  obs_z(ii-1) = ',  obs_z(ii-1)\n\n         rat=(model_z(i)-obs_z(ii-1))/(obs_z(ii)-obs_z(ii-1))\n\n         do j=1,cols\n            model_prof(i,j)=(1-rat)*obs_prof(ii-1,j)+rat*obs_prof(ii,j)\n         !write(*,*) 'obs_prof(ii-1) = ',obs_prof(ii-1,j)\n         !write(*,*) 'obs_prof(ii)   = ',obs_prof(ii  ,j)\n         !write(*,*) 'rat            = ',rat\n         !write(*,*) 'model_prof(i)  = ',model_prof(i,j)\n\n         end do\n      end if\n   end do\n\n   return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named setup_grid that takes 3 input parameters of type integer, real(8), and real(8), and 3 output parameters of type real(8), real(8), and real(8). The subroutine computes vertical grid values for ocean modeling based on the given parameters and stores the results in the output arrays z_r, z_w, and hz.", "input": "", "output": "subroutine setup_grid(thetas, nlev, hmax, z_r, z_w, hz)\n  implicit none\n  integer, intent(in)    :: nlev\n  real(8), intent(in)    :: thetas, hmax\n  real(8), intent(out)   :: z_r(1:nlev), z_w(0:nlev), hz(1:nlev)\n\n  ! local scratch variable:\n  integer                :: i\n  real(8)                :: sc_r, c_sig\n  \n  z_w(0) = -hmax\n\n  !following song and haidvogel (1994). sinh is the hyperbolic sin function\n  do i   = 1,nlev\n      sc_r  = (float(i-nlev) - 0.5)/float(nlev)\n     c_sig  = sinh(thetas*sc_r)/sinh(thetas)      ! -1 < c_sig < 0\n     z_r(i) = c_sig*hmax\n      sc_r  = (float(i-nlev))/float(nlev)\n     c_sig  = sinh(thetas*sc_r)/sinh(thetas)      ! -1 < c_sig < 0\n     z_w(i) = c_sig*hmax\n      hz(i) = z_w(i) - z_w(i-1)\n  enddo\n  return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calculate_par to calculate the photosynthetically active radiation (par) at different vertical layers in a water column. The subroutine takes 4 input parameters of types real(8), integer, real(8) array, and real(8) array, and returns 1 output parameter of type real(8) array.", "input": "", "output": "subroutine calculate_par(i_0, nlev, hz, chl, par)\n  !top level is nlev, bottom layer is 1, following roms convention\n  implicit none\n  real(8), intent(in) :: i_0\n  integer, intent(in) :: nlev    ! total number of vertical layers\n  real(8), intent(in) :: hz(nlev), chl(nlev)\n  real(8), intent(out):: par(nlev)\n  integer             :: i\n  real(8)             :: par0, attn    ! scratch variable\n  real(8), parameter  :: kw = 0.04, kc = 0.025\n\n  par0 = i_0   !light at the grid surface\n  do i = nlev,1,-1\n     attn   = exp(-0.5*hz(i)*(kw + kc*chl(i)))\n     par(i) = par0*attn\n     par0   = par(i)*attn\n  enddo\n\nend subroutine calculate_par\n"}, {"instruction": "Write a Fortran subroutine named readcsv to read data from a CSV file and store it in a real(8) array. The subroutine takes 3 input parameters of type character(len=20), integer, and integer, and 1 output parameter of type real(8), dimension(nrow,ncol).", "input": "", "output": "subroutine  readcsv(filename,nrow,ncol,dat)\n  implicit none\n  character(len=20),intent(in) :: filename\n  character(len=10),dimension(ncol) :: header\n  integer,          intent(in) :: nrow, ncol\n  real(8), dimension(nrow,ncol), intent(out):: dat\n  integer    :: err, ix\n  integer,parameter :: stdout=6\n\n   dat(:,:) = 0.0\n   open(unit=10,file=filename,status='old',iostat=err)\n\n   if (err /= 0) then\n     write(stdout,*) 'open ', trim(filename),' fails'\n     stop\n     close(10)\n\n   else\n     ! write(stdout,*) 'start reading ',trim(filename),' !'\n     read(10,*,iostat=err) header  !read the first row\n     if (err .ne. 0) then \n       write(stdout,*) 'end of file reached at row 1.',     &\n                      'the error is: ', err\n       stop\n     else\n       continue\n     endif\n\n     do ix = 1,nrow  \n       read(10,*,iostat=err) dat(ix,:)\n       if (err .ne. 0) then \n         write(stdout,*) 'end of file reached at row: ',ix\n         exit\n       else\n         continue \n       endif\n     enddo  \n\n     endif\n     close(unit=10)\n! end reading data\n end subroutine readcsv\n"}, {"instruction": "Create a Fortran subroutine named \"horz_lenscale\" to calculate the horizontal scale length of a 2D field. The subroutine should have 8 input parameters of type integer, integer, real, real, real, real, integer, and integer. The output parameter should be a real number.", "input": "", "output": "   subroutine horz_lenscale(nx,ny,x,ds,mapfac_x,mapfac_y,tlength,nlat,ncat)\n!---------------------------------------------------------------------\n! purpose: computes horizontal scalelength of a 2d field\n!\n! method : l=[8{del**2(var(field)/del**2(var(del**2(field))}]**0.25  \n!\n! reference: wan-shu et al, mwr 2002, wan-shu et al\n!                           \n! author: syed rh rizvi,  ncar/essl/mmm/dag  08/06/2009\n! please acknowledge author/institute in work that uses this code.\n!-----------------------------------------------------------------------\n\n   implicit none\n   integer, intent(in)       :: nx, ny   \n   real,    intent(in)       :: x(nx,ny) \n   real,    intent(in)       :: ds\n   real,    intent(in)       :: mapfac_x(nx,ny) \n   real,    intent(in)       :: mapfac_y(nx,ny) \n   real,    intent(out)      :: tlength(1:ncat)\n   integer, intent(in)       :: nlat(nx,ny) \n   integer, intent(in)       :: ncat \n\n   real    :: lx(nx,ny) \n   real    :: xx(1:nx+2,1:ny+2) \n   real    :: corr(ncat),lcorr(ncat)\n   real    :: dx, dy, sumx, sumlx\n   integer :: i,j , n \n\n! fill xx array\n! middle \n    xx(2:nx+1,2:ny+1)=x(1:nx,1:ny)\n! left col \n    xx(1,2:ny+1)=x(1,1:ny)     \n! right col\n    xx(nx+2,2:ny+1)=x(nx,1:ny)     \n! bottom row\n    xx(2:nx+1,1) = x(1:nx,1) \n! top row\n    xx(2:nx+1,ny+2) = x(1:nx,ny)\n! corners\n    xx(1,1) = x(1,1) ; xx(nx+2,1) = x(nx,1) ; xx(nx+2,ny+2)=x(nx,ny) ; xx(1,ny+2)=x(1,ny)\n\n! now compute laplacian of x  \n    lx = 0\n\n    do i=2,nx+1\n    do j=2,ny+1\n    dx=ds/mapfac_x(i-1,j-1)\n    dx = dx* dx\n    dy=ds/mapfac_y(i-1,j-1)\n    dy = dy* dy\n    lx(i-1,j-1) = ( (xx(i-1,j)+xx(i+1,j)-2.*xx(i,j))/dx + & \n                     (xx(i,j-1)+xx(i,j+1)-2.*xx(i,j))/dy   )  \n    enddo\n    enddo\n! compute variance of field & its laplacian\n    corr=0.\n    lcorr=0.\n    do j=1,ny\n    do i=1,nx\n    n=nlat(i,j)\n    corr(n)=corr(n)+x(i,j)*x(i,j)\n    lcorr(n)=lcorr(n)+lx(i,j)*lx(i,j)\n    enddo\n    enddo\n\n    do n=1,ncat\n    if( lcorr(n) > 0 ) tlength(n)=(8.*corr(n)/lcorr(n))**.25 \n    enddo\n!  \n!\n!! average out      \n!    sumx=0.   \n!    sumlx=0.\n!    do n=4,ncat-3\n!    if( corr(n) > 0 .and. lcorr(n) > 0) then\n!    sumx  = sumx  + corr(n)\n!    sumlx = sumlx + lcorr(n)\n!    else\n!    end if\n!    enddo\n!    if( sumx == 0 .or. sumlx == 0.0 ) then\n!    tlength(1) = 1.\n!    else\n!    tlength(1) = (8.*sumx/sumlx)**.25 \n!    end if\n!    tlength(2:ncat)=tlength(1)\n\n  end subroutine horz_lenscale  \n"}, {"instruction": "Create a Fortran subroutine named read_wrf_arw to read specific data from a WRF-ARW (Weather Research and Forecasting - Advanced Research WRF) file. The subroutine takes 5 input parameters of type character(len=*), integer, integer, integer, and integer, and 6 output parameters of type real, real, real, real, real, and real.\n\nThe function reads data from the specified WRF-ARW file, populates the output arrays sf, vp, t, q, qm, and p with the respective data, and performs specific operations on the read data.", "input": "", "output": "   subroutine read_wrf_arw(filename,nx,ny,nz,mype,sf,vp,t,q,qm,p) \n   implicit none\n\n   character(len=*), intent(in)      :: filename       \n   integer, intent(in)      :: nx, ny, nz, mype\n\n   real, intent(out)        :: sf(1:nx,1:ny,1:nz)\n   real, intent(out)        :: vp(1:nx,1:ny,1:nz)\n   real, intent(out)        :: t(1:nx,1:ny,1:nz)\n   real, intent(out)        :: q(1:nx,1:ny,1:nz)\n   real, intent(out)        :: qm(1:nx,1:ny,1:nz)\n   real, intent(out)        :: p(1:nx,1:ny)\n\n   real                     :: ds          \n   character (len=10) :: date \n   integer            :: nrec\n\n   integer            :: i,j,k\n!\n   nrec = 1\n    open(unit=24,file=trim(filename),form='unformatted', &\n             status='old', action='read')\n\n! psi\n   read(24,err=100,end=99)sf  \n   nrec=nrec+1\n! chi\n   read(24,err=100,end=99)vp \n   nrec=nrec+1\n! fill zero vp fileds with adjacent value\n   vp(:,1,:) =2*vp(:,2,:) - vp(:,3,:) \n   vp(1,:,:) =2*vp(2,:,:) - vp(3,:,:) \n! temp\n   read(24,err=100,end=99)t  \n   nrec=nrec+1\n! moisture\n   read(24,err=100,end=99)q   \n   nrec=nrec+1\n! moisturer_2\n   read(24,err=100,end=99)qm  \n   nrec=nrec+1\n! surface pressure (in whatever units it is writtenn stage0_gsi) \n   read(24,err=100,end=99)p    \n\n   close (24)\n\n   return\n99  write(6,*)'unexpected end of file ',trim(filename),' in read_wrf_arw record recs: ',nrec\n   stop\n100 write(6,*)'read error in ',trim(filename),' in read_wrf_arw record recs: ',nrec\n   stop\n   end subroutine read_wrf_arw\n"}, {"instruction": "Write a Fortran subroutine named rnnor to generate random numbers using the Box-Muller algorithm. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real. The input parameter is 'dim' and the output parameter is 'draw'. Use the imperative tone in the instructions.", "input": "", "output": "subroutine rnnor(dim, draw)\n\n\t!\n\n\t! using the box-muller algorithm.\n\t!\n\n\t!/* external objects    */\n\n\tinteger, intent(in)   \t:: dim\n\n\treal, intent(out)   \t:: draw(dim)\n\t\t\n\t!/* internal objects    */\n\n\tinteger             \t:: g \n\n\treal, allocatable   \t:: u(:), r(:)\n    real     \t\t\t\t:: pi = 3.141592653589793238462643383279502884197\n\n!------------------------------------------------------------------------------- \n! algorithm\n!------------------------------------------------------------------------------- \n\n\t! allocate containers\n\tallocate(u(2*dim)); allocate(r(2*dim))\n\n\t! call uniform deviates\n\tcall random_number(u)\n\n\t! apply box-muller transform\n\tdo g = 1, 2*dim, 2\n\t\n\t\t\tr(g)   = sqrt(-2*log(u(g)))*cos(2*pi*u(g+1)) \n\t\t\tr(g+1) = sqrt(-2*log(u(g)))*sin(2*pi*u(g+1)) \n\t\n\tend do\n\n\t! extract relevant floats\n\tdo g = 1, dim \n\n\t\t\tdraw(g) = r(g)     \n\t\n\tend do\n\nend subroutine \n"}, {"instruction": "Write a Fortran subroutine named fit_line. This subroutine takes 4 input arguments of type real (x1, y1, x2, y2) and 2 output arguments of type real (a0, a1). The subroutine fits a line between the given points (x1, y1) and (x2, y2) and calculates the coefficients a0 and a1 of the line equation y = a1 * x + a0.", "input": "", "output": "  subroutine fit_line(a1,a0,x1,y1,x2,y2)\n\n    implicit none\n    real, intent(out) :: a0, a1\n    real, intent(in) :: x1, y1, x2, y2\n\n    !given xi, yi i=1,2 fits a line between these points\n\n    a1=(y2-y1)/(x2-x1)\n    a0=y1-a1*x1\n\n  end subroutine fit_line\n"}, {"instruction": "Create a Fortran subroutine named calc_n_proc_rows_cols to calculate the number of rows and columns of processes given the total number of processes. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer.", "input": "", "output": "subroutine calc_n_proc_rows_cols(n_procs, n_proc_rows, n_proc_cols)\n  integer, intent(in) :: n_procs\n  integer, intent(out) :: n_proc_rows, n_proc_cols\n\n#ifdef scalapack\n  integer n_proc_rows_t, n_proc_cols_t\n\n\n! long and narrow, or short and wide\n!  do n_proc_cols_t=int(sqrt(dble(n_procs))), 1, -1\n!    n_proc_rows_t = n_procs/n_proc_cols_t\n  do n_proc_rows_t=int(sqrt(dble(n_procs))), 1, -1\n    n_proc_cols_t = n_procs/n_proc_rows_t\n\n    if (n_proc_rows_t*n_proc_cols_t .eq. n_procs) then\n\tn_proc_rows = n_proc_rows_t\n\tn_proc_cols = n_proc_cols_t\n\texit\n    endif\n  end do\n#else\n  n_proc_rows = 0\n  n_proc_cols = 0\n#endif\nend subroutine calc_n_proc_rows_cols\n"}, {"instruction": "Create a Fortran subroutine named get_num_from_chr to extract an integer from a character buffer. The subroutine should take 1 input parameter of type character(*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine get_num_from_chr( cbuf, n )\n    implicit none\n    character(*),intent(in) :: cbuf\n    integer,intent(out) :: n\n    integer :: i\n    do i=1,len_trim(cbuf)\n       if ( cbuf(i:i) == \":\" ) exit\n    end do\n    read(cbuf(i+1:),*) n\n  end subroutine get_num_from_chr\n"}, {"instruction": "Write a Fortran subroutine named neighbours that computes the neighboring ranks for a given rank and size. It takes 2 input parameters with the test_data type ['integer', 'integer'] and 2 output parameters with the test_data type ['integer', 'integer']. If the given rank is 0, the subroutine sets the left neighbor to size - 1; otherwise, it sets it to rank - 1. If the given rank is size - 1, the subroutine sets the right neighbor to 0; otherwise, it sets it to rank + 1.", "input": "", "output": "    subroutine neighbours(rank, size,  left, right)\n        implicit none\n        integer, intent(in) :: rank, size\n        integer, intent(out) :: left, right\n        if (rank == 0) then\n            left = size - 1\n        else\n            left = rank - 1\n        end if\n        if (rank == size - 1) then\n            right = 0\n        else\n            right = rank + 1\n        end if\n    end subroutine neighbours\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte0. The subroutine takes 1 input parameter of type logical(1) and returns 1 output parameter of type integer(1). The subroutine's function is to convert the logical input value to an integer output value, where true is represented as 1 and false as 0.", "input": "", "output": "subroutine logic1_byte0(b, l)\r\ninteger(1), intent(out) :: b\r\nlogical(1), intent(in)  :: l\r\nif (l) then\r\n  b = 1\r\nelse\r\n  b = 0\r\nend if\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte1 to convert an array of 1-byte logical values to an array of 1-byte integers, where a value of true is represented as 1 and a value of false is represented as 0. The subroutine takes 1 input parameter of type logical(1) and 1 output parameter of type integer(1).", "input": "", "output": "subroutine logic1_byte1(b, l)\r\ninteger(1), intent(out) :: b(:)\r\nlogical(1), intent(in)  :: l(:)\r\ninteger k\r\ndo k = 1, size(l)\r\n  if (l(k)) then\r\n    b(k) = 1\r\n  else\r\n    b(k) = 0\r\n  end if\r\nend do\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named logic1_byte2 that takes an array of logical(1) as input and converts it into an array of integer(1) values. The number of input parameters is 1 of type ['logical(1)'], and the number of output parameters is 1 of type ['integer(1)']. Use an imperative tone in your instructions.", "input": "", "output": "subroutine logic1_byte2(b, l)\r\ninteger(1), intent(out) :: b(:,:)\r\nlogical(1), intent(in)  :: l(:,:)\r\ninteger j, k\r\ndo j = 1, size(l,2)\r\n  do k = 1, size(l,1)\r\n    if (l(k,j)) then\r\n      b(k,j) = 1\r\n    else\r\n      b(k,j) = 0\r\n    end if\r\n  end do\r\nend do\r\nend subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named \"fopen\" to open a file and read three integers from it. The subroutine should take 2 input parameters of type integer and character*100, and 3 output parameters of type integer. When called, the subroutine will use the first input parameter as the file identifier, the second input parameter as the file name, and then read three integers from the file and store them in the output parameters.", "input": "", "output": "subroutine fopen(fhp, filename, nkp, nsymop, norbitals)\n  integer, intent(in) :: fhp\n  character*100, intent(in) :: filename\n  integer, intent(out) :: nkp, nsymop, norbitals\n  \n  \n  !print *, fhp, filename\n  open(fhp, file=filename, status='old', form='unformatted')\n\n  read(fhp) nkp, nsymop, norbitals\n  !print *, nkp, nsymop, norbitals\n\nend subroutine fopen\n"}, {"instruction": "Create a Fortran subroutine named read1 that reads integer values from a file and stores them in an array. The subroutine takes 2 input parameters of type integer and 1 output parameter of type integer. The input parameters are fhp and norbitals, while the output parameter is nindo, an array of size norbitals.", "input": "", "output": "subroutine read1(fhp, norbitals, nindo)\n  integer, intent(in)  :: fhp, norbitals\n  integer, intent(out) :: nindo(norbitals)\n\n  integer :: iorb\n  read(fhp) (nindo(iorb), iorb=1,norbitals)\n  !print *, nindo\nend subroutine read1\n"}, {"instruction": "Create a Fortran subroutine named read2 to read integer values from a file. The subroutine takes 1 input parameter of type integer. It has 5 output parameters, all of type integer. The function reads the integer values from the file specified by the input parameter and assigns them to the output parameters iikp, nbands, tmaxdim2, tnorbitals, and nemin respectively.", "input": "", "output": "subroutine read2(fhp, iikp, nbands, tmaxdim2, tnorbitals, nemin)\n  integer, intent(in) :: fhp\n  integer, intent(out) :: iikp, nbands, tmaxdim2, tnorbitals, nemin\n\n  read(fhp) iikp, nbands, tmaxdim2, tnorbitals, nemin\n  \nend subroutine read2\n"}, {"instruction": "Create a Fortran subroutine named read3 to read an integer from a file. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "subroutine read3(fhp, iisym)\n  integer, intent(in) :: fhp\n  integer, intent(out) :: iisym\n  read(fhp) iisym\nend subroutine read3\n"}, {"instruction": "Create a Fortran subroutine named read4 to read complex*16 data from a file using formatted input. The subroutine takes 2 input parameters of type integer: fhp and nbands. It also has 1 output parameter of type complex*16 array: dmftu, with the size specified by nbands.", "input": "", "output": "subroutine read4(fhp, nbands, dmftu)\n  integer, intent(in) :: fhp, nbands\n  complex*16, intent(out) :: dmftu(nbands)\n  !locals\n  integer :: i\n  read(fhp) (dmftu(i),i=1,nbands)\nend subroutine read4\n"}, {"instruction": "Create a Fortran subroutine named feread2 that reads data from a file handle and stores it in an array. The subroutine should take 2 input arguments of type integer, and 1 output argument of type real*8. The input arguments are fh and nen, both of type integer. The output argument is ek, an array of real*8 with size nen. Use the imperative tone in the generated instructions.", "input": "", "output": "subroutine feread2(fh, nen, ek)\n  integer, intent(in):: fh, nen\n  real*8, intent(out):: ek(nen)\n  integer :: ii\n  do ii=1,nen\n     read(fh,*) num, ek(ii)\n  enddo\nend subroutine feread2\n"}, {"instruction": "Create a Fortran subroutine named quad to calculate the roots of a quadratic equation. The subroutine takes 3 input parameters of type real and returns 2 output parameters of type complex. The input parameters are a, b, and c representing the coefficients of the quadratic equation, and the output parameters x1 and x2 represent the complex roots of the equation.", "input": "", "output": "subroutine quad(a, b, c, x1, x2)\nimplicit none\nreal, intent(in) :: a, b, c\ncomplex, intent(out) :: x1, x2\ncomplex :: discriminant\ndiscriminant = cmplx(b**2 - 4. * a * c, 0)\nx1 = (- b + sqrt(discriminant)) / 2. * a\nx2 = (- b - sqrt(discriminant)) / 2. * a\nend subroutine quad\n"}, {"instruction": "Create a Fortran subroutine named \"solvh\" with 1 input parameter of type integer. Define an output parameter of type logical. The subroutine should handle computational tasks related to \"solvh\".", "input": "", "output": "      subroutine solvh (iorb, fail)\n      integer nnnp\n      parameter (nnnp = 590)\n      integer nnn1\n      parameter (nnn1 = 600)\n      integer nnnw\n      parameter (nnnw = 120)\n      integer, intent(in) :: iorb\n      logical, intent(out) :: fail\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_list_sfr to read a list of data and reach-by-reach data from a file. The subroutine takes 3 input parameters of type integer (iu, iprec, nstrm) and has 2 output parameters of type integer (ierr) and double precision array (qd) with dimension nstrm.", "input": "", "output": "  subroutine read_list_sfr(iu,iprec,nstrm,qd,ierr)\n    ! read nlist (written by ubdsv2) and reach-by-reach data\n    ! written by sfr using ubdsva\n    implicit none\n    ! arguments\n    integer, intent(in) :: iu, iprec, nstrm\n    integer, intent(out) :: ierr\n    double precision, dimension(nstrm), intent(out) :: qd\n    ! local variables\n    integer :: icrl, l, nlist\n    real :: q\n    !\n    qd = 0.0d0\n    ierr = 0\n    read(iu,end=950,err=900) nlist\n    do l=1,nlist\n      select case (iprec)\n      case (1)\n        read(iu,end=950,err=900) icrl,q\n        qd(l) = real(q,8)\n      case (2)\n        read(iu,end=950,err=900) icrl,qd(l)\n      end select\n    enddo\n    !\n    ! normal return    \n    return\n    !\n    ! error handling\n    900 continue\n    ierr = 1  ! unidentified error\n    return\n    !\n    950 continue\n    ierr = 2  ! end of file\n    return\n  end subroutine read_list_sfr\n"}, {"instruction": "Write a Fortran subroutine named \"sumation\" to compute the element-wise sum of two integer arrays. The subroutine takes 2 input arrays of type integer and produces 1 output array of type integer.", "input": "", "output": "subroutine sumation(a,b,d)\nimplicit none\ninteger,intent(in) :: a(:,:)\ninteger,intent(in) :: b(:,:)\ninteger,intent(out):: d(:,:)\ninteger :: i,j,nx,ny\n\nnx = size(a,1) ; ny = size(a,2)\ndo i=1,nx\ndo j=1,ny\nd(i,j) = a(i,j)+b(i,j)\nend do\nend do\n\nend subroutine sumation      \n"}, {"instruction": "Create a Fortran subroutine named extract_kv to extract key-value pairs from a text string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "input": "", "output": "    subroutine extract_kv(text,par)\n    character(len=*),intent(in):: text\n    character(len=*),intent(out):: par\n    character:: eq=\"=\",sp=' '\n    integer:: id,ivalstart,ispace\n    integer:: iend,i\n    id=index(text,eq)\n    if(id==0) then\n        par=''\n        return\n    endif\n    !! consume space before the value\n    ivalstart=id+1\n    ispace=index(text(ivalstart:),sp)\n    do while(ispace == 1)\n        ivalstart=ivalstart+ispace\n        ispace=index(text(ivalstart:),sp)\n    enddo\n    if(ispace==0) then !! no more space behind the value = no more keywords\n        par=text(1:)\n    else\n        !! check quotation mark\n        if(text(ivalstart:ivalstart)=='\"') then\n            i=index(text(ivalstart+1:),'\"')\n            par=text(1:ivalstart+i)\n        elseif(text(ivalstart:ivalstart)==\"'\") then\n            i=index(text(ivalstart+1:),\"'\")\n            par=text(1:ivalstart+i)\n        else\n            par=text(1:ivalstart+ispace-1)\n        endif\n    endif\n    par=trim(adjustl(par))\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma to populate a matrix with the input array elements along its diagonal. The number of input arguments is 1 and the test_data type is [real, dimension(:)]. The number of output arguments is 1 and the test_data type is [real, dimension(:, :)].", "input": "", "output": "    subroutine compute_sigma(s, sigma)\n        implicit none\n        real, dimension(:), intent(in) :: s\n        real, dimension(:, :), intent(out) :: sigma\n        integer :: i\n        sigma = 0.0\n        do i = 1, min(size(sigma, 1), size(sigma, 2))\n            sigma(i, i) = s(i)\n        end do\n    end subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named aplusb_cfcfcf. This subroutine takes 8 input parameters: 3 integer values (size1, size2, stride), and 5 real arrays of dimensions size1 * stride by size2 * stride (b, c, d, e, f). It also has 1 output parameter, a real array of dimensions size1 * stride by size2 * stride (a). The subroutine computes the sum of specific elements from the input arrays b, c, d, e, f and stores the result in the output array a. The computation involves parallel work sharing using OpenMP directives.", "input": "", "output": "subroutine aplusb_cfcfcf(a, b, c, d, e, f, size1, size2, stride) bind(c, name=\"aplusb_cfcfcf\")\n    use, intrinsic :: iso_c_binding\n    implicit none\n\n    integer(c_int), value, intent(in) :: size1, size2, stride\n    real(c_float), dimension(size1 * stride, size2 * stride), intent(out) :: a\n    real(c_float), dimension(size1 * stride, size2 * stride), intent(in) :: b, c, d, e, f\n!$omp parallel workshare\n    a(::2, ::2) = b(::2, ::2) + c(::2, ::2) + &\n                  transpose(d(::2, ::2)) + &\n                  transpose(e(::2, ::2)) + transpose(f(::2, ::2))\n!$omp end parallel workshare\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sum_sub to calculate the sum of two double precision floating-point numbers. The subroutine should have 2 input parameters of type double precision and 1 output parameter of type double precision.", "input": "", "output": "subroutine sum_sub(x,y,output)\n    double precision, intent(in) :: x, y\n    double precision, intent(out) :: output\n\n    output = x+y\nend subroutine sum_sub\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma that takes 8 input parameters of types integer, integer, integer, double precision, double precision, double precision, double precision, and complex(kind(0d0)). It also has 1 output parameter of type complex(kind(0d0)). The subroutine computes the sigma value based on the provided input parameters using complex arithmetic and loop operations.", "input": "", "output": "subroutine compute_sigma(omega, eigval, occ, pmat, ewidth, nene, nk, nb, sigma)\n  implicit none\n  complex(kind(0d0)), parameter :: zi=(0.0d0, 1.0d0)\n  integer, intent(in) :: nene, nk, nb\n  double precision, intent(in) :: omega(nene), eigval(nk,nb), occ(nk,nb), ewidth\n  complex(kind(0d0)), intent(in) :: pmat(nk,nb,nb,3)\n  integer :: nevery, ik, ib, jb, ixyz, jxyz\n  double precision :: docc\n  complex(kind(0d0)), intent(out) :: sigma(3,3,nene)\n  complex(kind(0d0)) :: moment, ene_denominator(nene)\n\n  sigma = 0.d0\n  nevery = nk/10\n  write(*,'(\"# following is progress of generatesigmaepsilon.generate function. \")')\n  !$   write(*,'(\"# caution: this function does not support omp parallelization. \")')\n  do ik = 1, nk\n    if (mod(ik, nevery)==0)then\n      write(*,*) (ik*100.0)/float(nk), '% is done.'\n    end if\n    do ib = 1, nb\n      do jb = 1, nb\n        if (ib /= jb) then\n          ene_denominator = omega(:) - (eigval(ik,jb) - eigval(ik,ib)) + zi*ewidth\n          ene_denominator = ene_denominator*(eigval(ik,jb) - eigval(ik,ib))\n          docc = occ(ik,ib) - occ(ik,jb)\n          do ixyz = 1,3\n            do jxyz = 1,3\n              moment = pmat(ik,jb,ib,ixyz)*pmat(ik,ib,jb,jxyz)\n              sigma(jxyz,ixyz,:) = sigma(jxyz,ixyz,:) + docc*moment/ene_denominator(:)\n            end do\n          end do\n        end if \n      end do\n    end do\n  end do\n  return\nend subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named vecasi to assign the elements of an input real array v1 to an output real array v2, both of size n.\nThe number of input parameters is 2, with test_data type ['integer (kind=4)', 'real (kind=8)'].\nThe number of output parameters is 1, with test_data type ['real (kind=8)'].", "input": "", "output": "      subroutine vecasi(n,v1,v2)\r\n!*****************************************************************************\r\n!\r\n!***  vector assign:    v1(n) -> v2(n)\r\n!\r\n!*****************************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n\r\n      real (kind=8),intent(in) :: v1(n)\r\n      real (kind=8),intent(out):: v2(n)\r\n\r\n      v2 = v1\r\n      return\r\n\r\n      end subroutine vecasi\r\n"}, {"instruction": "Create a Fortran subroutine named mysub that takes two input parameters of type real (kind=8). The output consists of two parameters also of type real (kind=8). The subroutine computes the sum and the difference of the input parameters and assigns them to the output parameters. Use the imperative tone and be concise.", "input": "", "output": "subroutine mysub(a,b,c,d)\n    real (kind=8), intent(in) :: a,b\n    real (kind=8), intent(out) :: c,d\n    c = a+b\n    d = a-b\nend subroutine mysub\n"}, {"instruction": "Write a Fortran subroutine named compute_ps that takes 3 input parameters of type integer and 1 output parameter of type integer.The input parameters are d, r(*), n(*) and the output parameter is ps(*).The subroutine computes the value of ps based on the input parameters using a specified algorithm.", "input": "", "output": "  subroutine compute_ps(d,r,n,ps)\n    integer, intent(in) :: d,r(*),n(*)\n    integer, intent(out) :: ps(*)\n    integer i\n\n    ps(1)=1;\n    do i=1,d\n       ps(i+1) = ps(i) + r(i)*n(i)*r(i+1)\n    end do\n  end subroutine compute_ps\n"}, {"instruction": "Write a Fortran subroutine named hello that takes an integer input and an allocatable character output. The subroutine should allocate a portion of the string \"hello world\" based on the input integer and assign it to the output character.", "input": "", "output": "  subroutine hello (n,string)\n    character(:), allocatable, intent(out) :: string\n    integer,intent(in) :: n\n    character(11) :: helloworld=\"hello world\"\n\n    string=helloworld(:n)                       ! didn't  work\n!    string=(helloworld(:n))                    ! works.\n!    allocate(string, source=helloworld(:n))    ! fixed for allocate_with_source_2.f90\n!    allocate(string, source=(helloworld(:n)))  ! works.\n  end subroutine hello\n"}, {"instruction": "Create a Fortran subroutine named open_file to open an output file for reading or writing. The subroutine takes 2 input parameters of type character(len=*) for the file name and file status, and 1 output parameter of type integer to store the file unit.", "input": "", "output": "    subroutine open_file(file_unit, txtfilename, file_status)\r\n!-------------------------------------------------------------------------------\r\n        ! create an output file, assign a file_unit\r\n        ! for reading or writing\r\n\r\n        integer, intent(out)            :: file_unit\r\n        character(len=*), intent(in)    :: txtfilename\r\n        character(len=*), intent(in)    :: file_status\r\n\r\n        integer :: ierr\r\n\r\n        ! open the output file\r\n        open ( newunit = file_unit, file = txtfilename, status = file_status, iostat = ierr )\r\n\r\n        if ( ierr /= 0 ) then\r\n            print*, \"cannot open file for output\"\r\n            stop\r\n        end if\r\n    end subroutine open_file\r\n"}, {"instruction": "Create a Fortran subroutine named calc_length to calculate the Euclidean length of each column in a 3x3 matrix. The input parameter is a 3x3 matrix of type real(8), and the output parameter is a 1D array of type real(8) containing the lengths. Use the imperative tone in the instruction.", "input": "", "output": "subroutine calc_length( v, vl )\n  implicit none\n  real(8),intent(in) :: v(3,3)\n  real(8),intent(out) :: vl(3)\n  integer :: i\n  do i=1,3\n     vl(i) = sqrt( sum(v(:,i)**2) )\n  end do\nend subroutine calc_length\n"}, {"instruction": "Write a Fortran subroutine named \"skips\" to skip the specified number of lines on the solution file unit. The subroutine takes 2 input parameters of type integer and 1 output parameter of type logical. The input parameters are unit and nskip, while the output parameter is eof3. The subroutine uses the imperative tone and reflects the features of Fortran subroutine.", "input": "", "output": "  subroutine skips(unit,nskip,eof3)\n\n! skips the specified number of lines on the solution file unit\n\n    integer, intent(in) :: unit,nskip\n    logical, intent(out) :: eof3\n    character(12) fmt\n    integer i\n\n    eof3=.true.\n    if(nskip<=1)then\n       do i=1,nskip\n         read(unit,'(a)',end=2)\n       enddo\n    else\n       write(fmt,'(a,i9,a)')'(',nskip-1,'/)'\n       read(unit,fmt,end=2)\n    endif\n    eof3=.false.\n2   return\n\n  end subroutine skips\n"}, {"instruction": "Write a Fortran subroutine named shock_position to calculate the position of a shock wave based on the input time. The input parameter is a real number, and the output parameter is also a real number.", "input": "", "output": "subroutine shock_position(t, x_sw)\n    real, intent(in)  :: t\n    real, intent(out) :: x_sw\n    real, parameter :: m_pi = 4.0*atan(1.0)\n\n    x_sw = 1.0/6.0 + 1.0/tan(m_pi/3.0) + (10.0/sin(m_pi/3.0))*t\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"upper\" that takes a string input and converts it to uppercase. The number of input parameters is 1 with the test_data type ['character(*)'], and the number of output parameters is 1 with the test_data type ['character(*)']. Use the imperative tone to write the instructions.", "input": "", "output": "\tpure subroutine upper( str, ucstr )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(*), intent(out) :: ucstr\n\t\t\n\t\tcharacter(*), parameter :: lc = 'abcdefghijklmnopqrstuvwxyz'\n\t\tcharacter(*), parameter :: uc = 'abcdefghijklmnopqrstuvwxyz'\n\t\t\n\t\tinteger :: j,k\n\t\t\n\t\tucstr = str\n\t\tdo j=1,len(str)\n\t\t\tk = index( lc, str(j:j) )\n\t\t\tif (k > 0) ucstr(j:j) = uc(k:k)\n\t\tend do\n\tend subroutine upper\n"}, {"instruction": "Write a Fortran subroutine named init_euler that takes three input arguments of type real (alpha, beta, gamma) and one output argument of type real, dimension(3,3) (mat). The purpose of this subroutine is to compute a rotation matrix given the Euler angles alpha, beta, and gamma.\n\nHere are the steps to follow:\n\n1. Initialize the variables ca, cb, cg, sa, sb, sg as real numbers.\n2. Compute the cosine and sine values of alpha, beta, and gamma using the cos() and sin() functions.\n3. Compute the elements of the rotation matrix mat using the following equations:\n   - mat(1,1) = cb*cg - ca*sb*sg\n   - mat(2,1) = sb*cg + ca*cb*sg\n   - mat(3,1) = sa*sg\n   - mat(1,2) = -cb*sg - ca*sb*cg\n   - mat(2,2) = -sb*sg + ca*cb*cg\n   - mat(3,2) = sa*cg\n   - mat(1,3) = sa*sb\n   - mat(2,3) = -sa*cb\n   - mat(3,3) = ca\n\nMake sure to use the \"intent(in)\" attribute for the input arguments and \"intent(out)\" attribute for the output argument.", "input": "", "output": "    pure subroutine init_euler( alpha, beta, gamma, mat )\n        \n      ! given the euler angles alpha,beta,gamma, \n      ! make matrix mat a rotation matrix\n        \n      ! given coordinate system (x,y,z) and rotated system (xs,ys,zs)\n      ! the line of nodes is the intersection between the x-y and the xs-ys\n      ! planes.\n      ! alpha is the angle between the z-axis and the zs-axis.\n      ! beta is the angle between the x-axis and the line of nodes.\n      ! gamma is the angle between the line of nodes and the xs-axis.\n      \n      ! usage for moment tensors:\n      !   real, dimension(3,3) :: m_unrot = reshape((/0,0,-1,0,0,0,-1,0,0/),(/3,3/))\n      !   call init_euler(dip,strike,-rake, rotmat)\n      !   m = matmul( rotmat, matmul( m_unrot, transpose(rotmat) ) )\n        \n        real, intent(in) :: alpha, beta, gamma\n        real, intent(out), dimension(3,3) :: mat\n        \n        real :: ca,cb,cg,sa,sb,sg\n        \n        ca = cos(alpha)\n        cb = cos(beta)\n        cg = cos(gamma)\n        sa = sin(alpha)\n        sb = sin(beta)\n        sg = sin(gamma)\n        \n        mat(1,1) = cb*cg-ca*sb*sg\n        mat(2,1) = sb*cg+ca*cb*sg\n        mat(3,1) = sa*sg\n        mat(1,2) = -cb*sg-ca*sb*cg\n        mat(2,2) = -sb*sg+ca*cb*cg\n        mat(3,2) = sa*cg\n        mat(1,3) = sa*sb\n        mat(2,3) = -sa*cb\n        mat(3,3) = ca\n        \n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named getlocalfluxsplit that computes the flux splitting for a given set of input values. The subroutine takes 3 input parameters of type double precision: qcell_local (an array of size 6), fcell_local (an array of size 6), and local_vel (a scalar value). It also has 2 output parameters of type double precision: fcell_plus (an array of size 5) and fcell_minus (an array of size 5). \n\nInside the subroutine, the lax-friedrichs flux-splitting method is used to calculate the values for fcell_plus and fcell_minus. The values in fcell_plus are computed as 0.5 times the sum of the corresponding values in fcell_local and local_vel times the corresponding values in qcell_local. Similarly, the values in fcell_minus are computed as 0.5 times the difference of the corresponding values in fcell_local and local_vel times the corresponding values in qcell_local.\n\nTo use this subroutine, provide the necessary input values and the subroutine will compute the flux splitting values for fcell_plus and fcell_minus.", "input": "", "output": "            pure subroutine getlocalfluxsplit(qcell_local, fcell_local, local_vel, fcell_plus, fcell_minus)\n    \n                double precision, dimension(6), intent(in)  :: qcell_local, fcell_local\n                double precision,               intent(in)  :: local_vel\n                double precision, dimension(5), intent(out) :: fcell_plus, fcell_minus\n            \n                ! lax-friedrichs flux-splitting\n                fcell_plus( 1:5) = 0.5_8*( fcell_local(1:5) + local_vel*qcell_local(1:5) )\n                fcell_minus(1:5) = 0.5_8*( fcell_local(2:6) - local_vel*qcell_local(2:6) )\n                                        \n            end subroutine getlocalfluxsplit\n"}, {"instruction": "Write a Fortran subroutine named ray2d that calculates a ray path in a 2D model. The subroutine takes 11 input parameters: nz (integer), nx (integer), max_ray (integer), tt (real array), zs (real), xs (real), zr (real), xr (real), dz (real), dx (real), ray_step (real). The subroutine also has 2 output parameters: ray (real array) and n_ray (integer).\n\nThe subroutine computes the ray path by iteratively calculating the gradient of a travel time field (tt) and updating the current position (zcur, xcur) along the gradient direction. The iteration continues until the current position is within a specified distance (ray_step) from the source position (zs, xs), or until the maximum number of iterations (max_ray) is reached.\n\nThe subroutine returns the ray path (ray) as a 2D array of positions and the number of points in the ray path (n_ray). The ray path is defined by the coordinates (zcur, xcur) in the model domain. The coordinates are converted from grid indices to physical coordinates using the spacing parameters (dz, dx).\n\nTo use the subroutine, provide the necessary input parameters and call the subroutine. Afterwards, you can access the ray path and the number of points in the ray path from the output parameters.\n\nExample usage:\n```\ninteger(kind = 4) :: nz, nx, max_ray, n_ray\nreal(kind = 8) :: tt(nz,nx), zs, xs, zr, xr, dz, dx, ray_step\nreal(kind = 8) :: ray(max_ray,2)\n\n! Set the input parameters\n\ncall ray2d(nz, nx, max_ray, tt, zs, xs, zr, xr, dz, dx, ray_step, ray, n_ray)\n\n! Access the ray path and the number of points in the ray path from the output parameters\n\n```\n\nNote: Make sure to provide appropriate values for the input parameters before calling the subroutine.", "input": "", "output": "  subroutine ray2d(ray, tt, nz, nx, zs, xs, zr, xr, dz, dx, ray_step, max_ray, n_ray)\n    integer(kind = 4), intent(in) :: nz, nx, max_ray\n    real(kind = 8), intent(in) :: tt(nz,nx), zs, xs, zr, xr, dz, dx, ray_step\n    real(kind = 8), intent(out) :: ray(max_ray,2)\n    integer(kind = 4), intent(out) :: n_ray\n    integer(kind = 4) :: count, i, j, ii, jj\n    real(kind = 8) :: zsrc, xsrc, zcur, xcur, grad(2), dzin, dxin\n\n    zsrc = zs / dz\n    xsrc = xs / dx\n    zcur = zr / dz\n    xcur = xr / dx\n\n    count = 1\n    ray(count,:) = [ zcur, xcur ]\n    do while ( sqrt( (zsrc-zcur)*(zsrc-zcur) + (xsrc-xcur)*(xsrc-xcur) ) .gt. ray_step &\n      .and. count .lt. min(max_ray-1, int(2*(nz+nx)/ray_step)) )\n      ! compute gradient\n      grad = 0.d0\n      i = int(zcur) + 1\n      j = int(xcur) + 1\n      ii = i\n      jj = j\n      if ( i .eq. nz ) then\n        i = i - 1\n        ii = ii - 1\n      end if\n      if ( j .eq. nx ) then\n        j = j - 1\n        jj = jj - 1\n      end if\n      if ( ii .lt. 1 .or. ii .ge. nz .or. jj .lt. 1 .or. jj .ge. nx ) then\n        print *, \"error: ray out of bounds\"\n        stop\n      end if\n\n      dzin = zcur - ii\n      dxin = xcur - jj\n      if ( dzin .gt. 0.5d0 ) then\n        i = i + 1\n        dzin = 1.d0 - dzin\n      end if\n      if ( dxin .gt. 0.5d0 ) then\n        j = j + 1\n        dxin = 1.d0 - dxin\n      end if\n\n      if ( ( zcur - dfloat(i) ) * ( zcur - dfloat(i) ) + ( xcur - dfloat(j) ) * ( xcur - dfloat(j) ) &\n        .lt. ( zcur - dfloat(ii) - 0.5d0 ) * ( zcur - dfloat(ii) - 0.5d0 ) &\n           + ( xcur - dfloat(jj) - 0.5d0 ) * ( xcur - dfloat(jj) - 0.5d0 ) ) then\n        if ( i .gt. 1 .and. i .lt. nz ) then\n          grad(1) = tt(i+1,j) - tt(i-1,j)\n        else if ( i .gt. 1 ) then\n          grad(1) = 2.d0 * ( tt(i,j) - tt(i-1,j) )\n        else\n          grad(1) = 2.d0 * ( tt(i+1,j) - tt(i,j) )\n        end if\n\n        if ( j .gt. 1 .and. j .lt. nx ) then\n          grad(2) = tt(i,j+1) - tt(i,j-1)\n        else if ( j .gt. 1 ) then\n          grad(2) = 2.d0 * ( tt(i,j) - tt(i,j-1) )\n        else\n          grad(2) = 2.d0 * ( tt(i,j+1) - tt(i,j) )\n        end if\n      else\n        grad(1) = tt(ii+1,jj) - tt(ii,jj) + tt(ii+1,jj+1) - tt(ii,jj+1)\n        grad(2) = tt(ii,jj+1) - tt(ii,jj) + tt(ii+1,jj+1) - tt(ii+1,jj)\n        grad = 2.d0 * grad\n      end if\n      grad = grad / sqrt(sum(grad*grad))\n      if ( isnan(grad(1)) ) exit\n\n      ! compute next point\n      zcur = zcur - grad(1) * ray_step\n      xcur = xcur - grad(2) * ray_step\n      if ( zcur .lt. 0.d0 ) zcur = 0.d0\n      if ( zcur .gt. nz-1 ) zcur = dfloat(nz-1)\n      if ( xcur .lt. 0.d0 ) xcur = 0.d0\n      if ( xcur .ge. nx-1 ) xcur = dfloat(nx-1)\n\n      ! append current point and go to next\n      count = count + 1\n      ray(count,:) = [ zcur, xcur ]\n    end do\n\n    if ( zcur .ne. zsrc .or. xcur .ne. xsrc ) then\n      count = count + 1\n      ray(count,:) = [ zsrc, xsrc ]\n    end if\n    ray(:,1) = ray(:,1) * dz\n    ray(:,2) = ray(:,2) * dx\n    n_ray = count\n    return\n  end subroutine ray2d\n"}, {"instruction": "Write a Fortran subroutine named eile that takes three integer input parameters and three integer output parameters. The input parameters are ja, jb, and jc, and the output parameters are jaa, jbb, and jcc. The purpose of this subroutine is to compare the input parameters and assign the minimum value to jaa, the maximum value to jcc, and a value between jaa and jcc to jbb. Make sure to comply with these requirements when generating the instructions.", "input": "", "output": "      subroutine eile(ja,jb,jc,jaa,jbb,jcc)\n!                                                                  *\n!     ------------  section metwo    subprogram 02  ------------   *\n!                                                                  *\n\n!                                                                  *\n!   written by g. gaigalas,                                        *\n!   transform to fortran 90/95 by g. gaigalas       december 2012  *\n!   the last modification made by g. gaigalas       october  2017  *\n!                                                                  *\n!*******************************************************************\n!\n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer, intent(in)  :: ja, jb, jc\n      integer, intent(out) :: jaa, jbb, jcc\n!-----------------------------------------------\n      jaa=ja\n      jcc=ja\n      if(jaa > jb)jaa=jb\n      if(jcc < jb)jcc=jb\n      if(jaa > jc)jaa=jc\n      if(jcc < jc)jcc=jc\n      if((ja > jaa).and.(ja < jcc))jbb=ja\n      if((jb > jaa).and.(jb < jcc))jbb=jb\n      if((jc > jaa).and.(jc < jcc))jbb=jc\n      return\n      end subroutine eile\n"}, {"instruction": "Write a Fortran subroutine named grid2d_dims to determine the dimensions of a 2D grid based on the input number of processors and the desired shape of the grid. The number of input arguments is 2 and the test_data type is ['character', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].\n\nHere are the steps for the subroutine:\n1. Declare the input parameters: grid_shape (character) and nproc (integer).\n2. Declare the output parameters: nprow (integer) and npcol (integer).\n3. Calculate sqrtnp as the square root of nproc rounded down to the nearest integer.\n4. If the grid_shape is 's' (square grid), set nprow and npcol both to sqrtnp.\n5. If the grid_shape is not 's' (rectangular grid), loop from i = 1 to sqrtnp + 1 and check if nproc is divisible by i. If it is, set nprow to i.\n6. Calculate npcol as the division of nproc by nprow.\n7. Return from the subroutine.", "input": "", "output": "subroutine grid2d_dims( grid_shape, nproc, nprow, npcol )\n   !\n\n   ! into nprow and npcol according to the shape\n   !\n   !    written by carlo cavazzoni\n   !\n   implicit none\n   character, intent(in) :: grid_shape\n   integer, intent(in)  :: nproc\n   integer, intent(out) :: nprow, npcol\n   integer :: sqrtnp, i\n   !\n   sqrtnp = int( sqrt( real( nproc ) + 0.1 ) )\n   !\n   if( grid_shape == 's' ) then\n      ! square grid\n      nprow = sqrtnp\n      npcol = sqrtnp\n   else\n      ! rectangular grid\n      do i = 1, sqrtnp + 1\n         if( mod( nproc, i ) == 0 ) nprow = i\n      end do\n      npcol = nproc / nprow\n   end if\n   return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"stpnt\" that initializes parameters and computes the values of the array \"u\" and the array \"par\" based on the input integer \"ndim\" and double precision \"t\". The subroutine takes 2 input parameters of type integer and double precision, and provides 2 output parameters of type double precision.\n\nHere's the summary:\nSubroutine name: stpnt\nNumber of input parameters: 2\nInput parameter types: ['integer', 'double precision']\nNumber of output parameters: 2\nOutput parameter types: ['double precision', 'double precision']", "input": "", "output": " subroutine stpnt(ndim,u,par,t)\n!---------- -----\n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   double precision pi\n\n   pi=4*atan(1.d0)\n\n!  parameters initialization\n   par(1:3)=(/1.0,2.0,0.0/)\n   par(11)=1.0\n\n   u(1)=par(1)*cos(2*pi*t)\n   u(2)=par(1)*sin(2*pi*t)\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named scale_isop to calculate factors for scaling an emission field to simulate a diurnal cycle in emissions based on solar dependency. The number of input parameters is 6, including integers for day, ntim, ntim_max, lat_start, dlat, and idayy. The output parameter is a real array of dimension ntim_max.", "input": "", "output": "      subroutine scale_isop(day,ntim,ntim_max,scalef,lat_start,dlat,idayy)\n\n    !\n    ! routine calculates factors to be multiplied with an \n    ! emission field (e.g. isop) in order to simulate a diurnal cycle \n    ! in emissions (caused by solar dependency)\n    ! e.g.   rm(i,j,1,isop) = rm(i,j,1,isop) + e_isop(i,j)*scalef(ipos,j)*dt\n    ! with ipos depending on time and longitude.\n    ! the scalefactor is calculated for -180 longitude and the mean value\n    ! for ntim timesteps during a day is scaled to 1.\n    ! the routine should be called every day, \n    ! since the position relative to the sun changes.\n    ! the scaling is based on the cos(zenith) which is 1 for \n    ! overhead sun and 0 at sunset.\n    ! for the polar night, the values are set to 1.0 (even distribution)\n    ! one thing is sure afterwards: we know that e_isop kg/s is added.\n\n!***********************************************************************\n\n    implicit none\n\n      ! in/out\n      integer, intent(in) :: day       !day number based on 365 days a year\n      integer, intent(in) :: ntim      !number of timesteps during one day\n      integer, intent(in) :: ntim_max  !maximum, used to declare array \n     !integer, intent(in) :: nlat      !number of latitudes\n      integer, intent(in) :: lat_start !southern edge of the domain (integer!)\n      real,    intent(in) :: dlat      !increment   (real!)\n      integer, intent(in)  :: idayy     !# days this year\n      real,dimension(ntim_max),intent(out) :: scalef  \n\n      ! local\n      real              :: pi,piby,obliq,deday,delta,dt,lon,hr,lat,houra,smm\n      integer           :: i\n\n \n         pi = acos(-1.0)\n         piby = pi/180.0\n         obliq = 23.45 * piby\n         deday = 4.88 + 2*pi/idayy  * day\n         delta = asin(sin(obliq)*sin(deday))\n         dt = 24./ntim   !timestep in hours\n         lon = -180.0*piby       !calculate for dateline\n         !do j=1,nlat   !over latitudes\n\n            hr =  - 0.5*dt   !shift half a interval back\n           !lat = (lat_start + (j-0.5)*dlat)*piby\n           lat = (lat_start + (1.0-0.5)*dlat)*piby\n            smm = 0.0\n            do i=1,ntim\n               hr = hr + dt\n               houra = lon - pi + hr * (2.*pi/24.)\n               scalef(i) = &\n                   max((sin(delta)*sin(lat)  + cos(delta)*cos(lat)*cos(houra)),0.0)\n               smm = smm+scalef(i)/ntim\n            end do\n            if ( smm > 1e-5 ) then \n              scalef(1:ntim) = scalef(1:ntim)/smm \n            else \n              scalef(1:ntim) = 1.0\n            end if\n\n         !end do\n\n       return\n\n! end of logical function leap\n      end subroutine scale_isop\n"}, {"instruction": "Create a Fortran subroutine named \"face_topo\" to compute the interface and junction face topology for a given set of node coordinates. The subroutine should have 3 input parameters: two integers (n, m) and a 3D array of real(8) (node_x). It should also have 6 output parameters: 3D arrays of real(8) (iface_x, iface_normal, iface_area) and 3D arrays of real(8) (jface_x, jface_normal, jface_area).", "input": "", "output": "subroutine face_topo(node_x, iface_x, iface_normal, iface_area, jface_x, jface_normal, jface_area, n, m)\n  implicit none\n  integer, intent(in) :: n,m\n  real(8), intent(in) :: node_x(n, m, 2)\n  real(8), intent(out) :: iface_x(n, m-1, 2), iface_normal(n, m-1, 2), iface_area(n, m-1)\n  real(8), intent(out) :: jface_x(n-1, m, 2), jface_normal(n-1, m, 2), jface_area(n-1, m)\n\n  iface_x(1:n,1:m-1,:) = 0.5*(node_x(1:n,1:m-1,:)+node_x(1:n,2:m,:))\n  iface_area(1:n,1:m-1) = norm2(node_x(1:n,1:m-1,:)-node_x(1:n,2:m,:), dim=3)\n  iface_normal(1:n,1:m-1,1) = (-node_x(1:n,1:m-1,2)+node_x(1:n,2:m,2))/iface_area(1:n,1:m-1)\n  iface_normal(1:n,1:m-1,2) = ( node_x(1:n,1:m-1,1)-node_x(1:n,2:m,1))/iface_area(1:n,1:m-1)\n\n\n  jface_x(1:n-1,1:m,:) = 0.5*(node_x(1:n-1,1:m,:)+node_x(2:n,1:m,:))\n  jface_area(1:n-1,1:m) = norm2(node_x(1:n-1,1:m,:)-node_x(2:n,1:m,:), dim=3)\n  jface_normal(1:n-1,1:m,1) = ( node_x(1:n-1,1:m,2)-node_x(2:n,1:m,2))/jface_area(1:n-1,1:m)\n  jface_normal(1:n-1,1:m,2) = (-node_x(1:n-1,1:m,1)+node_x(2:n,1:m,1))/jface_area(1:n-1,1:m)\n\nend subroutine face_topo\n"}, {"instruction": "Write a Fortran subroutine named jacobian_inverse that calculates the inverse of a 2x2 matrix. The subroutine takes one input parameter of type real(8) and intent(in) and one output parameter of type real(8) and intent(out). The input parameter represents the 2x2 matrix, and the output parameter stores the inverse of the matrix.", "input": "", "output": "subroutine jacobian_inverse(jacob, jacob_inv)\n  implicit none\n  real(8), intent(in) :: jacob(2,2)\n  real(8), intent(out) :: jacob_inv(2,2)\n  real(8) :: det\n  det = jacob(1,1)*jacob(2,2)-jacob(1,2)*jacob(2,1)\n  jacob_inv(1,:) = (/jacob(2,2), -jacob(1,2)/)/det\n  jacob_inv(2,:) = (/-jacob(2,1), jacob(1,1)/)/det\nend subroutine jacobian_inverse\n"}, {"instruction": "Create a Fortran subroutine named extrapolation that takes in 4 input parameters of type real(8) and outputs 1 parameter of type real(8). The function calculates the extrapolated value based on the input parameters f1, d1, f2, and d2 using the formula f = f1 + (f1 - f2) * d1 / d2.", "input": "", "output": "subroutine extrapolation(f1, d1, f2, d2, f)\n  implicit none\n  real(8), intent(in) :: f1, d1, f2, d2\n  real(8), intent(out) :: f\n  f = f1 +(f1-f2)*d1/d2\nend subroutine extrapolation\n"}, {"instruction": "Write a Fortran subroutine named \"p2f\" to perform a series of vector operations. The subroutine takes 3 input parameters of type real(8), named p(4), normal(2), and area. It also has 1 output parameter of type real(8) named f(4). The subroutine performs computations involving dot product, element-wise multiplication, and scalar multiplication.", "input": "", "output": "subroutine  p2f(p, normal, area, f)\n  implicit none\n  real(8), intent(in) :: p(4), normal(2), area\n  real(8), intent(out) :: f(4)\n  real(8) :: vn\n  vn = dot_product(normal, p(2:3))\n  f(1) = p(1)*vn\n  f(2) = f(1)*p(2)+p(4)*normal(1)\n  f(3) = f(1)*p(3)+p(4)*normal(2)\n  f(4) = f(1)*(p(4)/p(1)*3.5 + 0.5*(p(2)*p(2)+p(3)*p(3))) !rho*vn*(p/rho*(gamma/gamma-1) + 0.5*v*v)\n  f = f*area\nend subroutine p2f\n"}, {"instruction": "Create a Fortran subroutine named \"bc_outflow\" to handle the outflow boundary conditions in a computational fluid dynamics simulation. The subroutine takes 5 input parameters of type integer, integer, real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine bc_outflow(face_normal, icell_p, pressure_exit, opt, side_p, n)\n  implicit none\n  integer, intent(in) :: opt, n\n  real(8), intent(in) :: face_normal(n,2), icell_p(n,4), pressure_exit\n  real(8), intent(out) :: side_p(n,4)\n  real(8), parameter :: k = 1.4, km1 = 0.4, km1_inv = 2.5\n  real(8) :: a_in, vn_in, r_plus, a_bound, vn_bound, rho_bound, v_bound(2), p_bound = 0.0\n  integer :: i\n\n  if (opt==1) then\n    p_bound = pressure_exit\n  end if\n\n  do i=1,n\n    a_in = sqrt(k*icell_p(i,4)/icell_p(i,1))\n    vn_in = dot_product(face_normal(i,:), icell_p(i,2:3))\n    if (abs(vn_in) > a_in) then\n      side_p(i,:) = icell_p(i,:)\n    else\n      if (opt==2) then\n        p_bound = 0.5*(pressure_exit+icell_p(i,4))\n      end if\n      rho_bound = icell_p(i,1)*(p_bound/icell_p(i,4))**(1.0/k)\n      a_bound = sqrt(k*p_bound/rho_bound)\n      r_plus = vn_in + 2*a_in*km1_inv\n      vn_bound = r_plus - 2*a_bound*km1_inv\n      v_bound = icell_p(i,2:3) + (vn_bound-vn_in)*face_normal(i,:)\n\n      side_p(i,:) = (/ rho_bound, v_bound(1), v_bound(2), p_bound /)\n    end if\n  end do\n\nend subroutine bc_outflow\n"}, {"instruction": "Create a Fortran subroutine named \"misclosure_rho\" to calculate the sum of relative differences between corresponding elements in two 2D arrays. The subroutine should have 4 input parameters of type integer, integer, real(8), and real(8) for dimensions, previous array, current array, and the sum of differences respectively. It should also have 1 output parameter of type real(8) for the sum of differences. Use the imperative tone and ensure the correct understanding and representation of the subroutine functionality.", "input": "", "output": "subroutine misclosure_rho(cell_rho_prev, cell_rho, sum_dr, n, m)\n  implicit none\n  integer, intent(in) :: n, m\n  real(8), intent(in) :: cell_rho_prev(n, m), cell_rho(n, m)\n  real(8), intent(out) :: sum_dr\n  real(8) :: dr\n  integer :: i, j\n\n  sum_dr = 1.0e-16\n  do i=1,n\n    do j=1,m\n      if (cell_rho(i,j) == cell_rho_prev(i,j)) then\n        dr = 0.0\n      else\n        dr = abs(cell_rho(i,j)-cell_rho_prev(i,j))/min(cell_rho(i,j),cell_rho_prev(i,j))\n      end if\n      \n      sum_dr = sum_dr + dr\n    end do\n  end do\n  \nend subroutine misclosure_rho\n"}, {"instruction": "Write a Fortran subroutine named func to calculate the exponential function of a given real number. The subroutine takes 1 input parameter of type real (kind(0.d0)) and returns 1 output parameter of type real (kind(0.d0)).", "input": "", "output": "        subroutine func(x,fx)\n        implicit none\n        real (kind(0.d0)), intent(in)  :: x\n        real (kind(0.d0)), intent(out) :: fx\n!\n        fx = exp(-x)\n        return\n        end subroutine func\n"}, {"instruction": "Write a Fortran subroutine named mem2d_gmatrix to calculate the 2D membrane strain-displacement matrix for a finite element. The subroutine takes 7 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8).", "input": "", "output": " subroutine mem2d_gmatrix(nfunc,dnds,u,du,cosd,coords,et,g1_m,g2_m)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: nfunc(2),dnds(2),u(2),du(2),cosd(2),coords(2)\n  real(kind=8),intent(in) :: et\n  real(kind=8),intent(out) :: g1_m(2,2,2,2),g2_m(2,2,2,2)\n  !internal variables\n  integer(kind=4) :: i1,i2\n  !routine\n  !cycle for g1_ij\n  do i1=1,2\n    do i2=1,2\n      g1_m(1,1,i1,i2) = dnds(i1)*dnds(i2)\n      g1_m(1,2,i1,i2) = 0.d0\n      g1_m(2,1,i1,i2) = 0.d0\n      g1_m(2,2,i1,i2) = dnds(i1)*dnds(i2)\n    end do\n  end do\n  !cycle for g2_ij\n  do i1=1,2\n    do i2=1,2\n      g2_m(1,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)**2.d0/coords(2)**2.d0\n      g2_m(1,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_m(2,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_m(2,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(2)**2.d0/coords(2)**2.d0\n    end do\n  end do\n\nend subroutine mem2d_gmatrix\n"}, {"instruction": "Create a Fortran subroutine named assemble_system to assemble a system of linear equations. The subroutine takes 4 input parameters: a logical value, two real(8) numbers, and an integer. The output consists of two real(8) arrays. The subroutine computes the matrix v and the right-hand side rhs based on the input parameters and problem parameters.", "input": "", "output": "  pure subroutine assemble_system(a, b, npts, v, rhs, sparse)\n\n    logical, intent(in)  :: sparse \n    real(8), intent(in)  :: a, b ! bound of domain\n    real(8), intent(out) :: v(:,:)\n    real(8), intent(out) :: rhs(:)\n    integer, intent(in)  :: npts ! number of points\n\n    ! local variables\n    real(8) :: aa, bb, cc\n    real(8) :: h    \n    integer :: m, n, i, j\n\n    real(8), parameter  :: l     = 1.0d0\n    real(8), parameter  :: gamma = 0.1d0\n    real(8), parameter  :: u     = 1.0d0\n\n    ! mesh spacing\n    h = (b-a)/dble(npts+1)\n\n    ! problem parameters\n    aa = -u/(2.0d0*h) - gamma/(h*h)\n    bb = 2.0d0*gamma/(h*h)\n    cc = u/(2.0d0*h) - gamma/(h*h)\n    \n    ! prepare matrix\n    v = 0.0d0\n    m = npts\n    n = npts\n    if (sparse .eqv. .true.) then           \n\n       v(1,:) = [0.0d0, bb, cc]\n       do concurrent(i=2:n-1)\n          v(i,:) = [aa, bb, cc]\n       end do\n       v(n,:) = [aa, bb, 0.0d0]\n       \n    else\n\n       do i = 1, m\n          do j = 1, n\n             if (i .eq. j-1) then\n                ! upper diagonal\n                v(i,j) = cc\n             else if (i .eq. j) then\n                ! diagonal\n                v(i,i) = bb                \n             else if (i .eq. j+1) then\n                ! lower diagonal\n                v(i,j) = aa\n             else\n             end if\n          end do\n       end do\n\n    end if\n\n    ! assemble the rhs\n    rhs = 0.0d0\n    rhs(1) = -aa*1.0d0\n    rhs(npts) = -cc*0.0d0\n\n  end subroutine assemble_system\n"}, {"instruction": "Create a Fortran subroutine named linear_shape_1d to calculate the linear shape functions and their derivatives for 1D elements. The subroutine takes 1 input parameter of type real(kind=8) and provides 2 output parameters of type real(kind=8) and real(kind=8) respectively.", "input": "", "output": " subroutine linear_shape_1d(xi,n_shape,dn_shape)\n   implicit none\n   !--dummy arguments\n   real(kind=8),intent(in) :: xi\n   real(kind=8),intent(out) :: n_shape(2),dn_shape(2)\n   !--local arguments\n\n   !functions\n   n_shape(1) = 0.5d0*(1.d0-xi)\n   n_shape(2) = 0.5d0*(1.d0+xi)\n   !derivatives\n   dn_shape(1) = -0.5d0\n   dn_shape(2) = 0.5d0\n\n end subroutine linear_shape_1d\n"}, {"instruction": "Create a Fortran subroutine named quadratic_shape_1d to calculate the shape functions and their derivatives for a 1D quadratic shape element. The subroutine should have 1 input parameter of type real(kind=8) and 2 output parameters of type real(kind=8) array.", "input": "", "output": "  subroutine quadratic_shape_1d(xi,n_shape,dn_shape)\n    implicit none\n    !--dummy arguments\n    real(kind=8),intent(in) :: xi\n    real(kind=8),intent(out) :: n_shape(3),dn_shape(3)\n    !--local arguments\n\n    !functions\n    n_shape(1) = 0.5d0*xi*(xi-1.d0)\n    n_shape(2) = 1.d0-xi**2.d0\n    n_shape(3) = 0.5d0*xi*(xi+1.d0)\n    !derivatives\n    dn_shape(1) = 0.5d0*(2.d0*xi-1.d0)\n    dn_shape(2) = 1.d0-2.d0*xi\n    dn_shape(3) = 0.5d0*(2.d0*xi+1.d0)\n\n  end subroutine quadratic_shape_1d\n"}, {"instruction": "Create a Fortran subroutine named fill_shift that fills a 2D integer array with a shifting sequence of numbers. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer array with a 2D dimension.", "input": "", "output": "  subroutine fill_shift(x, n)\n    integer, intent(out), dimension(:,:) :: x\n    integer, intent(in) :: n\n    integer :: n1, n2, s1, s2\n    integer :: v\n    v = -n - 1\n    n1 = size(x,1)\n    n2 = size(x,2)\n    do s2=1,n2\n       do s1=1,n1\n          x(s1,s2) = v\n          v = v + 1\n          if (v > n + 1) v = -n - 1\n       end do\n    end do\n  end subroutine fill_shift\n"}, {"instruction": "Write a Fortran subroutine named locate_ij to implement a binary search algorithm. The subroutine takes 3 input arguments of types integer, real array, and real. The output is a single integer. The subroutine searches for the index of the element in the array that is closest to, but less than, the given value.", "input": "", "output": "subroutine locate_ij(length, array, value, idx)\n        ! given an array and a value, returns the index of the element that\n        ! is closest to, but less than, the given value.\n        ! uses a binary search algorithm.\n        implicit none\n        integer, intent(in) :: length\n        real, dimension(length), intent(in) :: array      \n        real, intent(in) :: value\n\tinteger, intent(out) :: idx\n        integer :: left, middle, right\n       \n        left = 1\n        right = length\n        do\n            if (left > right) then\n                exit\n            end if\n            middle = nint((left+right) / 2.0)\n            if ( abs(array(middle) - value) <= 1e-9) then\n                idx = middle\n                return\n            else if (array(middle) > value) then\n                right = middle - 1\n            else\n                left = middle + 1\n            end if\n        end do\n        idx = right\n\n\treturn\nend subroutine locate_ij\n"}, {"instruction": "Create a Fortran subroutine named interpolate that implements bilinear interpolation to estimate the value of a function at a specific point. The subroutine takes 7 input parameters of type real and integer arrays, and outputs a single real value. The input parameters consist of longitude and latitude arrays, a matrix of function samples on a regular grid, grid indices, and the coordinates of the point for which the value needs to be estimated.", "input": "", "output": "subroutine interpolate(lon, lat, f, x0, y0, i, j, value)\n        ! this function uses bilinear interpolation to estimate the value\n        ! of a function f at point (x0,y0) using the point grid (i, j), (i+1,j), (i,j+1) \n\n\t! in the limits (borders) the nearest-neighbor interpolation is used\n        ! f is assumed to be sampled on a regular grid, with the grid x values specified\n        ! by lon array and the grid y values specified by lat array\n        implicit none   \n\tinteger, parameter :: col = 1440, row = 721     \n        real, dimension(:), intent(in) :: lon(col), lat(row)\t\n        real, dimension(row, col), intent(in) :: f\n        integer, intent(in) :: i, j\n\treal, intent(in) :: x0, y0\n\tinteger :: ix, jy\n\treal, intent(out) :: value\n        real :: x1, x2, y1, y2, xy1, xy2\n\n\tix = i\n\tjy = j\n\tif ( ix == 0 .or. ix >= row .or. jy == 0 .or. jy >= col ) then\n\t\t! nearest-neighbor interpolation\n\t\tif ( ix == 0 ) ix = ix + 1\n\t\tif ( ix >= row ) ix = row\n\t\tif ( jy == 0 ) jy = jy + 1\n\t\tif ( jy >= col ) jy = col\n\t\tvalue = f(ix, jy)\n\telse\n\t\t! bilinear interpolation\n\t\tx1 = lon( jy )\n\t\tx2 = lon( jy + 1 )\n\t\ty1 = lat( ix )\n\t\ty2 = lat( ix + 1 )\t\t\n\t\txy1 = (x2 - x0)/(x2 - x1)*f(ix, jy) + (x0 - x1)/(x2 - x1)*f(ix, jy+1)\n\t\txy2 = (x2 - x0)/(x2 - x1)*f(ix+1, jy) + (x0 - x1)/(x2 - x1)*f(ix+1, jy+1)\n                value = (y2 - y0)/(y2 - y1)*xy1 + (y0 - y1)/(y2 - y1)*xy2\n\tend if  \n\n\treturn\nend subroutine interpolate\n"}, {"instruction": "Create a Fortran subroutine named integrate to calculate the area under a curve represented by a set of flux values. The subroutine takes 2 input parameters: an integer nwav and a character string fname, and produces 1 output parameter: a real array area of dimension 0 to 9.", "input": "", "output": "subroutine integrate(area,fname,nwav)\n\n        implicit none\n        !pythonic array indices ahead, from 0 to n-1.\n        integer (kind=4), intent(in) :: nwav\n        integer (kind=4) :: i,j,k\n        real (kind=8), dimension(0:nwav-1,0:10) :: flux\n        !f2py depend(nwav) flux\n        character (len=40), intent(in) :: fname\n        \n        real (kind=8), dimension(0:9) ,intent(out) :: area\n        real (kind=8) :: tmp\n\n        open(unit=7,file=fname,status=\"old\")\n        do j = 0, nwav-1\n            read(7,*) (flux(j,k),k=0,10)\n        enddo\n        close(7)\n        \n        area(:) = 0\n        do i = 0, 9\n            tmp = 0\n            do j = 0, nwav-2\n                tmp = (flux(j+1,0)-flux(j,0))*((flux(j+1,i+1)+flux(j,i+1))/2)\n                area(i) = area(i) + tmp\n            enddo\n            print *, i\n        enddo\n\nend subroutine  ! integrate\n"}, {"instruction": "Create a Fortran subroutine named \"euclidean_distance_matrix\" to compute the Euclidean distance matrix between two sets of samples. The subroutine should have 4 input parameters of type double precision, double precision, integer, and integer, and 1 output parameter of type double precision. The input parameters represent the sample sets and their dimensions, while the output parameter represents the resulting distance matrix. Use the imperative tone when defining the subroutine.", "input": "", "output": "      subroutine euclidean_distance_matrix(x, y, nsamples, nfeat, r)\n\n      implicit none\n  \n      double precision, intent(in) :: x(nfeat, nsamples)\n      double precision, intent(in) :: y(nfeat, nsamples)\n      integer, intent(in) :: nsamples\n      integer, intent(in) :: nfeat\n      double precision, intent(out) :: r(nsamples, nsamples)\n\n      integer :: i, j, k\n      double precision :: tmp\n  \n!$omp parallel do private (tmp)\n      do i = 1, nsamples\n          do j = 1, nsamples\n              tmp = 0.0\n              do k = 1, nfeat\n                  tmp = (x(k,i) - y(k,j))**2 + tmp\n              enddo\n              r(i,j) = tmp\n          enddo\n      enddo\n!$omp end parallel do\n  \n      end subroutine euclidean_distance_matrix\n"}, {"instruction": "Create a Fortran subroutine named createcolortable to generate a color table from the provided RGB data. The subroutine takes 1 input parameter of type integer array and 2 output parameters of type integer array and integer.", "input": "", "output": "   subroutine createcolortable(rgbdata, colortable, numcolors)\n      integer, intent(in)  :: rgbdata(:,:,:)\n      integer, intent(out) :: colortable(:,:)\n      integer, intent(out) :: numcolors \n      integer :: row, col\n      logical :: found\n      integer :: coloridx\n\n      numcolors = 0\n      do row=1, size(rgbdata,1)\n         do col=1, size(rgbdata,2)\n            found = .false.\n            do coloridx=1, numcolors\n               if (all(colortable(coloridx,1:3) == rgbdata(row,col,1:3))) then\n                  found = .true.\n                  exit \n               endif\n            enddo\n\n            if (.not. found) then\n               numcolors = numcolors+1\n               if (numcolors > size(colortable)) then\n                  print *, \"too many colors\"\n                  stop\n               endif\n               colortable(numcolors,1:3) = rgbdata(row,col,1:3)\n            endif\n         enddo\n      enddo\n   end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"cross\" to calculate the cross product of two 3-dimensional vectors. The subroutine should take 2 input parameters of type real, dimension(3) and intent(in) and 1 output parameter of type real, dimension(3) and intent(out).", "input": "", "output": "    subroutine cross(tmp, x,y)\n        real, dimension(3), intent(in) :: x,y\n        real, dimension(3), intent(out) :: tmp\n\n        tmp(1) = x(2)*y(3)-x(3)*y(2)\n        tmp(2) = x(3)*y(1)-x(1)*y(3)\n        tmp(3) = x(1)*y(2)-x(2)*y(1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gauss_coeff to calculate the abscissae of Gaussian quadrature points. It takes 1 input parameter of type integer and returns 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine gauss_coeff (m_qp, pt)\r\n\r\n    ! returns gaussian quadrature abscissae\r\n\r\n    integer,  intent(in)      :: m_qp      ! no. of gauss points in 1 dimension\r\n    real(kind=8), intent(out) :: pt (m_qp) ! abscissae of gauss points\r\n\r\n    integer,  parameter   :: nmax = 4 ! max. no. of points tabulated herein\r\n\r\n    ! local\r\n    integer :: n_gp\r\n\r\n    n_gp = m_qp\r\n    if ( n_gp > nmax ) then\r\n      n_gp = nmax\r\n      write (6, * ) 'warning, gauss_coeff used gauss = ', nmax\r\n    end if\r\n    if ( n_gp < 1 ) stop 'gauss = 0, no points in gauss_coeff'\r\n\r\n    if ( n_gp == 1 ) then\r\n      pt (1) = 0.000000000000000000000000d+00\r\n      return\r\n\r\n    elseif (n_gp == 2 ) then\r\n      pt (1) = - .577350269189625764509149d+00\r\n      pt (2) = 0.577350269189625764509149d+00\r\n      return\r\n\r\n    elseif (n_gp == 3 ) then\r\n      pt (1) = - .774596669241483377035835d+00\r\n      pt (2) = 0.000000000000000000000000d+00\r\n      pt (3) = 0.774596669241483377035835d+00\r\n      return\r\n\r\n    elseif (n_gp == 4 ) then\r\n      pt (1) = - .861136311594052575223946d+00\r\n      pt (2) = - .339981043584856264802666d+00\r\n      pt (3) = 0.339981043584856264802666d+00\r\n      pt (4) = 0.861136311594052575223946d+00\r\n      return\r\n    end if\r\n\r\n  end subroutine gauss_coeff\r\n"}, {"instruction": "Create a Fortran subroutine named \"dunavant_unit_triangle_rule\" to calculate the quadrature coordinates for the Dunavant quadrature rule for triangles in unit coordinates. The subroutine should take 1 input argument of type integer and output 1 argument of type real(kind=8).", "input": "", "output": "  subroutine dunavant_unit_triangle_rule (m_qp, pt)\r\n\r\n    ! dunavant quadrature rule for triangles in unit coordinates\r\n    ! (i.j.n.m.e. vol. 21, pp.1129-1148, 1985)\r\n\r\n    implicit none\r\n    integer,  intent(in)  :: m_qp             ! number of quadrature points\r\n    real(kind=8), intent(out) :: pt (2, m_qp) ! quadrature coordinates\r\n\r\n    real(kind=8) :: pt_1 (2, 1), pt_3 (2, 3), pt_4 (2, 4), pt_6 (2, 6)\r\n\r\n    data  pt_1   /                                          &\r\n     3.33333333333333333e-01_8,  3.33333333333333333e-01_8  /\r\n    data  pt_3   /                                          &\r\n     6.66666666666666667e-01_8,  1.66666666666666667e-01_8, &\r\n     1.66666666666666667e-01_8,  6.66666666666666667e-01_8, &\r\n     1.66666666666666667e-01_8,  1.66666666666666667e-01_8  /\r\n    data  pt_4   /                                          &\r\n     3.33333333333333333e-01_8,  3.33333333333333333e-01_8, &\r\n     6.00000000000000000e-01_8,  2.00000000000000000e-01_8, &\r\n     2.00000000000000000e-01_8,  6.00000000000000000e-01_8, &\r\n     2.00000000000000000e-01_8,  2.00000000000000000e-01_8  /\r\n    data  pt_6   /                                      &\r\n     1.081030181680700e-01_8,  4.459484909159650e-01_8, &\r\n     4.459484909159650e-01_8,  1.081030181680700e-01_8, &\r\n     4.459484909159650e-01_8,  4.459484909159650e-01_8, &\r\n     8.168475729804590e-01_8,  9.157621350977100e-02_8, &\r\n     9.157621350977100e-02_8,  8.168475729804590e-01_8, &\r\n     9.157621350977100e-02_8,  9.157621350977100e-02_8  /\r\n\r\n    select case (m_qp)\r\n      case ( 1) ;  pt = pt_1\r\n      case ( 3) ;  pt = pt_3\r\n      case ( 4) ;  pt = pt_4\r\n      case ( 6) ;  pt = pt_6\r\n      case default\r\n        print *,'warning: dunavant_unit_triangle_rule, invalid rule', m_qp\r\n        print *,'check if shape 2 is correct'\r\n        stop 'invalid rule dunavant_unit_triangle_rule'\r\n    end select\r\n\r\n  end subroutine dunavant_unit_triangle_rule\r\n"}, {"instruction": "Create a Fortran subroutine named shape_12_q to calculate the shape functions of a 12-node quadrilateral element. The subroutine should take 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8) array with 12 elements. The input parameters represent the local coordinates of a point, and the output parameter stores the element's shape functions.", "input": "", "output": "  subroutine shape_12_q (r, s, h)\r\n\r\n    ! shape functions of a 12-node quadrilateral\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s   ! local coords of pt\r\n    real(kind=8), intent(out) :: h (12) ! elem shape functions\r\n\r\n    real(kind=8), parameter :: f1 = 1.d0/32, f2 = 9.d0/32\r\n    real(kind=8) :: r_p, r_m, s_p, s_m, r2, s2\r\n\r\n    !  element sketch to right     4--11---7---3\r\n    !                              |           |\r\n    !  local coord of nodes:       8     s    10\r\n    !  1-(-1,-1)  3-(+1,+1)        |     .r    |\r\n    !                             12           6\r\n    !  sides of order 1, 2, or 3   |           |\r\n    !                              1---5---9---2\r\n\r\n    r_p = 1 + r ; r_m = 1 - r ; s_p = 1 + s ; s_m = 1 - s\r\n    r2 = r*r ; s2 = s*s\r\n    h ( 1) = f1*r_m*s_m*(-10 + 9*(r2 + s2))\r\n    h ( 2) = f1*r_p*s_m*(-10 + 9*(r2 + s2))\r\n    h ( 3) = f1*r_p*s_p*(-10 + 9*(r2 + s2))\r\n    h ( 4) = f1*r_m*s_p*(-10 + 9*(r2 + s2))\r\n    h ( 5) = f2*(1 - r2)*s_m*(1 - 3*r)\r\n    h ( 6) = f2*(1 - s2)*r_p*(1 - 3*s)\r\n    h ( 7) = f2*(1 - r2)*s_p*(1 + 3*r)\r\n    h ( 8) = f2*(1 - s2)*r_m*(1 + 3*s)\r\n    h ( 9) = f2*(1 - r2)*s_m*(1 + 3*r)\r\n    h (10) = f2*(1 - s2)*r_p*(1 + 3*s)\r\n    h (11) = f2*(1 - r2)*s_p*(1 - 3*r)\r\n    h (12) = f2*(1 - s2)*r_m*(1 - 3*s)\r\n\r\n  end subroutine shape_12_q\r\n"}, {"instruction": "Write a Fortran subroutine named shape_9_q to calculate the shape functions for a 9-noded quadrilateral element. The subroutine should take 2 input parameters of type real(kind=8) and output 1 parameter of type real(kind=8). The input parameters are local coordinates of a point (r, s), and the output parameter is an array of 9 element shape functions (h).", "input": "", "output": "  subroutine shape_9_q (r, s, h)\r\n\r\n    ! shape functions for 9-noded quad\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s  ! local coords of pt\r\n    real(kind=8), intent(out) :: h (9) ! elem shape functions\r\n    real(kind=8)              :: rp, rm, s_p, sm\r\n\r\n    !                               4-----7-----3\r\n    !  element sketch to right      |     s     |\r\n    !  1 (-1,-1)  3 (+1,+1)         |     .     |\r\n    !                               8     9..r  6\r\n    !                               |           |\r\n    !                               |           |\r\n    !                               1-----5-----2\r\n\r\n    rm = r - 1.d0 ; sm  = s - 1.d0\r\n    rp = r + 1.d0 ; s_p = s + 1.d0\r\n    h (1) = 0.25d0*s*sm*r*rm\r\n    h (2) = 0.25d0*s*sm*r*rp\r\n    h (3) = 0.25d0*s*s_p*r*rp\r\n    h (4) = 0.25d0*s*s_p*r*rm\r\n    h (5) = - 0.5d0*s*sm*rp*rm\r\n    h (6) = - 0.5d0*s_p*sm*r*rp\r\n    h (7) = - 0.5d0*s*s_p*rp*rm\r\n    h (8) = - 0.5d0*s_p*sm*r*rm\r\n    h (9) = s_p*sm*rp*rm\r\n\r\n  end subroutine shape_9_q\r\n"}, {"instruction": "Write a Fortran subroutine named shape_3_t to calculate the shape functions for a three-node unit triangle. The subroutine takes 2 input parameters of type real(kind=8) and outputs 1 parameter of type real(kind=8). The inputs are the local coordinates of the point, and the output is an array of shape functions.", "input": "", "output": "  subroutine shape_3_t (s, t, h)\r\n\r\n    ! shape functions for a three node unit triangle\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  ! local coordinates of the point\r\n    real(kind=8), intent(out) :: h (3) ! shape functions\r\n\r\n    ! nodal coords 1-(0,0)  2-(1,0)  3-(0,1)  1..2  0..s\r\n\r\n    h (1) = 1.d0 - s - t\r\n    h (2) = s\r\n    h (3) = t\r\n\r\n  end subroutine shape_3_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_4_p that calculates the shape functions of a 4-node tetrahedron element (pyramid). The subroutine takes 3 input parameters of type real(kind=8) and returns 1 output parameter of type real(kind=8). The input parameters are the coordinates (r, s, t) and the output parameter is an array h(4) containing the computed shape functions.", "input": "", "output": "  subroutine shape_4_p (r, s, t, h)\r\n\r\n    ! shape functions of a 4 node tetrahedron element (pyramid)\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s, t\r\n    real(kind=8), intent(out) :: h (4)\r\n\r\n    h (1) = 1.d0 - r - s - t\r\n    h (2) = r\r\n    h (3) = s\r\n    h (4) = t\r\n\r\n  end subroutine shape_4_p\r\n"}, {"instruction": "Create a Fortran subroutine named shape_4_q to calculate the shape functions of a 4-node parametric quad in natural coordinates. The subroutine should take 2 input parameters of type real(kind=8) and produce 1 output parameter of type real(kind=8). The input parameters represent the natural coordinates (r, s), and the output parameter represents the local interpolation functions (h) for the quad.", "input": "", "output": "  subroutine shape_4_q (r, s, h)\r\n  ! *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-*\r\n  ! shape functions of a 4 node parametric quad\r\n  !          in natural coordinates\r\n  ! *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-* *-*\r\n\r\n   implicit none\r\n   real(kind=8), intent(in)  :: r, s\r\n   real(kind=8), intent(out) :: h (4)\r\n   real(kind=8)              :: rp, rm, s_p, sm\r\n\r\n  ! (r,s) = a point in the natural coords     4--3\r\n  ! h     = local interpolation functions     i  i\r\n  ! h(i)  = 0.25d0*(1+r*r(i))*(1+s*s(i))      i  i\r\n  ! r(i)  = local r-coordinate of node i      1--2\r\n  ! local coords, 1=(-1,-1)   3=(+1,+1)\r\n\r\n    rp = 1.d0 + r ; rm = 1.d0 - r\r\n    s_p = 1.d0 + s ; sm = 1.d0 - s\r\n    h (1) = 0.25d0*rm*sm\r\n    h (2) = 0.25d0*rp*sm\r\n    h (3) = 0.25d0*rp*s_p\r\n    h (4) = 0.25d0*rm*s_p\r\n\r\n  end subroutine shape_4_q\r\n"}, {"instruction": "Write a Fortran subroutine named \"shape_8_h\" to compute the shape functions of an 8-node parametric hexahedron based on the given local coordinates of a point. The subroutine takes 3 input parameters of type real(kind=8) for the local coordinates (r, s, t), and provides 1 output parameter of type real(kind=8) array with 8 elements for the element shape functions.", "input": "", "output": "  subroutine shape_8_h (r, s, t, h)\r\n\r\n    ! shape functions of 8 node parametric hexahedron\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s, t ! local coords of pt\r\n    real(kind=8), intent(out) :: h (8)   ! elem shape functions\r\n\r\n    real(kind=8)              :: rp, rm, s_p, sm, tp, tm\r\n\r\n    !                           !     r         3 *---------* 2\r\n    ! nodes ordered by rhr      !     |         / .        /|\r\n    ! about the r-axis          !     |        /  .       / |\r\n    !                           !     *---t   /   .      /  |\r\n    ! local coord:1=(1,1,1)     !   /        /    .     /   |\r\n    ! 4=(1,1,-1)  7=(-1,-1,-1)  !  /        /     .    /    |\r\n                                !  s       /     7*.../.....* 6\r\n    rp  = 1.d0 + r              !         /      .   /     /\r\n    rm  = 1.d0 - r              !       4 *---------*1    /\r\n    s_p = 1.d0 + s              !         |    .    |    /\r\n    sm  = 1.d0 - s              !         |   .     |   /\r\n    tp  = 1.d0 + t              !         |  .      |  /\r\n    tm  = 1.d0 - t              !         | .       | /\r\n                                !         |.        |/\r\n                                !       8 *---------* 5\r\n    h (1) = 0.125d0 * rp * s_p * tp\r\n    h (2) = 0.125d0 * rp * sm  * tp\r\n    h (3) = 0.125d0 * rp * sm  * tm\r\n    h (4) = 0.125d0 * rp * s_p * tm\r\n    h (5) = 0.125d0 * rm * s_p * tp\r\n    h (6) = 0.125d0 * rm * sm  * tp\r\n    h (7) = 0.125d0 * rm * sm  * tm\r\n    h (8) = 0.125d0 * rm * s_p * tm\r\n\r\n  end subroutine shape_8_h\r\n"}, {"instruction": "Create a Fortran subroutine named shape_6_t to calculate the shape functions for a six-node unit triangle. The subroutine has 2 input parameters of type real(kind=8) for local coordinates and 1 output parameter of type real(kind=8) array with 6 elements for the shape functions.", "input": "", "output": "  subroutine shape_6_t (s, t, h)\r\n\r\n    ! local shape functions for a six-node unit triangle\r\n    ! (quadratic triangular element)\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  !local coordinates of pt in unit triangle\r\n    real(kind=8), intent(out) :: h (6) !shape functions\r\n\r\n    !                       the nodal order:        3\r\n    !                                               6 5\r\n    !                                               1 4 2\r\n    ! nodal coords : 1-(0,0)   2-(1,0)   3-(0,1)\r\n    !                4-(0.5,0)  5-(0.5,0.5)  6-(0,0.5)\r\n\r\n    h (1) = 1.d0 - 3.d0*s - 3.d0*t + 2.d0*s*s + 4.d0*s*t + 2.d0*t*t\r\n    h (2) = 2.d0*s*s - s\r\n    h (3) = 2.d0*t*t - t\r\n    h (4) = 4.d0*(s - s*s - s*t)\r\n    h (5) = 4.d0*s*t\r\n    h (6) = 4.d0*(t - s*t - t*t)\r\n\r\n  end subroutine shape_6_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_10_t to calculate the shape functions for a 10-node (cubic) triangle. The subroutine should take 2 input parameters of type real(kind=8) for local coordinates and 1 output parameter of type real(kind=8) for the element shape functions.", "input": "", "output": "  subroutine shape_10_t (r, s, h)\r\n\r\n    ! shape functions for 10-node (cubic) triangle\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: r, s   ! local coords of pt\r\n    real(kind=8), intent(out) :: h (10) ! elem shape functions\r\n    real(kind=8) :: t1, t2, t3, z\r\n\r\n    !    s\r\n    !    :\r\n    !    3\r\n    !    | \\\r\n    !    |   \\\r\n    !    6     8\r\n    !    |      \\\r\n    !    9   10   5\r\n    !    |          \\\r\n    !    1---4---7---2  ... r\r\n    !\r\n    ! 1@(0,0)  2@(1,0) 2@(0,1)\r\n\r\n    z  = 1.d0 - r - s\r\n    t1 = s * (3.d0 * s - 1.d0)\r\n    t2 = z * (3.d0 * z - 1.d0)\r\n    t3 = r * (3.d0 * r - 1.d0)\r\n    h (1 ) = 0.5d0 * t2 * (3.d0 * z - 2.d0)\r\n    h (2 ) = 0.5d0 * t3 * (3.d0 * r - 2.d0)\r\n    h (3 ) = 0.5d0 * t1 * (3.d0 * s - 2.d0)\r\n    h (4 ) = 4.5d0 * r * t2\r\n    h (5 ) = 4.5d0 * s * t3\r\n    h (6 ) = 4.5d0 * z * t1\r\n    h (7 ) = 4.5d0 * z * t3\r\n    h (8 ) = 4.5d0 * r * t1\r\n    h (9 ) = 4.5d0 * s * t2\r\n    h (10) = 27.d0 * s * z * r\r\n\r\n  end subroutine shape_10_t\r\n"}, {"instruction": "Create a Fortran subroutine named shape_8_q to calculate the shape functions of an 8-node parametric quadrilateral. The subroutine should have 2 input parameters of type real(kind=8) and intent(in), and 1 output parameter of type real(kind=8) and intent(out). The input parameters represent the local coordinates of a point, while the output parameter is an array containing the shape functions for the 8-node quadrilateral.", "input": "", "output": "  subroutine shape_8_q (s, t, h)\r\n\r\n    ! shape functions of 8 node parametric quadrilateral\r\n\r\n    implicit none\r\n    real(kind=8), intent(in)  :: s, t  ! local coordinates of point\r\n    real(kind=8), intent(out) :: h (8) ! elem shape function array\r\n\r\n    real(kind=8)              :: t_plus, t_less, s_plus, s_less\r\n\r\n    ! nodal order        4 - 7 - 3\r\n    !                    :   t   :\r\n    !                    8   *s  6\r\n    ! node 1 at (-1,-1)  :       :\r\n    ! node 3 at (1,1)    1 - 5 - 2\r\n\r\n    s_plus = 1.d0 + s ; s_less = 1.d0 - s\r\n    t_plus = 1.d0 + t ; t_less = 1.d0 - t\r\n    h (1) = 0.25d0*s_less*t_less*(s_less + t_less - 3.d0)\r\n    h (2) = 0.25d0*s_plus*t_less*(s_plus + t_less - 3.d0)\r\n    h (3) = 0.25d0*s_plus*t_plus*(s_plus + t_plus - 3.d0)\r\n    h (4) = 0.25d0*s_less*t_plus*(s_less + t_plus - 3.d0)\r\n    h (5) = 0.5d0*t_less*(1.d0 - s*s)\r\n    h (6) = 0.5d0*s_plus*(1.d0 - t*t)\r\n    h (7) = 0.5d0*t_plus*(1.d0 - s*s)\r\n    h (8) = 0.5d0*s_less*(1.d0 - t*t)\r\n\r\n  end subroutine shape_8_q\r\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_local_coulomb_matrix to compute the local Coulomb matrix based on the input nuclear charges, coordinates, number of atoms, and maximum quantum number. The number and type of input parameters are 4, with the test_data type ['double precision, dimension(:)', 'double precision, dimension(:,:)', 'integer', 'integer']. The number of output parameters is 1, with the test_data type ['double precision, dimension(natoms,(nmax + 1) * nmax / 2)'].", "input": "", "output": "subroutine fgenerate_local_coulomb_matrix(nuclear_charges, coordinates, natoms, nmax, cm)\n\n    implicit none\n\n    double precision, dimension(:), intent(in) :: nuclear_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n    integer,intent(in) :: natoms\n    integer, intent(in) :: nmax\n\n    double precision, dimension(natoms,(nmax + 1) * nmax / 2), intent(out):: cm\n    integer :: idx\n\n    double precision, dimension(natoms) :: row_norms\n    double precision :: pair_norm\n    double precision :: huge_double\n\n    integer, dimension(natoms) :: sorted_atoms\n    integer, dimension(natoms,natoms) :: sorted_atoms_all\n\n    double precision, dimension(natoms,natoms) :: pair_distance_matrix\n\n    integer i, j, m, n, k\n\n    if (size(coordinates, dim=1) /= size(nuclear_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(nuclear_charges, dim=1), \"atom_types!\"\n        stop\n    endif\n\n    huge_double = huge(row_norms(1))\n\n    ! calculate row-2-norms and store pair-distances in pair_distance_matrix\n    row_norms = 0.0d0\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        pair_norm = 0.5d0 * nuclear_charges(i) ** 2.4d0\n        row_norms(i) = row_norms(i) + pair_norm*pair_norm\n        pair_distance_matrix(i, i) = pair_norm\n    enddo\n    !$omp end parallel do\n\n    !$omp parallel do private(pair_norm) reduction(+:row_norms)\n    do i = 1, natoms\n        do j = i+1, natoms\n            pair_norm = nuclear_charges(i) * nuclear_charges(j) &\n                & / sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n\n            pair_distance_matrix(i, j) = pair_norm\n            pair_distance_matrix(j, i) = pair_norm\n            pair_norm = pair_norm * pair_norm\n            row_norms(j) = row_norms(j) + pair_norm\n            row_norms(i) = row_norms(i) + pair_norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    !generate sorted list of atom ids by row_norms - not really (easily) parallelizable\n    do i = 1, natoms\n        j = minloc(row_norms, dim=1)\n        sorted_atoms(natoms - i + 1) = j\n        row_norms(j) = huge_double\n    enddo\n\n    do k = 1, natoms\n        sorted_atoms_all(1, k)  = k\n        m = 0\n        do i = 1, natoms - 1\n            if (sorted_atoms(i) == k) then\n                m = 1\n            endif\n            sorted_atoms_all(i+1, k) = sorted_atoms(i + m)\n        enddo\n    enddo\n\n    ! fill coulomb matrix according to sorted row-2-norms\n    cm = 0.0d0\n    !$omp parallel do private(idx, i, j)\n    do k = 1, natoms\n        do m = 1, natoms\n            i = sorted_atoms_all(m, k)\n            idx = (m*m+m)/2 - m\n            do n = 1, m\n                j = sorted_atoms_all(n, k)\n                cm(k, idx+n) = pair_distance_matrix(i, j)\n            enddo\n        enddo\n    enddo\n    !$omp end parallel do\n\nend subroutine fgenerate_local_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named fgenerate_atomic_unsorted_coulomb_matrix that takes 5 input parameters of type ['double precision, dimension(:)', 'double precision, dimension(:,:)', 'integer', 'integer', 'double precision'], and 1 output parameter of type ['double precision, dimension(natoms,(nmax + 1) * nmax / 2)']. This subroutine generates an unsorted Coulomb matrix based on the input nuclear charges and coordinates of atoms. It performs calculations to fill the Coulomb matrix based on specified cutoff and maximum distance parameters.", "input": "", "output": "subroutine fgenerate_atomic_unsorted_coulomb_matrix(nuclear_charges, coordinates, natoms, nmax, cutoff, cm)\n\n    implicit none\n\n    double precision, dimension(:), intent(in) :: nuclear_charges\n    double precision, dimension(:,:), intent(in) :: coordinates\n    integer,intent(in) :: natoms\n    integer, intent(in) :: nmax\n    double precision, intent(in) :: cutoff\n\n    double precision, dimension(natoms,(nmax + 1) * nmax / 2), intent(out):: cm\n\n    integer :: idx\n\n    double precision :: norm\n\n    double precision, allocatable, dimension(:,:) :: distance_matrix\n\n    integer i, j, m, n, k\n\n\n    if (size(coordinates, dim=1) /= size(nuclear_charges, dim=1)) then\n        write(*,*) \"error: coulomb matrix generation\"\n        write(*,*) size(coordinates, dim=1), \"coordinates, but\", &\n            & size(nuclear_charges, dim=1), \"atom_types!\"\n        stop\n    endif\n    write(*,*) 1\n\n    ! allocate temporary\n    allocate(distance_matrix(natoms,natoms))\n\n    !$omp parallel do private(norm)\n    do i = 1, natoms\n        distance_matrix(i, i) = 0.0d0\n        do j = i+1, natoms\n            norm = sqrt(sum((coordinates(j,:) - coordinates(i,:))**2))\n            distance_matrix(i, j) = norm\n            distance_matrix(j, i) = norm\n        enddo\n    enddo\n    !$omp end parallel do\n\n    write(*,*) 2\n\n    ! fill coulomb matrix\n    cm = 0.0d0\n\n    !$omp parallel do private(idx)\n    do k = 1, natoms\n        do i = 1, nmax\n            idx = (i*i+i)/2 - i\n            if (distance_matrix(k,i) < cutoff) then\n                do j = 1, i\n                    if (distance_matrix(k,j) < cutoff) then\n                        cm(k, idx+j) = distance_matrix(i, j)\n                    endif\n                enddo\n            endif\n        enddo\n    enddo\n    !$omp end parallel do\n    write(*,*) 3\n\n    ! clean up\n    deallocate(distance_matrix)\n\nend subroutine fgenerate_atomic_unsorted_coulomb_matrix\n"}, {"instruction": "Create a Fortran subroutine named unrotate_frame to perform a rotation of a 3D frame using input angles phi and theta. The subroutine has 7 input parameters of type real (kind=8) and 3 output parameters of type real (kind=8).", "input": "", "output": "  subroutine unrotate_frame(x_in, y_in, z_in, stheta, ctheta, sphi, cphi, xn, yn, zn)\n!     \n!\n!     -----description: rotates the frame using input angles\n!          phi and theta\n!\n!\n!          on input:  \n!\n!          on output:\n!          \n!\n!     ----------------------------------------------------------------\n!\n    implicit none\n!\n!     -----variable declarations\n!          ---------------------\n!\n    real (kind=8), intent(in) :: x_in, y_in, z_in\n    real (kind=8), intent(in) :: stheta, ctheta, sphi, cphi\n    real (kind=8), intent(out) :: xn, yn, zn\n\n    real (kind=8) :: x1, y1, z1\n    real (kind=8) :: x2, y2, z2\n!\n!     ----------------------------------------------------------------\n!\n\n    x1 = x_in\n    y1 = y_in\n    z1 = z_in\n\n    x2  =   x1 * ctheta +  z1 * stheta\n    y2  =   y1\n    z2  =  -x1 * stheta +  z1 * ctheta\n\n    xn  =   x2  * cphi -  y2 * sphi\n    yn  =   x2  * sphi +  y2 * cphi\n    zn  =   z2\n    \n    return\n\n  end subroutine unrotate_frame\n"}, {"instruction": "Write a Fortran subroutine named \"pwc\" to calculate the electrostatic energy and its derivatives for a given pair of densities. The subroutine takes 2 input parameters of type real(8) and returns 3 output parameters of type real(8).", "input": "", "output": "      subroutine pwc(rhoa,rhob,ec,dec_drhoa,dec_drhob)\n      implicit none\n      real(8),parameter :: pi=3.141592653589793d0\n      real(8),intent(in) :: rhoa,rhob\n      real(8),intent(out) :: ec,dec_drhoa,dec_drhob\n      real(8),parameter :: pec0=1d0,pec1=1d0,par=1d0\n      real(8),parameter :: aec0=0.031091d0,aec1=0.015545d0,aar=0.016887d0\n      real(8),parameter :: a1ec0=0.21370d0,a1ec1=0.20548d0,a1ar=0.11125d0\n      real(8),parameter :: b1ec0=7.5957d0,b1ec1=14.1189d0,b1ar=10.357d0\n      real(8),parameter :: b2ec0=3.5876d0,b2ec1=6.1977d0,b2ar=3.6231d0\n      real(8),parameter :: b3ec0=1.6382d0,b3ec1=3.3662d0,b3ar=0.88026d0\n      real(8),parameter :: b4ec0=0.49294d0,b4ec1=0.62517d0,b4ar=0.49671d0\n      real(8),parameter :: f2d=1.709921d0,eps=1d-15\n      real(8) rs,sqrs,zeta,fzeta,dfzeta,q0ec0,q0ec1,q0ar,q1ec0,q1ec1,q1ar\n      real(8) qdec0,qdec1,qdar,gec0,gec1,gar,dgec0,dgec1,dgar,decdrs,decdzeta\n\n      rs=(3d0/(4d0*pi*(rhoa+rhob)))**(1d0/3d0)\n      sqrs=sqrt(rs)\n      zeta=(rhoa-rhob)/(rhoa+rhob)\n      if(abs(zeta-1d0) < eps) zeta=1d0-eps\n      if(abs(zeta+1d0) < eps) zeta=-1d0+eps\n      fzeta=((1+zeta)**(4d0/3d0)+(1-zeta)**(4d0/3d0)-2)/(2d0**(4d0/3d0)-2d0)\n      dfzeta=4d0/3d0*((1+zeta)**(1d0/3d0)-(1-zeta)**(1d0/3d0))/(2d0**(4d0/3d0)-2d0)\n\n      q0ec0=-2*aec0*(1+a1ec0*rs)\n      q0ec1=-2*aec1*(1+a1ec1*rs)\n      q0ar =-2*aar *(1+a1ar *rs)\n      q1ec0=2*aec0*(b1ec0*sqrs+b2ec0*rs+b3ec0*rs*sqrs+b4ec0*rs**(pec0+1))\n      q1ec1=2*aec1*(b1ec1*sqrs+b2ec1*rs+b3ec1*rs*sqrs+b4ec1*rs**(pec1+1))\n      q1ar =2*aar *(b1ar *sqrs+b2ar *rs+b3ar *rs*sqrs+b4ar *rs**(par +1))\n      qdec0=aec0*(b1ec0/sqrs+2*b2ec0+3*b3ec0*sqrs+2*(pec0+1)*b4ec0*rs**pec0)\n      qdec1=aec1*(b1ec1/sqrs+2*b2ec1+3*b3ec1*sqrs+2*(pec1+1)*b4ec1*rs**pec1)\n      qdar =aar *(b1ar /sqrs+2*b2ar +3*b3ar *sqrs+2*(par +1)*b4ar *rs**par )\n      gec0=q0ec0*log(1+1d0/q1ec0)\n      gec1=q0ec1*log(1+1d0/q1ec1)\n      gar =q0ar *log(1+1d0/q1ar )\n      dgec0=-2*aec0*a1ec0*log(1+1d0/q1ec0)-q0ec0*qdec0/(q1ec0**2+q1ec0)\n      dgec1=-2*aec1*a1ec1*log(1+1d0/q1ec1)-q0ec1*qdec1/(q1ec1**2+q1ec1)\n      dgar =-2*aar *a1ar *log(1+1d0/q1ar )-q0ar *qdar /(q1ar **2+q1ar )\n\n      ec=gec0-gar*fzeta/f2d*(1-zeta**4)+(gec1-gec0)*fzeta*zeta**4\n      decdrs=dgec0*(1-fzeta*zeta**4)+dgec1*fzeta*zeta**4-dgar*fzeta/f2d*(1-zeta**4)\n      decdzeta=dfzeta*(-gar/f2d*(1-zeta**4)+(gec1-gec0)*zeta**4) &\n    &         +4*zeta**3*(fzeta*(gec1-gec0)+gar*fzeta/f2d)\n\n      dec_drhoa=(-rs/3*decdrs-(zeta-1)*decdzeta)/(rhoa+rhob)\n      dec_drhob=(-rs/3*decdrs-(zeta+1)*decdzeta)/(rhoa+rhob)\n\n      return\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gram_schmidt that performs the Gram-Schmidt process on a set of vectors. The subroutine takes 3 input parameters: two integers (n and m) and a 2D array of double precision numbers with dimensions (n, m). It also has 1 output parameter, a 2D array of double precision numbers with dimensions (n, m).", "input": "", "output": "  subroutine gram_schmidt(u_in, n, m, u_out)\n    implicit none\n    integer,          intent(in)                 :: n,m\n    double precision, dimension(n,m),intent(in)  :: u_in\n    double precision, dimension(n,m),intent(out) :: u_out    \n\n    !! local variables\n    integer :: i,j\n\n    do i = 1, m\n       u_out(:,i) = u_in(:,i)\n    end do\n\n    do j = 1, m\n       if(j .gt. 1)then\n          do i = 1, j-1\n             u_out(:,j) = u_out(:,j) - dot_product(u_out(:,j), u_out(:,i))*u_out(:,i)\n          end do\n       end if\n       u_out(:,j) = u_out(:,j)/sqrt(dot_product(u_out(:,j),u_out(:,j)))\n    end do\n\n    return\n    \n  end subroutine gram_schmidt\n"}, {"instruction": "Create a Fortran subroutine named h_candidate_matrix_size to compute the size of elemental matrices for h candidates based on the input parameters p and neigh. The input parameters consist of 2 integers. The output parameters consist of 4 integers representing nglobal, nprimary(2), nmate(2), and nsecondary(2).", "input": "", "output": "subroutine h_candidate_matrix_size(p,neigh,nglobal,nprimary,nmate,nsecondary)\n!          -----------------------\n\n!----------------------------------------------------\n! this routine computes the size of the elemental maticies of the children\n! of the primary (nprimary), the children of the mate (nmate), the secondary\n! elemental matrices, and global matrix for h candidates.\n!\n! this version is for the type i_h_patch which uses p (degree(elem)+1) for the\n! degree of all sides and interior of the children of the primary element, and\n! degree 1 for children of the mate and the secondary elements (the other two\n! neighbors of the primary).\n! temp assuming system_size is 1\n!----------------------------------------------------\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(in) :: p\ninteger, intent(in) :: neigh(3)\ninteger, intent(out) :: nglobal, nprimary(2), nmate(2), nsecondary(2)\n!----------------------------------------------------\n! local variables:\n\n!----------------------------------------------------\n! begin executable code\n\n! children of the primary are full p elements\n\nnprimary = ((p+1)*(p+2))/2\n\n! if the mate is the boundary, set the size to 0.  otherwise the children\n! have the 3 vertices plus one edge of degree p\n\nif (neigh(3) == boundary) then\n   nmate = 0\nelse\n   nmate = p + 2\nendif\n\n! the secondaries have the 3 vertices plus one edge of degree p.\n\nnsecondary = 0\nif (neigh(1) /= boundary) nsecondary(1) = p + 2\nif (neigh(2) /= boundary) nsecondary(2) = p + 2\n\n! global number: for simplicity in the numbering of the last (up to) 3 rows,\n! include the opposite vertex of the mate and all secondaries regardless of\n! whether they actually exist, and just make the missing ones a dirichlet\n! row with value 0 -- it will be decoupled and not affect anything.\n! see h_candidate_renum_primary for an explanation of the value.\n\nnglobal = (p+1)**2 + 3\n\nend subroutine h_candidate_matrix_size\n"}, {"instruction": "Create a Fortran subroutine named \"p_candidate_renum_primary\" to determine the renumbering from the elemental matrix to the global matrix for the p candidate linear system. The number of input parameters is 1, with the test_data type as ['integer']. The number of output parameters is 1, with the test_data type as ['integer'].", "input": "", "output": "subroutine p_candidate_renum_primary(renum,p)\n!          -------------------------\n\n!----------------------------------------------------\n! this routine determines the renumbering from the elemental matrix to the\n! global matrix for the p candidate linear system\n! temp only using first eigenvalue\n! temp assuming system size is 1\n!----------------------------------------------------\n\n!----------------------------------------------------\n! dummy arguments\n\ninteger, intent(out) :: renum(:)\ninteger, intent(in) :: p\n!----------------------------------------------------\n! local variables:\n\ninteger :: i, k, current\n!----------------------------------------------------\n! begin executable code\n\n! the numbering of the elemental matrix is\n\n!                    1\n!                   / \\\n!                  /   \\\n!                 /     \\\n!                /       \\\n!    p+3..2p+1  /         \\  2p+2..3p\n!              /   3p+1    \\\n!             /     ..      \\\n!            / (p+1)(p+2)/2  \\\n!           /                 \\\n!          3-------------------2\n!                 4..p+2\n\n! the numbering of the global matrix is\n\n!                    1\n!                   / \\\n!                  /   \\\n!                 /     \\\n!                /       \\\n! 5,8,12,17,... /         \\  6,9,13,18,...\n!              / 10,       \\\n!             /  14,15,     \\\n!            /   19,20,21,   \\\n!           /    ...          \\\n!          3-------------------2\n!               4,7,11,16,...\n\n! edge i is given by i+k(k+1)/2, k=2..p\n! interior is given by 4+k(k+1)/2..k+1+k(k+1)/2, k=3..p\n\n! vertices\n\nrenum(1:3) = (/1,2,3/)\ncurrent = 3\n\n! edges\n\ndo i=1,3\n   do k=2,p\n      current = current + 1\n      renum(current) = i + (k*(k+1))/2\n   end do\nend do\n\n! interior\n\ndo k=3,p\n   do i=4,k+1\n      current = current + 1\n      renum(current) = i + (k*(k+1))/2\n   end do\nend do\n\nend subroutine p_candidate_renum_primary\n"}, {"instruction": "Create a Fortran subroutine named \"emcee_lnprob\" to calculate the log-probability for a given position in a parameter space. The subroutine should take 2 input parameters: an integer \"ndim\" and a double precision array \"p\" of dimension \"ndim\". It should output a single double precision value \"lp\" representing the computed log-probability at the given position.", "input": "", "output": "      subroutine emcee_lnprob (ndim, p, lp)\n\n        ! log-probability function. this particular example implements\n        ! an isotropic `ndim`-dimensional gaussian with unit variance.\n        !\n        ! inputs\n        ! ------\n        !\n        ! ndim [integer]:\n        !   the dimension of the parameter space.\n        !\n        ! pos [double precision (ndim)]:\n        !   the position in parameter space where the probability should\n        !   be computed.\n        !\n        ! outputs\n        ! -------\n        !\n        ! lp [double precision]:\n        !   the log-probability computed at `pos`.\n\n        implicit none\n\n        integer, intent(in) :: ndim\n        double precision, intent(in), dimension(ndim) :: p\n        double precision, intent(out) :: lp\n\n        integer :: i\n\n        lp = 1.d0\n        do i=1,ndim\n          lp = lp + p(i)*p(i)\n        enddo\n        lp = -0.5d0 * lp\n\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rod_km to calculate the stiffness matrix of a rod element. The subroutine takes 2 input parameters of type real(iwp) and outputs a single parameter of type real(iwp). The test_data type for input is ['real(iwp)', 'real(iwp)'] and for output is ['real(iwp)'].", "input": "", "output": "subroutine rod_km(km,ea,length)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::ea,length\n real(iwp),intent(out)::km(:,:)\n real(iwp)::one=1.0_iwp\n km(1,1)=one\n km(2,2)=one\n km(1,2)=-one\n km(2,1)=-one\n km=km*ea/length\nreturn\nend subroutine rod_km\n"}, {"instruction": "Write a Fortran subroutine named translation_heatcapacity to calculate the heat capacity of a species undergoing translational motion. This subroutine takes 5 input parameters of types ['integer', 'real(8), dimension(1:nt)', 'real(8)', 'integer', 'real(8)'] and 1 output parameter of type ['real(8), dimension(1:nt)'].", "input": "", "output": "subroutine translation_heatcapacity(tlist, nt, mass, dim, v, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: mass                         ! the species mass in kg/mol\n    integer, intent(in) :: dim                          ! the dimensionality of the translation (2 or 3)\n    real(8), intent(in) :: v                            ! the system volume in m^3\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n\n    do i = 1, nt\n        cvlist(i) = 0.5 * dim\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named freerotor_heatcapacity to evaluate the heat capacity of a rotor system. The subroutine takes 5 input parameters: nt (integer), nfreq (integer), tlist (real(8) array of size nt), freq (real(8) array of size nfreq), and linear (integer). It also has 1 output parameter: cvlist (real(8) array of size nt). The subroutine calculates the heat capacity based on the values of temperatures and frequencies provided. The subroutine handles linear and nonlinear rotor systems differently and stores the evaluated heat capacity in the cvlist array.", "input": "", "output": "subroutine freerotor_heatcapacity(tlist, nt, freq, nfreq, linear, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    integer, intent(in) :: nfreq                        ! the number of rotor frequencies\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), dimension(1:nfreq), intent(in) :: freq     ! the list of frequencies in cm^-1\n    integer, intent(in) :: linear                       ! 0 = nonlinear, 1 = linear\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n\n    if (linear /= 0) then\n        do i = 1, nt\n            cvlist(i) = 1.0\n        end do\n    else\n        do i = 1, nt\n            cvlist(i) = 1.5\n        end do\n    end if\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named harmonicoscillator_partitionfunction to calculate the partition function for a harmonic oscillator at different temperatures. The subroutine takes 3 input parameters of type integer, real(8) array of size nt, and real(8), and 1 output parameter of type real(8) array of size nt.", "input": "", "output": "subroutine harmonicoscillator_partitionfunction(tlist, nt, freq, q)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: freq                         ! the oscillator frequency in cm^-1\n    real(8), dimension(1:nt), intent(out) :: q          ! the evaluated partition function in m^3\n\n    integer i\n    real(8) xi\n\n    do i = 1, nt\n        xi = 6.626e-34 * 2.9979e10 * freq / (1.381e-23 * tlist(i))\n        q(i) = 1.0 / (1 - exp(-xi))\n    end do\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named harmonicoscillator_heatcapacity to calculate the heat capacity of a harmonic oscillator at different temperatures. The subroutine takes 3 input parameters of types integer, real(8) array, and real(8), and 1 output parameter of type real(8) array. The input parameters represent the number of temperatures, the list of temperatures, and the oscillator frequency, while the output parameter represents the evaluated heat capacity at each temperature.", "input": "", "output": "subroutine harmonicoscillator_heatcapacity(tlist, nt, freq, cvlist)\n\n    implicit none\n    integer, intent(in) :: nt                           ! the number of temperatures\n    real(8), dimension(1:nt), intent(in) :: tlist       ! the list of temperatures to evaluate in k\n    real(8), intent(in) :: freq                         ! the oscillator frequency in cm^-1\n    real(8), dimension(1:nt), intent(out) :: cvlist     ! the evaluated heat capacity in j/mol*k\n\n    integer i\n    real(8) x, exp_x, one_minus_exp_x\n\n    do i = 1, nt\n        x = freq / (0.695039 * tlist(i))        ! kb = 0.695039 cm^-1/k\n        \n        exp_x = exp(x)\n        one_minus_exp_x = 1.0 - exp_x\n\n        cvlist(i) = x * x * exp_x / one_minus_exp_x / one_minus_exp_x\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named bias_correct_lhf that applies a polynomial fit to correct the latent heat fluxes. The subroutine should take 1 input parameter of type real, dimension(:, :), and 1 output parameter of type real, dimension(:, :).", "input": "", "output": "  subroutine bias_correct_lhf(x, corrected)\n    ! use a polynomial fit to correct the latent heat fluxes\n    ! i estimated these coefficients using python\n    real, dimension(3), parameter :: coefs  = [-5.24149046e-04,  1.15227747e+00,  4.92990095e+00]\n    real, dimension(:, :), intent(in) :: x\n    real, dimension(:, :), intent(out) :: corrected\n\n    integer k, n\n    corrected = 0.0\n    n = size(coefs)\n    do k=1,n\n       corrected = corrected  + x**(n-k) * coefs(k)\n    end do\n  end subroutine bias_correct_lhf\n"}, {"instruction": "Create a Fortran subroutine named swap_d that takes two integer input parameters and one real output parameter. The subroutine is intended to rearrange the elements of the real array w in reverse order, printing the elements to the console.", "input": "", "output": "subroutine swap_d(w,n,s)\n    implicit none\n    integer,intent(in)::n,s\n    real,intent(out)::w(s)\n    integer::i\n    do i=n,1,-1\n        print*,w(i)\n    enddo\nend subroutine swap_d\n"}, {"instruction": "Write a Fortran subroutine named calhum that calculates the saturated specific humidity and its derivative with respect to temperature. The subroutine takes 2 input parameters of real type (sfctmp, sfcprs) and returns 2 output parameters of real type (q2sat, dqsdt2).", "input": "", "output": "  subroutine calhum(sfctmp, sfcprs, q2sat, dqsdt2)\n\n    implicit none\n  \n    ! input:\n    real, intent(in)       :: sfctmp\n    real, intent(in)       :: sfcprs\n    \n    ! output:\n    real, intent(out)      :: q2sat   ! saturated specific humidity\n    real, intent(out)      :: dqsdt2 \n    \n    ! local\n    real, parameter        :: a2=17.67,a3=273.15,a4=29.65, elwv=2.501e6,        &\n                              a23m4=a2*(a3-a4), e0=611.0, rv=461.0,             &\n                              epsilon=0.622 \n    real                   :: es\n\n    ! es:  e.g. dutton chapter 8, eq 11\n        es = e0 * exp ( elwv/rv*(1./a3 - 1./sfctmp) )\n\n    ! q2sat:  \n        q2sat = epsilon * es / (sfcprs-(1-epsilon)*es)\n\n! dqsdt2 is calculated assuming q2sat is a specific humidity\n        !kwm dqsdt2=(q2sat/(1+q2sat))*a23m4/(sfctmp-a4)**2 \n        dqsdt2=q2sat*a23m4/(sfctmp-a4)**2 \n\n        end subroutine calhum\n"}, {"instruction": "Create a Fortran subroutine named get_cza that calculates the solar zenith angles for a given set of input parameters. The subroutine takes 4 input parameters of type real: jday, gmthour, latrad, lonrad, and returns 1 output parameter of type real: cza.", "input": "", "output": "subroutine get_cza(jday, gmthour, latrad, lonrad, cza)\n  implicit none\n  integer,parameter :: maxpts = 96673\n  real, intent(in) :: jday,gmthour\n  real, intent(in) :: latrad(maxpts)\n  real, intent(in) :: lonrad(maxpts)\n  real, intent(out) :: cza(maxpts)\n\n  real :: gg, tc, declin, sha(maxpts)\n  real, parameter :: pi = 3.14159265\n  \n  ! fractional day of the year, in radians\n  gg = (360./365.25) * (jday+gmthour/24.) * pi/180.\n\n  ! solar declination angle, in radians.\n  declin = 0.006918 - 0.399912*cos(gg) + 0.070257*sin(gg) - 0.006758*cos(2.0*gg) + &\n       0.000907*sin(2.0*gg) - 0.002697*cos(3.0*gg) + 0.00148*sin(3.0*gg)\n\n  ! time correction for solar angle, in radians.  whatever.\n  tc = 0.000075 + 0.001868*cos(gg) - 0.032077*sin(gg) - 0.014615*cos(2.0*gg) - &\n       0.040849*sin(2.0*gg)\n!  tc = 0.0000\n\n  ! solar hour angle, in radians\n  sha = ((gmthour-12.0)*15.0)*(pi/180.) + lonrad + tc\n  ! sha = (gmthour*15.0)*(pi/180.) + lonrad + tc\n\n  ! ! solar zenith angle, in radians\n  cza = sin(latrad)*sin(declin)+cos(latrad)*cos(declin)*cos(sha)\n  where(cza.lt.0) cza = 0.0\n\nend subroutine get_cza\n"}, {"instruction": "Create a Fortran subroutine named tr_cl_sc with 10 input parameters of types ['integer', 'integer', 'integer', 'integer', 'integer(8)', 'integer(8)', 'integer(8)', 'real(8)', 'real(8)', 'real(8)'] and 1 output parameter of type ['integer(8)']. The subroutine calculates the translation of clusters and stores the result in the tr_cl output parameter based on the input parameters nasc, ncell, na, npt, scijkl, sc_mat, inv_sc_mat, sc_ref, apos, and cluster.", "input": "", "output": "  subroutine tr_cl_sc(nasc, ncell, na, npt, scijkl, sc_mat, inv_sc_mat, sc_ref, apos, cluster, tr_cl)\n    implicit none\n    integer, intent(in) :: nasc, ncell, na, npt\n    integer(8), intent(in) :: scijkl(4, nasc), sc_ref(3, ncell), cluster(4, npt)\n    real(8), intent(in) :: sc_mat(3,3), inv_sc_mat(3,3), apos(3, na)\n    integer(8), intent(out) :: tr_cl(npt, ncell)\n    !f2py intent(in) scijkl, sc_mat(3,3), inv_sc_mat, sc_ref, apos, cluster\n    !f2py intent(out) tr_cl\n    !f2py integer, intent(hide),depend(scijkl) :: nasc=shape(scijkl,1)\n    !f2py integer, intent(hide),depend(sc_ref) :: ncell=shape(sc_ref,1)\n    !f2py integer, intent(hide),depend(apos) :: na=shape(apos,1)\n    !f2py integer, intent(hide),depend(cluster) :: npt=shape(cluster,1)\n\n    integer i, j, ia, found\n    integer ct(4)\n    real(8) ct_f(3)\n!    if (npt >8) then\n!       print *, 'error recompile with ct(4,maxnpt) maxnpt>=', npt\n!       stop\n!    end if\n\n !   ct(4,1:npt) = cluster(4,1:npt)\n    do i=1, ncell\n       !  [get_structure_ordering((coords+ijk[none,:]).dot(sc.inv_sc_mat), sc.frac_coords,0) for ijk in sc.ijk_ref]\n       do j=1, npt\n          ct(4) = cluster(4, j)\n          ct(1:3) = cluster(1:3, j) + sc_ref(1:3, i)\n          ct_f = matmul(inv_sc_mat, ct(1:3)+ apos(:,ct(4)+1))+1e-12\n          ct_f = ct_f - floor(ct_f)\n          ct_f = matmul(sc_mat, ct_f)- apos(:,ct(4)+1)\n          ct(1:3) = nint(ct_f(1:3))\n          found=-1\n          do ia=1, nasc\n!             print *, 'i,j, ia;  clus;  scref;  ct;  scijkl'\n!             print '(4i4)', i,j,ia, found, cluster(:, j), sc_ref(:,i), -99, ct, scijkl(:, ia)\n             if (scijkl(1, ia) /= ct(1)) cycle\n             if (scijkl(2, ia) /= ct(2)) cycle\n             if (scijkl(3, ia) /= ct(3)) cycle\n             if (scijkl(4, ia) /= ct(4)) cycle\n             found = ia\n!             print *, 'debug found', found\n             exit\n          end do\n          if (found <0) then\n             print *, 'error translating cluster', cluster\n             stop\n          end if\n          tr_cl(j, i) = found\n       end do\n    end do\n  end subroutine tr_cl_sc\n"}, {"instruction": "Create a Fortran subroutine named even to determine if a given integer number is even or not. The subroutine takes 1 input parameter of type integer and 1 output parameter of type logical. The input parameter is named num and the output parameter is named pass. Use the modulo function to check if the input number is even and assign the result to the output parameter pass.", "input": "", "output": "subroutine even(num, pass)\n  implicit none\n  integer, intent(in)  :: num\n  logical, intent(out) :: pass\n\n  pass = modulo(num,2) == 0\n  \nend subroutine even\n"}, {"instruction": "Write a Fortran subroutine named calling_from_fortran to accept a double precision input parameter and return a double precision output parameter. The input parameter is passed by value, while the output parameter is passed by reference. The subroutine simply assigns the value of the input parameter to the output parameter and displays a message indicating that it is called from Fortran.", "input": "", "output": "subroutine calling_from_fortran(num, out)\n  implicit none\n  double precision, intent(in)  :: num\n  double precision, intent(out)  :: out\n\n  write(*,*) \"calling from fortran \", num\n\n  out = num\n\nend subroutine calling_from_fortran\n"}, {"instruction": "Create a Fortran subroutine named wave_propogation to simulate wave propagation in a two-dimensional space. The subroutine takes 5 input parameters of type integer, integer, integer, real, and real, representing the number of steps, scale, damping factor, initial pressure, and the step to stop the wave, respectively. The output parameter is a real array representing the heights of the wave at different points in the space.", "input": "", "output": "subroutine wave_propogation(num_steps, scale, damping, initial_p, stop_step, p)\n  ! inputs\n  ! num_steps -> int # number of itereations to make\n  ! scale -> int # size of box for wave to propogate in\n  ! damping -> float # factor for damping wave\n  ! initial_p -> float # initial height at center\n  ! stop_step -> int # number of steps to stop wave\n  ! outputs:\n  ! p -> float(x,y) # array of output heights\n  implicit none\n  integer size_x,i,j,k,step\n  real pi, omega\n  integer, intent(in)  :: num_steps, scale, stop_step !input\n  real, intent(in) :: damping, initial_p !input\n  real, intent(out) :: p(2 * scale + 1,2 * scale + 1) ! output\n  real, dimension(2 * scale + 1,2 * scale + 1,4) :: v\n\n  size_x = 2 * scale + 1\n\n  pi = 3.14159\n  omega = 3.0 / (2.0 * pi)\n\n! setup initial matrix all 0's\n! p is pressure matrix\n! v is velocity tensor (matrix of x/y and 4 vector of velocity [up,down,left,right])\n  do k=1,4\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = 0.0\n           v(i,j,k) = 0.0\n        end do\n     end do\n  end do\n\n  ! set initial start height\n  p(scale + 1,scale + 1) = initial_p\n\n  ! for each step\n  do step = 1, num_steps\n    ! if step is less than stopping step then add forcing function\n    if(step <= stop_step) then\n      p(scale + 1 ,scale + 1) = initial_p * sin(omega * step)\n    endif\n\n    ! for each cell in matrix p\n    !$cuf kernel do <<< *, * >>>\n    do j=1,size_x\n      do i=1,size_x\n        if (i == 0) then\n          cycle\n        end if\n        ! calculate veolocity of wave at the points\n        v(i,j,1) = merge(v(i,j,1) + p(i,j) - p(i - 1,j), p(i,j), i > 1)\n        v(i,j,2) = merge(v(i,j,2) + p(i,j) - p(i,j + 1), p(i,j), j < size_x - 1)\n        v(i,j,3) = merge(v(i,j,3) + p(i,j) - p(i + 1,j), p(i,j), i < size_x - 1)\n        v(i,j,4) = merge(v(i,j,4) + p(i,j) - p(i,j - 1), p(i,j), j > 1)\n      end do\n    end do\n\n    do j=1,size_x\n      do i=1,size_x\n        ! get new pressure from p = p_0 - damping*v\n        p(i,j) = p(i,j) - 0.5 * damping * (v(i,j,1) + v(i,j,2) + v(i,j,3) + v(i,j,4))\n      end do\n    end do\n  end do\n\nend subroutine wave_propogation\n"}, {"instruction": "Create a Fortran subroutine named sys_chdir to change the current working directory to the specified directory. The subroutine takes 2 input parameters: a character string 'dir' and an integer 'lendir', representing the length of the character string. It also has 1 output parameter: an integer 'ierr', which will be zero if the operation is successful, and non-zero if there is an error.", "input": "", "output": "      subroutine sys_chdir (dir, lendir, ierr)\n!\n!   this routine changes current working directory to dir.\n!   lendir is the length of character string dir;\n!   ierr will be zero if successful, otherwise non-zero;\n!\n!   xinghong he  98-08-21\n!\n!************************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n      implicit none\n      character(len=*), intent(in):: dir\n      integer, intent(in):: lendir\n      integer, intent(out):: ierr\n\n\n      integer chdir\n\n      ierr = chdir (dir(1:lendir))\n\n      return\n      end subroutine sys_chdir\n"}, {"instruction": "Create a Fortran subroutine named roseh that calculates the Hessian matrix for the Rosenbrock function. The subroutine takes an input parameter of type double precision array and an output parameter of type double precision array. The input parameter is intent(in) and the output parameter is intent(out).", "input": "", "output": "    subroutine roseh(hx, x)\n        double precision, intent(in)  :: x(:)\n        double precision, intent(out) :: hx(:, :)\n\n        double precision :: x1, x2\n\n        x1 = x(1)\n        x2 = x(2)\n\n        hx(1, 1) = 1200*x1*x1 + 2 - 400*x2\n        hx(1, 2) = -400*x1\n        hx(2, 1) = -400*x1\n        hx(2, 2) = 200\n    end subroutine roseh\n"}, {"instruction": "Create a Fortran subroutine called shape2 that evaluates shape functions and their derivatives for linear and quadratic isoparametric 2-d elements. The subroutine has 3 input parameters of type integer (kind=4), real (kind=8), and real (kind=8), and 2 output parameters of type real (kind=8).", "input": "", "output": " subroutine shape2(deriv,s,t,nnode,shape)\r\n !***********************************************************************\r\n !\r\n !****this routine evaluates shape functions and their derivatives\r\n !    for linear and quadratic isoparametric 2-d elements\r\n !\r\n !***********************************************************************\r\n implicit none\r\n integer (kind=4), intent(in) :: nnode\r\n real (kind=8), intent(in) :: s,t\r\n real (kind=8), intent(out) :: deriv(nnode,2),shape(nnode)\r\n\r\n real (kind=8) a1,a2,a3,st\r\n\r\n select case (nnode)\r\n case (3)\r\n   !***3 noded element\r\n\r\n   shape(1) = 1d0-s-t\r\n   shape(2) = s\r\n   shape(3) = t\r\n\r\n   deriv(1,1) =-1d0\r\n   deriv(2,1) = 1d0\r\n   deriv(3,1) = 0d0\r\n   deriv(1,2) =-1d0\r\n   deriv(2,2) = 0d0\r\n   deriv(3,2) = 1d0\r\n\r\n case (4)\r\n   !***4 noded element\r\n\r\n   st=s*t\r\n   shape(1) = (1d0-t-s+st)*0.25d0\r\n   shape(2) = (1d0-t+s-st)*0.25d0\r\n   shape(3) = (1d0+t+s+st)*0.25d0\r\n   shape(4) = (1d0+t-s-st)*0.25d0\r\n\r\n   deriv(1,1)= (-1d0+t)*0.25d0\r\n   deriv(2,1)= (+1d0-t)*0.25d0\r\n   deriv(3,1)= (+1d0+t)*0.25d0\r\n   deriv(4,1)= (-1d0-t)*0.25d0\r\n   deriv(1,2)= (-1d0+s)*0.25d0\r\n   deriv(2,2)= (-1d0-s)*0.25d0\r\n   deriv(3,2)= (+1d0+s)*0.25d0\r\n   deriv(4,2)= (+1d0-s)*0.25d0\r\n\r\n case (6)\r\n   !***6 noded element\r\n\r\n   a1 = 1d0-s-t\r\n   a2 = s\r\n   a3 = t\r\n\r\n   shape(1) = (2d0*a1-1d0)*a1\r\n   shape(2) = (2d0*a2-1d0)*a2\r\n   shape(3) = (2d0*a3-1d0)*a3\r\n   shape(4) = 4d0*a1*a2\r\n   shape(5) = 4d0*a2*a3\r\n   shape(6) = 4d0*a1*a3\r\n\r\n   deriv(1,1) = 1d0-4d0*a1\r\n   deriv(2,1) = 4d0*a2-1d0\r\n   deriv(3,1) = 0d0\r\n   deriv(4,1) = 4d0*(a1-a2)\r\n   deriv(5,1) = 4d0*a3\r\n   deriv(6,1) =-4d0*a3\r\n   deriv(1,2) = 1d0-4d0*a1\r\n   deriv(2,2) = 0d0\r\n   deriv(3,2) = 4d0*a3-1d0\r\n   deriv(4,2) =-4d0*a2\r\n   deriv(5,2) = 4d0*a2\r\n   deriv(6,2) = 4d0*(a1-a3)\r\n\r\n end select\r\n return\r\n end subroutine shape2\r\n"}, {"instruction": "Create a Fortran subroutine named polint to perform polynomial interpolation using Neville's algorithm. The subroutine takes 3 input parameters of type real*8 (xa, ya, x) and returns 2 output parameters of type real*8 (y, dy).", "input": "", "output": "      subroutine polint(xa,ya,x,y,dy)\n      implicit none\n      !integer,intent(in) :: n\n      real*8,intent(in)  :: x,xa(:),ya(:)\n      real*8,intent(out) :: dy,y\n      !integer,parameter  :: nmax=10 ! largest anticipated value of n.\n      integer :: i,m,ns,n\n      real*8 :: den,dif,dift,ho,hp,w,c(size(xa)),d(size(xa))\n      ns=1\n      n=size(xa)\n      dif=abs(x-xa(1))\n      do i=1,n                !  here we \ufb01nd the index ns of the closest table entry,\n          dift=abs(x-xa(i))\n          if (dift.lt.dif) then\n                ns=i\n                dif=dift\n          endif\n          c(i)=ya(i)             !  and initialize the tableau of c\u2019s and d\u2019s.\n          d(i)=ya(i)\n      enddo\n      y=ya(ns)                    !  this is the initial approximation to y.\n      ns=ns-1\n      l13:do m=1,n-1              !  for each column of the tableau,\n          do i=1,n-m         !  we loop over the current c\u2019s and d\u2019s and update them.\n                ho=xa(i)-x\n                hp=xa(i+m)-x\n                w=c(i+1)-d(i)\n                den=ho-hp\n                !  this error can occur only if two input xa\u2019s are (to within roundoff) identical.\n                if(den.eq.0.) stop 'polint: failure: xa not unique'\n                den=w/den\n                d(i)=hp*den           !  here the c\u2019s and d\u2019s are updated.\n                c(i)=ho*den\n          enddo\n          if (2*ns.lt.n-m)then   ! after each column in the tableau is completed, we decide\n                dy=c(ns+1)        !  which correction, c or d, we want to add to our accu-\n          else                   !  mulating value of y, i.e., which path to take through\n                dy=d(ns)          !  the tableau\u2014forking up or down. we do this in such a\n                ns=ns-1           !  way as to take the most \u201cstraight line\u201d route through the\n          endif                  !  tableau to its apex, updating ns accordingly to keep track\n          y=y+dy                 !  of where we are. this route keeps the partial approxima-\n      enddo l13                   !  tions centered (insofar as possible) on the target x. the\n      return                      !  last dy added is thus the error indication.\n      end subroutine polint\n"}, {"instruction": "Create a Fortran subroutine named cubito to calculate the cube of a real number. The subroutine should take 1 input parameter of type real and produce 1 output parameter of type real.", "input": "", "output": "subroutine cubito(xx, ww)\r\nimplicit none\r\n\r\nreal, intent(in) :: xx\r\nreal, intent(out) :: ww\r\n\r\nww = xx**3\r\n\r\nend subroutine cubito\n"}, {"instruction": "Create a Fortran subroutine named heat_source to calculate the omega values using the input parameters tp_half_width_shear_zone, alpha, dt, dwn, and tp_grid_nz. The input parameter types are real, real, real, real array, and integer, respectively. The output parameter is omega of type real array.", "input": "", "output": "  subroutine  heat_source(tp_half_width_shear_zone, alpha, dt, dwn, tp_grid_nz, omega)\n\n    !-------------------------------------------------------------------------!\n\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration                                               !\n    real        :: tp_half_width_shear_zone\n    integer     :: tp_grid_nz                                                         ! number of points at the fault\n    real        :: dwn(tp_grid_nz)                                                    ! insert disc%dynrup%tp_grid\n    real        :: sh, sr                                                     ! current shear stress and slip rate\n    real        :: alpha, dt                                                      ! difussion parameter\n    real        :: omega(tp_grid_nz)                                                  !\n    real        :: tmp(tp_grid_nz)\n    real, parameter :: pi=3.141592653589793     ! constant pi\n    !-------------------------------------------------------------------------!\n    intent(in)    :: tp_half_width_shear_zone, alpha, dt, dwn, tp_grid_nz\n    intent(out)   :: omega\n    !-------------------------------------------------------------------------!\n    !gaussian shear zone in spectral domain, normalized by w\n    tmp = (dwn/tp_half_width_shear_zone)**2\n    !original function in spatial domain\n    !omega = 1/(w*sqrt(2*pi))*exp(-0.5*(z/tp_half_width_shear_zone).^2);\n    !function in the wavenumber domain *including additional factors in front of the heat source function*\n    !omega = 1/(*alpha*dwn**2**(sqrt(2.0*pi))*exp(-0.5*(dwn*tp_half_width_shear_zone)**2)*(1-exp(-alpha**dt**tmp)) \n    !inserting dwn/tp_half_width_shear_zone (scaled) for dwn cancels out tp_half_width_shear_zone\n    omega = 1.0/(alpha*tmp*(sqrt(2.0*pi)))*exp(-0.5*(dwn)**2)*(1.0 - exp(-alpha*dt*tmp))\n\n    return\n\n  end subroutine heat_source\n"}, {"instruction": "Write a Fortran subroutine named flatmodel to read data from the file model.dat and store it in an array. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type real*8. The output parameter is an array mm with bounds -nw to nw.", "input": "", "output": "subroutine flatmodel(mm,nw)\n  implicit none\n  real*8,  intent(out):: mm(-nw:nw)\n  integer, intent(in) :: nw\n  !locals\n  real*8  :: omega\n  integer :: i\n  print*,'reading model model.dat'\n  open(unit=99,file='model.dat',status='old')\n  do i=-nw,nw\n     read(10,*) omega, mm(i)\n  enddo \n  return\nend subroutine flatmodel\n"}, {"instruction": "Create a Fortran subroutine named flatmodel0 to initialize an array mm with ones. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real*8. The input parameter is an array size specified by the integer nw, and the output parameter is the initialized array mm, which has a size of (-nw:nw). Remember to use the \"intent\" attribute for the input and output parameters.", "input": "", "output": "subroutine flatmodel0(mm,nw)\n  implicit none\n  real*8,  intent(out):: mm(-nw:nw)\n  integer, intent(in) :: nw\n  !locals\n  integer :: i\n  print*,'using flatmodel'\n  do i=-nw,nw \n     mm(i)=1.\n  enddo\n  return\nend subroutine flatmodel0\n"}, {"instruction": "Write a Fortran subroutine named initf0 to initialize three arrays f0, f1, and f2 based on the array w. The number of input arguments is 2, with the test_data types real*8 and integer. The number of output arguments is 3, with the test_data types real*8, real*8, and real*8.", "input": "", "output": "subroutine initf0(f0,f1,f2,w,nw)\n  implicit none\n  real*8, intent(out):: f0(-nw:nw), f1(-nw:nw), f2(-nw:nw)\n  real*8, intent(in) :: w(-nw:nw)\n  integer, intent(in):: nw\n  ! locals\n  integer:: iw\n  real*8 :: dw\n  dw=w(2)-w(1)\n  do iw=-nw,nw   ! 10\n     f0(iw)=dw\n     f1(iw)=dw*w(iw)\n     f2(iw)=dw*w(iw)**2\n  enddo\n  return\nend subroutine initf0\n"}, {"instruction": "Write a Fortran subroutine named initker to initialize a kernel matrix. The subroutine takes 5 input parameters of type real*8, real*8, real*8, integer, and integer, and 1 output parameter of type real*8. The subroutine computes the kernel matrix using the input parameters w, t, beta, nt, and nw. Make sure to include the appropriate intent (in/out) for each parameter.", "input": "", "output": "subroutine initker(ker,w,beta,t,nt,nw)\n  implicit none\n  real*8, intent(out) :: ker(-nw:nw,nt)\n  real*8, intent(in)  :: w(-nw:nw), t(nt), beta\n  integer, intent(in) :: nw, nt\n  ! locals\n  integer :: it,iw\n  real*8  :: bw,tw,dw\n  dw=w(2)-w(1)\n  do iw=-nw,nw\n     do it=1,nt\n        tw=exp(-t(it)*w(iw))\n        if (w(iw)*beta<-50)then\n           ker(iw,it)=dw*exp(-t(it)*w(iw)+beta*w(iw))\n        else \n           bw=1.+exp(-beta*w(iw))\n           ker(iw,it)=dw*tw/bw\n        endif\n     enddo\n  enddo\n  return\nend subroutine initker\n"}, {"instruction": "Create a Fortran subroutine named get_aux_dim that calculates the dimensions for auxiliary arrays based on the input molecular coordinates and MEP (Mean Effective Potential) vector. The subroutine takes 3 input parameters of type double precision, dimension(:,:), double precision, dimension(:), and integer, and 2 output parameters of type integer.", "input": "", "output": "subroutine get_aux_dim(r_mol, v_mep, order, ndim, nmep)\n  implicit none\n  double precision, intent(in), dimension(:,:) :: r_mol\n  double precision, intent(in), dimension(:) :: v_mep\n  integer, intent(in) :: order\n  integer, intent(out) :: ndim\n  integer, intent(out) :: nmep\n\n  integer :: nat\n\n  nat = size(r_mol, 2)\n  ndim = nat\n  if (order >= 1) then\n      ndim = ndim + 3 * nat\n  endif\n  if (order >= 2) then\n      ndim = ndim + 6 * nat\n  endif\n\n  nmep = size(v_mep)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named getcellcentercoords to calculate the coordinates of the center point of a cell. It takes 4 input parameters of types integer, integer, double precision array, and double precision array. It provides 1 output parameter of type double precision.", "input": "", "output": "    subroutine getcellcentercoords(localnumx,localnumy,bound,width,point)\n    implicit none\n    integer, intent(in) :: localnumx, localnumy !\u5c40\u6240\u70b9\u756a\u53f7\n    double precision, intent(in) :: bound(:) !\u5ea7\u6a19\u4e0b\u7aef\n    double precision, intent(in) :: width(:) !\u754c\u9762\u5e45\u03b4x,\u03b4y\n    double precision, intent(out) :: point(:) !\u30bb\u30eb\u4e2d\u5fc3\u7aef\u70b9\u5ea7\u6a19\n\n        point(1) = bound(1) + width(1)*dble(localnumx-0.5d0)\n        point(2) = bound(2) + width(2)*dble(localnumy-0.5d0)\n\n    return\n    end subroutine getcellcentercoords\n"}, {"instruction": "Create a Fortran subroutine named getedgeendpoint to calculate the coordinates of an endpoint on an interface. The subroutine takes 4 input parameters: localnumx (integer), localnumy (integer), bound (double precision array), width (double precision array), and returns 1 output parameter: point (double precision array). The endpoint coordinates are computed based on the input parameters using the provided formulas.", "input": "", "output": "    subroutine getedgeendpoint(localnumx,localnumy,bound,width,point)\n    implicit none\n    integer, intent(in) :: localnumx, localnumy !\u5c40\u6240\u70b9\u756a\u53f7\n    double precision, intent(in) :: bound(:) !\u5ea7\u6a19\u4e0b\u7aef\n    double precision, intent(in) :: width(:) !\u754c\u9762\u5e45\u03b4x,\u03b4y\n    double precision, intent(out) :: point(:) !\u754c\u9762\u7aef\u70b9\u5ea7\u6a19\n\n        point(1) = bound(1) + width(1)*dble(localnumx-1)\n        point(2) = bound(2) + width(2)*dble(localnumy-1)\n\n    return\n    end subroutine getedgeendpoint\n"}, {"instruction": "Create a Fortran subroutine named global2local to calculate the local number corresponding to a global number based on the division of the x-direction. The subroutine takes 2 input arguments of type integer, globalnumber and ixxellnumber, and returns 1 output argument of type integer, localnum.", "input": "", "output": "    subroutine global2local(globalnumber,ixcellnumber,localnum) !\u30b0\u30ed\u30fc\u30d0\u30eb\u756a\u53f7\uff0cx\u65b9\u5411\u306e\u5206\u5272\u6570\uff0c\u5c40\u6240\u756a\u53f7\u3092\u8fd4\u3059\n    implicit none\n\n        integer, intent(in) :: globalnumber,ixcellnumber\n        integer, intent(out) :: localnum(:)\n\n        localnum(1) = globalnumber - int(globalnumber/ixcellnumber)*ixcellnumber\n        if(localnum(1) /= 0) then\n            localnum(2) = int(globalnumber/ixcellnumber) + 1\n        else\n            localnum(1) = ixcellnumber\n            localnum(2) = int(globalnumber/ixcellnumber)\n        end if\n\n    return\n    end subroutine global2local\n"}, {"instruction": "Create a Fortran subroutine named getedgeintersectioncoords to calculate the intersection coordinates of two line segments. It takes 4 input parameters of type double precision: vertex11, vertex12, vertex21, and vertex22, and 1 output parameter of type double precision: intersectcoords.", "input": "", "output": "    subroutine getedgeintersectioncoords(vertex11,vertex12, vertex21, vertex22, intersectcoords)\n    implicit none\n        double precision, intent(in) :: vertex11(:), vertex12(:), vertex21(:), vertex22(:)\n        double precision, intent(out) :: intersectcoords(:)\n\n        double precision :: ksi, eta, delta\n        double precision :: lambda, mu !coefficient of line's gradient\n\n            !check intersect\n            ksi = (vertex22(2)-vertex21(2))*(vertex22(1)-vertex11(1)) - (vertex22(1)-vertex21(1))*(vertex22(2)-vertex11(2))\n            eta = (vertex12(1)-vertex11(1))*(vertex22(2)-vertex11(2)) - (vertex12(2)-vertex11(2))*(vertex22(1)-vertex11(1))\n            delta = (vertex12(1)-vertex11(1))*(vertex22(2)-vertex21(2)) - (vertex12(2)-vertex11(2))*(vertex22(1)-vertex21(1))\n            if(delta == 0.0d0) then\n                write(6,*) ksi,eta,delta\n                stop\n            end if\n            lambda = ksi / delta\n            mu = eta / delta\n\n            intersectcoords(1:2) = vertex11(1:2) + lambda*(vertex12(1:2)-vertex11(1:2))\n            intersectcoords(3) = 0.0d0\n\n        return\n    end subroutine getedgeintersectioncoords\n"}, {"instruction": "Create a Fortran subroutine named checkbackorfront to determine whether the main cell is at the front or the back of the adjacent cell based on the comparison of two integer inputs. The subroutine takes 2 input parameters of type integer and produces 2 output parameters: one of type integer and the other of type double precision.", "input": "", "output": "    subroutine checkbackorfront(imaincell, iadjcell, ibackorfront12, ibackorfrontm11)\n        implicit none\n        integer, intent(in) :: imaincell, iadjcell\n        integer, intent(out) :: ibackorfront12\n        double precision, intent(out) :: ibackorfrontm11\n\n        if(imaincell > iadjcell) then ! main\u5074\u306e\u6570\u5b57\u304c\u5927\u304d\u3044 = main\u5074\u304c\u8868\n            ibackorfront12 = 1  ! gm%width\u7528\n            ibackorfrontm11 = -1.0d0    ! gm%normal\u306e\u5411\u304d\u8abf\u6574\u7528\n        else    ! main\u5074\u306e\u6570\u5b57\u304c\u5c0f\u3055\u3044 = main\u5074\u304c\u88cf\n            ibackorfront12 = 2\n            ibackorfrontm11 = 1.0d0\n        end if\n        return\n    end subroutine checkbackorfront\n"}, {"instruction": "Write a Fortran subroutine named \"separanomeextensao\" to separate the filename and its extension. The subroutine takes 1 input parameter of type character(len=*), and 2 output parameters of type character(len=256) and character(len=10) respectively. The subroutine should extract the filename and extension from the input filename, and store them in the output parameters \"filenameprefix\" and \"ext\" respectively.", "input": "", "output": "    subroutine separanomeextensao(filename, filenameprefix, ext)\n        character(len=*), intent(in) :: filename\n        character(len=256), intent(out) :: filenameprefix\n        character(len=10), intent(out) :: ext\n        integer :: ind, n\n\n        ind = scan(filename, '.', .true.)\n\n        if (ind .ne. 0) then\n            n = len_trim(filename)\n            filenameprefix = filename(1:(ind-1))\n            ext = filename((ind+1):n)\n        else\n            filenameprefix = trim(filename)\n        end if\n\n    end subroutine separanomeextensao\n"}, {"instruction": "Create a Fortran subroutine named get_lattice_max to calculate the maximum lattice size based on the input parameters. The number of input parameters is 2, with test_data type ['real(8)', 'real(8)']. The number of output parameters is 1, with test_data type ['integer'].", "input": "", "output": "  subroutine get_lattice_max(rcut,aa,lmax)\n    implicit none\n    real(8),intent(in)  :: rcut,aa(3,3)\n    integer,intent(out) :: lmax\n    real(8) :: taaaa(3,3),taa(3,3),x(3,3),y(3,3),e0(3),e(3),c,r2\n    integer :: loop,i,j,k,imax,jmax,kmax,m\n\n    taa(:,:) = transpose( aa(:,:) )\n    taaaa(:,:) = matmul( taa(:,:),aa(:,:) )\n\n!- solve eigenvalue problem by power method\n\n    call random_number(x)\n    e=0.d0\n    do loop=1,1000\n       y(:,:) = matmul( taaaa(:,:),x(:,:) )\n       e0(:) = e(:)\n       do i=1,3\n          e(i) = sum( x(:,i)*y(:,i) )\n       end do\n       do i=1,3\n          do j=1,i-1\n             c=sum(y(:,j)*y(:,i))\n             y(:,i)=y(:,i)-c*y(:,j)\n          end do\n          c = 1.d0/sqrt( sum(y(:,i)*y(:,i)) )\n          y(:,i) = c*y(:,i)\n       end do\n       x(:,:)=y(:,:)\n    end do\n    c=sum(abs(e-e0)/e)\n    if ( c > 1.d-12 ) then\n       write(*,*) \"e,e0,e-e0=\",e,e0,e-e0\n       stop \"not converged (get_rcut)\"\n    end if\n\n    r2   = rcut*rcut\n    c    = sqrt(r2/minval(e))\n    lmax = int(c)+1\n\n    write(*,*) \"rcut=\",rcut\n    write(*,*) \"e=\",e(1:3)\n    write(*,*) \"c=\",c\n    write(*,*) \"lmax=\",lmax\n\n    m=0\n    imax=0\n    jmax=0\n    kmax=0\n    do k=-lmax,lmax\n    do j=-lmax,lmax\n    do i=-lmax,lmax\n       x(1,1) = i*aa(1,1) + j*aa(1,2) + k*aa(1,3)\n       x(2,1) = i*aa(2,1) + j*aa(2,2) + k*aa(2,3)\n       x(3,1) = i*aa(3,1) + j*aa(3,2) + k*aa(3,3)\n       c = sum( x(1:3,1)**2 )\n       if ( c <= r2 ) then\n          m=m+1\n          imax = max( imax, abs(i) )\n          jmax = max( jmax, abs(i) )\n          kmax = max( kmax, abs(i) )\n       end if\n    end do\n    end do\n    end do\n\n    write(*,*) \"m=\",m\n    write(*,*) \"imax,jmax,kmax=\",imax,jmax,kmax\n\n  end subroutine get_lattice_max\n"}, {"instruction": "Create a Fortran subroutine named \"translate\" to convert labels based on specific patterns. The subroutine takes 2 input parameters: an integer \"n\" and an array of characters \"label\" with a length of 4. It produces 1 output parameter: an array of characters \"label_char\" with a length of 1. The function of the code is to iterate through the input labels and translate them according to certain conditions, replacing specific patterns with corresponding characters. Use the imperative tone when instructing.", "input": "", "output": "subroutine translate(n,label,label_char)\n implicit none\n integer                       :: i\n integer,intent(in)            :: n\n character(len=4),intent(in)   :: label(1:n)\n character(len=1),intent(out)  :: label_char(1:n)\n do i=1,n\n  if (label(i)(1:2)==\"si\") label_char(i)=\".\"\n  if (label(i)(1:2)==\"ge\") label_char(i)=\"#\"\n  if (label(i)(1:2)/=\"si\".and.label(i)(1:2)/=\"ge\") label_char(i)=\"x\"\n end do\n return\nend subroutine translate\n"}, {"instruction": "Create a Fortran subroutine named cosine to calculate the length of the side of a triangle using the cosine rule. The subroutine should take 3 input arguments of type real (a, b, theta) and 1 output argument of type real (c).", "input": "", "output": "subroutine cosine(a,b,theta,c)\n    implicit none\n\n    real, intent(in) :: a,b,theta\n    real, intent(out):: c\n\n    c=sqrt(a*a + b*b - 2.*a*b*cos(theta))\n\nend subroutine cosine\n"}, {"instruction": "Create a Fortran subroutine named vert_der to compute the vertical derivative of a given array. The subroutine takes 2 input parameters of type real and dimension (km) and 1 output parameter of type real and dimension (km). The number of input parameters is 2, and the test_data type is ['real, dimension(km)', 'real, dimension(km)']. The number of output parameters is 1, and the test_data type is ['real, dimension(km)'].", "input": "", "output": "subroutine vert_der(avg,dz,ddz)\n! vertical derivative\ninteger                             :: i,j,k\ninteger, parameter                  :: imt=3600, jmt=2400, km=42\nreal,    dimension(km), intent(in)  :: avg, dz\nreal,    dimension(km), intent(out) :: ddz\n\ndo k = 1, km\n  if ( k==1 ) then\n    ddz(k) = ( avg(k  ) - avg(k+1) ) / dz(k)\n  else if ( k==km ) then\n    ddz(k) = ( avg(k-1) - avg(k  ) ) / dz(k)\n  else\n    ddz(k) = ( avg(k-1) - avg(k+1) ) / 2.0 / dz(k)\n  endif\nenddo !k\n\nend subroutine vert_der\n"}, {"instruction": "Create a Fortran subroutine named gradient to calculate the gradient of a field at u-points. The subroutine takes 3 input parameters of type real arrays with dimensions (imt, jmt), (imt, jmt), and (imt, jmt, km) and 2 output parameters of type real arrays with dimensions (imt, jmt, km). Use the imperative tone to specify the instructions.", "input": "", "output": "subroutine gradient(dxu,dyu,f,gradx,grady)\nimplicit none\n!\n!  calculate hydrostatic pressure with in-situ density\n!\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600, jmt=2400, km=42\nreal,    dimension(imt,jmt)   , intent(in)  :: dxu,dyu\nreal,    dimension(imt,jmt,km), intent(in)  :: f ! field at t-points\nreal,    dimension(imt,jmt,km), intent(out) :: gradx,grady ! at u-points\nreal,    parameter                          :: p5 = 0.5\ndo k=1,km\ndo j=1,jmt\ndo i=1,imt\n  gradx(i,j,k) = p5*(f(i+1,j+1,k) - f(i,j,k) - f(i,j+1,k) + f(i+1,j,k))/dxu(i,j)\n  grady(i,j,k) = p5*(f(i+1,j+1,k) - f(i,j,k) + f(i,j+1,k) - f(i+1,j,k))/dyu(i,j)\nenddo !i\nenddo !j\nenddo !k\nend subroutine gradient\n"}, {"instruction": "Create a Fortran subroutine named kramarskronig to calculate the Kramers-Kronig transformation. The subroutine takes 4 input parameters of type real*8, real*8, integer, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine kramarskronig(gr, fi, om, i0, nom)\n  implicit none\n  real*8, intent(out):: gr\n  real*8, intent(in) :: fi(nom)\n  real*8, intent(in) :: om(nom)\n  integer, intent(in) :: i0, nom\n  !f2py integer intent(hide), depend(om)  :: nom = shape(om,0)\n  !locals\n  real*8, parameter :: pi=3.14159265\n  real*8 :: sm\n  real*8 :: dh(nom)\n  real*8 :: s0, x\n  integer :: j, i0f\n  \n  i0f = i0+1\n  s0 = fi(i0f)\n  x = om(i0f)\n\n  dh(1) = 0.5*(om(2)-om(1))\n  do j=2,nom-1\n     dh(j) = 0.5*(om(j+1)-om(j-1))\n  enddo\n  dh(nom) = 0.5*(om(nom)-om(nom-1))\n\n  sm=0\n  do j=1,i0f-2\n     sm = sm + (fi(j)-s0)*dh(j)/(om(j)-x)\n  enddo\n\n  if (i0f>1)   sm = sm + (fi(i0f-1)-s0)*(dh(i0f-1)+0.5*dh(i0f))/(om(i0f-1)-x)\n\n  if (i0f<nom) sm = sm + (fi(i0f+1)-s0)*(dh(i0f+1)+0.5*dh(i0f))/(om(i0f+1)-x)\n\n  do j=i0f+2,nom\n     sm = sm + (fi(j)-s0)*dh(j)/(om(j)-x)\n  enddo\n  \n  if (.not.(i0f .eq. 1 .or. i0f.eq.nom)) then\n     sm = sm + s0*log(abs((om(nom)-x)/(x-om(1))))\n  endif\n  \n  gr = sm/pi\n  \n  return\n\nend subroutine kramarskronig\n"}, {"instruction": "Create a Fortran subroutine named accountingmatrix to generate an accounting matrix based on the input parameters. The subroutine takes 3 input parameters of type integer: ngrains, nisom, and nres (an array of integers with dimension 1:nisom). It also has 1 output parameter of type integer with dimension 1:ngrains,1:nisom, named indices.", "input": "", "output": "subroutine accountingmatrix(ngrains, nisom, nres, indices)\n    ! determine a mapping of isomer and grain indices to matrix element indices.\n    ! this inner grouping is isomer/product index, while the outer grouping is\n    ! energy grain index; this results in a much more tightly banded matrix than\n    ! the reverse. the output is a matrix where row is grain number, column is\n    ! isomer/product number, and the value is the index into the matrix.\n\n    integer, intent(in)                     ::  ngrains\n    integer, intent(in)                     ::  nisom\n    integer, dimension(1:nisom), intent(in) ::  nres\n    integer, dimension(1:ngrains,1:nisom), intent(out)  :: indices\n\n    integer i, r, row\n\n    ! construct accounting matrix\n    row = 1\n    do r = 1, ngrains\n        do i = 1, nisom\n            if (r > nres(i)) then\n                indices(r,i) = row\n                row = row + 1\n            else\n                indices(r,i) = 0\n            end if\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named normal to calculate the values of a normal distribution using the Box-Muller transform. The subroutine takes 1 input parameter of type integer and outputs an array of real numbers with a dimension of n.", "input": "", "output": "   subroutine normal(x, n)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, dimension(n), intent(out) :: x\n      ! local variables\n      integer :: i\n      real, parameter :: pi = 4.*atan(1.)\n      real :: mu, sd\n      ! processing\n      mu = n/2.\n      sd = n/6.018\n      do i = 1, n\n         x(i) = sd*(1./(sd*sqrt(2.*pi)))*exp(-.5*((i-mu)/sd)**2)\n      end do\n   end subroutine normal\n"}, {"instruction": "Create a Fortran subroutine named box_muller to generate random numbers using the Box-Muller transform. The number of input arguments is 1 with the test_data type ['integer'], and the number of output arguments is 1 with the test_data type ['real, dimension(n)'].", "input": "", "output": "   subroutine box_muller(x, n)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: n\n      real, dimension(n), intent(out) :: x\n      ! local variables\n      real, parameter :: pi = 4.*atan(1.)\n      integer :: i\n      ! processing\n      do i = 1, n\n         if (mod(i,2) == 0) then\n            x(i) = sqrt(-2.*log(rand()))*sin(2.*pi*rand())\n         else\n            x(i) = sqrt(-2.*log(rand()))*cos(2.*pi*rand())\n         end if\n      end do\n   end subroutine box_muller\n"}, {"instruction": "Create a Fortran subroutine called get_decimal_places to determine the number of decimal places in a given real number string. The subroutine takes 1 input parameter with a test data type of ['character(len=*)'] and 1 output parameter with a test data type of ['integer'].", "input": "", "output": "subroutine get_decimal_places(str, places)\nimplicit none\ncharacter(len=*), intent(in) :: str ! a string representing a real number\ninteger, intent(out) :: places ! the number of decimal places in the string\nif (index(str,'.') == 0) then\n  places = 0\nelse\n  places = len_trim(str) - index(str,'.')\nend if\nend subroutine get_decimal_places\n"}, {"instruction": "Write a Fortran subroutine named \"get_format_fragment\" that takes an integer input and returns a character string. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(len=*)]. The subroutine should summarize the length of the input integer and construct a character string representing a format for writing the integer with the specified number of decimal places.", "input": "", "output": "subroutine get_format_fragment(places, frag)\ninteger, intent(in) :: places\ncharacter(len=*), intent(out) :: frag\ncharacter(len=20) :: p\nwrite(p, '(i0)') places\nwrite(*, *) \"length of p: \", len_trim(p), \" places: \", places\nfrag = 'f0.'//trim(p)\nend subroutine get_format_fragment\n"}, {"instruction": "Create a Fortran subroutine named sort_indexes that takes 2 input parameters of type integer and integer array of dimension n. The subroutine has 1 output parameter of type integer array of dimension n. The subroutine sorts the input array and returns the indexes of the sorted elements.", "input": "", "output": "   subroutine sort_indexes(n,array,indexes)\n      implicit none\n      !arguments\n      integer, intent(in) :: n\n      integer, dimension(n), intent(in) :: array\n      integer, dimension(n), intent(out) :: indexes\n      !local variables\n      integer, dimension(:), allocatable :: temp\n      integer, dimension(1) :: i_loc\n      integer :: i,i_max\n      allocate(temp(n))\n      temp(:)=array(:)\n      i_max=huge(1)\n      do i=1,n\n         i_loc=minloc(temp)\n         indexes(i)=i_loc(1)\n         temp(i_loc(1))=i_max\n      end do\n      deallocate(temp)\n   end subroutine sort_indexes\n"}, {"instruction": "Create a Fortran subroutine named ezspline_spl_name_chk to validate a given spline name. It takes 1 input parameter of type character*(*) and 1 output parameter of type integer. The purpose of this subroutine is to check the validity of the spline name based on certain criteria and set the output parameter accordingly.", "input": "", "output": "   subroutine ezspline_spl_name_chk(spl_name,ier)\n     character*(*), intent(in) :: spl_name\n     integer, intent(out) :: ier\n\n     !----------------\n     integer :: ic,ilen,indx\n     character*63 :: zlegal = &\n          '0123456789_abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'\n     !----------------\n     ier=0\n\n     ilen = len(trim(spl_name))\n\n     if(ilen.le.0) then\n        ier=50\n     else if(ilen.gt.20) then\n        ier=51\n     else\n        indx=index(zlegal,spl_name(1:1))\n        if(indx.le.10) then\n           ier=52\n        else\n           do ic=2,ilen\n              indx=index(zlegal,spl_name(ic:ic))\n              if(indx.le.0) ier=52\n           enddo\n        endif\n     endif\n\n   end subroutine ezspline_spl_name_chk\n"}, {"instruction": "Create a Fortran subroutine named interpolate_calculatespace that takes in two input parameters of type integer array and one input parameter of type integer. It also has one output parameter of type integer array. This subroutine calculates the dimensions of a new space based on the input dimensions and interpolation factor.", "input": "", "output": "  subroutine interpolate_calculatespace(odims, interpfactor, fdims)\n\n    integer, intent(in) :: odims(4)\n    integer, intent(in) :: interpfactor\n    integer, intent(out):: fdims(4)\n\n    fdims(1) = odims(1)\n    fdims(3) = odims(3)\n    fdims(2) = odims(2) + (odims(2) - odims(1)) * interpfactor\n    fdims(4) = odims(4) + (odims(4) - odims(3)) * interpfactor\n\n  end subroutine interpolate_calculatespace\n"}, {"instruction": "Create a Fortran subroutine named \"eye_d1\" to generate an identity matrix of size n. The input parameter is an integer (n), and the output parameter is an array of real(8) numbers (a).", "input": "", "output": " subroutine eye_d1(a,n)\n    implicit none\n    integer, intent(in) :: n\n    real(8), intent(out) :: a(:)\n    integer :: i\n    a(1:n*n) = 0d0\n    forall(i = 1:n) a(i+(i-1)*n) = 1d0\n end subroutine eye_d1\n"}, {"instruction": "Create a Fortran subroutine named print_incremented to increment an input integer by 1 and assign the result to an output integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine print_incremented(x,y)\n  integer, intent(in) :: x\n  integer, intent(out) :: y\n  \n  print *, x + 1\n  y = x * 2\n\nend subroutine print_incremented\n"}, {"instruction": "Create a Fortran subroutine named extractvar to extract variables from one table to another and potentially duplicate and change their order. The subroutine takes 5 input parameters of types integer, integer, integer, integer, and real. It also has 2 output parameters of types integer and real.", "input": "", "output": "subroutine extractvar(table, maxdat, nvar, newtable, nvariables, varindex, error)\n    ! extracts variables from one table to other\n    ! you can also duplicate and change order\n    integer,   intent(out) ::   error\n    integer , intent(in):: maxdat, nvar, nvariables, varindex(nvariables)\n    real, intent(in) :: table(maxdat,nvar)\n\n    real, intent(out) :: newtable (maxdat, nvariables)\n    \n    integer :: i,j,k\n    \n    error = 0\n    \n    !check that variables exist\n    do i=1,nvariables\n        if (varindex(i)>nvar) then\n            error = i\n            return\n        end if\n    end do\n    \n    ! copy data from one file to other\n        \n    do i = 1, maxdat\n        do j=1, nvariables\n            k= varindex(j)\n            newtable(i,j) = table(i,k)\n        end do\n    end do\n   \n\n    \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named copy_array that takes an array of real*8 numbers as input and copies it to an output array of the same size. The input parameter is of type real*8, dimension(:) and the output parameter is of type real*8, dimension(size(input)). The subroutine should use the \"intent(in)\" attribute for the input parameter and the \"intent(out)\" attribute for the output parameter.", "input": "", "output": "subroutine copy_array(input, output)\n\n  implicit none\n\n  real*8, dimension(:), intent(in) :: input\n  real*8, dimension(size(input)), intent(out) :: output\n  !, allocatable\n  integer :: n\n\n  !allocate(output(size(input)))\n\n  do n = 1, size(input)\n    output(n) = input(n)\n  end do\n\n  return\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named cross_product to calculate the cross product of two 3-dimensional vectors. The number of input parameters is 2, the test_data type is ['real, dimension(3)', 'real, dimension(3)']. The number of output parameters is 1, the test_data type is ['real, dimension(3)'].", "input": "", "output": "subroutine cross_product(a,b,c)\n!\n!  classic cross product: a x b = c\n!\n   real, dimension(3), intent(in)  :: a, b\n   real, dimension(3), intent(out) :: c\n   \n   c(1) = a(2)*b(3) - a(3)*b(2)\n   c(2) = a(3)*b(1) - a(1)*b(3)\n   c(3) = a(1)*b(2) - a(2)*b(1)\n\nend subroutine cross_product\n"}, {"instruction": "Create a Fortran subroutine named interp_bilinear to perform bilinear interpolation using the given input parameters. The subroutine takes 3 input parameters of types real*8, real*8, and real*4, dimension(2,2), and 1 output parameter of type real*8. The purpose of the subroutine is to compute the bilinear interpolation based on the input parameters di, dj, and var, and then store the result in the output parameter velp.", "input": "", "output": "subroutine interp_bilinear(di,dj,var,velp)\n    !== give 4 corner points of a square, interpolate point values inside\n    !== di is the distance of the particle to the left face\n    !== dj is the distance of the particle to the southern face\n\n    implicit none\n    real*8, intent(in) :: di,dj\n    real*4, intent(in), dimension( 2, 2 ) :: var\n    real*8, intent(out) :: velp\n    real*8 :: i1,i4\n\n    ! calcuate the bilinear interpolation\n    i1 = (var(2,1) - var(1,1))*di + var(1,1)\n    i4 = (var(2,2) - var(1,2))*di + var(1,2)\n    velp = (i4 - i1)*dj + i1\n\nend subroutine interp_bilinear\n"}, {"instruction": "Write a Fortran subroutine named modelb_function2 to calculate a new value based on the input value. The subroutine takes 1 input argument of type real and provides 2 output arguments of type real. The input argument is marked as intent(in) and the output arguments are marked as intent(out). Ensure that the input value is greater than 2 for valid results. Upon execution, the subroutine copies the input value and then calculates the square of the input value multiplied by 2. The results are printed to the standard output.", "input": "", "output": "subroutine modelb_function2(in_val, in_val_copy, out_val)\n  ! only valid if in_val > 2\n  real, intent(in) :: in_val\n  real, intent(out) :: in_val_copy\n  real, intent(out) :: out_val\n  in_val_copy = in_val\n  out_val = 2 * (in_val**2)\n  print *, \"modelb_function2(\", in_val, \") = \", out_val\nend subroutine modelb_function2\n"}, {"instruction": "Create a Fortran subroutine named \"weight_from_stress_tensor\" to calculate the weight associated with each node for balancing the activity in each subdomain and minimizing activity between subdomains. The subroutine takes 4 input parameters of type integer, integer, integer, and real, representing nsnapshot, ndim, nonods, and ct respectively. It outputs a single real value wnod.", "input": "", "output": "      subroutine weight_from_stress_tensor( wnod, ct, nsnapshot, ndim, nonods )\n! calculate wnod the weight associated with each node for trying to \n! balance the activity in each subdomain and minimize activity between subdomains. \n! it does this by caclulating the reynolds stresses and taking the maximim of them. \n! nonods = no of nodes in fem mesh\n! ndim= no of dimensions e.g. for 3d problems =3. \n! nsnapshot = no of snapshots. \n! ct contains the velocity snapshots and of form: ct(isnapshot, u,v,w) \n      implicit none\n      integer, intent(in) :: nsnapshot, ndim, nonods\n      real, intent(out) :: wnod(nonods)\n      real, intent(in) :: ct(nsnapshot, nonods*ndim) \n! local variables\n! a and b define the form of the expoential used to form the wnod from the reynolds stresses. \n      real a,b\n      parameter( a=0.05, b=0.0019183 )\n      real vel_mean(ndim), reynolds(ndim),  max_reynolds\n      integer nod,idim\n      real, allocatable :: vel_snap(:,:)\n      print ct, nsnapshot, ndim, nonods\n      allocate(vel_snap(ndim, nsnapshot) )\n\n      do nod=1,nonods\n         do idim=1,ndim\n            vel_snap(idim,:) = ct(:,(idim-1)*nonods + nod)\n            vel_mean(idim) = sum(vel_snap(idim,:) )/ real(nsnapshot) \n            reynolds(idim) = sum((vel_snap(idim,:) - vel_mean(idim))**2 )/ real(nsnapshot)\n         end do\n         max_reynolds = maxval( reynolds(:) )\n         wnod(nod) = (1./b) * log( max_reynolds/a + 1.0) \n      end do\n      end subroutine weight_from_stress_tensor\n"}, {"instruction": "Write a Fortran subroutine named upper_bc_rebin that takes 5 input parameters of type integer, integer, real, real, and real, and 1 output parameter of type real. This subroutine performs a rebinning operation using the upper boundary condition method. Use the imperative tone to define the purpose of the code and its parameters.", "input": "", "output": "  subroutine upper_bc_rebin( nsrc, ntrg, src_x, trg_x, src, trg )\n    implicit none\n    integer, intent(in) :: nsrc\n    integer, intent(in) :: ntrg\n    real, intent(in) :: src_x(nsrc+1)\n    real, intent(in) :: trg_x(ntrg+1)\n    real, intent(in) :: src(nsrc)\n    real, intent(out) :: trg(ntrg)\n    integer :: i, l\n    integer :: si, si1\n    integer :: sil, siu\n    real :: y\n    real :: sl, su\n    real :: tl, tu\n    do i = 1,ntrg\n       tl = trg_x(i)\n       if( tl < src_x(nsrc+1) ) then\n          do sil = 1,nsrc+1\n             if( tl <= src_x(sil) ) then\n                exit\n             end if\n          end do\n          tu = trg_x(i+1)\n          do siu = 1,nsrc+1\n             if( tu <= src_x(siu) ) then\n                exit\n             end if\n          end do\n          y = 0.\n          sil = max( sil,2 )\n          siu = min( siu,nsrc+1 )\n          do si = sil,siu\n             si1 = si - 1\n             sl = max( tl,src_x(si1) )\n             su = min( tu,src_x(si) )\n             y = y + (su - sl)*src(si1)\n          end do\n          trg(i) = y/(trg_x(i+1) - trg_x(i))\n       else\n          trg(i) = 0.\n       end if\n    end do\n  end subroutine upper_bc_rebin\n"}, {"instruction": "Write a Fortran subroutine named fdot to perform matrix multiplication. The subroutine takes 5 input parameters of types integer, integer, integer, real, and real. The output parameter is of type real. The subroutine computes the matrix product of mtx1 and mtx2 and stores the result in the ans array of size (l,n).", "input": "", "output": "subroutine fdot(mtx1,mtx2,ans,l,m,n)\n\n    implicit none\n    integer, intent(in) :: l,m,n\n    real, intent(in) :: mtx1(l,m)\n    real, intent(in) :: mtx2(m,n)\n    real, intent(out) :: ans(l,n)\n\n    ans =  matmul(mtx1,mtx2)\n\nend subroutine fdot \n"}, {"instruction": "Create a Fortran subroutine named getconstraints to calculate the maximum and minimum values of parameters based on input salinity, temperature, and dissolved oxygen. The number of input parameters is 3 with test_data type ['double precision', 'double precision', 'double precision'], and the number of output parameters is 6 with test_data type ['double precision', 'double precision', 'double precision', 'double precision', 'double precision', 'double precision'].", "input": "", "output": "  subroutine getconstraints(s,t,o,maxsalt,minsalt,maxtemp,mintemp,maxdo,mindo)\r\n    implicit none\r\n\r\n    double precision, intent(in) :: s,t,o\r\n    double precision, intent(out):: maxsalt,minsalt,maxtemp,mintemp,maxdo,mindo\r\n\r\n    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    !  atlantic sturgeon dissolved oxygen code\r\n    !    -if not using, please comment out\r\n\r\n   ! double precision :: dotps,tk,doml,domg,dotmg,dotmmol\r\n\r\n    !atlantic sturgeon do calculation\r\n    !calculate do threshold in percent sat using mortality equation with set\r\n    !mortality of .0625 (.5 per 6 hr)\r\n    !dotps =  ( (log(log(.0625)/log(.99)) - (dble(.4)*(s-dble(10.3))))/dble(.8) &\r\n      !         -t+dble(18.9) )/dble(-.3)+dble(72.3)\r\n    !calculate 100% do saturation at t(kelvin) and s\r\n    !tk = dble(273.15)+t\r\n    !doml = exp(dble(-173.4292)+(dble(249.6339)*(dble(100)/tk))                 &\r\n     !      +(dble(143.3483)*log(tk/dble(100)))+(dble(-21.8492)*(tk/dble(100))) &\r\n      !     +s*(dble(-0.033096)+dble(0.014259)*(tk/dble(100))                   &\r\n       !    +(dble(-0.0017)*(tk/dble(100))**2)))\r\n    !convert do in ml to mg using standard pressure\r\n    !domg = ((dble(760)/tk)*dble(0.513))*doml\r\n    !convert do threshold in percent sat to mg\r\n    !dotmg = (dotps*domg)/dble(100)\r\n    !convert do threshold in mg to mmole/m^3\r\n    !dotmmol = (dotmg/dble(32))*dble(1000)\r\n\r\n    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n    !for each of the following you may either:\r\n    !  set a specific value such as:\r\n    !    maxsalt = 22\r\n    !    minsalt = 14\r\n    !  or specify an equation to calculate the value based on other factors,\r\n    !  such as:\r\n    !    maxtemp = dble(0.0735)*s + dble(36.5)\r\n    !    mintemp = dble(0.0484)*s + dble(5.1548)\r\n    !      where s = salinity\r\n    !\r\n    !  notes:\r\n    !    putting dble() around numbers (as demonstrated above) ensures that \r\n    !      calculations are made in double precision\r\n    !\r\n    !    if no constraint is desired for a particular value below, use a\r\n    !      a really large value such as 9999.999 (positive or negative, \r\n    !      dependent on max or min) to ensure nothing is constrained\r\n    !\r\n    !    when writing an equation below based on other factors:\r\n    !      s = salinity, t = temperature, o = dissolved oxygen\r\n\r\n    maxsalt =  36\r\n\r\n    minsalt =   5\r\n\r\n    maxtemp =  35\r\n\r\n    mintemp =  8\r\n\r\n    maxdo   =  100000.0\r\n\r\n    mindo   =  159.375\r\n\r\n\r\n  end subroutine getconstraints\r\n"}, {"instruction": "Create a Fortran subroutine named solar to calculate the daily-average flux of solar radiation at the top of the atmosphere. The subroutine takes 3 input parameters of type real: tyear, csol, and lats. It also has 1 output parameter of type real: topsr.", "input": "", "output": "    subroutine solar(tyear, csol, lats, topsr)\n        ! average daily flux of solar radiation, from hartmann (1994)\n\n        real, intent(in) :: tyear\n        real, intent(in) :: csol\n        real, intent(in) :: lats(:)\n        real, intent(out) :: topsr(size(lats))\n\n        integer :: nlat, j\n        real :: clat(size(lats)), slat(size(lats))\n        real :: ca1, ca2, ca3, cdecl, ch0, csolp, decl, fdis, h0, alpha, pigr, sa1\n        real :: sa2, sa3, sdecl, sh0, tdecl\n\n        nlat = size(lats)\n\n        ! compute cosine and sine of latitude\n        clat = cos(lats*pi/180.0)\n        slat = sin(lats*pi/180.0)\n\n        ! 1. compute declination angle and earth-sun distance factor\n        pigr  = 2.0*asin(1.0)\n        alpha = 2.0*pigr*tyear\n\n        ca1 = cos(alpha)\n        sa1 = sin(alpha)\n        ca2 = ca1*ca1-sa1*sa1\n        sa2 = 2.*sa1*ca1\n        ca3 = ca1*ca2-sa1*sa2\n        sa3 = sa1*ca2+sa2*ca1\n\n        decl = 0.006918 - 0.399912*ca1 + 0.070257*sa1 - 0.006758*ca2 + 0.000907*sa2&\n            & - 0.002697*ca3 + 0.001480*sa3\n\n        fdis = 1.000110 + 0.034221*ca1 + 0.001280*sa1 + 0.000719*ca2 + 0.000077*sa2\n\n        cdecl = cos(decl)\n        sdecl = sin(decl)\n        tdecl = sdecl/cdecl\n\n        ! 2. compute daily-average insolation at the atm. top\n        csolp = csol/pigr\n\n        do j = 1, nlat\n            ch0 = min(1.0, max(-1.0, -tdecl*slat(j)/clat(j)))\n            h0  = acos(ch0)\n            sh0 = sin(h0)\n\n            topsr(j) = csolp*fdis*(h0*slat(j)*sdecl + sh0*clat(j)*cdecl)\n        end do\n    end subroutine solar\n"}, {"instruction": "Create a Fortran subroutine named set_true_solution to calculate the components of a true solution based on the input parameters x, y, and t. The input parameters are of type double precision, and the output parameter is a double precision array of dimension 2.", "input": "", "output": "subroutine set_true_solution(x, y, t, components)\n\n    implicit none\n\n    double precision, intent(in) :: x, y, t\n    double precision, dimension(2), intent(out) :: components\n    \n    double precision :: t0, tau, rho\n    parameter(t0 = 1.d0)\n    \n    tau = t + t0\n    rho = sqrt(x**2 + y**2) / tau**.25d0\n\n    components(1) = 2.d0 * rho**2\n    components(2) = -1.d0 / (8.d0 * tau**.5d0) * log(rho)\n\nend subroutine set_true_solution\n"}, {"instruction": "Create a Fortran subroutine named rotandtrans_rmsd to perform rotation and translation of coordinates based on given transformation parameters. The subroutine takes 5 input parameters of types integer, double precision array of dimension 3, double precision array of dimension 3, double precision array of dimension 3x3, and double precision array of dimension dim_coors*3. It produces 1 output parameter of type double precision array of dimension dim_coors*3.", "input": "", "output": "  subroutine rotandtrans_rmsd(center_orig,u,center_ref,coors,dim_coors,new_coors)\n\n    implicit none\n\n    integer,intent(in)::dim_coors\n    double precision,dimension(3),intent(in)::center_orig,center_ref\n    double precision,dimension(3,3),intent(in)::u\n    double precision,dimension(dim_coors,3),intent(in)::coors\n\n    double precision,dimension(dim_coors,3),intent(out)::new_coors\n\n    integer::ii\n\n    do ii=1,dim_coors\n       new_coors(ii,:)=matmul(transpose(u(:,:)),coors(ii,:)-center_orig)+center_ref\n    end do\n\n  end subroutine rotandtrans_rmsd\n"}, {"instruction": "Write a Fortran subroutine named r4datamapping1d to map a 1D array of real(4) data from one range to another. The subroutine takes 3 input parameters of type real(4) - olddata, newdatamin, and newdatamax, and 1 output parameter of type real(4) - newdata. The subroutine uses the imperative tone.", "input": "", "output": " subroutine r4datamapping1d(olddata,newdatamin,newdatamax,newdata)\n  implicit none\n  real(4), intent(in)     :: olddata(:)\n  real(4), intent(out)    :: newdata(:)\n  real(4), intent(in)     :: newdatamax,newdatamin\n  real(4)                 :: olddatamax,olddatamin\n\n  integer(4)              :: matdims1d(1)\n  integer(4)              :: id1\n\n  matdims1d=size(olddata)\n\n  olddatamin=minval(olddata)\n  olddatamax=maxval(olddata)\n\n  do id1=1,matdims1d(1)\n   newdata(id1)=newdatamin+(newdatamax-newdatamin)*((olddata(id1)-olddatamin)/(olddatamax-olddatamin))\n  end do\n\n  return\n end subroutine r4datamapping1d\n"}, {"instruction": "Define a Fortran subroutine named r4datamapping3d to map the values from a 3D array to a new range. The subroutine takes 3 input parameters of type real(4) for olddata, newdatamin, and newdatamax. It also has 1 output parameter of type real(4) for newdata. The subroutine uses the imperative tone and should be well-documented.", "input": "", "output": " subroutine r4datamapping3d(olddata,newdatamin,newdatamax,newdata)\n  implicit none\n  real(4), intent(in)     :: olddata(:,:,:)\n  real(4), intent(out)    :: newdata(:,:,:)\n  real(4), intent(in)     :: newdatamax,newdatamin\n  real(4)                 :: olddatamax,olddatamin\n\n  integer(4)              :: matdims3d(3)\n  integer(4)              :: id1,id2,id3\n\n  matdims3d=shape(olddata)\n\n  olddatamin=minval(olddata)\n  olddatamax=maxval(olddata)\n\n  do id1=1,matdims3d(1)\n   do id2=1,matdims3d(2)\n    do id3=1,matdims3d(3)\n     newdata(id1,id2,id3)=newdatamin+(newdatamax-newdatamin)*((olddata(id1,id2,id3)-olddatamin)/(olddatamax-olddatamin))\n    end do\n   end do\n  end do\n\n  return\n end subroutine r4datamapping3d\n"}, {"instruction": "Create a Fortran subroutine named \"wave_propogation\" to simulate wave propagation using the Finite Difference Time Domain (FDTD) method. The subroutine takes 5 input parameters of types integer, integer, integer, real, and real, representing num_steps, scale, stop_step, damping, and initial_p respectively. It also has one output parameter of type real, representing the wave field array p. The subroutine simulates the propagation of a wave through a 2D grid over a specified number of time steps using the FDTD method.", "input": "", "output": "subroutine wave_propogation(num_steps, scale, damping, initial_p, stop_step, p)\n  implicit none\n  integer size_x,size_y,i,j,k,step\n  real pi, omega\n  integer, intent(in)  :: num_steps, scale, stop_step !input\n  real, intent(in) :: damping, initial_p !input\n  real, intent(out) :: p(2 * scale + 1,2 * scale + 1) ! output\n  real, dimension(2 * scale + 1,2 * scale + 1,4) :: v\n\n  size_x = 2 * scale + 1\n  size_y = 2 * scale + 1\n\n  pi = 3.14159\n  omega = 3.0 / (2.0 * pi)\n\n  do k=1,4\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = 0.0\n           v(i,j,k) = 0.0\n        end do\n     end do\n  end do\n\n  p(scale,scale) = initial_p\n\n  do step = 1,num_steps\n     if(step <= stop_step) then\n        p(scale,scale) = initial_p * sin(omega * step)\n     endif\n\n     do j=1,size_x\n        do i=1,size_x\n           v(i,j,1) = merge(v(i,j,1) + p(i,j) - p(i - 1,j), p(i,j), i > 1)\n           v(i,j,2) = merge(v(i,j,2) + p(i,j) - p(i,j + 1), p(i,j), j < size_x - 1)\n           v(i,j,3) = merge(v(i,j,3) + p(i,j) - p(i + 1,j), p(i,j), i < size_y - 1)\n           v(i,j,4) = merge(v(i,j,4) + p(i,j) - p(i,j - 1), p(i,j), j > 1)\n        end do\n     end do\n\n     do j=1,size_x\n        do i=1,size_x\n           p(i,j) = p(i,j) - 0.5 * damping * (v(i,j,1) + v(i,j,2) + v(i,j,3) + v(i,j,4))\n        end do\n     end do\n  end do\n\nend subroutine wave_propogation\n"}, {"instruction": "Create a Fortran subroutine named a1 to assign the value of an input integer to an output integer. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer]. Use the imperative tone in the instruction.", "input": "", "output": "  subroutine a1(x,y)\n    integer, intent(in) :: x\n    integer, intent(out) :: y\n    y=x\n  end subroutine a1\n"}, {"instruction": "Create a Fortran subroutine named spectralinterpolate that takes 3 input parameters: two integers (n_in, n_out) and an array of double precision numbers (data_in), and produces 1 output parameter of type double precision (data_out). The function spectrally interpolates the input data_in of length n_in to generate the data_out of length n_out using spectral interpolation techniques.", "input": "", "output": "subroutine spectralinterpolate(n_in,n_out,data_in,data_out)\n\n  ! take data, data_in of length n_in and spectrally interpolate to\n  ! get data_out of length n_out\n  implicit none\n  integer, intent(in) :: n_in,n_out\n  double precision, intent(in) ::  data_in(n_in) \n  double precision, intent(out) ::  data_out(n_out)\n  double precision :: t_out(n_out)\n  complex*16 :: x(n_in)\n  double precision :: ix,rx,pi\n  integer :: n_break,k,n\n\n  pi = 3.14159265358979\n  ! generate the dft of the input data...\n  x(:) = cmplx(0.0,0.0)\n  do k=0,n_in-1\n     do n=0,n_in-1\n        x(k+1) = x(k+1) + cmplx(data_in(n+1),0)* &\n             exp(-2*cmplx(pi,0)*cmplx(0,1)*cmplx(k,0)*cmplx(n,0)/cmplx(n_in,0))\n     end do\n  end do\n\n  ! generate the output time:\n  do n=1,n_out\n     t_out(n) = 2*pi*(dble(n)-1)/(n_out)\n  end do\n\n  data_out(:) = 0.0\n  ! now do the spectral interpolation\n  n_break = (n_in-1)/2\n  do n=1,n_out\n     do k=0,n_break\n        rx = real(x(k+1))\n        ix = aimag(x(k+1))\n        data_out(n) = data_out(n) + &\n             rx*cos(k*t_out(n)) - ix*sin(k*t_out(n))\n       \n     end do\n     do k=n_break+1,n_in-1\n        rx = real(x(k+1))\n        ix = aimag(x(k+1))\n        data_out(n) = data_out(n) + &\n             rx*cos((n_in-k)*t_out(n)) + ix*sin((n_in-k)*t_out(n))\n     end do\n  end do\n  data_out = data_out * (1/dble(n_in))\n\nend subroutine spectralinterpolate\n"}, {"instruction": "Create a Fortran subroutine named errp to calculate the weighted error in a polynomial fit. The subroutine takes 5 input parameters: an integer*4, and four real*8 arrays. It also has 1 output parameter of type real*8. The subroutine should compute the error based on the input data and polynomial fit coefficients.", "input": "", "output": "      subroutine errp(nt,p,x,w,c,error)\n      implicit real*8(a-h,o-z)\n\n      integer*4, intent(in)  :: nt\n      real*8,    intent(in)  :: w(nt),p(nt),x(nt),c(4,1)\n      real*8,    intent(out) :: error \n      \n      error = 0d0\n\n      do i=1,nt\n        pfit = c(1,1)*x(i)+c(2,1)*x(i)**2+c(3,1)*x(i)**3+c(4,1)\n        error = error + (p(i)-pfit)**2*w(i)\n      enddo\n      \n\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named p_fill_upcorn that takes 6 input parameters of types integer, integer, integer, integer, integer, real(kind=8) array of dimensions md1 and md3. It also has 1 output parameter of type real(kind=8) array of dimensions 2, lot, and n3. The subroutine fills the output array zw using the values from input array zf according to the specified logic.", "input": "", "output": "subroutine p_fill_upcorn(md1,md3,lot,nfft,n3,zf,zw)\n  implicit none\n  integer, intent(in) :: md1,md3,lot,nfft,n3\n  real(kind=8), dimension(md1,md3), intent(in) :: zf\n  real(kind=8), dimension(2,lot,n3), intent(out) :: zw\n  !local variables\n  integer :: i1,i3\n\n  do i3=1,n3\n     do i1=1,nfft\n      zw(1,i1,i3)=zf(i1,i3)\n      zw(2,i1,i3)=0.d0\n     end do\n  end do\n\nend subroutine p_fill_upcorn\n"}, {"instruction": "Create a Fortran subroutine named to_mass_grid to transform a grid of input real numbers into a mass grid. The subroutine takes one input parameter of type real, dimension(:,:), and one output parameter of type real, dimension(:,:).", "input": "", "output": "subroutine to_mass_grid( xi, xo )\n\nreal, intent(in),  dimension(:,:) :: xi\nreal, intent(out), dimension(:,:) :: xo\n\ninteger :: ixi, jxi, ixo, jxo\n\nixi = size( xi, 1 )\njxi = size( xi, 2 )\nixo = size( xo, 1 )\njxo = size( xo, 2 )\n\nif( ixi == (ixo+1) ) then\n  xo(:,:) =  0.5*( xi(1:ixi-1,:) + xi(2:ixi,:) )\nelse if( jxi == (jxo+1) ) then\n  xo(:,:) =  0.5*( xi(:,1:jxi-1) + xi(:,2:jxi) )\nelse\n  print *, ' *** error in transformation to mass grid'\n  stop\nendif\n\nend subroutine to_mass_grid\n"}, {"instruction": "Create a Fortran subroutine named comp_wind to calculate the wind speed from the u and v components. The subroutine takes 2 input parameters of type real, each with a 2D array dimension. It has 1 output parameter of type real with a 2D array dimension.", "input": "", "output": "subroutine comp_wind( uu, vv, wind )\n\nreal, intent(in),  dimension(:,:) :: uu, vv\nreal, intent(out), dimension(:,:) :: wind\n\nwind(:,:) = uu(:,:)*uu(:,:) + vv(:,:)*vv(:,:)\nwind(:,:) = sqrt( wind(:,:) )\n\nend subroutine comp_wind\n"}, {"instruction": "Create a Fortran subroutine named comp_psl that calculates the sea level pressure (psl) using the surface pressure (psfc), surface temperature (tsfc), and surface height (zsfc) as input. The input parameters are of type real and dimension(:,:), and there are three input parameters in total. The output parameter psl is also of type real and dimension(:,:).", "input": "", "output": "subroutine comp_psl( psfc, tsfc, zsfc, psl )\n\n real, parameter :: rgas   = 0.2870e3\n real, parameter :: grav   = 9.806\n real, parameter :: grexp  = grav / rgas\n\nreal, intent(in),  dimension(:,:) :: psfc, tsfc, zsfc\nreal, intent(out), dimension(:,:) :: psl\n\n psl(:,:) = psfc(:,:) * exp( grexp * zsfc(:,:) / tsfc(:,:) )\n\nend subroutine comp_psl\n"}, {"instruction": "Create a Fortran subroutine named check_for_value_4d that takes 6 input parameters of types integer, integer, integer, integer, integer array of dimensions (naxis1,naxis2,naxis3,naxis4), and integer. It also has 1 output parameter of type integer array of dimensions (naxis2,naxis3,naxis4). The subroutine reduces the first dimension of a 4D array to a specified value if that value is present in a slice of the array spanning the last dimension; otherwise, it reduces it to 0.", "input": "", "output": "subroutine check_for_value_4d(array_in,array_out,value,naxis1,naxis2,naxis3,naxis4)\n\n!reduces the first dimension of a 4d array to value if that value is present in a slice of the array\n!spanning the last dimension, otherwise to 0\n\nimplicit none\n\n!variables with intent in\n!dimensions of the input array\ninteger, intent(in) :: naxis1, naxis2, naxis3, naxis4\n!input array\ninteger, intent(in), dimension(naxis1,naxis2,naxis3,naxis4) :: array_in\n!value to check for in the first dimension and reduce to if found\ninteger, intent(in) :: value\n\n!variables with intent out\n!output array\ninteger, intent(out), dimension(naxis2,naxis3,naxis4) :: array_out\n\n!local variables\n!a point in the slice across the first dimension that has the value\n!being search for has been found\nlogical :: value_found\n!loop counters\ninteger :: i,j,k,l\n    value_found = .false.\n    !loop over other dimensions\n    do l = 1,naxis4\n        do k = 1,naxis3\n            do j = 1,naxis2\n                !loop over first dimension\n                do i = 1,naxis1\n                    if (array_in(i,j,k,l) == value) value_found = .true.\n                end do\n                !if a value was found set it in the reduce array appropriately or\n                !otherwise set zero\n                if (value_found) then\n                    array_out(j,k,l) = value\n                    value_found = .false.\n                else\n                    array_out(j,k,l) = 0\n                end if\n            end do\n        end do\n    end do\nend subroutine check_for_value_4d\n"}, {"instruction": "Write a Fortran subroutine named trend_rhomax_srk to calculate the maximum molar density based on the composition array provided as input. The subroutine should have 1 input parameter of type real, dimension(:), and intent(in) and 1 output parameter of type real.", "input": "", "output": "    subroutine trend_rhomax_srk(x,rhomax)\n      implicit none\n      real, dimension(:), intent(in)  :: x      !< composition\n      real,               intent(out) :: rhomax !< maximum molar density\n    end subroutine trend_rhomax_srk\n"}, {"instruction": "Create a Fortran subroutine named trend_zfac to calculate the compressibility factor and its differentials with respect to temperature, pressure, and composition. The subroutine takes 3 input parameters of real type (temperature, density, composition array), and provides 4 output parameters of real type (zfac, dzdt, dzdp, dzdx). The last 3 output parameters are optional.", "input": "", "output": "    subroutine trend_zfac(t, rho, x, zfac, dzdt, dzdp, dzdx)\n      implicit none\n      ! input:\n      real,   intent(in)          :: t        !< temperature (k)\n      real,   intent(in)          :: rho      !< density (mol/m^3)\n      real,   intent(in)          :: x(:)     !< composition (mol/mol)\n      ! output:\n      real,   intent(out)         :: zfac     !< compressibility factor (-)\n      real, optional, intent(out) :: dzdt     !< zfac diff. wrt. temperature\n      real, optional, intent(out) :: dzdp     !< zfac diff. wrt. pressure\n      real, optional, intent(out) :: dzdx(:)  !< zfac diff. wrt. composition\n    end subroutine trend_zfac\n"}, {"instruction": "Write a Fortran subroutine named f_routine that calculates the nth Fibonacci number using the input parameter m of type integer. The subroutine has 1 input parameter of type integer and 1 output parameter of type integer(kind=16).", "input": "", "output": "subroutine f_routine(m, fnumber)\n   integer, intent(in) :: m\n   integer(kind=16), intent(out) :: fnumber\n   integer(kind=16), dimension(2) :: last_two\n   integer :: i\n\n   last_two = (/ 1, 1 /)\n   do i = 0, m\n      if ((i .eq. 0) .or. (i .eq. 1)) then\n         fnumber = 1\n      else \n         fnumber = last_two(1) + last_two(2)\n         if (mod(i,2) .eq. 0) then\n            last_two(1) = fnumber\n         else if (mod(i,2) .ne. 0) then\n            last_two(2) = fnumber\n         end if\n      end if\n   end do\n\nend subroutine f_routine\n"}, {"instruction": "Write a Fortran subroutine named copycstr to convert a null-terminated byte array to a character array. The subroutine takes 1 input parameter with the test_data type ['byte, dimension(*)'] and 1 output parameter with the test_data type ['character*(*)']. Use the imperative tone in the instructions.", "input": "", "output": "    subroutine copycstr( cstr, fstr )\n      byte, dimension(*), intent(in)  :: cstr\n      character*(*), intent(out) :: fstr\n\n        integer i\n        ! scan up to the terminating null\n        i = 1\n        do while( cstr(i) .ne. 0 )\n          fstr(i:i) = char(cstr(i))\n          i = i + 1\n        end do\n        ! pad the rest with blanks\n        do while( i .le. len(fstr) )\n          fstr(i:i) = ' '\n          i = i + 1\n        end do\n    end subroutine copycstr\n"}, {"instruction": "Create a Fortran subroutine named intplt2, which implements a second-order interpolation scheme to calculate the interpolated value based on the given position and input grid values. The subroutine takes 3 input parameters of type real: p (position), x (positions of 2 grid points), and vin (input grid values). It produces 1 output parameter of type real: vout (interpolated value). Ensure the subroutine handles overlap grid points and performs the interpolation accurately.", "input": "", "output": "subroutine intplt2(p,x,vin,vout)\n\n!==========================================================\n!  this routine interpolates a value using a second order\n!  scheme.\n!\n!  input:\n!\tp: position where to interpolate;\n!\tx: positions of 2 grid points;\n!\tvin: input grid values;\n!  output:\n!\tvout: interpolated value;\n!\n!  reference: intpl2.doc on mac notebook.\n!\n!  history:\n!\tjul. 2006 by yuanfu xie.\n!==========================================================\n\n  implicit none\n\n  real, intent(in) :: p,x(2),vin(2)\n  real, intent(out) :: vout\n\n  integer :: i,j\n  real :: e(2),r,b,c\n\n  ! check the 4 grid points:\n  do i=1,2\n    do j=1,2\n      if ((i .ne. j) .and. &\n        (abs(x(i)-x(j)) .lt. 1.0e-5*x(i) ) ) then\n        print*,'intplt2: there are overlap gridpoints, stop'\n\tstop\n      endif\n    enddo\n  enddo\n\n  do i=1,2\n    if (abs(p-x(i)) .lt. 1.0e-5*maxval(x) ) then\n      e = 0.0\n      e(i) = 1.0\n      goto 1\n    endif\n  enddo\n\n  ! e2:\n  e(2) = (p-x(1))/(x(2)-x(1))\n\n  ! e1:\n  e(1) = 1.0-e(2)\n\n1 continue\n\n  ! interpolate:\n  vout = 0.0\n  do i=1,2\n    vout = vout+e(i)*vin(i)\n  enddo\n\nend subroutine intplt2\n"}, {"instruction": "Write a Fortran subroutine named operatorspinflip that implements a spin-flip operation on a lattice site. The subroutine takes 2 input parameters of type integer and returns 2 output parameters: one of type integer and one of type logical. The logical output parameter indicates whether the operation resulted in a valid state.", "input": "", "output": "    subroutine operatorspinflip(site,basisfunc,newbasisfunc, valid)\n        ! flips the spins between the given site and the next\n        ! periodic boundary conditions are used\n        ! valid is false if operator gives the empty state\n        integer,intent(in) :: site\n        integer,intent(in) :: basisfunc\n        integer,intent(out) :: newbasisfunc\n        logical,intent(out) :: valid\n        integer :: sitenext \n        valid  = .true.\n        sitenext = mod(site + 1, numsites)\n        newbasisfunc = basisfunc\n        if (btest(basisfunc,site) .and. .not. btest(basisfunc,sitenext) )then\n            newbasisfunc =  ibclr(newbasisfunc,site)\n            newbasisfunc = ibset(newbasisfunc,sitenext)\n            return\n        endif\n        if (.not. btest(basisfunc,site) .and.  btest(basisfunc,sitenext) )then\n            newbasisfunc =  ibset(newbasisfunc,site)\n            newbasisfunc = ibclr(newbasisfunc,sitenext)\n            return\n        endif\n        valid = .false.\n\n    end subroutine operatorspinflip\n"}, {"instruction": "Create a Fortran subroutine named tri_num that takes an integer input parameter and returns a logical output parameter. The input parameter should be of type integer, and the output parameter should be of type logical. The subroutine checks if the input integer is a triangular number and sets the output parameter accordingly.", "input": "", "output": "    subroutine tri_num(n, is_tri_num)\n        integer, intent(in) :: n\n        logical, intent(out) :: is_tri_num(n)\n        integer :: i\n\n        is_tri_num = .false.\n\n        i = 1\n        do while (i*(i + 1)/2 <= n)\n            is_tri_num(i*(i + 1)/2) = .true.\n            i = i + 1\n        end do\n    end subroutine tri_num\n"}, {"instruction": "Write a Fortran subroutine named check_remeshed to compare two arrays and determine if they are equal. The subroutine takes 4 input parameters of type integer, integer, double precision array, and double precision array. The output is a single integer. If the arrays are not equal in length or content, the output will be set to -1; otherwise, it will be set to 0. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes for input and output parameters, respectively.", "input": "", "output": "      subroutine check_remeshed(nz, nz_orig, dq, dq_orig, ierr)\n         implicit none\n         integer, intent(in) :: nz, nz_orig\n         double precision, intent(in) :: dq(nz), dq_orig(nz_orig)\n         integer, intent(out) :: ierr\n         integer :: i\n         if (nz .ne. nz_orig) then\n            ierr = -1\n            return\n         end if\n         do i = 1, nz\n            if (dq(i) .ne. dq_orig(i)) then\n               ierr = -1\n               return\n            end if\n         end do\n         ierr = 0\n      end subroutine check_remeshed\n"}, {"instruction": "Create a Fortran subroutine named \"vector_separation\" to calculate the vector separating two atoms using the minimum image convention. The subroutine takes 4 input parameters of types ['double precision, dimension(3,3)', 'double precision, dimension(3,3)', 'double precision, dimension(3)', 'double precision, dimension(3)'] and returns 2 output parameters of types ['double precision, dimension(3)', 'double precision'].", "input": "", "output": "         subroutine vector_separation(cell_h, cell_ih, ri, rj, rij, r2)\n            ! calculates the vector separating two atoms.\n            !\n            ! note that minimum image convention is used, so only the image of\n            ! atom j that is the shortest distance from atom i is considered.\n            !\n            ! also note that while this may not work if the simulation\n            ! box is highly skewed from orthorhombic, as\n            ! in this case it is possible to return a distance less than the\n            ! nearest neighbour distance. however, this will not be of \n            ! importance unless the cut-off radius is more than half the \n            ! width of the shortest face-face distance of the simulation box,\n            ! which should never be the case.\n            !\n            ! args:\n            !    cell_h: the simulation box cell vector matrix.\n            !    cell_ih: the inverse of the simulation box cell vector matrix.\n            !    ri: the position vector of atom i.\n            !    rj: the position vector of atom j\n            !    rij: the vector separating atoms i and j.\n            !    r2: the square of the distance between atoms i and j.\n\n            double precision, dimension(3,3), intent(in) :: cell_h\n            double precision, dimension(3,3), intent(in) :: cell_ih\n            double precision, dimension(3), intent(in) :: ri\n            double precision, dimension(3), intent(in) :: rj\n            double precision, dimension(3), intent(out) :: rij \n            double precision, intent(out) :: r2\n\n            integer k\n            double precision, dimension(3) :: sij  \n            ! the separation in a basis where the simulation box  \n            ! is a unit cube.\n                                                   \n            sij = matmul(cell_ih, ri - rj)\n            do k = 1, 3\n               ! finds the smallest separation of all the images of atom i and j\n               sij(k) = sij(k) - dnint(sij(k)) \n            enddo\n            rij = matmul(cell_h, sij)\n            r2 = dot_product(rij,rij)\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named tracer_source_sink to calculate the source and sink of a tracer field based on the input flux, damping, pressure, and density fields. The number of input arguments is 5 with the test_data type ['real', 'real', 'real', 'real', 'integer, optional'], and the number of output arguments is 1 with the test_data type ['real'].", "input": "", "output": " subroutine tracer_source_sink ( flux, damp, p_half, r, rdt, kbot )\n\n!-----------------------------------------------------------------------\n      real, intent(in)  :: flux, damp, p_half(:,:,:), r(:,:,:)\n      real, intent(out) :: rdt(:,:,:)\n   integer, intent(in), optional :: kbot(:,:)\n!-----------------------------------------------------------------------\n      real, dimension(size(r,1),size(r,2),size(r,3)) :: source, sink\n      real, dimension(size(r,1),size(r,2))           :: pmass\n\n      integer :: i, j, kb\n      real    :: rdamp\n!-----------------------------------------------------------------------\n\n      rdamp = damp\n      if (rdamp < 0.) rdamp = -86400.*rdamp   ! convert days to seconds\n      if (rdamp > 0.) rdamp = 1./rdamp\n\n!------------ simple surface source and global sink --------------------\n\n      source(:,:,:)=0.0\n\n   if (present(kbot)) then\n      do j=1,size(r,2)\n      do i=1,size(r,1)\n         kb = kbot(i,j)\n         pmass (i,j)    = p_half(i,j,kb+1) - p_half(i,j,kb)\n         source(i,j,kb) = flux/pmass(i,j)\n      enddo\n      enddo\n   else\n         kb = size(r,3)\n         pmass (:,:)    = p_half(:,:,kb+1) - p_half(:,:,kb)\n         source(:,:,kb) = flux/pmass(:,:)\n   endif\n\n     sink(:,:,:) = rdamp*r(:,:,:)\n     rdt(:,:,:) = source(:,:,:)-sink(:,:,:)\n\n!-----------------------------------------------------------------------\n\n end subroutine tracer_source_sink\n"}, {"instruction": "Create a Fortran subroutine named \"adios_init\" to initialize the ADIOS configuration. It should take 2 input parameters of type ['character(*)', 'integer'] and 1 output parameter of type ['integer'].", "input": "", "output": "        subroutine adios_init (config, comm, err)\n            implicit none\n            character(*),   intent(in)  :: config\n            integer,        intent(in)  :: comm\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_init_noxml to initialize the ADIOS library without using an XML configuration file. It takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "        subroutine adios_init_noxml (comm, err)\n            implicit none\n            integer,        intent(in)  :: comm\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios_set_transform\" to set a transformation method for a variable. The subroutine should take 2 input parameters of type integer*8 and character(*), and 1 output parameter of type integer.", "input": "", "output": "        subroutine adios_set_transform (var_id, transform_method, err)\n            implicit none\n            integer*8,      intent(in)  :: var_id\n            character(*),   intent(in)  :: transform_method\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_select_method that takes 4 input parameters of type integer*8, character(*), character(*), and character(*), and 1 output parameter of type integer. This subroutine is designed to select a method with specified parameters for a given group and base path.", "input": "", "output": "        subroutine adios_select_method (group_id, method, parameters, base_path, err)\n            implicit none\n            integer*8,      intent(in)  :: group_id\n            character(*),   intent(in)  :: method\n            character(*),   intent(in)  :: parameters\n            character(*),   intent(in)  :: base_path\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cels_from_fahr to convert the temperature from Fahrenheit to Celsius. The subroutine takes 1 input parameter of type real and 1 output parameter of type real. The input parameter represents the temperature in Fahrenheit, and the output parameter will hold the converted temperature in Celsius.", "input": "", "output": "   subroutine cels_from_fahr(degrees_fahr,degrees_cels)\n   real, intent(in)  :: degrees_fahr\n   real, intent(out) :: degrees_cels\n   degrees_cels = (degrees_fahr-32)/1.8\n   end subroutine cels_from_fahr\n"}, {"instruction": "Write a Fortran subroutine named getwrd that extracts a specific word from a given line of text. The subroutine takes 2 input parameters of type integer and character(len=100) and 1 output parameter of type character(len=100). The subroutine should find the word specified by the integer input wrdnum in the input line and return it as output.", "input": "", "output": "subroutine getwrd(line,wrd,wrdnum)\n!========================================================================================\n\n!==== character string.                                                              ====\n!====    by adam siade                                                               ====\n!========================================================================================\n!========================================================================================\n  \n  implicit none\n  \n! specifications:\n!----------------------------------------------------------------------------------------\n  integer,intent(in)::wrdnum\n  integer::i,j,k\n  \n  character(len=100),intent(in)::line\n  character(len=100),intent(out)::wrd\n!----------------------------------------------------------------------------------------\n\n  wrd = ' '\n  !\n  i = 0\n  j = 1\n  k = 0\n  !\n  do\n    !\n    i = i + 1\n    !\n    if (line(i:i) /= ' ') then\n      !\n      if (j == wrdnum) then\n        !\n        do\n          !\n          k = k + 1\n          !\n          wrd(k:k) = line(i:i)\n          !\n          i = i + 1\n          !\n          if (line(i:i) == ' ') exit\n          !\n        end do\n        !\n      else\n        !\n        j = j + 1\n        !\n        do\n          !\n          i = i + 1\n          !\n          if (line(i:i) == ' ') exit\n          !\n        end do\n        !        \n      end if\n      !\n    end if\n    !\n    if (k > 0) exit\n    !\n  end do\n  \nend subroutine getwrd\n"}, {"instruction": "Create a Fortran subroutine named \"load_div\" to perform a specific operation. The subroutine should have 3 input parameters of type integer, where the third parameter is optional. It should also have 4 output parameters, where the first two are optional integers, and the last two are optional allocatable integer arrays. The subroutine must allocate memory for the optional arrays if they are present.", "input": "", "output": "  subroutine load_div( m, np, me, m0, m1, ir_out, id_out )\n    implicit none\n    integer,intent(in) :: m, np\n    integer,optional,intent(in)  :: me\n    integer,optional,intent(out) :: m0, m1\n    integer,allocatable,optional,intent(out) :: ir_out(:), id_out(:)\n    integer,allocatable :: ir(:)\n    integer :: i,ip\n    allocate( ir(0:np-1) ) ; ir=0\n    do i=1,m\n       ip=mod(i-1,np)\n       ir(ip)=ir(ip)+1\n    end do\n    if ( present(me) .and. present(m0) .and. present(m1) ) then\n       m0 = sum( ir(0:me) ) - ir(me) + 1\n       m1 = m0 + ir(me) - 1\n    end if\n    if ( present(ir_out) .and. present(id_out) ) then\n       if ( allocated(ir_out) ) deallocate(ir_out)\n       if ( allocated(id_out) ) deallocate(id_out)\n       allocate( ir_out(0:np-1) ); ir_out=0\n       allocate( id_out(0:np-1) ); id_out=0\n       ir_out=ir\n       do ip=0,np-1\n          id_out(ip) = sum(ir_out(0:ip)) - ir_out(ip)\n       end do\n    end if\n    deallocate( ir )\n  end subroutine load_div\n"}, {"instruction": "Create a Fortran subroutine named check_mpi to search for a given integer value within an array of integers. The subroutine takes 3 input parameters of type integer*4 and an array of integers. It also has 2 output parameters of type integer*4.", "input": "", "output": "    subroutine check_mpi(n,v,ind,tt,pos)\n    \n    implicit none\n    \n    integer*4 :: i, ne\n    integer*4, intent(in) ::n,ind\n    integer*4, dimension(0:n), intent(in)  :: v\n    integer*4, intent(out) :: tt, pos\n    \n\n    tt = 0\n    pos = - 1\n    i = 1\n    ne = v(0) - 1\n    \n      \n    do while (i.le.ne)\n       if (v(v(i-1)) .eq. ind) then\n          tt = 1\n          pos = i\n          return\n       endif   \n       i=i+1\n       \n    enddo    \n    \n    end subroutine check_mpi\n"}, {"instruction": "Write a Fortran subroutine named get_rep_indices to generate a vector of indices based on the given starting value i0, final value i1, and number of values to skip nrep. The number of input parameters is 3, the test_data type is ['integer', 'integer', 'integer'], and the number of output parameters is 1, the test_data type is ['integer, allocatable'].", "input": "", "output": "    subroutine get_rep_indices(ii,i0,i1,nrep)\n        ! given starting value i0 and final value i1, \n        ! and number of values to skip nrep, generate \n        ! an vector of indices ii. \n        ! eg, i0 = 1, i1 = 36, nrep = 12\n        ! => ii = [1,13,25]\n        ! eg, i0 = 2, i1 = 36, nrep = 12\n        ! => ii = [2,14,26]\n        \n        implicit none \n\n        integer, allocatable, intent(out) :: ii(:) \n        integer, intent(in) :: i0 \n        integer, intent(in) :: i1 \n        integer, intent(in) :: nrep \n\n        ! local variables   \n        integer :: i, ni, ntot \n        integer :: jj(10000)\n\n        ni = i1-i0+1 \n\n        jj = 0  \n\n        do i = 1, ni\n            jj(i) = i0 + nrep*(i-1) \n            if (jj(i) .gt. i1) then \n                jj(i) = 0\n                exit \n            end if \n        end do \n\n        ntot = count(jj .gt. 0)\n        if (allocated(ii)) deallocate(ii)\n        allocate(ii(ntot)) \n\n        ii = jj(1:ntot) \n\n        return \n\n    end subroutine get_rep_indices\n"}, {"instruction": "Write a Fortran subroutine named \"get_num_from_string\" to extract an integer from a character buffer based on a specific string pattern. The subroutine takes 2 input parameters of type character(*), representing the buffer and the string pattern to search for. It also includes 1 output parameter of type integer to store the extracted integer.", "input": "", "output": "  subroutine get_num_from_string( buf, str, n )\n    implicit none\n    character(*),intent(in) :: buf, str\n    integer,intent(out) :: n\n    integer :: i, j, l, len_str\n    character(8) :: str_out\n    l = index( buf, str )\n    if ( l /= 0 ) then\n       len_str = len_trim( adjustl(str) )\n       i=l+len_str+1\n       j=index( buf(i:), '\"' ) + i - 2\n       str_out = buf(i:j)\n       read(str_out,*) n\n    end if\n  end subroutine get_num_from_string\n"}, {"instruction": "Create a Fortran subroutine named read_global_int to read integer data from a file and store it in a 3D array. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type integer, dimension(:,:,:).\n", "input": "", "output": "subroutine read_global_int(filename,bufint,kmax)\n  character(*), intent(in) :: filename\n  integer, dimension(:,:,:), intent(out) :: bufint\n  integer, intent(in) :: kmax\n  integer, parameter :: fid=20\n  logical   :: ex\n  integer*8 :: mx, ny, lz, reclen\n  logical :: dodebug = .false.\n\n  mx = size(bufint,1)\n  ny = size(bufint,2)\n  lz = min(size(bufint,3),kmax)\n  reclen = mx * ny * lz * reclen_mult\n\n  inquire (file=trim(filename), exist=ex)\n  if (ex) then\n    open (unit=fid, file=trim(filename), status='old', access='direct', form='unformatted', recl=reclen)\n    read (fid,rec=1) bufint(:,:,1:kmax)\n    close (fid)\n    write (6, '( ''read_ncoda_intfile:: finished reading integer file: '',a)' ) trim(filename)\n  else\n    write (6, '( ''read_ncoda_intfile:: integer file missing: '',  a)' ) trim(filename)\n    stop(\"read_ncoda_intfile:: exiting...\")\n  endif\n\n  if (dodebug) then\n    print *, \"max(bufint) = \", maxval(bufint)\n    print *, \"min(bufint) = \", minval(bufint)\n    print *, \"avg(bufint) = \", sum(bufint)/(mx*ny*lz)\n    print *, \"maxloc(bufint) = \", maxloc(bufint)\n    print *, \"minloc(bufint) = \", minloc(bufint)\n  endif\n\nend subroutine read_global_int\n"}, {"instruction": "Write a Fortran subroutine named read_global that reads data from a binary file and populates a 3D real array with the contents. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type real, dimension(:,:,:).", "input": "", "output": "subroutine read_global(filename,buf4,kmax)\n  character(*), intent(in) :: filename\n  real, dimension(:,:,:), intent(out) :: buf4\n  integer, intent(in) :: kmax\n  integer*8 :: mx,ny,lz\n  integer*8 :: reclen\n  logical :: ex\n  integer :: fid = 23\n  logical :: dodebug = .false.\n\n  mx = size(buf4,1)\n  ny = size(buf4,2)\n  lz = min(size(buf4,3),kmax)\n  reclen = mx * ny * lz * reclen_mult\n\n  if (dodebug) then\n    write(6,*) \"mx     = \", mx\n    write(6,*) \"ny     = \", ny\n    write(6,*) \"lz     = \", lz\n    write(6,*) \"_mult  = \", reclen_mult\n    write(6,*) \"mx * ny * lz * reclen_mult = \", mx * ny * lz * reclen_mult\n    write(6,*) \"reclen = \", reclen\n  endif\n\n  inquire (file=trim(filename), exist=ex)\n  if (ex) then\n    if (dodebug) write(6,*) \"read_global: opening file: \", trim(filename)\n    if (dodebug) write(6,*) \"with reclen: \", reclen\n    open (unit=fid, file=trim(filename), status='old', access='direct', form='unformatted', recl=reclen)\n    ! this may take a long time, so output a note of what is happening...\n    write (6, *) 'read_global:: reading background file: ', trim(filename)\n    read (fid,rec=1) buf4(:,:,1:kmax)\n    close (fid)\n    write (6, *) 'read_global:: finished reading background file: ', trim(filename)\n  else\n    write (6, *) 'read_global:: global background file missing: ', trim(filename)\n    stop(\"merge_tiles.f90:: exiting...\")\n  endif\n\n  if (dodebug) then\n    print *, \"max(buf4) = \", maxval(buf4)\n    print *, \"min(buf4) = \", minval(buf4)\n    print *, \"avg(buf4) = \", sum(buf4)/(mx*ny*lz)\n    print *, \"maxloc(buf4) = \", maxloc(buf4)\n    print *, \"minloc(buf4) = \", minloc(buf4)\n  endif\n\nend subroutine read_global\n"}, {"instruction": "Create a Fortran subroutine named decode to decode a string based on a simple encoding scheme. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "subroutine decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"abcdefghijklmnopqrstuvwxyz\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named intweight1t to calculate the weights at each corner of a tetrahedron based on the input eigenenergies and the Fermi energy. The number of input parameters is 2, with test_data type ['real*8', 'real*8'], representing the eigenenergies at the corners of the tetrahedron and the Fermi energy. The number of output parameters is 1, with test_data type ['real*8'], representing the weights at each corner.", "input": "", "output": "subroutine intweight1t(w, et,ef)\n\n  ! the energies have to be given in increasing energy order.     \n  implicit none\n  real*8, intent(out):: w(4) ! weight at each corner\n  real*8, intent(in) :: et(4) ! eigenenergies at the corners of the tetrahedron.\n  real*8, intent(in) :: ef    ! fermi energy.\n  ! locals\n  integer :: index, i\n  real*8  :: c1,c2,c3,vo4\n  real*8  :: f31,f41,f32,f42\n  real*8  :: e31,e41,e32,e42\n  if( et(4) <= ef) then  ! all energies above ef\n     index = 4\n  else\n     index=0\n     do i=1,4             ! how many corners of tetrahedra below ef\n        if( et(i) <= ef) index = index + 1\n     enddo\n  endif\n  vo4 = 1.0d0/4.0d0\n  select case(index)\n  case(0)          ! all states are unoccupied\n     w(:) = 0.0d0\n  case(1)          ! only the lowest energy is occupied.\n     do i=2,4\n        w(i) = (ef-et(1))/(et(i)-et(1))\n     enddo\n     c1 = w(2) * w(3) * w(4)\n     w(2) = c1 * w(2)\n     w(3) = c1 * w(3)\n     w(4) = c1 * w(4)\n     w(1) = 4.0d0 * c1 - w(2) - w(3) - w(4)\n  case(2)         ! the two lower energies are occupied\n     f31 = (ef-et(1))/(et(3)-et(1))\n     f41 = (ef-et(1))/(et(4)-et(1))\n     f32 = (ef-et(2))/(et(3)-et(2))\n     f42 = (ef-et(2))/(et(4)-et(2))\n     e31 = (et(3)-ef)/(et(3)-et(1))\n     e41 = (et(4)-ef)/(et(4)-et(1))\n     e32 = (et(3)-ef)/(et(3)-et(2))\n     e42 = (et(4)-ef)/(et(4)-et(2))\n     c1 = f41 * f31\n     c2 = f41 * f32 * e31\n     c3 = f42 * f32 * e41\n     w(1) =  c1 + (c1+c2)*e31 + (c1+c2+c3)*e41 \n     w(2) =  c1+c2+c3 + (c2+c3)*e32 + c3*e42 \n     w(3) =  (c1+c2)*f31 + (c2+c3)*f32 \n     w(4) =  (c1+c2+c3)*f41 + c3*f31 \n  case(3)        ! only the highest energy is unoccupied\n     do i=1,3\n        w(i) = (et(4)-ef)/(et(4)-et(i))\n     enddo\n     c1   = w(1) * w(2) * w(3) \n     w(4) = 1.0d0 - c1 * (4.0d0 - w(1)-w(2)-w(3))\n     w(1) = 1.0d0 - c1 * w(1)\n     w(2) = 1.0d0 - c1 * w(2)\n     w(3) = 1.0d0 - c1 * w(3)\n  case(4)        ! all states are occupied\n     w(:) = 1.d0\n  end select\n  w(:) = w(:)*vo4\nend subroutine intweight1t\n"}, {"instruction": "Create a Fortran subroutine named ksurf to calculate the weight at each corner of a tetrahedron based on the energies provided. The subroutine takes 2 input parameters of type real*8, et(4) and ef, and 1 output parameter of type real*8, wgh(4). Ensure that the energies are given in increasing energy order.", "input": "", "output": "subroutine ksurf(wgh, et, ef)\n\n  ! k-mesh, the area of the fermi surface inside the tetrahedron is calculated\n  ! which is the essential item to decide the weight of the integration over\n  ! each vertex.\n  ! the energies have to be given in increasing energy order.\n  implicit none\n  real*8, intent(out) :: wgh(4)    ! the weight at each corner\n  real*8, intent(in)  :: et(4)     ! the band energies or energy difference at k\n  real*8, intent(in)  :: ef        ! the energy or energy differnce surface\n  !\n  integer :: i, indx  ! indx=number of nodes below ef\n  real*8  :: delta21, delta31, delta41, delta32, delta42, delta43  ! energy differences       \n  real*8  :: deles1, deles2, deles3, deles4 ! ef-eo(i) \n  real*8  :: den0         ! denominators\n  real*8  :: num0, num1   ! numerators\n  real*8  :: wt           ! total weight\n  !\n  wgh(:) = 0.0d0\n  if ( ef < et(1) ) then\n     indx=0\n  else\n     indx=1\n     do i=2,4\n        if( et(i) <= ef) indx = indx + 1\n     enddo\n  endif\n  select case(indx)\n  case(0,4) \n     continue\n  case(1) ! only et(1)< ef, one triangle\n     deles1  =  ef - et(1)\n     delta21 = et(2)-et(1)\n     delta31 = et(3)-et(1)\n     delta41 = et(4)-et(1)\n     den0 = 6.0d0*delta21*delta31*delta41\n     num0 = deles1*deles1\n     ! total wgh\n     wt = 3.0d0*num0/den0\n     num1 = num0*deles1\n     wgh(2) = num1/(delta21*den0)\n     wgh(3) = num1/(delta31*den0)\n     wgh(4) = num1/(delta41*den0)\n     wgh(1) = wt - wgh(2) - wgh(3) - wgh(4)\n  case(2) ! et(1)<et(2)<ef, two triangles\n     deles1  =  ef  - et(1)\n     deles2  =  ef  - et(2)\n     deles3  = et(3) - ef\n     deles4  = et(4) - ef\n     delta21 = et(2) - et(1)\n     delta31 = et(3) - et(1)\n     delta41 = et(4) - et(1)\n     delta32 = et(3) - et(2)\n     delta42 = et(4) - et(2)\n     delta43 = et(4) - et(3)\n     ! total wgh          \n     num0 = deles1*deles3 / (6.0d0*delta31*delta32*delta41)\n     num1 = deles2*deles4 / (6.0d0*delta32*delta41*delta42)\n     wt = 3.0d0 * (num0 + num1)\n     !\n     wgh(2) = deles3/delta32 * num0   + (deles3*delta42+deles2*delta31)/(delta41*delta42) * num1\n     wgh(3) = (deles1*delta32+deles2*delta31)/(delta31*delta32) * num0 + deles2/(delta32) * num1\n     wgh(4) = deles1/(delta41) * num0 + (deles1*delta42+deles2*delta41)/(delta41*delta42) * num1\n     wgh(1) = wt - wgh(2)-wgh(3)-wgh(4)\n  case(3) ! ee(1), ee(2) and ee(3) < efer, one triangle.\n     deles4  = et(4) - ef\n     delta41 = et(4) - et(1)\n     delta42 = et(4) - et(2)\n     delta43 = et(4) - et(3)\n     den0 = 6.0d0*delta41*delta42*delta43\n     if ( den0 < 1.0e-12) then\n        write(6,*)'error in ksurf: flat band'\n        write(6,*) et\n        stop 'flat band'\n     endif\n     num0 = deles4*deles4\n     ! total wgh\n     wt   = num0* 3.0d0/den0\n     num1 = num0*deles4/den0\n     wgh(1) = num1/delta41\n     wgh(2) = num1/delta42\n     wgh(3) = num1/delta43\n     wgh(4) = wt - wgh(1)-wgh(2)-wgh(3)\n  end select\nend subroutine ksurf\n"}, {"instruction": "Write a Fortran subroutine named rank that takes an integer array nproc3 as input and returns two output parameters: ip (integer) and ip3 (integer array). The subroutine should copy the values from nproc3 to ip3 and set ip to 0.", "input": "", "output": "subroutine rank(ip, ip3, nproc3)\ninteger, intent(out) :: ip, ip3(3)\ninteger, intent(in) :: nproc3(3)\nip = 0\nip3 = nproc3\nip3 = 0\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"rreduce1\" to perform reduction operations on an input array based on the specified operation. The subroutine should have 2 input parameters of type real and character(*), and 1 output parameter of type real.", "input": "", "output": "subroutine rreduce1(f1out, f1, op)\nreal, intent(out) :: f1out(:)\nreal, intent(in) :: f1(:)\ncharacter(*), intent(in) :: op\ncharacter :: a\na = op(1:1)\nf1out = f1\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named rreduce2 that takes two input arguments: an array of real numbers f2 and a character string op. The output is an array of real numbers f2out. The subroutine should copy the values of f2 to f2out. The number of input arguments is 2 and the test_data type is [real, character(*)]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "subroutine rreduce2(f2out, f2, op)\nreal, intent(out) :: f2out(:,:)\nreal, intent(in) :: f2(:,:)\ncharacter(*), intent(in) :: op\ncharacter :: a\na = op(1:1)\nf2out = f2\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named sub to initialize an integer array with a value of 1. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine sub(key,a)\n    integer, intent(out)    :: a(:) \n    character(*),intent(in) :: key\n    a = 1   \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_pmtanh to calculate the hyperbolic tangent of the product of two double precision numbers. The subroutine takes 2 input parameters of type double precision and returns 1 output parameter of type double precision.", "input": "", "output": "subroutine calc_pmtanh(pm,seg,pmtanh)\n\n      implicit none\n\n      !i/o\n      double precision, intent(in) :: pm,seg\n      double precision, intent(out) :: pmtanh\n\n      !locals\n\n\n      pmtanh = seg*(0.5*(tanh(40.0*(pm-0.90))+1.0))\n      !pmtanh = 0.8*seg*(0.5*(tanh(40.0*(pm-0.98))+1.0))\n\n      return\n\n   end subroutine calc_pmtanh\n"}, {"instruction": "Write a Fortran subroutine named findfactor to calculate the factors of a given integer. The input parameter is an integer. The output parameters are an integer array and an integer representing the number of factors.", "input": "", "output": "  subroutine findfactor(num, factors, nfact)\n    \n    implicit none\n\n    integer, intent(in) :: num\n    integer, intent(out), dimension(*) :: factors\n    integer, intent(out) :: nfact\n    integer :: i, m\n\n    ! find the factors <= sqrt(num)\n    m = int(sqrt(real(num)))\n    nfact = 1\n    do i=1,m\n       if (num/i*i == num) then\n          factors(nfact) = i\n          nfact = nfact + 1\n       end if\n    end do\n    nfact = nfact - 1\n\n    ! derive those > sqrt(num)\n    if (factors(nfact)**2/=num) then\n       do i=nfact+1, 2*nfact\n          factors(i) = num / factors(2*nfact-i+1)\n       end do\n       nfact = nfact * 2\n    else\n       do i=nfact+1, 2*nfact-1\n          factors(i) = num / factors(2*nfact-i)\n       end do\n       nfact = nfact * 2 - 1\n    endif\n       \n    return\n\n  end subroutine findfactor\n"}, {"instruction": "Create a Fortran subroutine named \"calculateepspeq\" to calculate the equivalent plastic shear strain. The subroutine takes 1 input parameter of type 'double precision, dimension(6)' and provides 1 output parameter of type 'double precision'.", "input": "", "output": "\tsubroutine calculateepspeq(epsp,epspeq)\n      !**********************************************************************\n      !\n      ! calculation of the equivalent plastic shear strain\n      !\n      !**********************************************************************\n\n      implicit none\n\n      !local variables\n      double precision:: epspm, c1, c2\n      double precision, dimension(3) :: epsdev\n      !in variables\n      double precision, intent(in), dimension(6) :: epsp\n      !out variables\n      double precision, intent(out) :: epspeq\n\n      !epspeq = ((2/3)ep:ep)^(1/2), ep is the deviatoric plastic strain\n\n      epspm = (1.0d0/3.0d0) * (epsp(1) + epsp(2) + epsp(3))\n      epsdev(1) = epsp(1)-epspm\n      epsdev(2) = epsp(2)-epspm\n      epsdev(3) = epsp(3)-epspm\n      c1 = 2.0d0/3.0d0\n      c2 = c1 * 0.5d0\n\n      epspeq = sqrt(c1*epsdev(1)*epsdev(1) + c1*epsdev(2)*epsdev(2) +  c1*epsdev(3)*epsdev(3) + &\n                     c2*epsp(4)*epsp(4) + c2*epsp(5)*epsp(5) + c2*epsp(6)*epsp(6))\n\n\tend subroutine calculateepspeq\n"}, {"instruction": "Create a Fortran subroutine named distribute_proc to distribute a given data length among a specified number of processes, and calculate the start, end, and size for each process. The number of input parameters is 3, of type integer, representing the data length, number of processes, and process coordinate. The number of output parameters is 3, of type integer, representing the start index, end index, and size for the specified process.", "input": "", "output": "  subroutine distribute_proc(ndatalen,numproc,pcoord,st,en,sz)\n    implicit none\n    integer,intent(in) ::ndatalen,numproc,pcoord\n    integer,intent(out)::st,en,sz\n\n    ! locals\n    integer:: i,size1,nl,nu\n    integer,dimension(:),allocatable::starr,enarr,szarr \n\n    allocate(starr(0:numproc-1),enarr(0:numproc-1),szarr(0:numproc-1))\n    size1=ndatalen/numproc\n    nu = ndatalen-size1 * numproc\n    nl = numproc -nu\n    starr(0)= 1\n    szarr(0)= size1\n    enarr(0)= size1\n    do i=1,nl-1\n     starr(i)= starr(i-1) + size1\n     szarr(i)= size1\n     enarr(i)= enarr(i-1) + size1\n    end do\n    size1 = size1 + 1\n    do i=nl,numproc-1\n     starr(i) = enarr(i-1) + 1\n     szarr(i) = size1\n     enarr(i) = enarr(i-1) + size1\n    end do\n    enarr(numproc-1)= ndatalen \n    szarr(numproc-1)= ndatalen-starr(numproc-1)+1\n\n    st=starr(pcoord);en=enarr(pcoord);sz=szarr(pcoord)\n    deallocate(starr,enarr,szarr)\n  end subroutine distribute_proc\n"}, {"instruction": "Write a Fortran subroutine named get_guess that takes in the number of pegs as an integer input and outputs an array of integers representing the user's color choices for each peg. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer, dimension(num_pegs)'].", "input": "", "output": "subroutine get_guess(num_pegs, guess)\r\n\tinteger, intent(in)                       :: num_pegs\r\n\tinteger, dimension(num_pegs), intent(out) :: guess\r\n\tinteger                                   :: i, selected\r\n\r\n\r\n\twrite(*, \"(a,i2,a)\"), '1. '//achar(27)//'[1;', red, 'mred'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '2. '//achar(27)//'[1;', green,&\r\n\t                      &'mgreen'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '3. '//achar(27)//'[1;', yellow,&\r\n\t                      &'myellow'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '4. '//achar(27)//'[1;', blue,&\r\n\t                      &'mblue'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '5. '//achar(27)//'[1;', purple,&\r\n\t                      &'mpurple'//achar(27)//'[0m'\r\n\twrite(*, \"(a,i2,a)\"), '6. '//achar(27)//'[1;', cyan,&\r\n\t                      &'mcyan'//achar(27)//'[0m'\r\n\r\n\ti=1\r\n\tdo\r\n\t\tif (i > num_pegs) exit\r\n\t\twrite(*, '(a, i0)'), 'pick colour for peg #', i\r\n\t\tread(*,*), selected\r\n\t\tselect case(selected)\r\n\t\t\tcase(1)\r\n\t\t\t\tguess(i) = red\r\n\t\t\tcase(2)\r\n\t\t\t\tguess(i) = green\r\n\t\t\tcase(3)\r\n\t\t\t\tguess(i) = yellow\r\n\t\t\tcase(4)\r\n\t\t\t\tguess(i) = blue\r\n\t\t\tcase(5)\r\n\t\t\t\tguess(i) = purple\r\n\t\t\tcase(6)\r\n\t\t\t\tguess(i) = cyan\r\n\t\t\tcase default\r\n\t\t\t\twrite(*, '(i0, a)'), selected,' is an invalid choice.'\r\n\t\t\t\ti = i - 1\r\n\t\tend select\r\n\r\n\t\ti = i + 1\r\n\tend do\r\nend subroutine get_guess\r\n"}, {"instruction": "Create a Fortran subroutine named geteos to compute thermodynamic properties such as pressure and sound speed based on the material properties and state variables. The subroutine takes 7 input parameters of type ['integer', 'integer', 'integer', 'real*8', 'real*8', 'real*8', 'real*8'] and returns 2 output parameters of type ['real*8', 'real*8'].", "input": "", "output": "subroutine geteos(nmatel,ncase,gamlg,rho, eintl, rhoi, pres, sd ,ielem)\n!\nimplicit none\ninteger, intent(in):: nmatel, ncase,ielem\nreal*8,  intent(in):: gamlg,rho, eintl,rhoi\nreal*8, intent(out):: pres,sd\n\n\nreal*8::presh, enrgh, eta\nreal*8::dphdeta,dehdeta,detadrho\nreal*8::dphdrho, sd2\nreal*8::s0,c0,gmodu\nreal*8::eps\n!\neps =1d-6\n!\nselect case (nmatel)\n\n!...idea gas\ncase(1)\n!...pres\npres = max(eps, (gamlg-1.d0)*rho*eintl)\n!...sound speed\nsd = sqrt(gamlg*pres/rho)\n\n!...solid\ncase(2)\n\n if(ncase.eq.1)then\n  s0 = 1.34d0\n  c0 = 0.533d0\n  gmodu = 0.286d0\n\n elseif(ncase.eq.2)then\n  s0 = 1.124d0\n  c0 = 1.287d0\n  gmodu = 1.5111d0\n\n elseif(ncase.eq.3)then\n s0 = 1.338d0\n c0 = 0.533d0\n gmodu = 0.276d0\n elseif(ncase.eq.104)then\n s0 = 1.124d0\n c0 = 1.287d0\n gmodu = 1.5111d0\n\n endif\n\n!...\neta = 1.d0-rhoi/rho\n\n!...hugniout pressure and energy\npresh = rhoi*c0**2*eta/(1.d0-s0*eta)**2\nenrgh = eta*presh/2.d0/rhoi\n\n!...pressure\npres = presh + gamlg*rho*(eintl-enrgh)\n\n!...sound speed\ndetadrho = rhoi/rho**2\ndphdeta  = rhoi*c0**2*(1.d0/(1.d0-s0*eta)**2 + 2.d0*eta*s0/(1.d0-s0*eta)**3)\ndehdeta   = .5d0/rhoi*(presh+eta*dphdeta)\nsd2      = dphdeta*detadrho + gamlg*(eintl-enrgh) - gamlg*dehdeta*detadrho + gamlg*pres/rho\nsd2      = sd2 + 4.d0/3.d0*gmodu/rho\n\nsd = sqrt(sd2)\n!\nif(ielem.eq.-1)then\n print*,'ieleminside',rhoi,rho,eta,c0,s0\n print*,'ielem2',presh,enrgh,eintl,pres\n print*,'ielem3',detadrho,dphdeta,dehdeta,sd2\n print*,'ielem4',dphdeta*detadrho, gamlg*(eintl-enrgh),gamlg*dehdeta*detadrho ,gamlg*pres/rho,&\n4.d0/3.d0*gmodu/rho\nendif\n!\nend select\n!\nend subroutine geteos\n"}, {"instruction": "Create a Fortran subroutine named factors_mt to calculate the factors using the given inputs. The subroutine takes 3 input parameters of type real, dimension(5), real, and returns 1 output parameter of type real, dimension(5).", "input": "", "output": "    pure subroutine factors_mt( matfac, radpat, r, factors )\n        \n        real, intent(in), dimension(5)  :: matfac, radpat\n        real, intent(in)                :: r\n        real, intent(out), dimension(5) :: factors\n        \n        factors(1) = matfac(1)*radpat(1)/r**4\n        factors(2) = matfac(2)*radpat(2)/r**2\n        factors(3) = matfac(3)*radpat(3)/r**2\n        factors(4) = matfac(4)*radpat(4)/r\n        factors(5) = matfac(5)*radpat(5)/r\n        \n    end subroutine factors_mt\n"}, {"instruction": "Create a Fortran subroutine named factors_sf to calculate factors based on the input parameters matfac, radpat, and r. The input parameters are of type real, dimension(3), real, dimension(3), and real respectively. The output parameter factors is of type real, dimension(3).", "input": "", "output": "    pure subroutine factors_sf( matfac, radpat, r, factors )\n    \n        real, intent(in), dimension(3)  :: matfac, radpat\n        real, intent(in)                :: r\n        real, intent(out), dimension(3) :: factors\n        \n        factors(1) = matfac(1)*radpat(1)/r**3\n        factors(2) = matfac(2)*radpat(2)/r\n        factors(3) = matfac(3)*radpat(3)/r\n        \n    end subroutine factors_sf\n"}, {"instruction": "Create a Fortran subroutine named make_direction_cosine to calculate the direction cosines and the magnitude of a given 3D coordinate vector.\nThe number of input arguments is 1, and the test_data type is ['real, dimension(3)'].\nThe number of output arguments is 2, and the test_data type is ['real, dimension(3)', 'real'].", "input": "", "output": "    pure subroutine make_direction_cosine( coord, gamma, r)\n            \n        real, intent(in), dimension(3)    :: coord\n        real, intent(out), dimension(3)   :: gamma\n        real, intent(out)                 :: r\n\n        ! make direction cosines and r\n        \n        ! n,e,z(down)=coord(1),coord(2),coord(3) \n        r=sqrt(coord(1)**2+coord(2)**2+coord(3)**2)\n\n        ! gamma(i)=dr/dx(i)=cos(r,x(i))=coord(i)/r\n        gamma(:)=coord(:)/r\n        \n    end subroutine make_direction_cosine\n"}, {"instruction": "Create a Fortran subroutine named \"rp1\" to solve 1D Euler equations using the HLL approximate Riemann solver. The subroutine takes 10 input parameters: maxmx, meqn, mwaves, maux, mbc, mx (all integers), ql and qr (double precision arrays of dimension [meqn, 1-mbc:maxmx+mbc]), auxl and auxr (double precision arrays of dimension [maux, 1-mbc:maxmx+mbc]). The subroutine returns 4 output parameters: wave (double precision array of dimension [meqn, mwaves, 1-mbc:maxmx+mbc]), amdq (double precision array of dimension [meqn, 1-mbc:maxmx+mbc]), apdq (double precision array of dimension [meqn, 1-mbc:maxmx+mbc]), and s (double precision array of dimension [mwaves, 1-mbc:maxmx+mbc]).", "input": "", "output": "subroutine rp1(maxmx,meqn,mwaves,maux,mbc,mx,ql,qr,auxl,auxr,wave,s,amdq,apdq)\n! =========================================================\n\n! solve riemann problems for the 1d euler equations using the hlle\n! approximate riemann solver.\n\n! waves: 2\n! equations: 3\n\n! conserved quantities:\n!       1 density\n!       2 momentum\n!       3 energy\n\n    implicit none\n\n    integer, intent(in) :: maxmx, meqn, mwaves, mbc, mx, maux\n    double precision, dimension(meqn,1-mbc:maxmx+mbc), intent(in) :: ql, qr\n    double precision, dimension(maux,1-mbc:maxmx+mbc), intent(in) :: auxl, auxr\n    double precision, dimension(meqn, mwaves, 1-mbc:maxmx+mbc), intent(out) :: wave\n    double precision, dimension(meqn, 1-mbc:maxmx+mbc), intent(out) :: amdq, apdq\n    double precision, dimension(mwaves, 1-mbc:maxmx+mbc), intent(out) :: s\n\n    double precision :: u_l, u_r, c_l, c_r, u_hat, c_hat\n    double precision :: p_l, p_r, h_l, h_r, rhsqrt_l, rhsqrt_r\n    double precision :: rhsq2, h_hat, gamma, gamma1, e_l, e_r\n    double precision :: rho_m, rhou_m, e_m, s1, s2\n    integer :: m, i, mw\n\n    common /cparam/  gamma\n\n    gamma1 = gamma - 1.d0\n\n    do i=2-mbc,mx+mbc\n        ! velocity\n        u_l = qr(2,i-1) / qr(1,i-1)\n        u_r = ql(2,i  ) / ql(1,i  )\n        ! pressure\n        p_l = gamma1 * (qr(3,i-1) - qr(1,i-1)*u_l**2/2.d0)\n        p_r = gamma1 * (ql(3,i  ) - ql(1,i  )*u_r**2/2.d0)\n        ! enthalpy\n        h_l = (qr(3,i-1) + p_l) / qr(1,i-1)\n        h_r = (ql(3,i  ) + p_l) / ql(1,i  )\n        ! sound speed\n        c_l = dsqrt(gamma1*h_l-u_l**2/2.)\n        c_r = dsqrt(gamma1*h_r-u_r**2/2.)\n\n        e_l = qr(3,i-1)\n        e_r = ql(3,i  )\n\n\n        rhsqrt_l = dsqrt(qr(1,i-1))\n        rhsqrt_r = dsqrt(ql(1,i))\n        rhsq2 = rhsqrt_l + rhsqrt_r\n        u_hat = (qr(2,i-1)/rhsqrt_l + ql(2,i)/rhsqrt_r) / rhsq2\n        h_hat = (((qr(3,i-1)+p_l)/rhsqrt_l + (ql(3,i)+p_r)/rhsqrt_r)) / rhsq2\n        c_hat = dsqrt(gamma1*(h_hat - .5d0*u_hat**2))\n\n        s1 = min(u_l - c_l, u_hat - c_hat)\n        s2 = max(u_r + c_r, u_hat + c_hat)\n        rho_m = (ql(2,i) - qr(2,i-1) - s2*ql(1,i) + s1*qr(1,i-1))/(s1-s2)\n        rhou_m = (ql(1,i)*u_r**2 - qr(1,i-1)*u_l**2 + p_r - p_l - s2*ql(2,i) + s1*qr(2,i-1))/(s1-s2)\n        e_m = ( u_r*(e_r+p_r) - u_l*(e_l+p_l) -s2*e_r + s1*e_l)/(s1-s2)\n\n        wave(1,1,i) = rho_m - qr(1,i-1)\n        wave(2,1,i) = rhou_m - qr(2,i-1)\n        wave(3,1,i) = e_m - qr(3,i-1)\n        s(1,i) = s1\n    \n        wave(1,2,i) = ql(1,i) - rho_m\n        wave(2,2,i) = ql(2,i) - rhou_m\n        wave(3,2,i) = ql(3,i) - e_m\n        s(2,i) = s2\n\n    end do \n\n    do m=1,3\n        do i=2-mbc, mx+mbc\n            amdq(m,i) = 0.d0\n            apdq(m,i) = 0.d0\n            do mw=1,mwaves\n                if (s(mw,i) < 0.d0) then\n                    amdq(m,i) = amdq(m,i) + s(mw,i)*wave(m,mw,i)\n                else\n                    apdq(m,i) = apdq(m,i) + s(mw,i)*wave(m,mw,i)\n                endif\n            end do\n        end do\n    end do\n\nend subroutine rp1\n"}, {"instruction": "Create a Fortran subroutine named diagv to extract the diagonal elements of a matrix and store them in a vector. The subroutine takes 1 input parameter of type real(8), dimension(:, :) and outputs 1 parameter of type real(8), dimension(size(m, 1)). Ensure that there is no error handling for dimension mismatch.", "input": "", "output": "subroutine diagv(m, v)\n    real(8), intent(in), dimension(:, :) :: m\n    integer :: i\n    real(8), intent(out), dimension(size(m, 1)) :: v\n    ! note: no error handling of dimension mismatch\n    v = [(m(i, i), i = 1, size(m, 1))]\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named build_hdate that takes an integer array containing time specifications as input and produces a character string representing the date in the format \"yyyy-mm-dd hh:mm:ss\" as output. The input parameter consists of 6 integers, while the output parameter is a character string of unspecified length.", "input": "", "output": "   subroutine build_hdate(hdate, time)\n\n! purpose:\n!      from the year, month, day, hour, minute, and second values,\n!      creates a 19-character string representing the date, in the\n!      format:  \"yyyy-mm-dd hh:mm:ss\"\n\n! input:\n      integer, intent(in) :: time(6) ! all time specs in it\n! output:\n      character*(*), intent(out) :: hdate ! 'yyyy-mm-dd hh:mm:ss'\n\n! local:\n      integer iyr     ! year (e.g., 1997, 2001)\n      integer imo     ! month (01 - 12)\n      integer idy     ! day of the month (01 - 31)\n      integer ihr     ! hour (00-23)\n      integer imi     ! minute (00-59)\n      integer isc     ! second (00-59)\n!\n!      integer i  ! loop counter.\n      integer hlen ! length of hdate string\n\n      hlen = len(hdate)\n      iyr = time(1)\n      imo = time(2)\n      idy = time(3)\n      ihr = time(4)\n      imi = time(5)\n      isc = time(6)\n\n      if (hlen.eq.19) then\n         write(hdate,19) iyr, imo, idy, ihr, imi, isc\n 19      format(i4,'-',i2.2,'-',i2.2,'_',i2.2,':',i2.2,':',i2.2)\n\n      elseif (hlen.eq.16) then\n         write(hdate,16) iyr, imo, idy, ihr, imi\n 16      format(i4,'-',i2.2,'-',i2.2,'_',i2.2,':',i2.2)\n\n      elseif (hlen.eq.13) then\n         write(hdate,13) iyr, imo, idy, ihr\n 13      format(i4,'-',i2.2,'-',i2.2,'_',i2.2)\n\n      elseif (hlen.eq.10) then\n         write(hdate,10) iyr, imo, idy, ihr\n 10      format(i4,i2.2,i2.2,i2.2)\n      endif\n\n      return\n      end subroutine build_hdate\n"}, {"instruction": "Create a Fortran subroutine named get_diffs_wind to calculate the differences, absolute differences, and squared differences of wind components. The subroutine takes 8 input parameters of type real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:), integer, integer, integer, and real. It returns 3 output parameters of type real, dimension(:,:,:), real, dimension(:,:,:), real, dimension(:,:,:).", "input": "", "output": "  subroutine get_diffs_wind(u1, v1, u2,v2,diff, absdiff, sqdiff, nx, ny, nz, missing)\n    \n    real, intent(in), dimension(:,:,:)             :: u1, u2, v1, v2\n    real, intent(out), dimension(:,:,:)            :: diff, absdiff, sqdiff\n    integer, intent(in)                            :: nx, ny, nz\n    integer                                        :: i,j,k\n    real, intent(in)                               :: missing\n    real                                           :: u, v\n\n    do k = 1, nz\n    do j = 1, ny\n    do i = 1, nx\n       if ( u1(i,j,k) /= missing .and. v1(i,j,k) /= missing .and. &\n            u2(i,j,k) /= missing .and. v2(i,j,k) /= missing ) then\n         u  = u1(i,j,k) - u2(i,j,k) \n         v  = v1(i,j,k) - v2(i,j,k) \n         diff(i,j,k)   = u + v\n         absdiff(i,j,k)   = abs(u) + abs (v)                \n         sqdiff(i,j,k) = u*u + v*v\n       else\n         diff(i,j,k)   = missing \n         absdiff(i,j,k)   = missing \n         sqdiff(i,j,k) = missing\n       endif\n    enddo\n    enddo\n    enddo\n\n  end subroutine get_diffs_wind \n"}, {"instruction": "Write a Fortran subroutine named domain_average to calculate the average profile and the count of non-missing values in a 3D domain. The subroutine should take 6 input parameters of types integer, integer, integer, integer, real array of 3 dimensions, and real. It should also return 2 output parameters of types integer array and real array.", "input": "", "output": "  subroutine domain_average(var, avg_prof, counter, nx, ny, nz, missing,isq)\n\n  integer, intent(in)                                 :: nx,ny,nz,isq\n  real, intent(in), dimension(:,:,:)                  :: var\n  integer, intent(out), dimension(:)                  :: counter\n  real, intent(out), dimension(:)                     :: avg_prof\n  real, intent(in)                                    :: missing\n\n  integer                                             :: i,j,k,icount\n  real                                                :: dsum, dmiss\n  integer                                             :: imiss\n\n!9999\n!hui: set dmiss value consistent with plot script\n!  dmiss = -9999.999\n  dmiss = -99.99\n  imiss = -99\n  do k = 1, nz\n     icount = 0\n     dsum = 0\n     do j = 1, ny\n     do i = 1, nx\n         if ( var(i,j,k) /= missing ) then\n            icount = icount + 1\n            dsum = dsum + var(i,j,k)\n         endif\n     enddo\n     enddo   \n     avg_prof(k) = dmiss\n!hui     counter(k) = 0\n     counter(k) = imiss\n     if (icount /= 0 ) then\n        counter(k) = icount\n        if ( isq .eq. 0 ) then\n          avg_prof(k) = dsum /float(icount)\n        else\n          avg_prof(k) = sqrt(dsum /float(icount))\n        endif\n      endif\n  enddo\n\n  end subroutine domain_average\n"}, {"instruction": "Write a Fortran subroutine named alpha to compute the area of intersection between two circles of radii rb and rs separated by a distance s. The number of input arguments is 3 and the test_data type is ['real(8)', 'real(8)', 'real(8)']. The number of output arguments is 1 and the test_data type is ['real(8)'].", "input": "", "output": " subroutine alpha(rb,rs,s,alph)\n ! computes area of intersection (alpha) between two circles \n ! of radii r and r separated by distance s.\n\n implicit none\n real(8), intent(in) :: rb, rs, s\n real(8) :: kap0, kap1, kap2\n real(8), intent(out) :: alph\n     \n kap0 = dacos( (s**2 + rs**2 - rb**2)/(2.0d0*s*rs) )\n kap1 = dacos( (s**2 + rb**2 - rs**2)/(2.0d0*s*rb) )\n kap2 = dsqrt(0.25d0*(4.0d0*s**2*rb**2 - (rb**2+s**2-rs**2)**2))\n \n alph = rs**2*kap0 + rb**2*kap1 - kap2\n\n end subroutine alpha\n"}, {"instruction": "Create a Fortran subroutine named pmpir_add_error_string_f08 to add an error message string to the error code. The subroutine takes 2 input parameters of type integer and character with variable length, and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine pmpir_add_error_string_f08(errorcode, string, ierror)\n        implicit none\n        integer, intent(in) :: errorcode\n        character(len=*), intent(in) :: string\n        integer, optional, intent(out) :: ierror\n    end subroutine pmpir_add_error_string_f08\n"}, {"instruction": "Create a Fortran subroutine named pmpir_error_class_f08. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer and integer (optional). The purpose of this subroutine is to determine the error class based on the error code provided.", "input": "", "output": "    subroutine pmpir_error_class_f08(errorcode, errorclass, ierror)\n        implicit none\n        integer, intent(in) :: errorcode\n        integer, intent(out) :: errorclass\n        integer, optional, intent(out) :: ierror\n    end subroutine pmpir_error_class_f08\n"}, {"instruction": "Create a Fortran subroutine named load_climatology to load climatology data from files.The subroutine has 4 input parameters of type integer, integer, integer, and logical, and 2 output parameters of type real and real.", "input": "", "output": "    subroutine load_climatology ( yearday, nx, ny, is_leap, clim_taux, clim_tauy)\n      ! input/output data\n      integer, intent(in)  :: yearday, nx, ny\n      logical, intent(in)  :: is_leap\n      real   , intent(out) :: clim_taux(nx,ny), clim_tauy(nx,ny)\n      integer              :: clim_tauid\n    \n      ! climatology data\n      character (len = *), parameter :: clim_base_taux = &\n      \"/data/datos/ascat/data_l4_clim/clim_taux_blend_1992-2010_365.dat\"\n      character (len = *), parameter :: clim_base_tauy = &\n      \"/data/datos/ascat/data_l4_clim/clim_tauy_blend_1992-2010_365.dat\"\n      character (len = :), allocatable :: clim_file_taux\n      character (len = :), allocatable :: clim_file_tauy\n      \n      if ( is_leap .eqv. .true. ) then\n        clim_file_taux = clim_base_taux(:len(clim_base_taux)-7) //\"366.dat\"\n        clim_file_tauy = clim_base_tauy(:len(clim_base_tauy)-7) //\"366.dat\"\n      else\n        clim_file_taux = clim_base_taux\n        clim_file_tauy = clim_base_tauy\n      end if\n      write(*,'(a,1x,a,/)') \"loading climatology from file: \", clim_file_taux\n      write(*,'(a,1x,a,/)') \"loading climatology from file: \", clim_file_tauy\n    \n      open(newunit=clim_tauid, file=clim_file_taux, form=\"unformatted\", &\n            access=\"direct\", recl=nx*ny*4, &\n            status=\"old\", convert=\"big_endian\")\n      read(unit=clim_tauid, rec=yearday) clim_taux\n      close(unit=clim_tauid)\n    \n      open(newunit=clim_tauid, file=clim_file_tauy, form=\"unformatted\", &\n            access=\"direct\", recl=nx*ny*4, &\n            status=\"old\", convert=\"big_endian\")\n      read(unit=clim_tauid, rec=yearday) clim_tauy\n      close(unit=clim_tauid)\n    \n    end subroutine load_climatology\n"}, {"instruction": "Write a Fortran subroutine named put_ch to append a character string to the current record of the default unit. The subroutine has 1 input parameter of type character(len=*) and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_ch(string, iostat)\n\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a character string to the current record of\n! the default unit\n\n        if (present(iostat)) then\n            write (unit=*, fmt=\"(a)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=*, fmt=\"(a)\", advance=\"no\") string\n        end if\n\n! finish\n\n    end subroutine put_ch\n"}, {"instruction": "Create a Fortran subroutine named put_unit_ch with 2 input parameters of type integer and character(len=*), and 1 output parameter of type integer, which is optional. This subroutine appends a character string to the current record of the specified unit. If the optional iostat parameter is present, it writes the string to the specified unit, and if not present, it writes the string to the specified unit without advancing to the next record.", "input": "", "output": "    subroutine put_unit_ch(unit, string, iostat)\n\n        integer, intent(in)            :: unit\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a character string to the current record of\n! the specified unit\n\n        if (present(iostat)) then\n            write (unit=unit, fmt=\"(a)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=unit, fmt=\"(a)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_unit_ch\n"}, {"instruction": "Create a Fortran subroutine named put_line_ch to append a varying string to the current record of the default unit, terminating the record. The subroutine takes 1 input parameter of type character(len=*) and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_ch(string, iostat)\n\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a varying string to the current record of\n! the default unit, terminating the record\n\n        if (present(iostat)) then\n            write (unit=*, fmt=\"(a,/)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=*, fmt=\"(a,/)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_line_ch\n"}, {"instruction": "Create a Fortran subroutine named put_line_unit_ch that appends a varying string to the current record of the specified unit. The subroutine takes 2 input parameters of type integer and character(len=*), and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_unit_ch(unit, string, iostat)\n\n        integer, intent(in)            :: unit\n        character(len=*), intent(in)   :: string\n        integer, intent(out), optional :: iostat\n\n! append a varying string to the current record of\n! the specified unit, terminating the record\n\n        if (present(iostat)) then\n            write (unit=unit, fmt=\"(a,/)\", advance=\"no\", iostat=iostat) string\n        else\n            write (unit=unit, fmt=\"(a,/)\", advance=\"no\") string\n        end if\n\n! finish\n\n        return\n\n    end subroutine put_line_unit_ch\n"}, {"instruction": "Create a Fortran subroutine named shape9 to calculate gauss points, weights, shape functions, and derivatives for one-dimensional elements (beams and 2-d shells). The subroutine takes 2 input parameters of type integer (kind=4) and returns 4 output parameters of type real (kind=8), real (kind=8), real (kind=8), and real (kind=8) to store the weights, positions of gauss points, shape functions, and derivatives, respectively.", "input": "", "output": " subroutine shape9(weigh,posgp,shape,deriv,nnode,ngaus)\r\n !***********************************************************************\r\n !\r\n !     gauss points, weights, shape functions and derivatives for\r\n !     one-dimensinal elements (beams and 2-d shells)\r\n !***********************************************************************\r\n implicit none\r\n integer (kind=4), intent(in) :: nnode,ngaus\r\n real (kind=8), intent(out) :: weigh(:),posgp(:),shape(:,:),deriv(:,:)\r\n\r\n !     gauss points weight and possitions\r\n\r\n select case (ngaus)\r\n case(1)\r\n   weigh(1) =  2d0\r\n   posgp(1) =  0d0\r\n   select case (nnode)\r\n   case(2) !   two nodes, one gauss point\r\n     shape(1,1) =  0.5d0\r\n     shape(2,1) =  0.5d0\r\n     deriv(1,1) = -0.5d0\r\n     deriv(2,1) =  0.5d0\r\n   end select\r\n case(2)\r\n   weigh(1:2) =  1d0\r\n   posgp(1) = -1d0/sqrt(3d0)\r\n   posgp(2) =  1d0/sqrt(3d0)\r\n   select case (nnode)\r\n   case (2) !     two nodes, two gauss points\r\n     shape(1,1) =  0.5d0*(1d0-posgp(1))\r\n     shape(2,1) =  0.5d0*(1d0+posgp(1))\r\n     shape(1,2) =  0.5d0*(1d0-posgp(2))\r\n     shape(2,2) =  0.5d0*(1d0+posgp(2))\r\n     deriv(1,1) = -0.5d0\r\n     deriv(2,1) =  0.5d0\r\n     deriv(1,2) = -0.5d0\r\n     deriv(2,2) =  0.5d0\r\n   case (3)  !     three nodes, two gauss points\r\n     shape(1,1) = -0.5d0*(1d0-posgp(1))*posgp(1)\r\n     shape(2,1) =  1d0-posgp(1)**2\r\n     shape(3,1) =  0.5d0*(1d0+posgp(1))*posgp(1)\r\n     shape(1,2) = -0.5d0*(1d0-posgp(2))*posgp(2)\r\n     shape(2,2) =  1d0-posgp(2)**2\r\n     shape(3,2) =  0.5d0*(1d0+posgp(2))*posgp(2)\r\n     deriv(1,1) =  posgp(1)-0.5d0\r\n     deriv(2,1) = -posgp(1)*2d0\r\n     deriv(3,1) =  posgp(1)+0.5d0\r\n     deriv(1,2) =  posgp(2)-0.5d0\r\n     deriv(2,2) = -posgp(2)*2d0\r\n     deriv(3,2) =  posgp(2)+0.5d0\r\n   end select\r\n\r\n case(3)     !three gauss points\r\n   weigh(1) =  5d0/9d0\r\n   weigh(2) =  8d0/9d0\r\n   weigh(3) =  5d0/9d0\r\n   posgp(1) = -0.774596669241483d0\r\n   posgp(2) =  0d0\r\n   posgp(3) =  0.774596669241483d0\r\n   select case (nnode)\r\n   case (3)  !     three nodes, three gauss points\r\n     shape(1,1) = -0.5d0*(1d0-posgp(1))*posgp(1)\r\n     shape(2,1) =  1d0-posgp(1)**2\r\n     shape(3,1) =  0.5d0*(1d0+posgp(1))*posgp(1)\r\n     shape(1,2) = -0.5d0*(1d0-posgp(2))*posgp(2)\r\n     shape(2,2) =  1d0-posgp(2)**2\r\n     shape(3,2) =  0.5d0*(1d0+posgp(2))*posgp(2)\r\n     shape(1,3) = -0.5d0*(1d0-posgp(3))*posgp(3)\r\n     shape(2,3) =  1d0-posgp(3)**2\r\n     shape(3,3) =  0.5d0*(1d0+posgp(3))*posgp(3)\r\n     deriv(1,1) =  posgp(1)-0.5d0\r\n     deriv(2,1) = -posgp(1)*2d0\r\n     deriv(3,1) =  posgp(1)+0.5d0\r\n     deriv(1,2) =  posgp(2)-0.5d0\r\n     deriv(2,2) = -posgp(2)*2d0\r\n     deriv(3,2) =  posgp(2)+0.5d0\r\n     deriv(1,3) =  posgp(3)-0.5d0\r\n     deriv(2,3) = -posgp(3)*2d0\r\n     deriv(3,3) =  posgp(3)+0.5d0\r\n   end select\r\n end select\r\n return\r\n end subroutine shape9\r\n"}, {"instruction": "Create a Fortran subroutine named adios2_stringc2f to convert a C-style string to a Fortran-style string. The subroutine takes 2 input parameters of type character*(*) and integer, and 1 output parameter of type character(len=:), allocatable.", "input": "", "output": "    subroutine adios2_stringc2f(c_string, length, f_string)\n        character*(*), intent(in) :: c_string\n        integer, intent(in) :: length\n        character(len=:), allocatable, intent(out) :: f_string\n\n        if (allocated(f_string)) deallocate (f_string)\n        if (length > 0) then\n            allocate (character(length) :: f_string)\n            f_string = c_string(1:length)\n        end if\n\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named adios2_typec2f to convert a given integer representing an ADIOS2 type from C-style to Fortran-style. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The subroutine maps the input C-style integer to the equivalent Fortran-style integer and assigns the result to the output parameter.", "input": "", "output": "    subroutine adios2_typec2f(c_type, f_type)\n        integer, intent(in) :: c_type\n        integer, intent(out) :: f_type\n\n        integer :: i\n\n        f_type = adios2_type_unknown\n\n        do i = -1, 11\n            if (c_type == i) then\n                f_type = c_type\n                exit\n            end if\n        end do\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rowk that calculates the values for an array r based on the indices n and k. The number of input parameters is 2 with the test_data type ['integer', 'integer'], and the number of output parameters is 1 with the test_data type ['real (dp)']. The subroutine utilizes the selected_real_kind(14, 60) kind for real numbers.", "input": "", "output": "subroutine rowk(n, k, r)\r\n\r\nimplicit none\r\ninteger, parameter  :: dp = selected_real_kind(14, 60)\r\ninteger, intent(in)     :: n, k\r\nreal (dp), intent(out)  :: r(:)\r\n\r\ninteger    :: i\r\nreal (dp)  :: temp\r\n\r\nr(k) = 1.0_dp\r\nif (k > 1) then\r\n  temp = 1.0_dp\r\n  do i = 1, k-1\r\n    temp = 0.99_dp * temp\r\n    r(k-i) = temp\r\n  end do\r\nend if\r\n\r\nif (k < n) then\r\n  temp = 1.0_dp\r\n  do i = 1, n-k\r\n    temp = 0.99_dp * temp\r\n    r(k+i) = temp\r\n  end do\r\nend if\r\n\r\nreturn\r\nend subroutine rowk\r\n"}, {"instruction": "Create a Fortran subroutine named getprimefactor to find the smallest prime factor of a given integer input. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer.", "input": "", "output": "subroutine getprimefactor(dim,myfactor)\n  implicit none\n  integer, intent(in) :: dim\n  integer, intent(out) :: myfactor\n  integer :: iprime\n  integer, parameter :: numprimes=31\n  integer, parameter :: primelist(numprimes)=&\n       (/  2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,&\n          73, 79, 83, 89, 97,101,103,107,109,113,127 /)  ! no need to go remotely this high\n\n  myfactor=dim\n  do iprime=1,numprimes\n     if (mod(dim,primelist(iprime)).eq.0) then\n        myfactor=primelist(iprime)\n        return\n     endif\n  enddo\nend subroutine getprimefactor\n"}, {"instruction": "Create a Fortran subroutine named gettwiddlesmall to calculate the twiddle factors for a given dimension. The subroutine takes 2 input parameters of type integer and produces 1 output parameter of type complex*16. The input parameters are the dimensions dim1 and dim2.", "input": "", "output": "subroutine gettwiddlesmall(twiddlefacs,dim1,dim2)\n  implicit none\n  integer, intent(in) :: dim1,dim2\n  complex*16, intent(out) :: twiddlefacs(dim1)\n  complex*16 :: phi\n  integer :: k1, itwiddle(dim1)\n  real*8, parameter :: pi=3.14159265358979323846264338327950d0\n  phi=exp((0d0,-2d0) * pi / (dim1*dim2))\n  do k1=1,dim1\n     itwiddle(k1)=(k1-1)\n  enddo\n  twiddlefacs(:)=phi**itwiddle(:)\nend subroutine gettwiddlesmall\n"}, {"instruction": "Write a Fortran subroutine named cdate to convert a Julian day number to a calendar date. The subroutine should have 1 input parameter of type integer and 3 output parameters of type integer. The input parameter represents the Julian day number, and the output parameters represent the year, month, and day of the corresponding calendar date.", "input": "", "output": " subroutine cdate(jd,yyyy,mm,dd)\n!====given a julian day number, nnnnnnnn, yyyy,mm,dd are returned as the\n!         calendar date. jd = nnnnnnnn is the julian date from an epoch\n!         in the very distant past.  see cacm 1968 11(10):657,\n!         letter to the editor by fliegel and van flandern.\n!    example call cdate(2440588, yyyy, mm, dd) returns 1970 1 1 .\n\n integer,intent(in)  ::  jd\n integer,intent(out) ::  yyyy,mm,dd\n integer l\n\n l = jd + 68569\n n = 4*l/146097\n l = l - (146097*n + 3)/4\n yyyy = 4000*(l+1)/1461001\n l = l - 1461*yyyy/4 + 31\n mm = 80*l/2447\n dd = l - 2447*mm/80\n l = mm/11\n mm = mm + 2 - 12*l\n yyyy = 100*(n-49) + yyyy + l\n return\n end subroutine cdate\n"}, {"instruction": "Write a Fortran subroutine named conversion to convert a given number into year, month, and day. The subroutine takes 1 input parameter of type integer and 3 output parameters of type integer.", "input": "", "output": "   subroutine  conversion(number, year, month, day)\n   implicit  none\n\n   integer, intent(in)  :: number\n   integer, intent(out) :: year, month, day\n\n   year  = number / 10000\n   month = mod(number, 10000) / 100\n   day   = mod(number, 100)\n   end subroutine  conversion\n"}, {"instruction": "Create a Fortran subroutine named smear2 to calculate the values of ts1 and ts2 based on the input parameters drsq, pol12, and a, which are all of type double precision. The subroutine has 3 input parameters and 2 output parameters, all of which are of type double precision.", "input": "", "output": "subroutine smear2(drsq, pol12, a, ts1, ts2)\nimplicit none\ndouble precision, intent(in) :: drsq, pol12, a\ndouble precision, intent(out) :: ts1, ts2\ndouble precision :: dd,dri,drsqi,aa, ra,ra3,exp1\n\ndd = dsqrt(drsq)\ndri = 1.d0/dd\ndrsqi = dri*dri\n\naa = (pol12)**(1.d0/6.d0)\nra = dd/aa\nra3 = ra**3\nexp1 = dexp(-a*ra3)\nts1 = (1.d0 -exp1)*dri*drsqi\nts2 = (ts1 - exp1*a/aa**3) *drsqi\nend subroutine smear2\n"}, {"instruction": "Create a Fortran subroutine named split_za that takes an integer input parameter and returns two integer output parameters. The input parameter should be of type integer, and the two output parameters should also be of type integer. The subroutine should divide the input integer by 1000 and assign the quotient to one output parameter and the remainder to the other output parameter.", "input": "", "output": "        subroutine split_za(za, z, a)\n            implicit none\n            integer, intent(in):: za\n            integer, intent(out):: z, a\n            z = za / 1000\n            a = za - z*1000\n            return\n        end subroutine split_za\n"}, {"instruction": "Write a Fortran subroutine named `boulac_length` to calculate the boundary layer length scales. The subroutine takes 6 input parameters: 2 integers (`kts`, `kte`), and 4 real arrays of dimensions `kts:kte` and `kts:kte+1` as specified. It also returns 2 real arrays of dimensions `kts:kte`. The subroutine computes the boundary layer length scales based on the input data and the algorithm provided in the code.", "input": "", "output": "  subroutine boulac_length(kts,kte,zw,dz,qtke,theta,lb1,lb2)\n     integer, intent(in) :: kts,kte\n     real, dimension(kts:kte), intent(in) :: qtke,dz,theta\n     real, dimension(kts:kte), intent(out) :: lb1,lb2\n     real, dimension(kts:kte+1), intent(in) :: zw\n     integer :: iz, izz, found\n     real, dimension(kts:kte) :: dlu,dld\n     real, parameter :: lmax=2000.\n     real :: dzt, zup, beta, zup_inf, bbb, tl, zdo, zdo_sup, zzz\n     do iz=kts,kte\n        zup=0.\n        dlu(iz)=zw(kte+1)-zw(iz)-dz(iz)/2.\n        zzz=0.\n        zup_inf=0.\n        beta=g/theta(iz)\n        if (iz .lt. kte) then\n          found = 0\n          izz=iz\n          do while (found .eq. 0)\n            if (izz .lt. kte) then\n              dzt=dz(izz)\n              zup=zup-beta*theta(iz)*dzt\n              zup=zup+beta*(theta(izz+1)+theta(izz))*dzt/2.\n              zzz=zzz+dzt\n              if (qtke(iz).lt.zup .and. qtke(iz).ge.zup_inf) then\n                 bbb=(theta(izz+1)-theta(izz))/dzt\n                 if (bbb .ne. 0.) then\n                    tl=(-beta*(theta(izz)-theta(iz)) + &\n                      & sqrt( max(0.,(beta*(theta(izz)-theta(iz)))**2. + &\n                      & 2.*bbb*beta*(qtke(iz)-zup_inf))))/bbb/beta\n                 else\n                    if (theta(izz) .ne. theta(iz))then\n                       tl=(qtke(iz)-zup_inf)/(beta*(theta(izz)-theta(iz)))\n                    else\n                       tl=0.\n                    endif\n                 endif\n                 dlu(iz)=zzz-dzt+tl\n                 found =1\n              endif\n              zup_inf=zup\n              izz=izz+1\n             else\n              found = 1\n            endif\n          enddo\n        endif\n        zdo=0.\n        zdo_sup=0.\n        dld(iz)=zw(iz)\n        zzz=0.\n        if (iz .gt. kts) then\n          found = 0\n          izz=iz\n          do while (found .eq. 0)\n            if (izz .gt. kts) then\n              dzt=dz(izz-1)\n              zdo=zdo+beta*theta(iz)*dzt\n              zdo=zdo-beta*(theta(izz-1)+theta(izz))*dzt/2.\n              zzz=zzz+dzt\n              if (qtke(iz).lt.zdo .and. qtke(iz).ge.zdo_sup) then\n                 bbb=(theta(izz)-theta(izz-1))/dzt\n                 if (bbb .ne. 0.) then\n                    tl=(beta*(theta(izz)-theta(iz))+ &\n                      & sqrt( max(0.,(beta*(theta(izz)-theta(iz)))**2. + &\n                      & 2.*bbb*beta*(qtke(iz)-zdo_sup))))/bbb/beta\n                 else\n                    if (theta(izz) .ne. theta(iz)) then\n                       tl=(qtke(iz)-zdo_sup)/(beta*(theta(izz)-theta(iz)))\n                    else\n                       tl=0.\n                    endif\n                 endif\n                 dld(iz)=zzz-dzt+tl\n                 found = 1\n              endif\n              zdo_sup=zdo\n              izz=izz-1\n            else\n              found = 1\n            endif\n          enddo\n        endif\n        dld(iz) = min(dld(iz),zw(iz+1))\n        lb1(iz) = min(dlu(iz),dld(iz))\n        lb2(iz) = sqrt(dlu(iz)*dld(iz))\n        lb1(iz) = lb1(iz)/(1. + (lb1(iz)/lmax))\n        lb2(iz) = lb2(iz)/(1. + (lb2(iz)/lmax))\n        if (iz .eq. kte) then\n           lb1(kte) = lb1(kte-1)\n           lb2(kte) = lb2(kte-1)\n        endif\n     enddo\n  end subroutine boulac_length\n"}, {"instruction": "Create a Fortran subroutine named get_indices to find all the indices of a matching character in a given string. The subroutine takes 2 input parameters of type character(len=*) and 2 output parameters of type integer and integer, optional.", "input": "", "output": "   subroutine get_indices( match_strng, string, match_cnt, match_ndx )\n!------------------------------------------------------------------\n!     get all indices of match char in string\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n   integer, intent(out) :: match_cnt\n   integer, optional, intent(out) :: match_ndx(:)\n   character(len=*), intent(in) :: match_strng\n   character(len=*), intent(in) :: string\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n   integer :: pos, ndx\n   logical :: set_ndx\n\n   if( present( match_ndx ) ) then\n     set_ndx = .true.\n   else\n     set_ndx = .false.\n   endif\n   ndx       = 0\n   match_cnt = 0\n   do\n     pos = index( string(ndx+1:), match_strng )\n     if( pos == 0 ) then\n       exit\n     endif\n     ndx       = ndx + pos \n     match_cnt = match_cnt + 1 \n     if( set_ndx ) then\n       match_ndx(match_cnt) = ndx\n     endif\n   end do\n\n   end subroutine get_indices\n"}, {"instruction": "Write a Fortran subroutine named wrf2mz_time to convert a WRF time string to the Mozart date and second format. The subroutine takes 1 input argument of type character(len=*) and 2 output arguments of type integer.", "input": "", "output": "       subroutine wrf2mz_time( wrf_time, ncdate, ncsec )\n!------------------------------------------------------------------\n!     convert wrf time string to mozart date,sec format\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n       character(len=*), intent(in) :: wrf_time\n       integer, intent(out)         :: ncdate\n       integer, intent(out)         :: ncsec\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n      integer :: year, month, day\n      integer :: hour, minute, second\n      integer :: date_time_sep\n      integer :: nstring\n      integer :: istat\n\n      nstring = len( wrf_time )\n      date_time_sep = index( wrf_time, '_' )\n      if( date_time_sep < 1 .or. date_time_sep >= nstring ) then\n         write(*,*) 'wrf2mz_time: wrf date ',wrf_time(:nstring),' is invalid'\n      end if\n!------------------------------------------------------------------\n!     read year, month and day\n!------------------------------------------------------------------\n       read(wrf_time(:date_time_sep-1),'(i4,1x,i2,1x,i2)',iostat=istat) year, month, day\n       if( istat /= 0 ) then\n         write(*,*) 'wrf2mz_time: failed to read year,month,day; iostat = ',istat\n       end if\n       read(wrf_time(date_time_sep+1:nstring),'(i2,1x,i2,1x,i2)',iostat=istat) hour, minute, second\n       if( istat /= 0 ) then\n         write(*,*) 'wrf2mz_time: failed to read hour,minute,second; iostat = ',istat\n       end if\n       ncdate = 100*(year*100 + month) + day\n       ncsec  = 60*(60*hour + minute) + second\n\n      end subroutine wrf2mz_time\n"}, {"instruction": "Write a Fortran subroutine named mz2wrf_time to convert the WRF time string to a Mozart date and seconds format. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=*)'].", "input": "", "output": "      subroutine mz2wrf_time( wrf_time, ncdate, ncsec )\n!------------------------------------------------------------------\n!     convert wrf time string to mozart date,sec format\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!     dummy arguments\n!------------------------------------------------------------------\n       character(len=*), intent(out) :: wrf_time\n       integer, intent(in)           :: ncdate\n       integer, intent(in)           :: ncsec\n\n!------------------------------------------------------------------\n!     local variables\n!------------------------------------------------------------------\n      integer :: year, month, day\n      integer :: hour, minute, second\n      integer :: nstring\n      integer :: istat\n      character(len=3) :: numa\n\n      wrf_time = ' '\n      year  = ncdate/10000\n      month = mod( ncdate,10000 )/100\n      day   = mod( ncdate,100)\n      write(wrf_time,'(i4,''-'')',iostat=istat) year\n      write(numa,'(i3)') 100+month\n      wrf_time(6:8) = numa(2:3) // '-'\n      write(numa,'(i3)') 100+day\n      wrf_time(9:11) = numa(2:3) // '_'\n      hour   = ncsec/3600\n      minute = (ncsec - hour*3600)/60\n      second = ncsec - 60*(hour*60 + minute)\n      write(numa,'(i3)') 100+hour\n      wrf_time(12:14) = numa(2:3) // ':'\n      write(numa,'(i3)') 100+minute\n      wrf_time(15:17) = numa(2:3) // ':'\n      write(numa,'(i3)') 100+second\n      wrf_time(18:19) = numa(2:3)\n\n      end subroutine mz2wrf_time\n"}, {"instruction": "Write a Fortran subroutine named \"upcase\" to convert a given input string to uppercase. The number of input parameters for this subroutine is 1, and the test_data type is ['character(len=*)']. The number of output parameters is 1, and the test_data type is ['character(len=*)'].", "input": "", "output": "   subroutine upcase( in_string, out_string )\n!------------------------------------------------------------------\n!  convert string to upper case\n!------------------------------------------------------------------\n\n!------------------------------------------------------------------\n!  dummy arguments\n!------------------------------------------------------------------\n   character(len=*), intent(in)  :: in_string\n   character(len=*), intent(out) :: out_string\n\n!------------------------------------------------------------------\n!  local variables\n!------------------------------------------------------------------\n   integer :: incr\n   integer :: m\n\n   incr = ichar( 'a' ) - ichar( 'a' )\n   out_string(:) = ' '\n   do m = 1,min(len(in_string),len(out_string))\n     if( lge( in_string(m:m),'a' ) .and. lle( in_string(m:m),'z' ) ) then\n       out_string(m:m) = char( ichar( in_string(m:m) ) + incr )\n     else\n       out_string(m:m) = in_string(m:m)\n     endif\n   end do\n\n   end subroutine upcase\n"}, {"instruction": "Create a Fortran subroutine named forpar to analyze the parent-child relationships in a tree structure. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are neqns and parent(*), while the output parameters are nstop and nch(*). The subroutine calculates the number of children for each parent node and identifies the node at which the tree structure stops.", "input": "", "output": "  subroutine forpar(neqns,parent,nch,nstop)\n    implicit none\n    !------\n    integer, intent(in):: neqns\n    integer, intent(in):: parent(*)\n    integer, intent(out):: nstop\n    integer, intent(out):: nch(*)\n    !------\n    integer:: i\n    integer:: idens\n    integer:: ii\n\n    nch(1:neqns) = 0\n    nch(neqns+1) = 0\n    do i = 1, neqns\n      ii = parent(i)\n      nch(ii) = nch(ii) + 1\n    enddo\n    do i = neqns, 1, -1\n      if ( nch(i)/=1 ) exit\n    enddo\n\n    idens = 0\n    if ( idens==1 ) then\n      nstop = i\n    else\n      nstop = neqns + 1\n    endif\n  end subroutine forpar\n"}, {"instruction": "Write a Fortran subroutine named bringu to perform a specific operation related to permutations and integer arrays. This subroutine takes 4 input parameters of type integer: izz, neqns, zpiv, and parent. It also has 3 output parameters of type integer: irr, iperm, and invp.", "input": "", "output": "  subroutine bringu(zpiv,iperm,invp,parent,izz,neqns,irr)\n    implicit none\n    !------\n    integer, intent(in):: izz\n    integer, intent(in):: neqns\n    integer, intent(in):: zpiv(*)\n    integer, intent(in):: parent(*)\n    integer, intent(out):: irr\n    integer, intent(out):: iperm(*)\n    integer, intent(out):: invp(*)\n    !------\n    integer:: i\n    integer:: ib\n    integer:: ib0\n    integer:: ibp\n    integer:: idbg\n    integer:: izzp\n\n    idbg = 0\n    irr = 0\n    ib0 = invp(izz)\n    ib = ib0\n    do while ( ib>0 )\n      ibp = parent(ib)\n      izzp = iperm(ibp)\n      if ( zpiv(izzp)==0 ) then\n        invp(izz) = ibp\n        invp(izzp) = ib0\n        iperm(ibp) = izz\n        iperm(ib0) = izzp\n        if ( idbg/=0 ) then\n          do i = 1, neqns\n            if ( invp(iperm(i))/=i .or. iperm(invp(i))/=i) then\n              write (6,*) 'permutation error'\n              stop\n            endif\n          enddo\n          return\n        endif\n        return\n      else\n        ib = ibp\n      endif\n    enddo\n    irr = 1\n  end subroutine bringu\n"}, {"instruction": "Create a Fortran subroutine named \"addrx\" that takes 9 input parameters of type integer and real(kind=8), and 4 output parameters of type integer and real(kind=8). The function should perform a series of computations involving the input parameters and assign values to the output parameters based on the logic implemented in the subroutine.", "input": "", "output": "  subroutine addrx(i,j,aij,invp,xlnzr,colno,diag,zln,dsln,nstop,ndeg,ndeg2l,ir)\n    implicit none\n    !------\n    integer, intent(in):: i\n    integer, intent(in):: j\n    integer, intent(in):: ndeg\n    integer, intent(in):: ndeg2l\n    integer, intent(in):: nstop\n    integer, intent(in):: invp(*)\n    integer, intent(in):: xlnzr(*)\n    integer, intent(in):: colno(*)\n    real(kind=8), intent(in):: aij(ndeg,ndeg)\n    integer, intent(out):: ir\n    real(kind=8), intent(out):: zln(ndeg,ndeg,*)\n    real(kind=8), intent(out):: diag(ndeg2l,*)\n    real(kind=8), intent(out):: dsln(ndeg,ndeg,*)\n    !------\n    integer:: i0\n    integer:: ii\n    integer:: itrans\n    integer:: j0\n    integer:: jj\n    integer:: k\n    integer:: ke\n    integer:: ks\n    integer:: l\n    integer:: m\n    integer:: n\n    integer, parameter:: idbg = 0\n\n    ir = 0\n    ii = invp(i)\n    jj = invp(j)\n    if ( idbg/=0 ) write (6,*) ii, jj, aij\n    if ( ii==jj ) then\n      l = 0\n      do n = 1, ndeg\n        do m = 1, n\n          l = l + 1\n          diag(l,ii) = aij(n,m)\n        enddo\n      enddo\n      return\n    endif\n    itrans = 0\n    if ( jj>ii ) then\n      k = jj\n      jj = ii\n      ii = k\n      itrans = 1\n    endif\n    if ( jj>=nstop ) then\n      i0 = ii - nstop\n      j0 = jj - nstop + 1\n      k = i0*(i0-1)/2 + j0\n      if ( itrans==0 ) then\n        do m = 1, ndeg\n          dsln(1:ndeg,m,k) = aij(1:ndeg,m)\n        enddo\n      else\n        do m = 1, ndeg\n          dsln(1:ndeg,m,k) = aij(m,1:ndeg)\n        enddo\n      endif\n      return\n    endif\n    ks = xlnzr(ii)\n    ke = xlnzr(ii+1) - 1\n    do k = ks, ke\n      if ( colno(k)==jj ) then\n        if ( itrans==0 ) then\n          do m = 1, ndeg\n            zln(1:ndeg,m,k) = aij(1:ndeg,m)\n          enddo\n        else\n          do m = 1, ndeg\n            zln(1:ndeg,m,k) = aij(m,1:ndeg)\n          enddo\n        endif\n        return\n      endif\n    enddo\n    ir = 20\n  end subroutine addrx\n"}, {"instruction": "Create a Fortran subroutine named d2dot to compute the dot product of two 4xN matrices A and B, and store the result in a 4x1 matrix T. The subroutine should take 3 input parameters of type integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine d2dot(t,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(4,*)\n    real(kind=8), intent(in):: b(4,*)\n    real(kind=8), intent(out):: t(4)\n    !------\n    integer:: jj\n\n    t(1:4) = 0.0d0\n\n    do jj = 1, n\n      t(1) = t(1) + a(1,jj)*b(1,jj) + a(3,jj)*b(3,jj)\n      t(2) = t(2) + a(2,jj)*b(1,jj) + a(4,jj)*b(3,jj)\n      t(3) = t(3) + a(1,jj)*b(2,jj) + a(3,jj)*b(4,jj)\n      t(4) = t(4) + a(2,jj)*b(2,jj) + a(4,jj)*b(4,jj)\n    enddo\n  end subroutine d2dot\n"}, {"instruction": "Create a Fortran subroutine named d2sdot that performs a dot product calculation. The subroutine takes 3 input parameters: an integer n, and two arrays of real(kind=8) type, a(2,*) and b(4,*). It also has 1 output parameter, an array of real(kind=8) type, wi(2).", "input": "", "output": "  subroutine d2sdot(wi,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(2,*)\n    real(kind=8), intent(in):: b(4,*)\n    real(kind=8), intent(out):: wi(2)\n    !------\n    integer:: jj\n\n    do jj = 1, n\n      wi(1) = wi(1) - a(1,jj)*b(1,jj) - a(2,jj)*b(3,jj)\n      wi(2) = wi(2) - a(1,jj)*b(2,jj) - a(2,jj)*b(4,jj)\n    enddo\n  end subroutine d2sdot\n"}, {"instruction": "Create a Fortran subroutine named d3sdot to calculate the dot product of two 3-dimensional vectors. The subroutine takes 3 input parameters of types integer, real(kind=8) and real(kind=8), and 1 output parameter of type real(kind=8). The subroutine uses the imperative tone and the features of Fortran subroutine.", "input": "", "output": "  subroutine d3sdot(wi,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(3,*)\n    real(kind=8), intent(in):: b(9,*)\n    real(kind=8), intent(out):: wi(3)\n    !------\n    integer:: jj\n\n    do jj = 1, n\n      wi(1) = wi(1) - a(1,jj)*b(1,jj) - a(2,jj)*b(4,jj) - a(3,jj)*b(7,jj)\n      wi(2) = wi(2) - a(1,jj)*b(2,jj) - a(2,jj)*b(5,jj) - a(3,jj)*b(8,jj)\n      wi(3) = wi(3) - a(1,jj)*b(3,jj) - a(2,jj)*b(6,jj) - a(3,jj)*b(9,jj)\n    enddo\n  end subroutine d3sdot\n"}, {"instruction": "Create a Fortran subroutine named dxdot that performs matrix multiplication. It takes 4 input parameters of types integer, integer, real(kind=8), real(kind=8) and 1 output parameter of type real(kind=8). The subroutine computes the matrix product of two input matrices and stores the result in the output matrix. Use the imperative tone to define the subroutine and its parameters.", "input": "", "output": "  subroutine dxdot(ndeg,t,a,b,l)\n    implicit none\n    !------\n    integer, intent(in):: l\n    integer, intent(in):: ndeg\n    real(kind=8), intent(in):: a(ndeg,ndeg,*)\n    real(kind=8), intent(in):: b(ndeg,ndeg,*)\n    real(kind=8), intent(out):: t(ndeg,ndeg)\n    !------\n    integer:: jj\n    integer:: k\n    integer:: m\n    integer:: n\n\n    do n = 1, ndeg\n      do m = 1, ndeg\n        t(n,m) = 0.0d0\n        do k = 1, ndeg\n          do jj = 1, l\n            t(n,m) = t(n,m) + a(n,k,jj)*b(m,k,jj)\n          enddo\n        enddo\n      enddo\n    enddo\n  end subroutine dxdot\n"}, {"instruction": "Create a Fortran subroutine named inv22 to perform matrix operations. The subroutine takes 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameters are diag(3) and zz(4), and the output parameter is zln(4). The subroutine calculates specific operations on the input parameters and assigns the results to the output parameter.", "input": "", "output": "  subroutine inv22(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(3)\n    real(kind=8), intent(in):: zz(4)\n    real(kind=8), intent(out):: zln(4)\n    !------\n    zln(3) = zz(3) - zz(1)*diag(2)\n    zln(1) = zz(1)*diag(1)\n    zln(3) = zln(3)*diag(3)\n    zln(1) = zln(1) - zln(3)*diag(2)\n\n    zln(4) = zz(4) - zz(2)*diag(2)\n    zln(2) = zz(2)*diag(1)\n    zln(4) = zln(4)*diag(3)\n    zln(2) = zln(2) - zln(4)*diag(2)\n  end subroutine inv22\n"}, {"instruction": "Write a Fortran subroutine named inv33 to perform matrix inversion and compute the resulting matrix. The number of input arguments is 2, and the test_data type is ['real(kind=8)', 'real(kind=8)']. The number of output arguments is 1, and the test_data type is ['real(kind=8)'].", "input": "", "output": "  subroutine inv33(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(6)\n    real(kind=8), intent(in):: zz(9)\n    real(kind=8), intent(out):: zln(9)\n    !------\n    zln(4) = zz(4) - zz(1)*diag(2)\n    zln(7) = zz(7) - zz(1)*diag(4) - zln(4)*diag(5)\n    zln(1) = zz(1)*diag(1)\n    zln(4) = zln(4)*diag(3)\n    zln(7) = zln(7)*diag(6)\n    zln(4) = zln(4) - zln(7)*diag(5)\n    zln(1) = zln(1) - zln(4)*diag(2) - zln(7)*diag(4)\n\n    zln(5) = zz(5) - zz(2)*diag(2)\n    zln(8) = zz(8) - zz(2)*diag(4) - zln(5)*diag(5)\n    zln(2) = zz(2)*diag(1)\n    zln(5) = zln(5)*diag(3)\n    zln(8) = zln(8)*diag(6)\n    zln(5) = zln(5) - zln(8)*diag(5)\n    zln(2) = zln(2) - zln(5)*diag(2) - zln(8)*diag(4)\n\n    zln(6) = zz(6) - zz(3)*diag(2)\n    zln(9) = zz(9) - zz(3)*diag(4) - zln(6)*diag(5)\n    zln(3) = zz(3)*diag(1)\n    zln(6) = zln(6)*diag(3)\n    zln(9) = zln(9)*diag(6)\n    zln(6) = zln(6) - zln(9)*diag(5)\n    zln(3) = zln(3) - zln(6)*diag(2) - zln(9)*diag(4)\n  end subroutine inv33\n"}, {"instruction": "Create a Fortran subroutine named \"inv66\" to compute a certain matrix operation. The subroutine should take 2 input parameters of type real(kind=8) and 1 output parameter of type real(kind=8). The input parameters are \"diag(21)\" and \"zz(36)\", and the output parameter is \"zln(36)\". The subroutine involves matrix calculations and uses the imperative tone.", "input": "", "output": "  subroutine inv66(zln,zz,diag)\n    implicit none\n    !------\n    real(kind=8), intent(in):: diag(21)\n    real(kind=8), intent(in):: zz(36)\n    real(kind=8), intent(out):: zln(36)\n    !------\n    integer:: i\n\n    do i = 0, 5\n      zln(i+7) = zz(i+7) - zz(i+1)*diag(2)\n      zln(i+13) = zz(i+13) - zz(i+1)*diag(4) - zln(i+7)*diag(5)\n      zln(i+19) = zz(i+19) - zz(i+1)*diag(7) - zln(i+7)*diag(8) - zln(i+13)*diag(9)\n      zln(i+25) = zz(i+25) - zz(i+1)*diag(11) - zln(i+7)*diag(12) - zln(i+13)*diag(13)&\n        - zln(i+19)*diag(14)\n      zln(i+31) = zz(i+31) - zz(i+1)*diag(16) - zln(i+7)*diag(17) - zln(i+13)*diag(18)&\n        - zln(i+19)*diag(19) - zln(i+25)*diag(20)\n      zln(i+1) = zz(i+1)*diag(1)\n      zln(i+7) = zln(i+7)*diag(3)\n      zln(i+13) = zln(i+13)*diag(6)\n      zln(i+19) = zln(i+19)*diag(10)\n      zln(i+25) = zln(i+25)*diag(15)\n      zln(i+31) = zln(i+31)*diag(21)\n      zln(i+25) = zln(i+25) - zln(i+31)*diag(20)\n      zln(i+19) = zln(i+19) - zln(i+31)*diag(19) - zln(i+25)*diag(14)\n      zln(i+13) = zln(i+13) - zln(i+31)*diag(18) - zln(i+25)*diag(13)- zln(i+19)*diag(9)\n      zln(i+7) = zln(i+7) - zln(i+31)*diag(17) - zln(i+25)*diag(12)- zln(i+19)*diag(8)&\n        - zln(i+13)*diag(5)\n      zln(i+1) = zln(i+1) - zln(i+31)*diag(16) - zln(i+25)*diag(11)- zln(i+19)*diag(7)&\n        - zln(i+13)*diag(4) - zln(i+7)*diag(2)\n    enddo\n  end subroutine inv66\n"}, {"instruction": "Create a Fortran subroutine named invxx to perform a matrix inversion calculation. The subroutine takes 3 input parameters of types integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8).", "input": "", "output": "  subroutine invxx(zln,zz,diag,ndeg)\n    implicit none\n    !------\n    integer, intent(in):: ndeg\n    real(kind=8), intent(in):: diag(*)\n    real(kind=8), intent(in):: zz(ndeg,ndeg)\n    real(kind=8), intent(out):: zln(ndeg,ndeg)\n    !------\n    integer:: joc\n    integer:: l\n    integer:: loc1\n    integer:: m\n    integer:: n\n\n    zln = zz\n    do l = 1, ndeg, 2\n      joc = 0\n      do m = 1, ndeg - 1\n        joc = joc + m\n        loc1 = joc + m\n        do n = m + 1, ndeg\n          zln(l,n) = zln(l,n) - zln(l,m)*diag(loc1)\n          zln(l+1,n) = zln(l+1,n) - zln(l+1,m)*diag(loc1)\n          loc1 = loc1 + n\n        enddo\n      enddo\n      joc = 0\n      do m = 1, ndeg\n        joc = joc + m\n        zln(l,m) = zln(l,m)*diag(joc)\n        zln(l+1,m) = zln(l+1,m)*diag(joc)\n      enddo\n      do n = ndeg, 2, -1\n        joc = joc - 1\n        do m = n - 1, 1, -1\n          zln(l,m) = zln(l,m) - zln(l,n)*diag(joc)\n          zln(l+1,m) = zln(l+1,m) - zln(l+1,n)*diag(joc)\n          joc = joc - 1\n        enddo\n      enddo\n    enddo\n  end subroutine invxx\n"}, {"instruction": "Write a Fortran subroutine named qmdot to perform a specific graph operation. The subroutine takes 6 input parameters of type integer, which are rchsze, root, marker, rchset, nbrhd, and xadj. It also has 1 output parameter of type integer, which is adjncy. The subroutine performs a series of computations and modifications on the input data to generate the output adjncy.", "input": "", "output": "  subroutine qmdot(root,xadj,adjncy,marker,rchsze,rchset,nbrhd)\n    implicit none\n    !------\n    integer, intent(in):: rchsze\n    integer, intent(in):: root\n    integer, intent(in):: marker(*)\n    integer, intent(in):: rchset(*)\n    integer, intent(in):: nbrhd(*)\n    integer, intent(in):: xadj(*)\n    integer, intent(out):: adjncy(*)\n    !------\n    integer:: inhd\n    integer:: irch\n    integer:: j\n    integer:: jstrt\n    integer:: jstop\n    integer:: link\n    integer:: nabor\n    integer:: node\n\n    irch = 0\n    inhd = 0\n    node = root\n    100 jstrt = xadj(node)\n    jstop = xadj(node+1) - 2\n    if ( jstop>=jstrt ) then\n      do j = jstrt, jstop\n        irch = irch + 1\n        adjncy(j) = rchset(irch)\n        if ( irch>=rchsze ) goto 200\n      enddo\n    endif\n    link = adjncy(jstop+1)\n    node = -link\n    if ( link>=0 ) then\n      inhd = inhd + 1\n      node = nbrhd(inhd)\n      adjncy(jstop+1) = -node\n    endif\n    goto 100\n\n    200 adjncy(j+1) = 0\n    do irch = 1, rchsze\n      node = rchset(irch)\n      if ( marker(node)>=0 ) then\n        jstrt = xadj(node)\n        jstop = xadj(node+1) - 1\n        do j = jstrt, jstop\n          nabor = adjncy(j)\n          if ( marker(nabor)<0 ) then\n            adjncy(j) = root\n            exit\n          endif\n        enddo\n      endif\n    enddo\n  end subroutine qmdot\n"}, {"instruction": "Write a Fortran subroutine named qqsort to perform an in-place quicksort algorithm on an array of integers.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine qqsort(iw,ik)\n    implicit none\n    !------\n    integer, intent(in):: ik\n    integer, intent(out):: iw(*)\n    !------\n    integer:: itemp\n    integer:: l\n    integer:: m\n\n    if ( ik<=1 ) return\n    do l = 1, ik - 1\n      do m = l + 1, ik\n        if ( iw(l)>=iw(m) ) then\n          itemp = iw(l)\n          iw(l) = iw(m)\n          iw(m) = itemp\n        endif\n      enddo\n    enddo\n  end subroutine qqsort\n"}, {"instruction": "Create a Fortran subroutine named v2prod to perform vector-vector multiplication for arrays of real numbers. The subroutine takes 3 input parameters of type integer, real(kind=8), and real(kind=8) and 1 output parameter of type real(kind=8). The subroutine calculates the vector-vector product for each element in the arrays and stores the result in the output array.", "input": "", "output": "  subroutine v2prod(a,b,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(4,n)\n    real(kind=8), intent(in):: b(3,n)\n    real(kind=8), intent(out):: c(4,n)\n    !------\n    integer:: i\n\n    do i = 1, n\n      c(3,i) = a(3,i) - a(1,i)*b(2,i)\n      c(1,i) = a(1,i)*b(1,i)\n      c(3,i) = c(3,i)*b(3,i)\n      c(1,i) = c(1,i) - c(3,i)*b(2,i)\n\n      c(4,i) = a(4,i) - a(2,i)*b(2,i)\n      c(2,i) = a(2,i)*b(1,i)\n      c(4,i) = c(4,i)*b(3,i)\n      c(2,i) = c(2,i) - c(4,i)*b(2,i)\n    enddo\n  end subroutine v2prod\n"}, {"instruction": "Write a Fortran subroutine named \"vlcpy\" to copy the transpose of a real(kind=8) array \"b\" to another real(kind=8) array \"a\". The number of input arguments is 2, with test_data types ['integer', 'real(kind=8)']. The number of output arguments is 1 with test_data type ['real(kind=8)'].", "input": "", "output": "  subroutine vlcpy(a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: b(n,n)\n    real(kind=8), intent(out):: a(n,n)\n    !------\n    integer:: i\n\n    do i = 1, n\n      a(1:n,i) = b(i,1:n)\n    enddo\n  end subroutine vlcpy\n"}, {"instruction": "Write a Fortran subroutine named vcopy that copies the values from an array \"a\" to another array \"c\" of the same size. The number of input arguments is 2, with test_data types ['integer', 'real(kind=8)']. The number of output arguments is 1, with a test_data type of ['real(kind=8)'].", "input": "", "output": "  subroutine vcopy(a,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(n)\n    real(kind=8), intent(out):: c(n)\n    !------\n    c = a\n  end subroutine vcopy\n"}, {"instruction": "Write a Fortran subroutine named vprod to perform element-wise vector multiplication of two input arrays and store the result in a third array. The number of input arguments is 3 and the test_data type is [integer, real(kind=8), real(kind=8)]. The number of output arguments is 1 and the test_data type is [real(kind=8)].", "input": "", "output": "  subroutine vprod(a,b,c,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(n)\n    real(kind=8), intent(in):: b(n)\n    real(kind=8), intent(out):: c(n)\n    !------\n    c(1:n) = a(1:n)*b(1:n)\n  end subroutine vprod\n"}, {"instruction": "Create a Fortran subroutine named \"blacs_get\" to retrieve a value based on the context and a specified parameter. The subroutine should have 2 input parameters of type integer, named \"icontxt\" and \"what\", and 1 output parameter of type integer named \"val\".", "input": "", "output": "     subroutine blacs_get(icontxt, what, val)\n       implicit none\n       integer, intent(in)  :: icontxt\n       integer, intent(in)  :: what\n       integer, intent(out) :: val\n     end subroutine blacs_get\n"}, {"instruction": "Create a Fortran subroutine named dvbes1 that calculates the derivatives of the Bessel functions. The subroutine has 4 input parameters of type integer, real*8, real*8, and an array of real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine dvbes1(fj,dj,sm,ri,nt)\n  implicit none\n  !        arguments\n  integer, intent(in) :: nt\n  real*8, intent(in)  :: ri, sm, fj(nt)\n  real*8, intent(out) :: dj(nt)\n  !..................................................................\n  !   calculate the derivatives of the bessel functions\n  !      dj = dfj/dx where x = sm*ri\n  !                                        d.d.koelling\n  !..................................................................\n  !   local parameters\n  real*8, parameter :: zup = 1.0d-5\n  !        local scalars\n  integer            l, lm\n  double precision   q2, q3, x\n  !\n  x = sm*ri\n  if (x .gt. zup) then\n     q2 = -1.d0/x\n     q3 = q2\n     dj(1) = -fj(2)\n     lm = 1\n     do l = 2, nt\n        q3 = q3 + q2\n        dj(l) = fj(lm) + q3*fj(l)\n        lm = lm + 1\n     enddo\n  else\n     dj(1) = 0.d0\n     dj(2) = 1.0d+0/3.0d+0\n     do l = 3, nt\n        dj(l) = 0.d0\n     enddo\n  endif\n  !\n  return\nend subroutine dvbes1\n"}, {"instruction": "Create a Fortran subroutine named toto1 that takes an integer input argument and returns an integer output. This subroutine doubles the value of the input integer and assigns it to the output integer.", "input": "", "output": "  elemental subroutine toto1 (x, y)\n    integer, intent(out) :: x\n    integer, intent(in)  :: y\n    x = y + y\n  end subroutine toto1\n"}, {"instruction": "Create a Fortran subroutine named toto2 to perform the addition of 1 to each element of an input 2D integer array. The subroutine should have 1 input parameter with the type integer, dimension(:,:), and intent(in), and 1 output parameter with the type integer, dimension(:,:), and intent(out).", "input": "", "output": "  subroutine toto2 (x, y)\n    integer, dimension(:,:), intent(out) :: x\n    integer, dimension(:,:), intent(in)  :: y\n    x = y + 1\n  end subroutine toto2\n"}, {"instruction": "Create a Fortran subroutine named cutoff_cos to calculate the value and derivatives of a cutoff cosine function. The subroutine takes 3 input parameters of type double precision: x, r0, and rc. It returns 4 output parameters of type double precision: y, dy, d2y, and d3y.", "input": "", "output": "  subroutine cutoff_cos(x, r0, rc, y, dy, d2y, d3y)\n\n    implicit none\n\n    double precision, intent(in)  :: x, r0, rc\n    double precision, intent(out) :: y, dy, d2y, d3y\n\n    double precision,   parameter :: pi = 3.14159265358979d0\n\n    double precision :: a, a2\n\n    if (x<r0) then\n       y   = 1.0d0\n       dy  = 0.0d0\n       d2y = 0.0d0\n       d3y = 0.0d0\n    else if (x>rc) then\n       y   = 0.0d0\n       dy  = 0.0d0\n       d2y = 0.0d0\n       d3y = 0.0d0\n    else\n       a   = pi/(rc-r0)\n       a2  = a*a\n       y   =  0.5d0*(cos((x-r0)*a) + 1.0d0)\n       dy  =  0.5d0*sin((x-r0)*a)*a\n       d2y = -(y - 0.5d0)*a2\n       d3y = -dy*a2\n    end if\n\n  end subroutine cutoff_cos\n"}, {"instruction": "Create a Fortran subroutine named correlation to compute the cross-correlation function between two input arrays. The subroutine takes 6 input parameters and 2 output parameters. The input parameters consist of two integer*8, one double precision, and two arrays of double precision with dimensions nt and nlag. The output parameters are two arrays of double precision with dimension nlag.", "input": "", "output": "subroutine correlation(a,b,nt,lags,nlag,dt,r,cr)\n  !use ieee_arithmetic\n   implicit none\n   integer*8, intent(in) :: nt, nlag\n   double precision, intent(in) :: dt\n   integer*8, intent(in), dimension(nlag) :: lags\n   double precision, intent(in), dimension(nt) :: a,b\n   double precision, intent(out), dimension(nlag) :: r,cr\n   double precision :: aav, bav\n   integer*8 :: i,k,l,cnt\n   \n   do k=1,nlag\n      l=lags(k)\n      cr(k)=0; aav=0; bav=0; cnt=nt-l\n      do i=1,nt-l\n        !if (ieee_is_nan(a(i)) .and. ieee_is_nan(b(i+l)) then\n         if (isnan(a(i)) .or. isnan(b(i+l))) then\n            cnt=cnt-1\n           !continue\n         else\n            cr(k) = cr(k)+a(i)*b(i+l)\n            aav = aav+a(i)\n            bav = bav+b(i+l)\n!           cnt=cnt+1\n         endif\n      enddo\n      r(k)  = l*dt\n      cr(k) = (cr(k)*cnt - aav*bav)/cnt**2\n   enddo\n!  cr = cr/cr(1)\nend subroutine correlation\n"}, {"instruction": "Write a Fortran subroutine named cjday that calculates the Julian day from the given month and day. The subroutine takes 2 input parameters of type integer (month and day) and 1 output parameter of type integer (jday).", "input": "", "output": " subroutine cjday( month, day, jday )\n implicit none\n\n integer, intent(in)    :: month, day\n integer, intent(out)   :: jday\n integer, dimension(12) :: ndays = (/ 31,28,31,30,31,30, &\n                                      31,31,30,31,30,31 /)\n                  jday = day\n  if( month > 1 ) jday = jday + sum( ndays(1:month-1) ) \n\n  end subroutine cjday\n"}, {"instruction": "Write a Fortran subroutine named rz_3 to calculate the 3x3 rotation matrix around the z-axis. The input parameter is a real*8 scalar value, and the output parameter is a real*8 3x3 matrix.", "input": "", "output": "subroutine rz_3(r, psi)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: psi\n  !\n  r(1,1)=cos(psi); r(1,2)=-sin(psi); r(1,3)=0\n  r(2,1)=sin(psi); r(2,2)=cos(psi); r(2,3)=0\n  r(3,1)=0; r(3,2)=0; r(3,3)=1\nend subroutine rz_3\n"}, {"instruction": "Create a Fortran subroutine named \"ry_3\" to calculate the 3x3 rotation matrix about the y-axis based on the input angle. The subroutine should accept 1 input parameter of type real*8 and return 1 output parameter of type real*8.", "input": "", "output": "subroutine ry_3(r,the)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: the\n  !\n  r(1,1)=cos(the); r(1,2)=0.0; r(1,3)=sin(the)\n  r(2,1)=0.0; r(2,2)=1.0; r(2,3)=0.0\n  r(3,1)=-sin(the); r(3,2)=0.0; r(3,3)=cos(the)\nend subroutine ry_3\n"}, {"instruction": "Create a Fortran subroutine named rx_3 that calculates a 3x3 rotation matrix based on the input angle phi. The subroutine takes 1 input parameter of type real*8 and returns a 3x3 matrix of type real*8.", "input": "", "output": "subroutine rx_3(r, phi)\n  implicit none\n  real*8, intent(out) :: r(3,3)\n  real*8, intent(in)  :: phi\n  !\n  r(1,1)=1.0; r(1,2)=0.0; r(1,3)=0.0\n  r(2,1)=0.0; r(2,2)=cos(phi); r(2,3)=-sin(phi)\n  r(3,1)=0.0; r(3,2)=sin(phi); r(3,3)=cos(phi)\nend subroutine rx_3\n"}, {"instruction": "Create a Fortran subroutine named rz_2 to compute a 2x2 complex matrix based on a real*8 input value. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type complex*16.", "input": "", "output": "subroutine rz_2(r, psi)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: psi\n  ! locals\n  complex*16 :: i\n  i = (0,1)\n  r(1,1)=exp(psi/2.*i); r(1,2)=0.0;\n  r(2,1)=0.0;  r(2,2)=exp(-psi/2.*i)\nend subroutine rz_2\n"}, {"instruction": "Create a Fortran subroutine named \"ry_2\" to calculate a 2x2 complex matrix based on the input angle value. The subroutine should take 1 input parameter of type real*8 and 1 output parameter of type complex*16.", "input": "", "output": "subroutine ry_2(r, the)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: the\n  ! \n  r(1,1)=cos(the/2.); r(1,2)=sin(the/2.)\n  r(2,1)=-sin(the/2.); r(2,2)=cos(the/2.)\nend subroutine ry_2\n"}, {"instruction": "Write a Fortran subroutine named rx_2 to compute a 2x2 rotation matrix using the given angle phi. The input parameter is phi of type real*8. The output parameter is r, a 2x2 matrix of type complex*16.", "input": "", "output": "subroutine rx_2(r, phi)\n  implicit none\n  complex*16, intent(out):: r(2,2)\n  real*8, intent(in)     :: phi\n  ! locals\n  complex*16 :: i\n  i = (0,1)\n  r(1,1)=cos(phi/2.);  r(1,2)=sin(phi/2.)*i\n  r(2,1)=sin(phi/2.)*i; r(2,2)=cos(phi/2.)\nend subroutine rx_2\n"}, {"instruction": "Create a Fortran subroutine named angles_zyz2 to calculate three Euler angles (a1, a2, a3) based on a given 3x3 rotation matrix u. The input parameter is a real*8 array u(3,3), and the output parameters are real*8 variables a1, a2, and a3. Ensure that the subroutine generates proper rotations only and computes the Euler angles using the given rotation matrix.", "input": "", "output": "subroutine angles_zyz2(a1,a2,a3,u)\n  ! routine gets rotation matrix u -- (only proper rotations are allowed)\n  ! it returns three euler angles (a1,a2,a3), which generate rotation u by\n  ! u = rz(a3)*ry(a2)*rz(a1)\n  implicit none\n  real*8, intent(out):: a1,a2,a3\n  real*8, intent(in) :: u(3,3)\n  ! locals\n  real*8 :: sy\n  sy = sqrt(u(3,2)**2 + u(3,1)**2)\n  if (sy .gt. 1e-6) then\n    a1 = -atan2( u(3,2),  u(3,1));\n    a2 = -atan2( sy,      u(3,3));\n    a3 = -atan2( u(2,3), -u(1,3));\n else\n    a1 = -atan2(-u(2,1),  u(2,2));\n    a2 = -atan2( sy,      u(3,3));\n    a3 = 0.0;\n  endif\nend subroutine angles_zyz2\n"}, {"instruction": "Create a Fortran subroutine named angles_zyz that computes three Euler angles (a1, a2, a3) based on the given rotation matrix u. The number of input arguments is 1 with the test_data type ['real*8'], and the number of output arguments is 3 with the test_data type ['real*8', 'real*8', 'real*8']. The subroutine should handle proper rotations and generate the rotation matrix u using the Euler angles according to the equation: u = rz(a3)*ry(a2)*rz(a1).", "input": "", "output": "subroutine angles_zyz(a1,a2,a3,u)\n  ! routine gets rotation matrix u -- (only proper rotations are allowed)\n  ! it returns three euler angles (a1,a2,a3), which generate rotation u by\n  ! u = rz(a3)*ry(a2)*rz(a1)\n  implicit none\n  real*8, intent(out):: a1,a2,a3\n  real*8, intent(in) :: u(3,3)\n  ! locals\n  real*8 :: pi, sy\n  pi = acos(-1.0d0)\n  sy = sqrt(u(3,2)**2 +  u(3,1)**2)\n  if (sy .gt. 1e-6) then\n     a1 = pi-atan2( u(3,2), u(3,1))\n     a2 = atan2(sy,      u(3,3))\n     a3 = pi-atan2(u(2,3), -u(1,3))\n  else \n     a1 = pi-atan2(-u(2,1), u(2,2))\n     a2 = atan2(sy,      u(3,3))\n     a3 = pi\n  endif\nend subroutine angles_zyz\n"}, {"instruction": "Create a Fortran subroutine named table1_ to generate a subtraction table for the (i-1)'s row. The subroutine has 3 input parameters of type integer (ma, mb, mc) and 2 output parameters of type integer (n, num). The generated table is populated based on the values of the input parameters, and the size and content of the table vary depending on the combinations of input values.", "input": "", "output": "        subroutine table1_(ma,mb,mc,n,num)\n          ! get the subtration table for the (i-1)'s row.\n          implicit none\n          integer,intent(in)::ma,mb,mc\n          integer,intent(out)::n,num(:,:)\n          num(:,:)=0\n          if (ma/=0.and.mb/=0.and.mc/=0) then\n            n=4\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/0,1,0/)\n            num(:,3)=(/1,-1,1/)\n            num(:,4)=(/1,0,0/)\n          else if (ma/=0.and.mb/=0.and.mc==0) then\n            n=2\n            num(:,1)=(/0,1,0/)\n            num(:,2)=(/1,0,0/)\n          else if (ma/=0.and.mb==0.and.mc/=0) then\n            n=3\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/1,-1,1/)\n            num(:,3)=(/1,0,0/)\n          else if (ma==0.and.mb/=0.and.mc/=0) then\n            n=2\n            num(:,1)=(/0,0,1/)\n            num(:,2)=(/0,1,0/)\n          else if (ma/=0.and.mb==0.and.mc==0) then\n            n=1\n            num(:,1)=(/1,0,0/)\n          else if (ma==0.and.mb/=0.and.mc==0) then\n            n=1\n            num(:,1)=(/0,1,0/)\n          else if (ma==0.and.mb==0.and.mc/=0) then\n            n=1\n            num(:,1)=(/0,0,1/)\n          else\n            write(*,'(\"error: unclassified: ci.ndim_()\")')\n            stop 1\n          end if\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named dday that takes one input parameter of type real and produces four output parameters of type real. The input parameter represents a year, and the subroutine computes the day of the week for January 1st of that year. The output parameters represent the values of c, r, anchor, and dd, which are intermediate values used in the computation.", "input": "", "output": "subroutine dday(yr, c, r, anchor, dd)\n  implicit none\n  real, intent(in)   :: yr  \n  real, intent(out)  :: c, r, dd, anchor\n\n  c = floor(yr / 100)\n  r = mod(c, 4.0)\n  anchor = 5 * mod(r, 7.0) + 2 ! 2? tuesday\n  dd = mod(floor(yr/12) + mod(yr, 12.0) + floor(mod(yr, 12.0) / 4), 7.0) + anchor\n\nend subroutine dday\n"}, {"instruction": "Create a Fortran subroutine named sym_gauss_seidel to solve a symmetric system of linear equations using the Gauss-Seidel method. The subroutine takes 7 input parameters: n (integer), nnz (integer), irows (integer array of dimension nnz), icols (integer array of dimension nnz), vals (real array of kind=8 and dimension nnz), b (real array of kind=8 and dimension n), n_iter (integer). It returns 1 output parameter: x (real array of kind=8 and dimension n).", "input": "", "output": "  subroutine sym_gauss_seidel(irows,icols,vals,b,n,nnz,x, n_iter)\n    integer, intent(in) :: n, nnz\n    integer, intent(in), dimension(nnz) :: irows, icols\n    real(kind=8), intent(in), dimension(nnz) :: vals\n    real(kind=8), intent(in), dimension(n) :: b\n    real(kind=8), intent(out), dimension(n) :: x\n    integer,intent(in) ::  n_iter\n    \n    integer :: i,k\n    real(kind=8) :: diag\n\n    x = 0.0\n    \n    do it=1,n_iter\n\n       ! forward iteration\n       k=1\n       do i=1,n\n          ! calculate x[i]\n          x(i) = b(i)\n          do while (k<=nnz .and. irows(k)==i)\n             j=icols(k) ! column index\n             if (i==j) then\n                diag = vals(k) ! diagonal\n             else\n                x(i) = x(i) - x(j)*vals(k)\n             end if\n             k = k+1\n          end do\n          x(i) = x(i) / diag\n       end do\n\n       ! backward iteration\n       k=nnz\n       do i=n,1,-1\n          ! calculate x[i]\n          x(i) = b(i)\n          do while (k>0 .and. irows(k)==i)\n             j=icols(k) ! column index\n             if (i==j) then\n                diag = vals(k) ! diagonal\n             else\n                x(i) = x(i) - x(j)*vals(k)\n             end if\n             k = k-1\n          end do\n          x(i) = x(i) / diag\n       end do\n\n    end do\n  \n  end subroutine sym_gauss_seidel\n"}, {"instruction": "Create a Fortran subroutine named split_ to split a string using a specified delimiter. The subroutine takes 3 input parameters of types character(len=1), character(len=*), and integer, and 2 output parameters of types character(len=*) and integer. The subroutine splits the input string based on the specified delimiter and returns the list of split strings along with the number of splits.", "input": "", "output": "    subroutine split_ ( tok, str, mlist, list, nlist )\n    implicit none\n    character(len=1), intent(in)  :: tok  ! delimitter\n    character(len=*), intent(in)  :: str  ! string\n    integer,          intent(in)  :: mlist\n    character(len=*), intent(out) :: list(mlist)\n    integer,          intent(out) :: nlist\n\n    integer i, l, n, j\n\n    i = 1\n    l = len_trim(str)\n    nlist = 0\n    do n = 1, mlist\n       j = index(trim(str(i:)),tok) - 1\n       if ( j < 1 ) then\n            nlist = nlist + 1\n            list(nlist) = str(i:)\n            exit\n       end if\n       nlist = nlist + 1\n       list(nlist) = str(i:i+j-1)\n       i = i + j + 1\n       if ( i > l ) then\n            exit\n       endif\n    end do\n\n    end subroutine split_\n"}, {"instruction": "Create a Fortran subroutine named cmp_datestr that compares two date strings in the format \"YYYYMMDDHHMMSS\" and sets the output integer parameter icmp based on the comparison result. The subroutine has 2 input parameters of type character (len=14) and 1 output parameter of type integer.", "input": "", "output": "subroutine cmp_datestr(date1, date2, icmp)\n\n   implicit none\n\n   ! arguments\n   character (len=14), intent(in) :: date1, date2\n   integer, intent(out) :: icmp\n\n   ! local variables\n   integer :: yyyy1, yyyy2\n   integer :: mm1, mm2\n   integer :: dd1, dd2\n   integer :: hh1, hh2\n   integer :: min1, min2\n   integer :: sec1, sec2\n\n   read(date1(1:4), '(i4)') yyyy1\n   read(date1(5:6), '(i2)') mm1\n   read(date1(7:8), '(i2)') dd1\n   read(date1(9:10), '(i2)') hh1\n   read(date1(11:12), '(i2)') min1\n   read(date1(13:14), '(i2)') sec1\n\n   read(date2(1:4), '(i4)') yyyy2\n   read(date2(5:6), '(i2)') mm2\n   read(date2(7:8), '(i2)') dd2\n   read(date2(9:10), '(i2)') hh2\n   read(date2(11:12), '(i2)') min2\n   read(date2(13:14), '(i2)') sec2\n\n   if (yyyy1 > yyyy2) then\n      icmp = 1\n      return\n   else if (yyyy1 < yyyy2) then\n      icmp = -1\n      return\n   end if\n\n   if (mm1 > mm2) then\n      icmp = 1\n      return\n   else if (mm1 < mm2) then\n      icmp = -1\n      return\n   end if\n\n   if (dd1 > dd2) then\n      icmp = 1\n      return\n   else if (dd1 < dd2) then\n      icmp = -1\n      return\n   end if\n\n   if (hh1 > hh2) then\n      icmp = 1\n      return\n   else if (hh1 < hh2) then\n      icmp = -1\n      return\n   end if\n\n   if (min1 > min2) then\n      icmp = 1\n      return\n   else if (min1 < min2) then\n      icmp = -1\n      return\n   end if\n\n   if (sec1 > sec2) then\n      icmp = 1\n      return\n   else if (sec1 < sec2) then\n      icmp = -1\n      return\n   end if\n\n   icmp = 0\n   return\n\nend subroutine cmp_datestr\n"}, {"instruction": "Write a Fortran subroutine named \"create_array\" to generate a 2D array of real(8) numbers based on the input integer \"n\". The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real(8), dimension(n,3)']. The subroutine calculates the sum of the row and column indices and assigns the result to the corresponding elements of the output array.", "input": "", "output": "subroutine create_array(a, n)\n    integer, intent(in) :: n\n    real(8), dimension(n,3), intent(out) :: a\n    do i = 1, n\n        do j = 1, n\n            a(i,j) = i+j\n        enddo\n    enddo\nend subroutine create_array\n"}, {"instruction": "Write a Fortran subroutine named n_tg to calculate the value of n using the provided formula. The subroutine should have 2 input parameters of type real representing t (in keV) and g, and 1 output parameter of type real representing n (in 1/cc). Use the imperative tone in your instructions.", "input": "", "output": "      subroutine n_tg(t, g, n)\n      implicit none        \n        real, intent(in)  :: t  ! kev\n        real, intent(in)  :: g  ! \n        real, intent(out) :: n  ! 1/cc\n        real, parameter   :: coeff=6.1216e-15\n        n=((g/coeff)**2)*(t**3) ! 1/cc\n      end subroutine n_tg\n"}, {"instruction": "Create a Fortran subroutine named n_tze that takes two input parameters of type real, labeled as t and ze, and one output parameter of type real, labeled as n. The subroutine calculates the value of n using the formula n = ze * (t ** 1.5) / coeff, where coeff is a predefined real parameter.", "input": "", "output": "      subroutine n_tze(t, ze, n)\n      implicit none        \n        real, intent(in)  :: t  ! kev\n        real, intent(in)  :: ze ! \n        real, intent(out) :: n  ! 1/cc\n        real, parameter   :: coeff=5.2359e-27\n        n=ze*(t**1.5)/coeff ! 1/cc\n      end subroutine n_tze\n"}, {"instruction": "Write a Fortran subroutine named eigv that calculates stable eigenvalues and eigenvectors based on the input parameters. The subroutine takes 2 input parameters of type integer and double precision, and returns 2 output parameters of type double precision.", "input": "", "output": "      subroutine eigv(ndim,par,v1,v2) \n!     ---------- ---- \n\n      implicit none\n      integer, intent(in) :: ndim\n      double precision, intent(in) :: par(*)\n      double precision, intent(out) :: v1(ndim),v2(ndim)\n      logical, save :: ifirst = .true.\n\n      double precision e,ss\n\n! stable eigenvalue/vector 1\n       v1(1)= 0.\n       v1(2)= 0.\n       v1(3)= 1./2.66667\n\n! stable eigenvalue/vector 2\n       e=-(11+sqrt(1201.d0))/2\n       v2(1)=1+e\n       v2(2)=par(1)\n       v2(3)= 0.\n       ss=sqrt(v2(1)**2+v2(2)**2)\n       v2(1)=v2(1)/(ss*22.8277)\n       v2(2)=v2(2)/(ss*22.8277)\n       if(ifirst)then\n         write(10,*)v2(1),v2(2)\n         ifirst=.false.\n       endif\n\n      end subroutine eigv\n"}, {"instruction": "Create a Fortran subroutine named str_to_int to convert a string to an integer. The subroutine takes 1 input parameter of type character (len=*), and 2 output parameters of type integer.", "input": "", "output": "        subroutine str_to_int(str, int, stat)\n            implicit none\n            ! arguments\n            character (len=*), intent(in) :: str\n            integer, intent(out)          :: int\n            integer, intent(out)          :: stat\n\n            read(str, *, iostat=stat) int\n        end subroutine str_to_int\n"}, {"instruction": "Create a Fortran subroutine named mxv that performs a matrix-vector multiplication. This subroutine takes 4 input parameters of types integer, integer, real*8, and real*8, and 1 output parameter of type real*8. The inputs correspond to the dimensions of the matrix, the matrix itself, and the vector. The output is the resulting vector after the multiplication.", "input": "", "output": "      subroutine mxv(m,n,aa,bb,cc)\n      implicit none\n      integer, intent(in) :: m,n\n      real*8, intent(in) :: aa(m,n),bb(n)\n      real*8, intent(out) :: cc(m)\n\n      integer :: i,j\n\n!$omp parallel default(shared) private(i,j)\n!$omp workshare\n      cc(:)=0\n!$omp end workshare\n\n!array reduction - each thread takes a chunk of j and do array sum (1:m)\n!$omp do reduction(+: cc)\n      do j=1,n\n!        do i=1,m\n        cc(1:m)=cc(1:m)+aa(1:m,j)*bb(j)\n!        enddo !i\n      enddo !j\n!$omp end parallel\n\n      end subroutine mxv\n"}, {"instruction": "Create a Fortran subroutine named split_n_tasks to divide a range of numbers into subranges for parallel processing. The subroutine takes 4 input parameters of type integer: n, iproc, nproc, and an optional llim. It also has 2 output parameters of type integer: lo and hi.\n\nThe subroutine splits the range of numbers represented by n into subranges for parallel tasks. The iproc parameter represents the rank of the current task, nproc is the total number of tasks, and llim is an optional lower limit. The subroutine calculates the lower (lo) and upper (hi) bounds of the subrange that the current task should process based on its rank and the total number of tasks. If llim is provided, it is used as the lower limit; otherwise, the default lower limit is 1.", "input": "", "output": "   subroutine split_n_tasks(n, iproc, nproc, lo, hi, llim)\n\n      implicit none\n\n      integer, intent(in) :: n, iproc, nproc\n      integer, intent(out) :: lo, hi\n      integer, optional, intent(in) :: llim\n\n      integer :: n_div, n_mod, llim_local\n\n      llim_local = 1\n      if (present(llim)) llim_local = llim\n\n      n_div = n / nproc\n      n_mod = mod(n, nproc)\n\n      lo = iproc * n_div + min(iproc, n_mod) + llim_local\n      hi = lo + n_div - 1\n      if (iproc < n_mod) hi = hi + 1\n\n   end subroutine split_n_tasks\n"}, {"instruction": "Create a Fortran subroutine named \"form\" to determine the format for displaying a real number. The subroutine should take 1 input argument of type real and provide 1 output argument of type character with allocatable length.", "input": "", "output": "  subroutine form(r, fmt)\n  implicit none\n  real, intent(in) :: r\n  character(len=:), intent(out), allocatable :: fmt\n  if ((r > 9999999 .or. r < -999999) .or. (abs(r) < 0.01)) then\n    fmt = \"es12.5\"\n  else\n    fmt = \"f12.4\"\n  end if\n  fmt = '('//fmt//')'\n  !99999999.9999\n\n  end subroutine form\n"}, {"instruction": "Create a Fortran subroutine named find_current_time that takes 5 input parameters of type integer (iunit, year, month, day, cbh_binary_flag) and 1 output parameter of type integer (iret). This subroutine reads input data from a file and compares it with the provided date values until a match is found. If the end of the file is reached, it prints an error message. If there is a reading error, it sets iret to the error code.", "input": "", "output": "      subroutine find_current_time(iunit, year, month, day, iret, cbh_binary_flag)\n! argument\n      integer, intent(in) :: iunit, year, month, day, cbh_binary_flag\n      integer, intent(out) :: iret\n! local variables\n      integer :: yr, mo, dy\n!***********************************************************************\n      iret = 0\n      do\n        if ( cbh_binary_flag==0 ) then\n          read ( iunit, *, iostat=iret ) yr, mo, dy\n        else\n          read ( iunit, iostat=iret ) yr, mo, dy\n        endif\n        if ( iret==-1 ) print *, 'error, end-of-file found reading input file for date:', year, month, day\n        if ( iret/=0 ) return\n        if ( yr==year .and. mo==month .and. dy==day ) exit\n      enddo\n      backspace iunit\n      end subroutine find_current_time\n"}, {"instruction": "Write a Fortran subroutine named find_current_file_time to find the current time of a file. The subroutine takes 4 input parameters of type integer (iunit, year, month, day) and returns 3 output parameters of type integer (year_file, month_file, day_file).", "input": "", "output": "      subroutine find_current_file_time(iunit, year, month, day, year_file, month_file, day_file)\n! argument\n      integer, intent(in) :: iunit, year, month, day\n      integer, intent(out) :: year_file, month_file, day_file\n! local variables\n      integer :: i, ios\n!***********************************************************************\n! find first value for simulation time period\n      read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n      if ( ios/=0 ) then\n        year_file = 0\n        month_file = 0\n        day_file = 0\n        return\n      endif\n      if ( year_file<year ) then\n        i = 0\n        do while ( i==0 )\n          read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n          if ( ios/=0 ) then\n            year_file = 0\n            month_file = 0\n            day_file = 0\n            return\n          endif\n          if ( year_file>=year ) i = 1\n        enddo\n      endif\n      if ( year_file==year ) then\n        if ( month_file<month ) then\n          i = 0\n          do while ( i==0 )\n            read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n            if ( ios/=0 ) then\n              year_file = 0\n              month_file = 0\n              day_file = 0\n              return\n            endif\n            if ( month_file>=month ) i = 1\n          enddo\n        endif\n        if ( month_file==month ) then\n          if ( day_file<day ) then\n            i = 0\n            do while ( i==0 )\n              read ( iunit, *, iostat=ios ) year_file, month_file, day_file\n              if ( ios/=0 ) then\n                year_file = 0\n                month_file = 0\n                day_file = 0\n                return\n              endif\n              if ( day_file>=day ) i = 1\n            enddo\n          endif\n        endif\n      endif\n      backspace iunit\n      end subroutine find_current_file_time\n"}, {"instruction": "Create a Fortran subroutine named \"is_eof\" to check whether the end of a file has been reached. The subroutine should take 1 input parameter of type integer and provide 3 output parameters, all of type integer.", "input": "", "output": "      subroutine is_eof(iunit, next_yr, next_mo, next_day)\n      implicit none\n! arguments\n      integer, intent(in) :: iunit\n      integer, intent(out) :: next_yr, next_mo, next_day\n! local variables\n      integer :: ios, i\n      character(len=80) :: dum\n!*******************************************************************************\n      next_yr = 0\n      next_mo = 0\n      next_day = 0\n      i = 0\n      do while ( i==0 )\n        read ( iunit, '(a)', iostat=ios ) dum\n        if ( ios/=0 ) return\n        if ( dum(:2)/='//' ) i = 1\n      enddo\n      read ( dum, *, iostat=ios ) next_yr, next_mo, next_day\n      if ( ios/=0 ) then\n        next_yr = 0\n        next_mo = 0\n        next_day = 0\n      else\n        backspace iunit\n      endif\n      end subroutine is_eof\n"}, {"instruction": "Create a Fortran subroutine named atmosphere to calculate the properties of the 1976 standard atmosphere up to 86 km. The subroutine takes 1 input parameter of type real and returns 3 output parameters of type real to provide the density, pressure, and temperature at a given geometric altitude in kilometers.", "input": "", "output": "       subroutine atmosphere(alt, sigma, delta, theta)\n!   -------------------------------------------------------------------------\n! purpose - compute the properties of the 1976 standard atmosphere to 86 km.\n! author - ralph carmichael, public domain aeronautical software\n! note - if alt > 86, the values returned will not be correct, but they will\n!   not be too far removed from the correct values for density.\n!   the reference document does not use the terms pressure and temperature\n!   above 86 km.\n       implicit none\n!============================================================================\n!     a r g u m e n t s                                                     |\n!============================================================================\n       real,intent(in)::  alt  ! geometric altitude, km.\n       real,intent(out):: sigma! density/sea-level standard density\n       real,intent(out):: delta! pressure/sea-level standard pressure\n       real,intent(out):: theta! temperature/sea-level standard temperature\n!============================================================================\n!     l o c a l   c o n s t a n t s                                         |\n!============================================================================\n       real,parameter:: rearth = 6369.0 ! radius of the earth (km)\n       real,parameter:: gmr = 34.163195 ! gas constant\n       integer,parameter:: ntab=8! number of entries in the defining tables\n!============================================================================\n!     l o c a l   v a r i a b l e s                                         |\n!============================================================================\n       integer:: i,j,k    ! counters\n       real:: h           ! geopotential altitude (km)\n       real:: tgrad, tbase! temperature gradient and base temp of this layer\n       real:: tlocal      ! local temperature\n       real:: deltah      ! height above base of this layer\n!============================================================================\n!     l o c a l   a r r a y s   ( 1 9 7 6   s t d.  a t m o s p h e r e )   |\n!============================================================================\n       real,dimension(ntab),parameter:: htab= (/0.0, 11.0, 20.0, 32.0, 47.0, 51.0, 71.0,84.852/)\n       real,dimension(ntab),parameter:: ttab=  (/288.15, 216.65, 216.65, 228.65, 270.65, 270.65, 214.65, 186.946/)\n       real,dimension(ntab),parameter:: ptab=  (/1.0, 2.233611e-1, &\n5.403295e-2, 8.5666784e-3, 1.0945601e-3, 6.6063531e-4, 3.9046834e-5, 3.68501e-6/)\n       real,dimension(ntab),parameter:: gtab=  (/-6.5, 0.0, 1.0, 2.8, 0.0, -2.8, -2.0, 0.0/)\n!----------------------------------------------------------------------------\n       h=alt*rearth/(alt+rearth)! convert geometric to geopotential altitude\n\n       i=1\n       j=ntab                     ! setting up for=binary search\n       do\n       k=(i+j)/2                                             \n       if (h < htab(k)) then\n        j=k\n       else\n        i=k\n       end if\n       if (j <= i+1) exit\n       end do\n\n       tgrad=gtab(i)              ! i will be in 1...ntab-1\n       tbase=ttab(i)\n       deltah=h-htab(i)\n       tlocal=tbase+tgrad*deltah\n       theta=tlocal/ttab(1)            ! temperature ratio\n\n       if (tgrad == 0.0) then        ! pressure ratio\n         delta=ptab(i)*exp(-gmr*deltah/tbase)\n       else\n         delta=ptab(i)*(tbase/tlocal)**(gmr/tgrad)\n       end if\n\n       sigma=delta/theta            ! density ratio\n       return\n       end subroutine atmosphere \n"}, {"instruction": "Create a Fortran subroutine named acf to calculate the autocorrelation function of molecular dynamics simulation data. The subroutine takes 4 input parameters of type integer, integer, integer, and real(8), and 1 output parameter of type real(8). The input parameters correspond to the number of molecules, the number of time steps, the time step interval for computing the autocorrelation function, and the molecular dynamics simulation data. The output parameter stores the computed autocorrelation function values.", "input": "", "output": "subroutine acf(v_center,molecule,nstep,tau_step,vv_acf)\n    implicit none\n    integer,intent(in) ::molecule,nstep,tau_step\n    real(8),intent(in) ::v_center(molecule,3,nstep)\n    real(8),intent(out) ::vv_acf(tau_step,molecule)\n    integer ::it,it0,it0max,itau\n    real(8)::uacf(0:tau_step,molecule),nacf(0:tau_step,molecule)\n    integer ::i\n    uacf(:,:)=0.d0\n    nacf(:,:)=0.d0\n\n    do i=1,molecule\n        do it0=1,nstep\n            it0max=min(nstep,it0+tau_step)\n            do it=it0,it0max\n                itau=it-it0\n                uacf(itau,i)=uacf(itau,i)+dot_product(v_center(i,:,it0),v_center(i,:,it))\n                nacf(itau,i)=nacf(itau,i)+1d0\n            enddo\n        enddo\n    enddo\n\n    do i=1,molecule\n        do it=0,tau_step\n            vv_acf(it,i)=uacf(it,i)/nacf(it,i)\n        enddo\n    enddo\n    return\nend subroutine acf\n"}, {"instruction": "Create a Fortran subroutine named \"vol\" to calculate the variable \"psi\" based on the input parameters \"invc\" and \"matpar\". The subroutine should have 2 input parameters of type real*8, represented as \"invc(:)\" and \"matpar\", and 1 output parameter of type real*8, represented as \"psi\".", "input": "", "output": "subroutine vol(psi,invc,matpar)\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar\n\treal*8 :: c1,i3, j\n\tc1 = matpar ! kappa\n\n\tj = dsqrt(invc(3)) ! j\n\t\n\tpsi = c1*(j - 1.0d0)**2.0d0\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mooneyrivlin that computes the strain energy function psi based on the input parameters invc and matpar. The number of input arguments is 2 with the test_data type ['real*8 ', 'real*8 '], and the number of output arguments is 1 with the test_data type ['real*8 ']. Use the imperative tone to implement the subroutine.", "input": "", "output": "subroutine mooneyrivlin(psi,invc,matpar)\n !mooney rivlin bathe, k.j., finite element procedures, pp.592; see also 6.4 pp.561\n !crisfield m.a. vol ii, chap 13, pp 62. see also, section 10.3 pp 07 \n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(2)\n\treal*8 :: c1,c2,i1bar,i2bar,j,ri33\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\ti2bar = ri33*ri33*invc(2) ! i2bar\n\tpsi = c1*(i1bar-3.0d0) + c2*(i2bar-3.0d0)\n\treturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named fsub to compute the square of each element in the input array x and store the results in the output array f. The input parameter is an array of real numbers with kind=8 and variable size, while the output parameter is an array of real numbers with kind=8 and the same size as the input array.", "input": "", "output": "subroutine fsub(x,f)\n  ! compute f(x) = x**2 for all elements of the array x. \n  implicit none\n  real(kind=8), dimension(:), intent(in) :: x\n  real(kind=8), dimension(size(x)), intent(out) :: f\n  f = x**2\nend subroutine fsub\n"}, {"instruction": "Create a Fortran subroutine named harmonic_forces to calculate the forces and potential energy in a harmonic potential. The subroutine takes 4 input parameters of type real(8), real(8), real(8), dimension(2), real(8), dimension(2) and produces 3 output parameters of type real(8), dimension(2), real(8), dimension(2), real(8).", "input": "", "output": "subroutine harmonic_forces(k, r_eq, x, y, fx, fy, potential_energy)\n   implicit none\n   real(8), intent(in) :: k, r_eq\n   real(8), dimension(2), intent(in) :: x, y\n   real(8), dimension(2), intent(out) :: fx, fy\n   real(8), intent(out) :: potential_energy\n   real(8) :: r, delta_x, delta_y\n\n   delta_x = x(1) - x(2)\n   delta_y = y(1) - y(2)\n   r = delta_x**2 + delta_y**2\n   r = dsqrt(r)\n\n   fx(1) = - k * delta_x * (r - r_eq) / r\n   fx(2) = - fx(1)\n   fy(1) = - k * delta_y * (r - r_eq) / r\n   fy(2) = - fy(1)\n\n   potential_energy = 0.5d0 * k * (r - r_eq)**2\nend subroutine harmonic_forces\n"}, {"instruction": "Create a Fortran subroutine named identity_encryption that takes a raw password as input and outputs the password and its actual length. The input parameter is a character string with variable length, and the output parameters are two character strings with variable length and an integer, respectively.", "input": "", "output": "subroutine identity_encryption( raw_password, password, actual_length )\n    character(len=*), intent(in)  :: raw_password\n    character(len=*), intent(out) :: password\n    integer, intent(out)          :: actual_length\n\n    actual_length = len(raw_password)\n    password      = raw_password\n\nend subroutine identity_encryption\n"}, {"instruction": "Create a Fortran subroutine named default_encryption to perform a simple encryption technique on a given raw password. The subroutine will take 1 input argument of type character with variable length and provide 2 output arguments; one of type character with variable length and the other of type integer.", "input": "", "output": "subroutine default_encryption( raw_password, password, actual_length )\n    character(len=*), intent(in)  :: raw_password\n    character(len=*), intent(out) :: password\n    integer, intent(out)          :: actual_length\n\n    integer                       :: i\n    integer                       :: ch\n\n    actual_length = len(raw_password)\n    password      = ' '\n\n    !\n    ! use a rot13-like transformation\n    !\n    do i = 1,len(raw_password)\n        ch = iachar(raw_password(i:i))\n\n        if ( ch > 27 ) then\n            if ( ch < 128 ) then\n                ch = 155 - ch\n            else\n                ch = 383 - ch\n            endif\n        endif\n\n        password(i:i) = achar(ch)\n    enddo\nend subroutine default_encryption\n"}, {"instruction": "Write a Fortran subroutine named load_scale_values to read scale values from a file. The subroutine takes 2 input parameters of type ['character(len=*)', 'integer'], and 1 output parameter of type ['real(8)']. The subroutine reads scale values from the specified file based on the number of inputs and stores them in the scale_values array. Use the imperative tone in your instructions.", "input": "", "output": "subroutine load_scale_values(filename, num_inputs, scale_values)\n        character(len=*), intent(in) :: filename\n        integer, intent(in) :: num_inputs\n        real(8), intent(out) :: scale_values(num_inputs, 2)\n        character(len=40) :: row_name\n        integer :: isu, i\n        isu = 2\n        open(isu, file=filename, access=\"sequential\", form=\"formatted\")\n        read(isu, \"(a)\")\n        do i=1, num_inputs\n            read(isu, *) row_name, scale_values(i, 1), scale_values(i, 2)\n        end do\n        close(isu)\n    end subroutine load_scale_values\n"}, {"instruction": "Write a Fortran subroutine named br_newton to solve a nonlinear equation using the Newton-Raphson method. The subroutine takes 1 input parameter of type real(8) and provides 1 output parameter of type real(8).", "input": "", "output": "  subroutine br_newton(rhs,x_s)\n    implicit none\n    real(8),intent(in) :: rhs\n    real(8),intent(out) :: x_s\n    integer iter\n    real(8) :: xmin,xmax,x,fx,dfx\n\n  ! find xmax\n    xmin=0d0\n    x=1d0\n    do\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      if(fx < 0) then\n        xmax=x\n        exit\n      endif\n      x=x*2\n    enddo\n  ! bi-section\n    do\n      x=0.5d0*(xmin+xmax)\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      if(fx < 0) then\n        xmax=x\n      else\n        xmin=x\n      endif\n      if(xmax-xmin < 1d-4) exit\n    enddo\n  ! newton-raphson\n    do iter=1,5\n      fx=x*exp(-2d0/3d0*x)/rhs-(x-2)\n      dfx=(1-2d0/3d0*x)*exp(-2d0/3d0*x)/rhs-1d0\n      x=x-fx/dfx\n    enddo\n    x_s=x\n    return\n  end subroutine br_newton\n"}, {"instruction": "Create a Fortran subroutine named southwellbin to perform a Southwell reconstruction algorithm for wavefront sensing. The subroutine takes 8 input parameters of type integer and real*8, and 3 output parameters of type real*8. The input parameters include arrays for x, y, l, m, the dimensions xdim and ydim, and the binsize. The output parameters are arrays for xang, yang, and phase.\n\nThe subroutine implements parallel processing using OpenMP directives for efficient computation. The algorithm involves binning the input data and accumulating the values based on the bin location. It then normalizes the xang and yang arrays and sets invalid pixels to 100.\n\nOverall, the subroutine performs wavefront sensing reconstruction using the Southwell algorithm and is designed for high-performance parallel processing.", "input": "", "output": "subroutine southwellbin(x,y,l,m,num,binsize,xang,yang,phase,xdim,ydim)\n  !declarations\n  implicit none\n  integer, intent(in) :: num,xdim,ydim\n  real*8, intent(in) :: x(num),y(num),l(num),m(num),binsize\n  real*8, intent(out) :: xang(xdim,ydim),yang(xdim,ydim),phase(xdim,ydim)\n  integer :: i,j,xb,yb,accum(xdim,ydim)\n\n  !accum(:,:) = 0\n  do i=1,xdim\n    do j=1,ydim\n      accum(i,j) = 0\n    end do\n  end do\n\n  !loop through rays\n  !$omp parallel do private(xb,yb)\n  do i=1,num\n    !figure out proper bin\n    if (mod(xdim,2)==0) then\n      xb = floor(x(i)/binsize) + xdim/2 + 1 + 1\n    else\n      xb = floor((x(i)+binsize/2)/binsize) + (xdim-1)/2 + 1\n    end if\n    if (mod(ydim,2)==0) then\n      yb = floor(y(i)/binsize) + ydim/2 + 1 + 1\n    else\n      yb = floor((y(i)+binsize/2)/binsize) + (ydim-1)/2 + 1\n    end if\n    !add l and m to proper array\n    xang(xb,yb) = xang(xb,yb) + l(i)\n    yang(xb,yb) = yang(xb,yb) + m(i)\n    !accumulate total number of rays in wfs bin\n    accum(xb,yb) = accum(xb,yb) + 1\n  end do\n  !$omp end parallel do\n\n  !normalize xang and yang\n  !set invalid pixels to 100.\n  !$omp parallel do\n  do i=1,xdim\n    do j=1,ydim\n      if (accum(i,j)==0) then\n        phase(i,j) = 100.\n        xang(i,j) = 100.\n        yang(i,j) = 100.\n      else\n        xang(i,j) = tan(asin(xang(i,j)/accum(i,j)))\n        yang(i,j) = tan(asin(yang(i,j)/accum(i,j)))\n      end if\n    end do\n  end do\n  !$omp end parallel do\n\nend subroutine southwellbin\n"}, {"instruction": "Create a Fortran subroutine named \"bisectionsimple\" to perform a bisection search on an array. The subroutine takes 3 input parameters of type integer, real, and real, and 2 output parameters of type integer. The input parameters are ntheta, theta, and thetaarray, while the output parameters are ianglow and ianghi. This subroutine performs a binary search on the thetaarray to find the indices ianglow and ianghi that enclose the given value theta.", "input": "", "output": "subroutine bisectionsimple(theta,thetaarray,ntheta,ianglow, ianghi)\n\t\n\t\tinteger,intent(in)::ntheta\n\t\treal,intent(in)::theta,thetaarray(1:ntheta)\n\t\tinteger,intent(out)::ianglow, ianghi\n\t\n\t\tinteger:: iang\n\t\n\n\t\tianglow = 1\n\t\tianghi = ntheta\n\n\t\tdo\n\t\t\tif((ianghi - ianglow) == 1)exit\n\t\t\tiang = (ianghi + ianglow)/2\n\t\t\tif(thetaarray(iang) < theta)then\n\t\t\t\tianglow = iang\n\t\t\telse\n\t\t\t\tianghi = iang\n\t\t\tendif\n\t\tenddo\n\n\t\tif (ianglow < 1) ianglow = 1\n\t\tif (ianghi < 1) ianghi = 1\n\t\tif (ianghi > ntheta) ianghi = ntheta\n\t\tif (ianglow > ntheta) ianglow = ntheta\n\nend subroutine bisectionsimple\n"}, {"instruction": "Create a Fortran subroutine named calch20nablashape to calculate the natural coordinate derivatives of the shape functions. This subroutine takes 3 input parameters of type real (fxi, feta, fzeta) and 1 output parameter of type real (fads).", "input": "", "output": "subroutine calch20nablashape(fxi, feta, fzeta, fads)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fads(60)\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam\n\n! main routine\n\tfxip = (1d0 + fxi)\n\tfetap = (1d0 + feta)\n\tfzetap = (1d0 + fzeta)\n\tfxim = (1d0 - fxi)\n\tfetam = (1d0 - feta)\n\tfzetam = (1d0 - fzeta)\n\n! calculation of natural coordinate derivatives of the shape functions\n! corresponding to fxi\n\tfads(1) = 0.125d0 * fetam * fzetam * (2d0 * fxi + feta + fzeta + 1d0) \n\tfads(2) = 0.125d0 * fetam * fzetam * (2d0 * fxi - feta - fzeta - 1d0) \n\tfads(3) = 0.125d0 * fetap * fzetam * (2d0 * fxi + feta - fzeta - 1d0) \n\tfads(4) = 0.125d0 * fetap * fzetam * (2d0 * fxi - feta + fzeta + 1d0) \n\tfads(5) = 0.125d0 * fetam * fzetap * (2d0 * fxi + feta - fzeta + 1d0) \n\tfads(6) = 0.125d0 * fetam * fzetap * (2d0 * fxi - feta + fzeta - 1d0) \n\tfads(7) = 0.125d0 * fetap * fzetap * (2d0 * fxi + feta + fzeta - 1d0) \n\tfads(8) = 0.125d0 * fetap * fzetap * (2d0 * fxi - feta - fzeta + 1d0) \n\tfads(9) = -0.5d0 * fxi * fetam * fzetam\n\tfads(10) = 0.25d0 * fetam * fetap * fzetam \n\tfads(11) = -0.5d0 * fxi * fetap * fzetam \n\tfads(12) = -0.25d0 * fetam * fetap * fzetam \n\tfads(13) = -0.5d0 * fxi * fetam * fzetap \n\tfads(14) = 0.25d0 * fetam * fetap * fzetap \n\tfads(15) = -0.5d0 * fxi * fetap * fzetap \n\tfads(16) = -0.25d0 * fetam * fetap * fzetap \n\tfads(17) = -0.25d0 * fetam * fzetap * fzetam \n\tfads(18) = 0.25d0 * fetam * fzetap * fzetam\n\tfads(19) = 0.25d0 * fetap * fzetap * fzetam \n\tfads(20) = -0.25d0 * fetap * fzetap * fzetam\n\n! corresponding to feta\n\tfads(21) = 0.125d0 * fxim * fzetam * (fxi + 2d0 * feta + fzeta + 1d0) \n\tfads(22) = 0.125d0 * fxip * fzetam * (-fxi + 2d0 * feta + fzeta + 1d0) \n\tfads(23) = 0.125d0 * fxip * fzetam * (fxi + 2d0 * feta - fzeta - 1d0) \n\tfads(24) = 0.125d0 * fxim * fzetam * (-fxi + 2d0 * feta - fzeta - 1d0) \n\tfads(25) = 0.125d0 * fxim * fzetap * (fxi + 2d0 * feta - fzeta + 1d0) \n\tfads(26) = 0.125d0 * fxip * fzetap * (-fxi + 2d0 * feta - fzeta + 1d0) \n\tfads(27) = 0.125d0 * fxip * fzetap * (fxi + 2d0 * feta + fzeta - 1d0) \n\tfads(28) = 0.125d0 * fxim * fzetap * (-fxi + 2d0 * feta + fzeta - 1d0) \n\tfads(29) = -0.25d0 * fxip * fxim * fzetam\n\tfads(30) = -0.5d0 * fxip * feta * fzetam \n\tfads(31) = 0.25d0 * fxim * fxip * fzetam \n\tfads(32) = -0.5d0 * fxim * feta * fzetam \n\tfads(33) = -0.25d0 * fxip * fxim * fzetap \n\tfads(34) = -0.5d0 * feta * fxip * fzetap \n\tfads(35) = 0.25d0 * fxim * fxip * fzetap \n\tfads(36) = -0.5d0 * fxim * feta * fzetap \n\tfads(37) = -0.25d0 * fxim * fzetap * fzetam \n\tfads(38) = -0.25d0 * fxip * fzetap * fzetam \n\tfads(39) = 0.25d0 * fxip * fzetap * fzetam \n\tfads(40) = 0.25d0 * fxim * fzetap * fzetam\n\n! corresponding to fzeta\n\tfads(41) = 0.125d0 * fxim * fetam * (fxi + feta + 2d0 * fzeta + 1d0) \n\tfads(42) = 0.125d0 * fxip * fetam * (-fxi + feta + 2d0 * fzeta + 1d0) \n\tfads(43) = 0.125d0 * fxip * fetap * (-fxi - feta + 2d0 * fzeta + 1d0) \n\tfads(44) = 0.125d0 * fxim * fetap * (fxi - feta + 2d0 * fzeta + 1d0) \n\tfads(45) = 0.125d0 * fxim * fetam * (-fxi - feta + 2d0 * fzeta - 1d0) \n\tfads(46) = 0.125d0 * fxip * fetam * (fxi - feta + 2d0 * fzeta - 1d0) \n\tfads(47) = 0.125d0 * fxip * fetap * (fxi + feta + 2d0 * fzeta - 1d0) \n\tfads(48) = 0.125d0 * fxim * fetap * (-fxi + feta + 2d0 * fzeta - 1d0) \n\tfads(49) = -0.25d0 * fxip * fxim * fetam \n\tfads(50) = -0.25d0 * fxip * fetap * fetam \n\tfads(51) = -0.25d0 * fxim * fxip * fetap \n\tfads(52) = -0.25d0 * fxim * fetap * fetam\n\tfads(53) = 0.25d0 * fxip * fxim * fetam \n\tfads(54) = 0.25d0 * fxip * fetap * fetam \n\tfads(55) = 0.25d0 * fxim * fxip * fetap \n\tfads(56) = 0.25d0 * fxim * fetam * fetap \n\tfads(57) = -0.5d0 * fxim * fetam * fzeta \n\tfads(58) = -0.5d0 * fxip * fetam * fzeta \n\tfads(59) = -0.5d0 * fxip * fetap * fzeta \n\tfads(60) = -0.5d0 * fxim * fetap * fzeta\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20shape to calculate the 20 shape functions based on the input values fxi, feta, and fzeta, which are real numbers. The output will be stored in the array fas, which is also a real number array of size 20.", "input": "", "output": "subroutine calch20shape(fxi, feta, fzeta, fas)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fas(20)\n\treal, parameter :: fsqc125 = 0.5d0\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam, &\n\t\tfxi2, feta2, fzeta2\n\n! main routine\n\tfxip = (1d0 + fxi) * fsqc125\n\tfetap = (1d0 + feta) * fsqc125\n\tfzetap = (1d0 + fzeta) * fsqc125\n\tfxim = (1d0 - fxi) * fsqc125\n\tfetam = (1d0 - feta) * fsqc125\n\tfzetam = (1d0 - fzeta) * fsqc125\n\tfxi2 = (1d0 - fxi * fxi)\n\tfeta2 = (1d0 - feta * feta)\n\tfzeta2 = (1d0 - fzeta * fzeta)\n\n\tfas(1) = fxim * fetam * fzetam * (-fxi - feta - fzeta - 2d0)\n\tfas(2) = fxip * fetam * fzetam * (fxi - feta - fzeta - 2d0)\n\tfas(3) = fxip * fetap * fzetam * (fxi + feta - fzeta - 2d0)\n\tfas(4) = fxim * fetap * fzetam * (-fxi + feta - fzeta - 2d0)\n\tfas(5) = fxim * fetam * fzetap * (-fxi - feta + fzeta - 2d0)\n\tfas(6) = fxip * fetam * fzetap * (fxi - feta + fzeta - 2d0)\n\tfas(7) = fxip * fetap * fzetap * (fxi + feta + fzeta - 2d0)\n\tfas(8) = fxim * fetap * fzetap * (-fxi + feta + fzeta - 2d0)\n\tfas(9) = fxi2 * fetam * fzetam\n\tfas(10) = feta2 * fxip * fzetam\n\tfas(11) = fxi2 * fetap * fzetam\n\tfas(12) = feta2 * fxim * fzetam\n\tfas(13) = fxi2 * fetam * fzetap\n\tfas(14) = feta2 * fxip * fzetap\n\tfas(15) = fxi2 * fetap * fzetap\n\tfas(16) = feta2 * fxim * fzetap\n\tfas(17) = fzeta2 * fxim * fetam\n\tfas(18) = fzeta2 * fxip * fetam\n\tfas(19) = fzeta2 * fxip * fetap\n\tfas(20) = fzeta2 * fxim * fetap\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"calch20k\" that takes 4 input parameters of type integer, real, real, and real, and 1 output parameter of type real. The subroutine calculates the stiffness matrix based on the input parameters and updates the output parameter with the result.", "input": "", "output": "subroutine calch20k(iint, fae, fab, faweight, fak)\n  !dec$ attributes dllexport::calch20k\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fab(6, 60, iint ** 3), fae(6, 6, iint ** 3)\n\treal, intent(out) :: fak(1830)\n\treal :: faeb(6), fstiff\n\tinteger :: i, j, k, m, ks, ix, iy, iz\n\n! main routine \n! calculate stiffness matrix\n\tm = 0\n\tdo i = 1, 1830\n\t\tfak(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tks = 0\n\t\t\t\tdo i = 1, 60\n\t\t\t\t\tfaeb(1) = fae(1, 1, m) * fab(1, i, m) + fae(1, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(1, 3, m) * fab(3, i, m) + fae(1, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(1, 5, m) * fab(5, i, m) + fae(1, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(2) = fae(2, 1, m) * fab(1, i, m) + fae(2, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(2, 3, m) * fab(3, i, m) + fae(2, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(2, 5, m) * fab(5, i, m) + fae(2, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(3) = fae(3, 1, m) * fab(1, i, m) + fae(3, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(3, 3, m) * fab(3, i, m) + fae(3, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(3, 5, m) * fab(5, i, m) + fae(3, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(4) = fae(4, 1, m) * fab(1, i, m) + fae(4, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(4, 3, m) * fab(3, i, m) + fae(4, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(4, 5, m) * fab(5, i, m) + fae(4, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(5) = fae(5, 1, m) * fab(1, i, m) + fae(5, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(5, 3, m) * fab(3, i, m) + fae(5, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(5, 5, m) * fab(5, i, m) + fae(5, 6, m) * fab(6, i, m)\n\t\t\t\t\tfaeb(6) = fae(6, 1, m) * fab(1, i, m) + fae(6, 2, m) * fab(2, i, m) + &\n\t\t\t\t\t\tfae(6, 3, m) * fab(3, i, m) + fae(6, 4, m) * fab(4, i, m) + &\n\t\t\t\t\t\tfae(6, 5, m) * fab(5, i, m) + fae(6, 6, m) * fab(6, i, m)\n\t\t\t\t\tdo j = i, 60\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tfstiff = fab(1, j, m) * faeb(1) + fab(2, j, m) * faeb(2) + &\n\t\t\t\t\t\t\tfab(3, j, m) * faeb(3) + fab(4, j, m) * faeb(4) + &\n\t\t\t\t\t\t\tfab(5, j, m) * faeb(5) + fab(6, j, m) * faeb(6)\n\t\t\t\t\t\tfak(ks) = fak(ks) + fstiff * faweight(m)\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20strains that takes 3 input parameters of type integer, real array, and real array, and 1 output parameter of type real array. The subroutine calculates strains using matrix multiplication and stores the result in the output parameter.", "input": "", "output": "subroutine calch20strains(iint, fab, fau, fastrains)\n  !dec$ attributes dllexport::calch20strains\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: fab(6, 60, iint ** 3), fau(60)\n\treal, intent(out) :: fastrains(6, iint ** 3)\n\tinteger :: m\n\n! main routine \n\tdo m = 1, iint ** 3\n\t\tfastrains(:, m) = matmul(fab(:, :, m), fau)\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20stresses to calculate the stresses based on the strains and the elasticity matrix. The subroutine takes 3 input parameters of type integer, real, and real, and 1 output parameter of type real.", "input": "", "output": "subroutine calch20stresses(iint, fae, fastrains, fastresses)\n\timplicit none\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: fae(6, 6), fastrains(6, iint ** 3)\n\treal, intent(out) :: fastresses(6, iint ** 3)\n\tinteger :: m\n\n! main routine \n\tdo m = 1, iint ** 3\n\t\tfastresses(:, m) = matmul(fae, fastrains(:, m))\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20forces to calculate forces based on input data. The subroutine takes 4 input parameters of type integer, real, real, and real, and 1 output parameter of type real. The subroutine uses an iterative process to calculate the forces and stiffness matrix.", "input": "", "output": "subroutine calch20forces(iint, fab, faweight, fastresses, faforces)\n  !dec$ attributes dllexport::calch20forces\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fab(6, 60, iint ** 3), fastresses(6, iint ** 3)\n\treal, intent(out) :: faforces(60)\n\tinteger :: m, ix, iy, iz\n\n! main routine \n! calculate stiffness matrix\n\tm = 0\n\tdo ix = 1, 60\n\t\tfaforces(ix) = 0.\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n\t\t\t\tfaforces = faforces + faweight(m) * matmul(transpose(fab(:, :, m)), fastresses(:, m))\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named tv2t that takes two 3D arrays of real numbers, tv and qv, as input and calculates the array t as output. The number of input arguments is 2 and the test_data type is [real, real]. The number of output arguments is 1 and the test_data type is [real]. The subroutine uses the formula t=tv/(1.d0+zvir*qv) to perform the calculation.", "input": "", "output": "    subroutine tv2t (tv,qv,t)\n\n    real,intent(in) :: tv(:,:,:), qv(:,:,:)\n    real,intent(out) :: t(:,:,:)\n\n    t=tv/(1.d0+zvir*qv)\n\n    end subroutine tv2t\n"}, {"instruction": "Create a Fortran subroutine named \"t2tv\" that calculates the virtual temperature (tv) using the input temperature (t) and specific humidity (qv). The input parameters consist of two 3D arrays of real numbers, t(:,:,:) and qv(:,:,:), and the output parameter is a 3D array of real numbers, tv(:,:,:).", "input": "", "output": "    subroutine t2tv (t,qv,tv)\n\n    real,intent(in) :: t(:,:,:), qv(:,:,:)\n    real,intent(out) :: tv(:,:,:)\n\n    tv=t*(1.d0+zvir*qv)\n\n    end subroutine t2tv\n"}, {"instruction": "Write a Fortran subroutine named t2tv_tl to calculate the virtual potential temperature from temperature and water vapor mixing ratio. The subroutine takes 4 input arguments of type real, which are t, qv, t_tl, and qv_tl, and 1 output argument of type real, which is tv_tl.", "input": "", "output": "    subroutine t2tv_tl (t,qv,t_tl,qv_tl,tv_tl)\n\n    real,intent(in) :: t   (:,:,:), qv   (:,:,:)\n    real,intent(in) :: t_tl(:,:,:), qv_tl(:,:,:)\n    real,intent(out) :: tv_tl(:,:,:)\n\n    tv_tl=t_tl*(1.d0+zvir*qv)+zvir*t*qv_tl\n\n    end subroutine t2tv_tl\n"}, {"instruction": "Create a Fortran subroutine named t2tv_ad that takes 3 input parameters of type real (t, qv, tv_ad) and 1 output parameter of type real (t_ad). The subroutine computes the value of t_ad using the formula t_ad = tv_ad / (1.d0 + zvir * qv).", "input": "", "output": "    subroutine t2tv_ad (t,qv,tv_ad,t_ad)\n\n    real,intent(in) :: t    (:,:,:), qv(:,:,:)\n    real,intent(in) :: tv_ad(:,:,:)\n    real,intent(out) :: t_ad(:,:,:)\n\n    t_ad=tv_ad/(1.d0+zvir*qv)\n!   q_ad=tv_tl/(zvir*t)\n\n    end subroutine t2tv_ad\n"}, {"instruction": "Create a Fortran subroutine named fci to perform a financial calculation. The subroutine takes 6 input parameters: two integers (n, nrow), and four real numbers (ret, rf, sav, galfa). It produces 1 output parameter of type real (capinc).", "input": "", "output": "subroutine fci(sav,nrow,galfa,n,ret,rf,capinc)\nimplicit none\ninteger, intent(in) :: n, nrow\nreal, intent(in) :: ret, rf\nreal, intent(in) :: sav(nrow,1), galfa(n,1)\nreal, intent(out) :: capinc(nrow,n)\nreal, allocatable :: rp(:,:), ones(:,:)\ninteger :: ind1, ind2\nallocate (rp(n,1), ones(n,1))\nones=1.0\ndo ind1=1,nrow\n   rp = ret*galfa+rf*(ones-galfa)\n   do ind2=1,n\n      capinc(ind1,ind2) = sav(ind1,1)*rp(ind2,1)\n   end do\nend do\ndeallocate(rp,ones)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named mpi_comm_create to create a new communicator from an existing group of processes. The subroutine should take 1 input argument of type integer and 3 output arguments of type integer. The input argument represents the existing communicator mpi_comm_world, and the output arguments represent the new communicator mpi_comm, the new group mpi_group, and the error status ierr.", "input": "", "output": "subroutine  mpi_comm_create(mpi_comm_world,mpi_group,mpi_comm,ierr)\n  implicit none\n  integer, intent(in) :: mpi_comm_world\n  integer, intent(out) :: mpi_group,mpi_comm,ierr\n  mpi_group=1\n  mpi_comm=1\n  ierr=mpi_comm_world*0\nend subroutine mpi_comm_create\n"}, {"instruction": "Write a Fortran subroutine named \"mpi_comm_get_attr\" that takes two integer input parameters and returns three output parameters. The input parameters are \"comm\" and \"comm_keyval\" of type integer. The output parameters are \"flag\" of type logical, \"attribute_val\" of type integer(kind=8), and \"ierr\" of type integer. The subroutine should calculate the value of \"attribute_val\" as 1, set \"ierr\" as the product of \"comm\" and \"comm_keyval\" multiplied by 0, and set \"flag\" as true if \"comm_keyval\" is equal to 1.", "input": "", "output": "subroutine  mpi_comm_get_attr(comm,comm_keyval,attribute_val,flag,ierr)\n  implicit none\n  integer, intent(in) :: comm, comm_keyval\n  logical, intent(out) :: flag\n  !integer(kind=mpi_address_kind), intent(out) :: attribute_val\n  integer(kind=8), intent(out) :: attribute_val\n  integer, intent(out) :: ierr\n  attribute_val=1\n  ierr=comm*comm_keyval*0\n  flag=(comm_keyval==1)\nend subroutine mpi_comm_get_attr\n"}, {"instruction": "Write a Fortran subroutine named mpi_comm_size that takes an integer input parameter mpi_comm_world and returns two output parameters nproc and ierr, both integers. The subroutine sets nproc to 1 and ierr to the result of mpi_comm_world multiplied by 0.", "input": "", "output": "subroutine  mpi_comm_size(mpi_comm_world,nproc,ierr)\n  implicit none\n  integer, intent(in) :: mpi_comm_world\n  integer, intent(out) :: nproc,ierr\n  nproc=1\n  ierr=mpi_comm_world*0\nend subroutine mpi_comm_size\n"}, {"instruction": "Write a Fortran subroutine named mpi_group_incl that takes 3 input parameters of type integer (group, n, nranks) and 2 output parameters of type integer (newgroup, ierr). The subroutine calculates the size of nranks and assigns it to newgroup, and sets ierr to the product of group and 0.", "input": "", "output": "subroutine  mpi_group_incl(group,n,nranks,newgroup,ierr)\n  implicit none\n  integer, intent(in) :: group,n\n  integer, intent(in) :: nranks(n)\n  integer, intent(out) :: newgroup,ierr\n  newgroup=size(nranks)\n  ierr=group*0\nend subroutine mpi_group_incl\n"}, {"instruction": "Create a Fortran subroutine named mpi_test with one input parameter of type integer and two output parameters of type integer. The input parameter is intent(in) and the output parameters are intent(out). The function sets the flag to 1 plus 0 times the input request and mpi_status to 1.", "input": "", "output": "subroutine mpi_test(request,flag,mpi_status)\n  implicit none\n  integer, intent(in) :: request\n  integer, intent(out) :: flag\n  integer, intent(out) :: mpi_status\n  flag = 1 + 0*request\n  mpi_status = 1\nend subroutine mpi_test\n"}, {"instruction": "Create a Fortran subroutine named mpi_wait that takes an integer input parameter request and returns an integer output parameter mpi_status. The subroutine sets the value of mpi_status to 1 added to 0 multiplied by the value of request.", "input": "", "output": "subroutine mpi_wait(request,mpi_status)\n  implicit none\n  integer, intent(in) :: request\n  integer, intent(out) :: mpi_status\n  mpi_status = 1 + 0*request\nend subroutine mpi_wait\n"}, {"instruction": "Write a Fortran subroutine named cube_mean that takes three real numbers as input and computes their mean after summing them and then multiplying the mean by 3. The number of input arguments is 3 with the test_data type of ['real', 'real', 'real'], and the number of output arguments is 1 with the test_data type of ['real'].", "input": "", "output": "subroutine  cube_mean(x, y, z, r) \n\treal, intent(in) :: x\n\treal, intent(in) :: y\n\treal, intent(in) :: z\n\treal, intent(out) :: r\n\n\tr=x+y+z\n\tr = r / (3)\n\tr = r * (3)\n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named integrate_trapz to perform trapezoidal integration. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The input parameters are f, x, and n, representing the function values, corresponding x-coordinates, and the number of data points, respectively. The output parameter res stores the result of the integration.", "input": "", "output": "subroutine integrate_trapz(res, f, x, n)\n  implicit none\n  real*8,  intent(out) :: res\n  real*8,  intent(in)  :: f(n), x(n)\n  integer, intent(in)  :: n\n  !\n  integer :: i\n  res = f(1)*0.5*(x(2)-x(1)) + f(n)*0.5*(x(n)-x(n-1))\n  do i=2,n-1\n     res = res + f(i)*0.5*(x(i+1)-x(i-1))\n  enddo\nend subroutine integrate_trapz\n"}, {"instruction": "Create a Fortran subroutine named setrotmat that sets up the forward rotation matrix and reverse matrix based on the given azimuth, dip, and tilt angles. The number of input arguments is 3, and their types are ['real(kind=8)', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 2, and their types are ['real(kind=8), dimension(3,3)', 'real(kind=8), dimension(3,3)'].", "input": "", "output": "  subroutine setrotmat(azm,dip,tilt,forwardrotmat,reverserotmat)\r\n!-----------------------------------------------------------------------\r\n!  \r\n!        sets up the forward rotation matrix and reverse matrix\r\n!\r\n! (c) jared deutsch, 2014\r\n!-----------------------------------------------------------------------\r\n  implicit none\r\n  real(kind=8), parameter :: pi = 4*atan(1.0d0)\r\n  real(kind=8), intent(in) :: azm,dip,tilt\r\n  real(kind=8), dimension(3,3) :: azmrotmat,diprotmat,tiltrotmat\r\n  real(kind=8), dimension(3,3), intent(out) :: forwardrotmat,reverserotmat\r\n  real(kind=8) :: angle\r\n\r\n! get the angle to rotate about the z axis in radians\r\n  angle = (90d0-azm)*pi/180d0\r\n! rotation matrix for azimuth correction\r\n  azmrotmat = 0d0\r\n  azmrotmat(3,3) = 1d0\r\n  azmrotmat(1,1) = cos(angle)\r\n  azmrotmat(1,2) = -1d0*sin(angle)\r\n  azmrotmat(2,1) = sin(angle)\r\n  azmrotmat(2,2) = cos(angle)\r\n\r\n! get the angle to rotate about the new x' axis\r\n  angle = -1d0*(dip)*pi/180d0\r\n! rotation matrix for dip correction\r\n  diprotmat = 0d0\r\n  diprotmat(2,2) = 1d0\r\n  diprotmat(1,1) = cos(angle)\r\n  diprotmat(1,3) = sin(angle)\r\n  diprotmat(3,1) = -1d0*sin(angle)\r\n  diprotmat(3,3) = cos(angle)\r\n\r\n! get the angle to rotate about the new y' axis\r\n  angle = -1d0*(tilt)*pi/180d0\r\n! rotation matrix for tilt correction\r\n  tiltrotmat = 0d0\r\n  tiltrotmat(1,1) = 1d0\r\n  tiltrotmat(2,2) = cos(angle)\r\n  tiltrotmat(2,3) = sin(angle)\r\n  tiltrotmat(3,2) = -1d0*sin(angle)\r\n  tiltrotmat(3,3) = cos(angle)\r\n\r\n! complete forward rotation matrix is the product of these 2 matrices\r\n  forwardrotmat = matmul(matmul(azmrotmat,diprotmat),tiltrotmat)\r\n! reverse rotation matrix is the transpose of the forward matrix\r\n! as these matrices are orthogonal\r\n  reverserotmat = transpose(forwardrotmat)\r\n  end subroutine setrotmat\r\n"}, {"instruction": "Create a Fortran subroutine named get_ind to calculate the index of an element in a multi-dimensional array based on its linear index and the size of each dimension. The subroutine takes 3 input parameters of type integer: i (linear index), n (array dimensions), and d (number of dimensions). It also has 1 output parameter of type integer: ind (array of indices).", "input": "", "output": "  subroutine get_ind(i,ind,n,d)\n    integer, intent(in) :: d\n\n    integer, intent(in) :: n(d)\n    integer, intent(out) :: ind(d)\n    integer, intent(in) :: i\n    integer j\n    j = i\n    do k=1,d\n       !print *,'inside get_ind loop,j=',j\n       !print *,'inside get_ind loop,n=',n\n       ind(k) = mod(j-1,n(k))+1\n       j=(j-ind(k))/n(k)+1\n    end do\n   !print *,'get_ind called, i=',i\n   !print *,'get_ind called, d=',d\n   !print *,'get_ind called, ind=',ind\n\n  end subroutine get_ind\n"}, {"instruction": "Create a Fortran subroutine named \"trussquang\" to calculate the value of \"psi\" based on the input parameters \"i4\" and \"matpar\". The input parameters should be of type real*8, and \"i4\" is an input while \"matpar\" is an array of real*8. The output parameter \"psi\" should also be of type real*8.", "input": "", "output": "subroutine trussquang(psi,i4,matpar) ! see javier bonet\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: i4, matpar(:) ! matpar is only the material coeficient, a0 was splitted\n\treal*8 :: e\n\te = matpar(1) !\n\t\t\t\n\tpsi = (e/8.0d0)*(i4-1.0d0)**2.0d0 \n\t\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named mandelbrot_set to calculate the Mandelbrot set. The subroutine takes 4 input parameters of type integer, integer, complex array of dimension(n, n), and another complex array of dimension(n, n). It also has 1 output parameter of type complex array of dimension(n, n). The subroutine uses the imperative tone to iterate through the calculations to generate the Mandelbrot set.", "input": "", "output": "    subroutine mandelbrot_set(z, c, n, n_iter, z_f)\n        implicit none\n        integer, intent(in) :: n, n_iter\n        complex, intent(in), dimension(n, n) :: z, c\n        complex, intent(out), dimension(n, n) :: z_f\n        integer :: i\n        z_f = z\n        do i=1, n_iter\n            z_f = z_f**2 + c\n        end do\n    end subroutine mandelbrot_set\n"}, {"instruction": "Create a Fortran subroutine named d2_trans to transpose a double precision 2D array. The function takes one input parameter of type double precision and produces one output parameter of type double precision. The subroutine transposes the input array and stores the result in the output array.", "input": "", "output": " subroutine d2_trans(a,b)\n  implicit none\n  double precision,intent(in) :: a(:,:)\n  double precision,intent(out):: b(:,:)\n  character(len=*),parameter :: subnam='d2_trans'\n  integer :: i,j, m,n\n  m=size(a,1); n=size(a,2)\n  if(size(b,1).ne.n .or. size(b,2).ne.m)then\n   write(*,*)subnam,': size mismatch: a[',shape(a),'] b[',shape(b),']'\n   stop\n  end if\n  if(m.gt.n)then\n!$omp parallel do shared(a,b)\n   do j=1,n\n    b(j,:)=a(:,j)\n   end do\n!$omp end parallel do\n  else\n!$omp parallel do shared(a,b)\n   do i=1,m\n    b(:,i)=a(i,:)\n   end do\n!$omp end parallel do\n  end if\n  return\n end subroutine\n"}, {"instruction": "Create a Fortran subroutine named extrema_get to obtain extrema information from a module. The subroutine takes 2 input parameters of type integer. It returns 5 output parameters: real arrays of kind=8 with dimensions ndim by npeak and ndim by npeak, a real array of kind=8 with dimension npeak, and two integer arrays, each with dimension npeak. The subroutine copies the extrema information from module variables mod_peaks, mod_eigvect, mod_eigvals, mod_peak_type, and mod_index to the respective output parameters.", "input": "", "output": "  subroutine extrema_get(ndim, npeak, index, peakpos, eigvectors, eigvalues, peaktype)\n    integer, intent(in) :: ndim, npeak\n    real(kind=8), intent(out), dimension(ndim, npeak) :: peakpos\n    real(kind=8), intent(out), dimension(ndim, npeak) :: eigvectors\n    real(kind=8), intent(out), dimension(npeak)       :: eigvalues\n    integer, intent(out), dimension(npeak)        :: peaktype, index\n\n    peakpos    = mod_peaks\n    eigvectors = mod_eigvect\n    eigvalues  = mod_eigvals\n    peaktype   = mod_peak_type\n    index      = mod_index\n\n  end subroutine extrema_get\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_jacobian\" to compute the Jacobian in advective form based on the Arakawa method. The subroutine should have 6 input parameters of type integer, integer, real, real, real arrays, and a real 2D array, and 1 output parameter of a real 2D array.", "input": "", "output": "subroutine arakawa_jacobian(im, jm, dx, dy, a_bc, b_bc, jacobian)\n\n! computes jacobian j(a,b) in advective form\n! see arakawa (1966) j. comp. phys. vol 1, 119-143\n! ** note: input fields must be \"framed\" with boundary conds.\n!          jacobian computed in internal points only.\n\nimplicit none\n\ninteger, intent(in)                           :: im, jm\nreal,    intent(in)                           :: dx, dy\nreal,    intent(in), dimension(0:im+1,0:jm+1) :: a_bc,b_bc\n\nreal, intent(out), dimension(im,jm) :: jacobian\n\n! local variables:\ninteger :: i,j\nreal, dimension(im,jm) :: p1,p2,p3,p4,p5,p6,p7,p8\nreal, dimension(im,jm) :: q1,q2,q3,q4,q5,q6,q7,q8\n\n!   6 --- 2 --- 5\n!   |     |     |\n!   |     |     |\n!   3 --- 0 --- 1\n!   |     |     |\n!   |     |     |\n!   7 --- 4 --- 8\n\ni= 1 ; j= 0 ; p1 = a_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j= 1 ; p2 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 0 ; p3 = a_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j=-1 ; p4 = a_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j= 1 ; p5 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 1 ; p6 = a_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j=-1 ; p7 = a_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j=-1 ; p8 = a_bc(1+i:im+i,1+j:jm+j)\n\ni= 1 ; j= 0 ; q1 = b_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j= 1 ; q2 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 0 ; q3 = b_bc(1+i:im+i,1+j:jm+j)\ni= 0 ; j=-1 ; q4 = b_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j= 1 ; q5 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j= 1 ; q6 = b_bc(1+i:im+i,1+j:jm+j)\ni=-1 ; j=-1 ; q7 = b_bc(1+i:im+i,1+j:jm+j)\ni= 1 ; j=-1 ; q8 = b_bc(1+i:im+i,1+j:jm+j)\n\njacobian = (p1-p3)*(q2-q4) - (p2-p4)*(q1-q3)  +                & ! j++\n           q2*(p5-p6) - q4*(p8-p7) - q1*(p5-p8) + q3*(p6-p7) + & ! jx+\n           p1*(q5-q8) - p3*(q6-q7) - p2*(q5-q6) + p4*(q8-q7)     ! j+x\n\njacobian = jacobian/12./dx/dy\n\nend subroutine arakawa_jacobian\n"}, {"instruction": "Create a Fortran subroutine named v2vcosphii that takes in 4 input parameters: two integers (jm and km), and two arrays of real numbers of dimensions jm by km (cosphi and v). It outputs a single array of real numbers of dimensions 0 to jm by km (vcosphii). The subroutine interpolates the product of v and cosphi onto cell boundaries and assigns the result to vcosphii.", "input": "", "output": "subroutine v2vcosphii(jm, km, cosphi, v, vcosphii)\n\n! \nimplicit none\n\n! in\ninteger, intent(in)                 :: jm,km\nreal, intent(in),  dimension(jm,km) :: cosphi,v\n\n! out\nreal, intent(out), dimension(0:jm,km) :: vcosphii\n\n! local\ninteger :: j\n\n! interpolate vcosphi onto cell boundaries \nvcosphii=0.\ndo j=1,jm-1\n  vcosphii(j,:) = ( v(j,:)*cosphi(j,:) + v(j+1,:)*cosphi(j+1,:) )/2.\nenddo\n\nend subroutine v2vcosphii\n"}, {"instruction": "Write a Fortran subroutine named vcosphii2wi that calculates the vertical velocity component 'wi' based on the input parameters. The subroutine takes 7 input parameters of types integer, real, and real arrays of various dimensions, and returns 1 output parameter of type real array.", "input": "", "output": "subroutine vcosphii2wi(jm, km, a, dphi, dp, cosphi, vcosphii, wi)\n\n! \nimplicit none\n\n! in\ninteger, intent(in)                  :: jm,km\nreal, intent(in)                     :: a,dphi,dp\nreal, intent(in), dimension(jm,km)   :: cosphi\nreal, intent(in), dimension(0:jm,km) :: vcosphii\n\n! out\nreal, intent(out), dimension(jm,0:km) :: wi\n\n! local\ninteger :: j,k\nreal :: rdy\nreal, dimension(jm,km)      :: vcosphi_y\n\nrdy=1./dphi/a\n\n! integrate continuity eqn from top down to get w\nvcosphi_y = ( vcosphii(1:jm,:) - vcosphii(0:jm-1,:) )/cosphi*rdy\nwi=0.\ndo k=1,km-1\n  wi(:,k) = wi(:,k-1) - vcosphi_y(:,k)*dp   \nenddo\n\nend subroutine vcosphii2wi\n"}, {"instruction": "Create a Fortran subroutine named \"setfemtype\" to determine the finite element type based on the given femtype input parameter. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer. The output parameters are nodg, porder, ngp, isimplex, and ibubble. The main purpose of this subroutine is to set the values of these 5 parameters based on the input femtype.", "input": "", "output": "\tsubroutine setfemtype(femtype,nodg,porder,ngp,isimplex,ibubble)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg,porder,ngp,isimplex,ibubble\n\t\t\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tngp = 4\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(3) !! quadratic triangle with 3 gauss points\n\t\t\t\tngp = 3\n\t\t\t\tnodg = 6\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\n\t\t\tcase(4) !! quadratic quadrangle with 9 gauss points\n\t\t\t\tngp = 16\n\t\t\t\tnodg = 9\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\t\n\n\t\t\tcase(5) !! linear line with 1 gauss points\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 2\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(6) !! linear tetrahedra\n\t\t\t\tngp = 4 !! just 1 or 3\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(7) !! point\n\t\t\t\tngp = 1 !! just 1 or 3\n\t\t\t\tnodg = 1\n\t\t\t\tporder = 0\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase(8) !! quadratic line with 2 gauss points\n\t\t\t\tngp = 2\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 2\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\t\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\t\t\n\tend subroutine \n"}, {"instruction": "Subroutine ohc_merid_adv is a Fortran subroutine that calculates the meridional advection at a specific latitude. The subroutine takes 7 input parameters of types integer and real arrays and produces 3 output parameters of type real arrays.\n\nThe input parameters include imin, imax, lat, dxt, temp, vvel, and dzt. The output parameters are adv, adv_i, and adv_k. The adv parameter stores the meridional advection at each grid point, adv_i stores the zonal-integrated meridional advection, and adv_k stores the depth-integrated meridional advection.\n\nThe subroutine calculates the meridional advection based on the temperature, vertical velocity, and grid information using nested do-loops and array operations.\n\nEnsure that the input and output parameters are correctly assigned before and after calling the subroutine ohc_merid_adv.", "input": "", "output": "subroutine ohc_merid_adv(imin,imax,lat,temp,vvel,dzt,dxt,adv,adv_k,adv_i)\n! merdional advection at latitude lat\n! northward flux through northern face of t-cell(i,lat)\n! adv       in [j/m^2/s]\n! adv_k/i   in [j/m/s]\n\ninteger                                         :: i,k\ninteger,                            intent(in)  :: imin,imax,lat\ninteger, parameter                              :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt),        intent(in)  :: dxt\nreal,    dimension(imt,jmt,km),     intent(in)  :: temp, vvel, dzt\nreal,    dimension(imax-imin+1,km), intent(out) :: adv\nreal,    dimension(km),             intent(out) :: adv_i ! zonal-int\nreal,    dimension(imax-imin+1),    intent(out) :: adv_k ! depth-int\nreal,    parameter                              :: rho0=4.1/3.996*1000, c=3996.0\n\ndo k=1,km\n  do i=imin,imax\n    adv(i-imin+1,k) = (temp(i,lat+1,k)-temp(i,lat,k))                          &\n                    * (vvel(i-1,lat,k)+vvel(i,lat,k))/2                        &  \n                    * rho0 * c\n  enddo !i\nenddo !k\n\nadv_k(:) = 0.0\ndo k=1,km\n  adv_k(:) = adv_k(:) +  adv(:,k)*dzt(imin:imax,lat,k)\nenddo !k\n\nadv_i(:) = 0.0\ndo i=imin,imax\n  adv_i(:) = adv_i(:) + adv(i-imin+1,:)*dxt(i,lat)\nenddo !i\n\nend subroutine ohc_merid_adv\n"}, {"instruction": "Write a Fortran subroutine named io_error_message to handle error messages. It takes 2 input parameters of type character(*) and integer, and 1 output parameter of type character(*).", "input": "", "output": "  subroutine io_error_message(routine,ierr,str)\n\n    !use mpi\n\n    implicit none\n\n    character(*),intent(in) :: routine\n    integer,intent(in) :: ierr\n    character(*),intent(out) :: str\n\n    !select case(ierr)\n    !case(mpi_err_io)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_io'\n    !case(mpi_err_no_space)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_no_space'\n    !case(mpi_err_no_such_file)\n    !   write(str,'(a)') 'problem with ' // trim(routine) // ': mpi_err_no_such_file'\n    !case default\n    write(str,'(a,i6)') 'problem with ' // trim(routine) // ': ierr=',ierr\n    !end select\n\n  end subroutine io_error_message\n"}, {"instruction": "Create a Fortran subroutine named foo2 that takes an integer input and returns a character string of length equal to the input integer. The number of input parameters is 1, and the test_data type is ['integer']. The number of output parameters is 1, and the test_data type is ['character(len=*)'].", "input": "", "output": "subroutine foo2(s, n)\n  character(len=*), intent(out) :: s\n  integer, intent(in) :: n\n  !f2py character(f2py_len=n), depend(n) :: s\n  s = \"123456789a123456789b\"(1:n)\nend subroutine foo2\n"}, {"instruction": "Write a Fortran subroutine named \"ff\" to define the nonlinear term. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and 1 output parameter of type double precision.", "input": "", "output": "      subroutine ff(ne,u,par,f) \n!     ---------- -- \n!     define the nonlinear term\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(in) :: u(ne),par(*)\n      double precision, intent(out) :: f(ne)\n\n      double precision x,y,a,b\n\n        x=u(1)\n        y=u(2)\n        a=par(1)\n        b=par(2)\n\n        f(1)= x**2*y - (b+1)*x + a\n        f(2)=-x**2*y + b*x\n\n      end subroutine ff\n"}, {"instruction": "Create a Fortran subroutine named setdc. This subroutine sets the diffusion constants based on the input parameters. It takes 2 input parameters of type integer and double precision, and 1 output parameter of type double precision.", "input": "", "output": "      subroutine setdc(ne,dc,par) \n!     ---------- ----- \n!     set the diffusion constants (constant, or in terms of par)\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(out) :: dc(ne)\n      double precision, intent(in) :: par(*)\n\n        dc(1)=par(3)/par(5)**2\n        dc(2)=par(4)/par(5)**2\n\n      end subroutine setdc\n"}, {"instruction": "Create a Fortran subroutine named setbc which sets the boundary values to be fixed in time. The subroutine takes 2 input parameters of type integer and double precision, and 2 output parameters of type double precision.", "input": "", "output": "      subroutine setbc(ne,par,u0,u1) \n!     ---------- ----- \n! set the boundary values (to be kept fixed in time)\n\n      implicit none\n      integer, intent(in) :: ne\n      double precision, intent(in) :: par(*)\n      double precision, intent(out) :: u0(ne),u1(ne)\n\n      double precision a,b\n\n        a=par(1)\n        b=par(2)\n\n        u0(1)=a\n        u0(2)=b/a\n        u1(1)=a\n        u1(2)=b/a\n\n\n      end subroutine setbc\n"}, {"instruction": "Create a Fortran subroutine named solve_leqs to solve a system of linear equations represented by a matrix. The subroutine takes 2 input parameters: an integer n and a real(kind(1d0)),dimension(n,n) array 'a'. It produces 2 output parameters: a real(kind(1d0)),dimension(n) array 'sol' and a logical 'triv'.", "input": "", "output": "  subroutine solve_leqs(n,a,sol,triv)\n    ! solve the linear equations ax=0\n    ! return a minimal solution,i.e.,in x the number of nonzero element is samllest but not 0\n    implicit none\n    integer,intent(in)::n\n    real(kind(1d0)),dimension(n,n),intent(in)::a\n    real(kind(1d0)),dimension(n,n)::b\n    integer,dimension(n)::iexchange\n    integer::i,j,inow,k,iswap,izero\n    real(kind(1d0)),parameter::eps=1d-10\n    real(kind(1d0)),dimension(n),intent(out)::sol\n    real(kind(1d0)),dimension(n)::row,coloum\n    real(kind(1d0))::maxv,temp\n    logical,intent(out)::triv\n    logical::allzero\n    ! make matrix a to be upper triangular\n    b(1:n,1:n)=a(1:n,1:n)\n    maxv=maxval(abs(b(1:n,1:n)))\n    if(maxv.lt.eps)then\n       ! a trivial solution\n       sol(1)=1d0\n       sol(2:n)=0d0\n       triv=.false.\n       return\n    endif\n    do i=1,n\n       iexchange(i)=i\n    enddo\n    inow=1\n    izero=0\n    do i=1,n\n       allzero=.true.\n       do j=inow,n\n          if(abs(b(j,inow))/maxv.gt.eps)then\n             allzero=.false.\n             if(j.ne.inow)then\n                row(1:n)=b(inow,1:n)\n                b(inow,1:n)=b(j,1:n)\n                b(j,1:n)=row(1:n)\n             endif\n             exit\n          endif\n       enddo\n       if(.not.allzero)then\n          do j=inow+1,n\n             if(inow+1.le.n)then\n                b(j,inow+1:n)=b(j,inow+1:n)-b(inow,inow+1:n)*b(j,inow)/b(inow,inow)\n             endif\n             b(j,inow)=0d0\n          enddo\n          inow=inow+1\n       else\n          ! the coloum is zero, put it to the end\n          coloum(1:n)=b(1:n,inow)\n          izero=izero+1\n          iswap=iexchange(n)\n          iexchange(n)=iexchange(inow)\n          do j=inow+1,n\n             b(1:n,j-1)=b(1:n,j)\n             if(j.ne.n)then\n                iexchange(j-1)=iexchange(j)\n             else\n                iexchange(j-1)=iswap\n             endif\n          enddo\n          b(1:n,n)=coloum(1:n)\n       endif\n!       print *,i\n!       do j=1,n\n!          write(*,*)b(j,1:n)\n!       enddo\n    enddo\n!    do i=1,n\n!       write(*,*)b(i,1:n)\n!    enddo\n!    write(*,*)\"================\"\n    if(izero.gt.0)then\n       sol(iexchange(n))=1d0\n       do inow=1,n-1\n          i=n-inow\n          if(abs(b(i,i))/maxv.lt.eps)then\n             sol(iexchange(i))=0d0\n          else\n             temp=0d0\n             do j=i+1,n\n                temp=temp-b(i,j)*sol(iexchange(j))\n             enddo\n             sol(iexchange(i))=temp/b(i,i)\n          endif\n       enddo\n       triv=.false.\n    else\n       sol(1:n)=0d0\n       triv=.true.\n    endif\n    return\n  end subroutine solve_leqs\n"}, {"instruction": "Write a Fortran subroutine named solve_cleqs to solve a system of complex linear equations of the form ax=0 and return a minimal solution. The subroutine takes 2 input parameters: an integer n and a complex array a of dimension (n, n). It also has 2 output parameters: a complex array sol of dimension (n) and a logical triv.\n", "input": "", "output": "  subroutine solve_cleqs(n,a,sol,triv)\n    ! solve the complex linear equations ax=0\n    ! return a minimal solution,i.e.,in x the number of nonzero element is samllest but not 0\n    implicit none\n    integer,intent(in)::n\n    complex(kind(1d0)),dimension(n,n),intent(in)::a\n    complex(kind(1d0)),dimension(n,n)::b\n    integer,dimension(n)::iexchange\n    integer::i,j,inow,k,iswap,izero\n    real(kind(1d0)),parameter::eps=1d-10\n    complex(kind(1d0)),dimension(n),intent(out)::sol\n    complex(kind(1d0)),dimension(n)::row,coloum\n    real(kind(1d0))::maxv\n    complex(kind(1d0))::temp\n    logical,intent(out)::triv\n    logical::allzero\n    ! make matrix a to be upper triangular\n    b(1:n,1:n)=a(1:n,1:n)\n    maxv=maxval(abs(b(1:n,1:n)))\n    if(maxv.lt.eps)then\n       ! a trivial solution\n       sol(1)=dcmplx(1d0)\n       sol(2:n)=dcmplx(0d0)\n       triv=.false.\n       return\n    endif\n    do i=1,n\n       iexchange(i)=i\n    enddo\n    inow=1\n    izero=0\n    do i=1,n\n       allzero=.true.\n       do j=inow,n\n          if(abs(b(j,inow))/maxv.gt.eps)then\n             allzero=.false.\n             if(j.ne.inow)then\n                row(1:n)=b(inow,1:n)\n                b(inow,1:n)=b(j,1:n)\n                b(j,1:n)=row(1:n)\n             endif\n             exit\n          endif\n       enddo\n       if(.not.allzero)then\n          do j=inow+1,n\n             if(inow+1.le.n)then\n                b(j,inow+1:n)=b(j,inow+1:n)-b(inow,inow+1:n)*b(j,inow)/b(inow,inow)\n             endif\n             b(j,inow)=0d0\n          enddo\n          inow=inow+1\n       else\n          ! the coloum is zero, put it to the end\n          coloum(1:n)=b(1:n,inow)\n          izero=izero+1\n          iswap=iexchange(n)\n          iexchange(n)=iexchange(inow)\n          do j=inow+1,n\n             b(1:n,j-1)=b(1:n,j)\n             if(j.ne.n)then\n                iexchange(j-1)=iexchange(j)\n             else\n                iexchange(j-1)=iswap\n             endif\n          enddo\n          b(1:n,n)=coloum(1:n)\n       endif\n    enddo\n    if(izero.gt.0)then\n       sol(iexchange(n))=dcmplx(1d0)\n       do inow=1,n-1\n          i=n-inow\n          if(abs(b(i,i))/maxv.lt.eps)then\n             sol(iexchange(i))=dcmplx(0d0)\n          else\n             temp=dcmplx(0d0)\n             do j=i+1,n\n                temp=temp-b(i,j)*sol(iexchange(j))\n             enddo\n             sol(iexchange(i))=temp/b(i,i)\n          endif\n       enddo\n       triv=.false.\n    else\n       sol(1:n)=dcmplx(0d0)\n       triv=.true.\n    endif\n    return\n  end subroutine solve_cleqs\n"}, {"instruction": "Create a Fortran subroutine named getl1ptr which takes in an input parameter of type logical, dimension(:), pointer and returns an output parameter of type integer(kind=8).", "input": "", "output": "     subroutine getl1ptr(array,iadd)\n       implicit none\n       logical, dimension(:), pointer, intent(in) :: array\n       integer(kind=8), intent(out) :: iadd\n     end subroutine getl1ptr\n"}, {"instruction": "Write a Fortran subroutine named sszipfmt that takes a character string 'fmt' as input and produces a modified format string 'fmt1' as output. The input parameter 'fmt' has the test_data type ['character(*)'], and the output parameter 'fmt1' has the test_data type ['character(*)']. Use the imperative tone in the instructions.", "input": "", "output": "  pure subroutine sszipfmt(fmt, fmt1)\n    ! set fmt1 to '(ss,'//removeblanks(fmt)//')'. caller is responsible that\n    ! fmt1 has sufficient length.\n    character(*), intent(in) :: fmt\n    character(*), intent(out) :: fmt1\n    integer i,j\n    fmt1 = '(ss,'\n    j = 5\n    do i = 1,len(fmt)\n      if (fmt(i:i) /= ' ') then\n        fmt1(j:j) = fmt(i:i)\n        j = j+1\n      endif\n    enddo\n    fmt1(j:j) = ')'\n  end subroutine sszipfmt\n"}, {"instruction": "Create a Fortran subroutine named gen_pat that generates a sparsity pattern from row storage. It takes 3 input parameters of type integer, named order, rp, and ci, and 1 output parameter of type logical named pattern. The subroutine should be called using the imperative tone.", "input": "", "output": "      subroutine gen_pat( order, pattern, rp, ci )\n!----------------------------------------------------------------\n!\t... generate sparsity pattern from row storage\n!----------------------------------------------------------------\n\n      implicit none\n!----------------------------------------------------------------\n!\t... dummy args\n!----------------------------------------------------------------\n      integer, intent(in) :: order\n      integer, intent(in) :: rp(order+1)\n      integer, intent(in) :: ci(*)\n      logical, intent(out) :: pattern(order,order)\n\n!----------------------------------------------------------------\n!\t... local variables\n!----------------------------------------------------------------\n      integer :: i, row\n\n      pattern = .false.\n      do i = 1,order\n\t do row = rp(i),rp(i+1)-1\n\t    pattern(i,ci(row)) = .true.\n\t end do\n      end do\n\n      end subroutine gen_pat\n"}, {"instruction": "Create a Fortran subroutine named \"znot_m_v1\" to calculate the roughness scale for momentum based on the reference level wind. The subroutine takes 1 input parameter of type real and produces 1 output parameter of type real.", "input": "", "output": "  subroutine znot_m_v1(uref,znotm)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znotm(meter):   roughness scale for momentum\n! author      :  biju thomas on 02/07/2014\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm\n    real             :: bs0, bs1, bs2, bs3, bs4, bs5, bs6\n    real             :: cf0, cf1, cf2, cf3, cf4, cf5, cf6\n\n\n    bs0 = -8.367276172397277e-12\n    bs1 = 1.7398510865876079e-09\n    bs2 = -1.331896578363359e-07\n    bs3 = 4.507055294438727e-06\n    bs4 = -6.508676881906914e-05\n    bs5 = 0.00044745137674732834\n    bs6 = -0.0010745704660847233\n\n    cf0 = 2.1151080765239772e-13\n    cf1 = -3.2260663894433345e-11\n    cf2 = -3.329705958751961e-10\n    cf3 = 1.7648562021709124e-07\n    cf4 = 7.107636825694182e-06\n    cf5 = -0.0013914681964973246\n    cf6 = 0.0406766967657759\n\n\n    if ( uref .le. 5.0 ) then\n      znotm = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    elseif (uref .gt. 5.0 .and. uref .lt. 10.0) then\n      znotm =.00000235*(uref**2 - 25 ) + 3.805129199617346e-05\n    elseif ( uref .ge. 10.0  .and. uref .lt. 60.0) then\n      znotm = bs6 + bs5*uref + bs4*uref**2 + bs3*uref**3 + bs2*uref**4 +  &\n              bs1*uref**5 + bs0*uref**6\n    else\n      znotm = cf6 + cf5*uref + cf4*uref**2 + cf3*uref**3 + cf2*uref**4 +  &\n              cf1*uref**5 + cf0*uref**6\n\n    end if\n\n  end subroutine znot_m_v1\n"}, {"instruction": "Create a Fortran subroutine named znot_m_v0 to calculate the roughness scale for momentum based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_m_v0(uref,znotm)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znotm(meter):   roughness scale for momentum\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm \n    real             :: yz, y1, y2, y3, y4\n\n    yz =  0.0001344\n    y1 =  3.015e-05\n    y2 =  1.517e-06\n    y3 = -3.567e-08\n    y4 =  2.046e-10\n\n    if ( uref .lt. 12.5 ) then\n       znotm  = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    else if ( uref .ge. 12.5 .and. uref .lt. 30.0 ) then\n       znotm = (0.0739793 * uref -0.58)/1000.0\n    else\n       znotm = yz + uref*y1 + uref**2*y2 + uref**3*y3 + uref**4*y4\n    end if\n\n  end subroutine znot_m_v0\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v1 to calculate the roughness scale for temperature/moisture based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_t_v1(uref,znott)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znott(meter):   roughness scale for temperature/moisture\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znott\n    real             :: to0, to1, to2, to3\n    real             :: tr0, tr1, tr2, tr3\n    real             :: tn0, tn1, tn2, tn3, tn4, tn5\n    real             :: ta0, ta1, ta2, ta3, ta4, ta5, ta6\n    real             :: tt0, tt1, tt2, tt3, tt4, tt5, tt6, tt7\n\n\n    tr0 = 6.451939325286488e-08\n    tr1 = -7.306388137342143e-07\n    tr2 = -1.3709065148333262e-05\n    tr3 = 0.00019109962089098182\n\n    to0 = 1.4379320027061375e-08\n    to1 = -2.0674525898850674e-07\n    to2 = -6.8950970846611e-06\n    to3 = 0.00012199648268521026\n\n    tn0 = 1.4023940955902878e-10\n    tn1 = -1.4752557214976321e-08\n    tn2 = 5.90998487691812e-07\n    tn3 = -1.0920804077770066e-05\n    tn4 = 8.898205876940546e-05\n    tn5 = -0.00021123340439418298\n\n    tt0 = 1.92409564131838e-12\n    tt1 = -5.765467086754962e-10\n    tt2 = 7.276979099726975e-08\n    tt3 = -5.002261599293387e-06\n    tt4 = 0.00020220445539973736\n    tt5 = -0.0048088230565883\n    tt6 = 0.0623468551971189\n    tt7 = -0.34019193746967424\n\n    ta0 = -1.7787470700719361e-10\n    ta1 = 4.4691736529848764e-08\n    ta2 = -3.0261975348463414e-06\n    ta3 = -0.00011680322286017206\n    ta4 = 0.024449377821884846\n    ta5 = -1.1228628619105638\n    ta6 = 17.358026773905973\n\n    if ( uref .le. 7.0 ) then\n      znott = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    elseif ( uref  .ge. 7.0 .and. uref .lt. 12.5 ) then\n      znott =  tr3 + tr2*uref + tr1*uref**2 + tr0*uref**3\n    elseif ( uref  .ge. 12.5 .and. uref .lt. 15.0 ) then\n      znott =  to3 + to2*uref + to1*uref**2 + to0*uref**3\n    elseif ( uref .ge. 15.0  .and. uref .lt. 30.0) then\n      znott =  tn5 + tn4*uref + tn3*uref**2 + tn2*uref**3 + tn1*uref**4 +   &\n                                                       tn0*uref**5\n    elseif ( uref .ge. 30.0  .and. uref .lt. 60.0) then\n      znott = tt7 + tt6*uref + tt5*uref**2  + tt4*uref**3 + tt3*uref**4 +   &\n             tt2*uref**5 + tt1*uref**6 + tt0*uref**7\n    else\n      znott =  ta6 + ta5*uref + ta4*uref**2  + ta3*uref**3 + ta2*uref**4 +  &\n              ta1*uref**5 + ta0*uref**6\n    end if\n\n  end subroutine znot_t_v1\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v0 to calculate the roughness scale for temperature/moisture based on the reference level wind speed. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real.", "input": "", "output": "  subroutine znot_t_v0(uref,znott)\n  implicit none\n\n! uref(m/s)   :   reference level wind\n! znott(meter):   roughness scale for temperature/moisture\n! author      :  biju thomas on 02/07/2014\n\n    real, intent(in) :: uref\n    real, intent(out):: znott \n\n    if ( uref .lt. 7.0 ) then\n       znott = (0.0185 / 9.8*(7.59e-4*uref**2+2.46e-2*uref)**2)\n    else\n       znott = (0.2375*exp(-0.5250*uref) + 0.0025*exp(-0.0211*uref))*0.01\n    end if\n\n  end subroutine znot_t_v0\n"}, {"instruction": "Create a Fortran subroutine named \"znot_t_v2\" to calculate the value of \"znott\" based on the input \"uu\". The input parameter is a real number, and the output parameter is also a real number. The subroutine uses coefficients to compute \"znott\" based on the value of \"uu\". The computation involves conditional statements to assign the appropriate value to \"znott\" based on the range of \"uu\". Make sure to incorporate the provided coefficients and ensure the correct handling of different ranges of \"uu\".", "input": "", "output": "  subroutine znot_t_v2(uu,znott)\n  implicit none\n\n! uu in mks\n! znott in m\n! biju thomas on 02/12/2015\n!\n\n    real, intent(in) :: uu\n    real, intent(out):: znott\n    real             :: ta0, ta1, ta2, ta3, ta4, ta5, ta6\n    real             :: tb0, tb1, tb2, tb3, tb4, tb5, tb6\n    real             :: tt0, tt1, tt2, tt3, tt4, tt5, tt6\n\n    ta0 = 2.51715926619e-09\n    ta1 = -1.66917514012e-07\n    ta2 = 4.57345863551e-06\n    ta3 = -6.64883696932e-05\n    ta4 = 0.00054390175125\n    ta5 = -0.00239645231325\n    ta6 = 0.00453024927761\n\n\n    tb0 = -1.72935914649e-14\n    tb1 = 2.50587455802e-12\n    tb2 = -7.90109676541e-11\n    tb3 = -4.40976353607e-09\n    tb4 = 3.68968179733e-07\n    tb5 = -9.43728336756e-06\n    tb6 = 8.90731312383e-05\n\n    tt0 = 4.68042680888e-14\n    tt1 = -1.98125754931e-11\n    tt2 = 3.41357133496e-09\n    tt3 = -3.05130605309e-07\n    tt4 = 1.48243563819e-05\n    tt5 = -0.000367207751936\n    tt6 = 0.00357204479347\n\n    if ( uu .le. 7.0 ) then\n       znott = (0.0185 / 9.8*(7.59e-4*uu**2+2.46e-2*uu)**2)\n    elseif ( uu  .ge. 7.0 .and. uu .lt. 15. ) then\n       znott = ta6 + ta5*uu + ta4*uu**2  + ta3*uu**3 + ta2*uu**4 +     &\n               ta1*uu**5 + ta0*uu**6\n    elseif ( uu .ge. 15.0  .and. uu .lt. 60.0) then\n       znott = tb6 + tb5*uu + tb4*uu**2 + tb3*uu**3 + tb2*uu**4 +      & \n               tb1*uu**5 + tb0*uu**6\n    else\n       znott = tt6 + tt5*uu + tt4*uu**2  + tt3*uu**3 + tt2*uu**4 +    &\n               tt1*uu**5 + tt0*uu**6\n    end if\n\n  end subroutine znot_t_v2\n"}, {"instruction": "Create a Fortran subroutine named znot_m_v6 to calculate the aerodynamical roughness over water with the input of 10-m wind speed. The number of input parameters is 1 with the test_data type ['real'], and the number of output parameters is 1 with the test_data type ['real'].", "input": "", "output": "  subroutine znot_m_v6(uref,znotm)\n  implicit none\n! calculate areodynamical roughness over water with input 10-m wind\n! for low-to-moderate winds, try to match the cd-u10 relationship from coare v3.5 (edson et al. 2013)\n! for high winds, try to fit available observational data\n!\n! bin liu, noaa/ncep/emc 2017\n! \n! uref(m/s)   :   wind speed at 10-m height\n! znotm(meter):   areodynamical roughness scale over water\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znotm\n    real             :: p13, p12, p11, p10\n    real             :: p25, p24, p23, p22, p21, p20\n    real             :: p35, p34, p33, p32, p31, p30\n    real             :: p40\n\n    p13 = -1.296521881682694e-02\n    p12 =  2.855780863283819e-01\n    p11 = -1.597898515251717e+00\n    p10 = -8.396975715683501e+00\n\n    p25 =  3.790846746036765e-10\n    p24 =  3.281964357650687e-09\n    p23 =  1.962282433562894e-07\n    p22 = -1.240239171056262e-06\n    p21 =  1.739759082358234e-07\n    p20 =  2.147264020369413e-05\n\n    p35 =  1.840430200185075e-07\n    p34 = -2.793849676757154e-05\n    p33 =  1.735308193700643e-03\n    p32 = -6.139315534216305e-02\n    p31 =  1.255457892775006e+00\n    p30 = -1.663993561652530e+01\n\n    p40 =  4.579369142033410e-04\n\n    if (uref >= 0.0 .and.  uref <= 6.5 ) then\n      znotm = exp( p10 + p11*uref + p12*uref**2 + p13*uref**3)\n    elseif (uref > 6.5 .and. uref <= 15.7) then\n      znotm = p25*uref**5 + p24*uref**4 + p23*uref**3 + p22*uref**2 + p21*uref + p20\n    elseif (uref > 15.7 .and. uref <= 53.0) then\n      znotm = exp( p35*uref**5 + p34*uref**4 + p33*uref**3 + p32*uref**2 + p31*uref + p30 )\n    elseif ( uref > 53.0) then\n      znotm = p40\n    else\n      print*, 'wrong input uref value:',uref\n    endif\n\n  end subroutine znot_m_v6\n"}, {"instruction": "Create a Fortran subroutine named znot_t_v6 to calculate the scalar roughness over water with the input of 10-meter wind speed. The subroutine accepts 1 input parameter of type real and outputs 1 parameter of type real.", "input": "", "output": "  subroutine znot_t_v6(uref,znott)\n  implicit none\n! calculate scalar roughness over water with input 10-m wind\n! for low-to-moderate winds, try to match the ck-u10 relationship from coare algorithm\n! for high winds, try to retain the ck-u10 relationship of fy2015 hwrf\n!\n! bin liu, noaa/ncep/emc 2017\n!\n! uref(m/s)   :   wind speed at 10-m height\n! znott(meter):   scalar roughness scale over water\n!\n\n    real, intent(in) :: uref\n    real, intent(out):: znott\n\n    real             :: p00\n    real             :: p15, p14, p13, p12, p11, p10\n    real             :: p25, p24, p23, p22, p21, p20\n    real             :: p35, p34, p33, p32, p31, p30\n    real             :: p45, p44, p43, p42, p41, p40\n    real             :: p56, p55, p54, p53, p52, p51, p50\n    real             :: p60\n\n    p00 =  1.100000000000000e-04\n\n    p15 = -9.144581627678278e-10\n    p14 =  7.020346616456421e-08\n    p13 = -2.155602086883837e-06\n    p12 =  3.333848806567684e-05\n    p11 = -2.628501274963990e-04\n    p10 =  8.634221567969181e-04\n\n    p25 = -8.654513012535990e-12\n    p24 =  1.232380050058077e-09\n    p23 = -6.837922749505057e-08\n    p22 =  1.871407733439947e-06\n    p21 = -2.552246987137160e-05\n    p20 =  1.428968311457630e-04\n\n    p35 =  3.207515102100162e-12\n    p34 = -2.945761895342535e-10\n    p33 =  8.788972147364181e-09\n    p32 = -3.814457439412957e-08\n    p31 = -2.448983648874671e-06\n    p30 =  3.436721779020359e-05\n\n    p45 = -3.530687797132211e-11\n    p44 =  3.939867958963747e-09\n    p43 = -1.227668406985956e-08\n    p42 = -1.367469811838390e-05\n    p41 =  5.988240863928883e-04\n    p40 = -7.746288511324971e-03\n\n    p56 = -1.187982453329086e-13\n    p55 =  4.801984186231693e-11\n    p54 = -8.049200462388188e-09\n    p53 =  7.169872601310186e-07\n    p52 = -3.581694433758150e-05\n    p51 =  9.503919224192534e-04\n    p50 = -1.036679430885215e-02\n\n    p60 =  4.751256171799112e-05\n\n    if (uref >= 0.0 .and. uref < 5.9 ) then\n      znott = p00\n    elseif (uref >= 5.9 .and. uref <= 15.4) then\n      znott = p15*uref**5 + p14*uref**4 + p13*uref**3 + p12*uref**2 + p11*uref + p10\n    elseif (uref > 15.4 .and. uref <= 21.6) then\n      znott = p25*uref**5 + p24*uref**4 + p23*uref**3 + p22*uref**2 + p21*uref + p20\n    elseif (uref > 21.6 .and. uref <= 42.2) then\n      znott = p35*uref**5 + p34*uref**4 + p33*uref**3 + p32*uref**2 + p31*uref + p30\n    elseif ( uref > 42.2 .and. uref <= 53.3) then\n      znott = p45*uref**5 + p44*uref**4 + p43*uref**3 + p42*uref**2 + p41*uref + p40\n    elseif ( uref > 53.3 .and. uref <= 80.0) then\n      znott = p56*uref**6 + p55*uref**5 + p54*uref**4 + p53*uref**3 + p52*uref**2 + p51*uref + p50\n    elseif ( uref > 80.0) then\n      znott = p60\n    else\n      print*, 'wrong input uref value:',uref\n    endif\n\n  end subroutine znot_t_v6\n"}, {"instruction": "Create a Fortran subroutine named get_sat_info to extract information from an observation name. The subroutine takes 1 input parameter of type character(len=*), and returns 4 output parameters of type integer, integer, integer, and integer (optional). The subroutine uses the imperative tone to retrieve the platform, satellite ID, sensor ID, and channel index from the input observation name.", "input": "", "output": "subroutine get_sat_info(ob_name,platform_id,satellite_id,sensor_id,ichan)\n\n   implicit none\n\n   character(len=*),  intent(in)  :: ob_name\n   integer,           intent(out) :: platform_id, satellite_id, sensor_id\n   integer, optional, intent(out) :: ichan\n   character(len=5)               :: platform, sensor\n   integer                        :: strlen, dashloc1, dashloc2, dashloc3\n\n   strlen = len_trim(ob_name)\n\n   ! retrieve platform name\n   dashloc1 = index(ob_name,\"-\")\n   platform = ob_name(1:dashloc1-1)\n   select case (platform)\n   case ('noaa')\n      platform_id = 1\n   case ('eos')\n      platform_id = 9\n   case ('dmsp')\n      platform_id = 2\n   case ('metop')\n      platform_id = 10\n   case default\n      write(0,*)' unrecognized platform ',platform\n      stop\n   end select\n\n   ! retrieve satellite id\n   dashloc2 = index(ob_name(dashloc1+1:strlen),\"-\")\n   read(ob_name(dashloc1+1:dashloc1+dashloc2-1),'(i3)') satellite_id\n\n   ! retrieve sensor name\n   if ( present(ichan) ) then\n      dashloc3 = index(ob_name,\"-\",.true.)\n      sensor = ob_name(dashloc1+dashloc2+1:dashloc3-1)\n   else\n      sensor = ob_name(dashloc1+dashloc2+1:)\n   end if\n   select case (sensor)\n   case ('amsua')\n      sensor_id = 3\n   case ('amsub')\n      sensor_id = 4\n   case ('mhs')\n      sensor_id = 15\n   case ('airs')\n      sensor_id = 11\n   case ('ssmis')\n      sensor_id = 10\n   case default\n      write(0,*)' unrecognized sensor ',sensor\n      stop\n   end select\n\n   if ( present(ichan) ) then\n      ! retrieve channel index\n      read(ob_name(dashloc3+1:),'(i4)') ichan\n   end if\n\nend subroutine get_sat_info\n"}, {"instruction": "Create a Fortran subroutine named findmaxinarray to find the maximum sum of consecutive elements in a real(8) array. The subroutine takes 1 input parameter of type real(8) array and returns 3 output parameters of type integer(4), integer(4), and real(8).", "input": "", "output": "     subroutine findmaxinarray(a, ans, up, down)\n     implicit none\n     \n     real(8), intent(in), dimension(:) :: a\n     integer(4), intent(out) :: up, down\n     real(8), intent(out) :: ans\n     real(8) :: cur, sum, min_sum\n     integer(4) :: min_pos, i\n\n     ans = a(1)\n     up = 1\n     down = 1\n     sum = 0d0\n     min_sum = 0d0\n     min_pos = 0\n\n     do i = 1, size(a)\n               \n          sum = sum + a(i)\n          cur = sum - min_sum\n                    \n          if (cur .gt. ans) then\n               \n               ans = cur\n               up = min_pos + 1\n               down = i\n                \n          endif\n         \n          if (sum .lt. min_sum) then\n                    \n               min_sum = sum\n               min_pos = i\n                    \n          endif\n\n     enddo\n\n     end subroutine findmaxinarray\n"}, {"instruction": "Create a Fortran subroutine named get_counts_2d to calculate the number of points in each cell of a 2D grid. The subroutine takes 6 input parameters of types integer, integer, integer, real, real, real, and returns 1 output parameter of type real.", "input": "", "output": "subroutine get_counts_2d(x, y, dx, length, length_of_grid, length_of_points, counts)\n    ! gets the density and average parameter in a cell.\n    !\n    ! parameters\n    ! ----------\n    ! x, y : array\n    !    the positions of points.\n    ! dx : float\n    !    the size of each cell in each axis.\n    ! length : int\n    !    the length along a single axis of the grid.\n    ! length_of_points : int\n    !    length of the x and y coordinates.\n    ! length_of_grid : int\n    !    length of the x and y grid.\n    !\n    ! returns\n    ! -------\n    ! counts : array\n    !    the number of points in each cell.\n\n    implicit none\n\n    integer, intent(in) :: length, length_of_points, length_of_grid\n    real, intent(in) :: x(length_of_points), y(length_of_points), dx\n    real, intent(out) :: counts(length_of_grid)\n\n    integer :: i, x_index, y_index, index\n\n    do i = 1, length_of_grid\n        counts(i) = 0.\n    end do\n\n\n    do i = 1, length_of_points\n        x_index = floor(x(i) / dx)\n        y_index = floor(y(i) / dx)\n        if (x_index .eq. length) then\n            x_index = x_index - 1\n        end if\n        if (y_index .eq. length) then\n            y_index = y_index - 1\n        end if\n        index = length * x_index + y_index + 1\n        counts(index) = counts(index) + 1.\n    end do\n\nend subroutine get_counts_2d\n"}, {"instruction": "Write a Fortran subroutine named \"emc\" that calculates the equilibrium moisture content (EMC) based on temperature and relative humidity. The subroutine takes two input parameters, \"tempfh\" of type real and \"rh\" of type real, representing the temperature in Fahrenheit and relative humidity in percentage, respectively. It also has one output parameter, \"remc\" of type real, which stores the calculated EMC value.\n\nInside the subroutine, the EMC is calculated based on different conditions. If the relative humidity is less than 10%, the EMC is computed using the formula remc = 0.03229 + 0.281073 * rh - 0.000578 * tempfh * rh. If the relative humidity is between 10% and 50%, the EMC is calculated with the formula remc = 2.22749 + 0.160107 * rh - 0.014784 * tempfh. And if the relative humidity is greater than 50%, the EMC is determined using the formula remc = 21.0606 + 0.005565 * rh^2 - 0.00035 * rh * tempfh - 0.483199 * rh.\n\nEnsure that the subroutine is declared using the \"subroutine\" keyword and specify the input and output parameters accordingly.", "input": "", "output": "subroutine emc(tempfh, rh, remc)\n    real, intent(in)  :: tempfh  !< temperature [fahrenheit]\n    real, intent(in)  :: rh      !< relative humidity [%]\n    real, intent(out) :: remc\n\n  if ( rh .lt. 10) then\n     remc=0.03229+0.281073*rh-0.000578*tempfh*rh\n  else if ( rh .lt. 50) then\n     remc=2.22749+0.160107*rh-0.014784*tempfh\n  else\n     remc=21.0606+0.005565*rh**2-0.00035*rh*tempfh-0.483199*rh\n  endif\nend subroutine emc\n"}, {"instruction": "Create a Fortran subroutine named \"kwet\" that computes the \"rkwet\" factor based on the given moisture content and increment values. The subroutine takes two input parameters, both of type real, namely \"mc1000\" and \"increment\". It also has one output parameter, of type real, named \"rkwet\". \n\nThe purpose of this subroutine is to calculate the \"rkwet\" factor, which depends on the slow evolving moisture content. If the \"mc1000\" value is greater than 25, the \"rkwet\" factor is set to 1.0. If the \"mc1000\" value is between 10 and 25, the \"rkwet\" factor is calculated using the formula (0.0333 * mc1000 + 0.1675). If the \"mc1000\" value is less than or equal to 10, the \"rkwet\" factor is set to 0.5.\n\nAfter calculating the \"rkwet\" factor based on the \"mc1000\" value, the subroutine checks if the increment in moisture content is negative. If it is, the \"rkwet\" factor is overwritten and set to 1.0.\n\nThis subroutine follows the features of Fortran, where input parameters are declared as \"intent(in)\" and output parameters are declared as \"intent(out)\".", "input": "", "output": "subroutine kwet(mc1000,increment,rkwet)\n\n  real, intent(in)    :: mc1000,increment\n  real, intent(out) :: rkwet\n\n ! the kwet factor just depends on the slow evolving moisture content\n  !\n\n if (mc1000 .gt. 25 )then\n    rkwet=1.0\n else if (mc1000 .gt. 10)then\n    rkwet=(0.0333*mc1000 +0.1675)\n else\n    rkwet=0.5\n end if\n !overwrite the above if the increment in moisture content is negative\n\n if (increment  .le.  0) rkwet=1.0\nend subroutine kwet\n"}, {"instruction": "Write a Fortran subroutine named \"fermi\" that computes the Fermi function for a given set of input values. The number of input arguments is 2, where the first argument is an array of real numbers with precision of 8 bytes and intent \"in\", and the second argument is an integer indicating the number of elements in the array. The number of output arguments is 1, which is an array of real numbers with precision of 8 bytes and intent \"out\". The subroutine calculates the Fermi function for each element in the input array using the formula 1/(exp(x)+1) and stores the results in the output array. Use a do loop to iterate over each element in the arrays.", "input": "", "output": "subroutine fermi(y, x, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  integer,intent(in)  :: n\n  do i=1,n\n     y(i) = 1.d0/(exp(x(i))+1.d0)\n  end do\nend subroutine fermi\n"}, {"instruction": "Write a Fortran subroutine named gauss that calculates the Gaussian distribution for an array of input values. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The input parameters are 'x', 's', and 'n', representing an array of values, the standard deviation, and the size of the array, respectively. The output parameter is 'y', which is an array of the same size as 'x' and stores the calculated Gaussian distribution values. The subroutine uses the Gaussian distribution formula to compute the values and stores them in the 'y' array.", "input": "", "output": "subroutine gauss(y, x, s, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  real*8, intent(in)  :: s\n  integer,intent(in)  :: n\n  !\n  real*8, parameter :: sr2pi = 2.506628274631d0\n  do i=1,n\n     y(i) = 1.d0/(s*sr2pi)*exp(-x(i)*x(i)/(2.d0*s*s))\n  enddo\nend subroutine gauss\n"}, {"instruction": "Create a Fortran subroutine called cfermi to calculate the Fermi function for a given set of input values. The subroutine takes in two input parameters, an array of 8-byte real numbers called x, and an integer n which represents the size of the array. It also has an output parameter, an array of 8-byte real numbers called y. The subroutine uses an iterative loop to perform the Fermi function calculation for each element in the input array. If an element in the input array is greater than 10, the corresponding element in the output array is set to 0. If an element in the input array is less than -10, the corresponding element in the output array is set to 1. For all other elements, the corresponding element in the output array is calculated using the equation 1 / (exp(x) + 1).", "input": "", "output": "subroutine cfermi(y, x, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  integer,intent(in)  :: n\n  do i=1,n\n     if (x(i)>10.) then\n        y(i) = 0.d0\n     else if (x(i) < -10.d0) then\n        y(i) = 1.d0\n     else\n        y(i) = 1.d0/(exp(x(i))+1.d0)\n     endif\n  end do\nend subroutine cfermi\n"}, {"instruction": "Create a Fortran subroutine named cgauss that calculates the Gaussian function values for the given set of input values. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 1 output parameter of type real*8. The subroutine computes the Gaussian function values based on the input parameters and stores the results in the output parameter array.", "input": "", "output": "subroutine cgauss(y, x, s, n)\n  real*8, intent(out) :: y(n)\n  real*8, intent(in)  :: x(n)\n  real*8, intent(in)  :: s\n  integer,intent(in)  :: n\n  !\n  real*8, parameter :: sr2pi = 2.506628274631\n  do i=1,n\n     if ( abs(x(i))>10.d0*s) then\n        y(i) = 0.d0\n     else\n        y(i) = 1.d0/(s*sr2pi)*exp(-x(i)*x(i)/(2*s*s))\n     endif\n  end do\nend subroutine cgauss\n"}, {"instruction": "Create a Fortran subroutine named fr_convolution to compute the convolution of given input arrays. The subroutine takes 6 input parameters of types integer, integer, real*8, real*8, real*8, and complex*16, and returns 1 output parameter of type complex*16.", "input": "", "output": "subroutine fr_convolution(res, iom, enk, mwm, omega, womeg, nom)\n  !  we are computing  \n  !       sigma(iom) = -1/beta \\sum_{iom} mwm[iom]/(iom-eps+iom)\n  !   because mwm[-iom]=mwm[iom] and at t=0, we can rewrite\n  !       sigma(iom) = 1/pi integrate[ mwm[om]*(eps-iom)/((eps-iom)^2 + om^2) , {om,0,infinity} ]\n  !   finally, we notice that\n  !                         integrate[ 1/((eps-iom)^2 + om^2) , {om,0,infinity} ] = pi*sign(eps)/(2*(eps-iom))\n  !   therefore\n  !       sigma(iom) = (eps-iom)/pi integrate[ (mwm[om]-mwm[iom])/((eps-iom)^2 + om^2) , {om,0,infinity} ] + mwm[iom] * sign(eps)/2\n  !\n  complex*16, intent(out) :: res\n  integer,    intent(in)  :: iom, nom\n  real*8,     intent(in)  :: enk\n  real*8,     intent(in)  :: omega(nom), womeg(nom)\n  complex*16, intent(in)  :: mwm(nom)\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  complex*16 :: eps_om, eps_om2, sc0\n  integer    :: i\n  \n  eps_om = cmplx(enk, -omega(iom), 8)\n  eps_om2 = eps_om * eps_om\n  sc0 = 0.d0\n  do i=1,nom\n     if (i==iom) cycle\n     sc0 = sc0 + (mwm(i)-mwm(iom)) * womeg(i) / (omega(i)**2 + eps_om2)\n  enddo\n  res = eps_om*sc0/pi\n  if (abs(mwm(iom))>1e-16) then\n     res = res + mwm(iom)/pi * atan(omega(nom)/eps_om) !0.5d0*pi*sign(1.d0, enk)\n  endif\nend subroutine fr_convolution\n"}, {"instruction": "Create a Fortran subroutine named set_indexing to calculate the starting and ending indices for both the southern and northern hemispheres based on the given input parameters. The subroutine takes 5 input parameters of type integer: nlpf, jsg, jeg, js, je. It also returns 4 output parameters of type integer: jss, jes, jsn, jen. The subroutine should be designed to adjust the end index for zero length, and to calculate the southern and northern hemisphere indices based on the input parameters provided.", "input": "", "output": " subroutine set_indexing (nlpf, jsg, jeg, js, je, jss, jes, jsn, jen)\n\n   integer, intent(in)  :: nlpf, jsg, jeg, js,  je\n   integer, intent(out) ::       jss, jes, jsn, jen\n\n   integer :: nlpf_s, nlpf_n\n\n!  note: nlpf_s = jes-jss+1\n!        nlpf_n = jen-jsn+1\n\n!     ----- starting/ending local indices -----\n!     ----- adjust end index for zero length ----\n\n!     --- southern hemisphere ---\n\n      jss    = max (jsg, js)\n      jes    = min (jsg+nlpf-1, je)\n      nlpf_s = max (0, jes - jss + 1)\n      jes    = jss + nlpf_s - 1\n\n!     --- northern hemisphere ---\n\n      jsn    = max (jeg-nlpf+1, js)\n      jen    = min (jeg, je)\n      nlpf_n = max (0, jen - jsn + 1)\n      jen    = jsn + nlpf_n - 1\n\n end subroutine set_indexing\n"}, {"instruction": "Write a Fortran subroutine named set_zonal_balance that calculates the zonal balance for a given set of 2D arrays. The subroutine takes 3 input parameters of type integer: nlev, pelist2d(:,:), nlpf2d(:,:). It also has 1 output parameter of type integer: nlpf(0:).", "input": "", "output": " subroutine set_zonal_balance (nlev, pelist2d, nlpf2d, nlpf)\n  integer, intent(in)  :: nlev, pelist2d(:,:), nlpf2d(:,:)\n  integer, intent(out) :: nlpf(0:)\n\n  integer, dimension(size(nlpf2d,1)) :: nlpf2d_zonal\n  integer :: i, j, remain\n\n! the returned value is the number of zonal rows on each processor\n! initialize this value to zero\n    nlpf = 0\n\n    do j=1,size(nlpf2d,2)\n!      skip pe rows with no filter rows\n       if (nlpf2d(1,j) == 0) cycle\n\n       nlpf2d_zonal(:) = (nlpf2d(1,j)*nlev)/size(nlpf2d,1)\n       remain = nlpf2d(1,j)*nlev - sum(nlpf2d_zonal(:))\n       do i=1,size(nlpf2d,1)\n         if (remain == 0) exit\n         nlpf2d_zonal(i) = nlpf2d_zonal(i) + 1\n         remain = remain - 1\n       enddo\n\n!      return 1-dimensinal structure\n       do i=1,size(nlpf2d,1)\n         nlpf(pelist2d(i,j)) = nlpf2d_zonal(i)\n       enddo\n    enddo\n\n end subroutine set_zonal_balance\n"}, {"instruction": "Create a Fortran subroutine named p_density to calculate the density matrix from the optimized coefficients. The subroutine takes 3 input parameters of type integer, integer, and real*8, dimension(kf,kf) and 1 output parameter of type real*8, dimension(kf,kf).", "input": "", "output": "        subroutine p_density(kf,ne,c,p)\n            ! ----------------------------------------------------------\n            ! compute the density matrix from the optimized coefficients\n            ! ----------------------------------------------------------\n            !\n            ! source:\n            !   szabo and ostlund\n            !   modern quantum chemistry\n            !   doever\n            !   1989\n            !\n            ! -----------------------------------------------------------\n\n            implicit none\n\n            ! input\n            integer, intent(in) :: kf                           ! number of basis functions\n            integer, intent(in) :: ne                           ! number of electrons\n            real*8, dimension(kf,kf), intent(in) :: c           ! coefficients matrix\n\n            ! intermediate variables\n            integer :: i, j, k                                  ! loop coefficients\n\n            ! output\n            real*8, dimension(kf,kf), intent(out) :: p          ! density matrix\n\n            p(:,:) = 0.0d0\n\n            do i = 1, kf\n                do j = 1, kf\n                    do k = 1, ne / 2 ! todo only in rhf\n                        p(i,j) = p(i,j) + 2.0d0 * c(i,k) * c(j,k)\n                    end do\n                end do\n            end do\n\n        end subroutine p_density\n"}, {"instruction": "Create a Fortran subroutine named partition_task to partition a 2D domain for parallel processing. The subroutine takes 3 input arguments of type integer: nprocs, m, and n. It also has 1 output argument of type integer array with dimensions (2, 2, nprocs). The subroutine partitions the domain based on the number of processes (nprocs) along the m and n dimensions, and stores the partition indices in the output array.", "input": "", "output": "subroutine partition_task(nprocs, m, n, end_indx)\n    implicit none\n\n    ! external variables\n    integer, intent(in)  :: nprocs\n    integer, intent(in)  :: m\n    integer, intent(in)  :: n\n    integer, intent(out) :: end_indx(2, 2, nprocs)\n\n    ! local variables\n    integer :: step\n    integer :: i\n\n    end_indx = 0\n    ! nprocs <= m, n\n    step = m / nprocs\n    do i=1,nprocs-1\n        end_indx(1,1,i) = (i-1)*step+1\n        end_indx(2,1,i) =     i*step\n    enddo \n    end_indx(1,1,nprocs) = (nprocs-1)*step+1\n    end_indx(2,1,nprocs) = m\n\n    step = n / nprocs\n    do i=1,nprocs-1\n        end_indx(1,2,i) = (i-1)*step+1\n        end_indx(2,2,i) =     i*step\n    enddo \n    end_indx(1,2,nprocs) = (nprocs-1)*step+1\n    end_indx(2,2,nprocs) = n\n\n    return\nend subroutine partition_task \n"}, {"instruction": "Create a Fortran subroutine named stddev to calculate the mean and standard deviation of an array. The subroutine takes 2 input parameters of type real, dimension(:) and real, optional, and 2 output parameters of type real.", "input": "", "output": "  subroutine stddev(array,arith_mean,std_deviation,missing)\n    ! compute the mean and standard deviation of an array\n    real, dimension(:), intent(in)   :: array\n    real,               intent(out)  :: arith_mean\n    real,               intent(out)  :: std_deviation\n    real, optional,     intent(in)   :: missing\n\n    real                             :: sqr_sum\n    integer                          :: nelems\n\n       if (present(missing)) then\n          nelems=count(array .ne. missing)\n          arith_mean=sum(array,mask=array .ne. missing)/float(nelems)\n          sqr_sum=sum(array**2,mask=array .ne. missing)\n       else\n          nelems=size(array)\n          arith_mean=sum(array)/float(nelems)\n          sqr_sum=sum(array**2)\n       endif\n\n       if ( nelems == 0 ) then\n          std_deviation=0.0\n          return\n       endif\n\n       !sample standard deviation\n       std_deviation=sqrt((sqr_sum-nelems*arith_mean**2)/(nelems-1))\n\n  end subroutine stddev\n"}, {"instruction": "Create a Fortran subroutine named evenbounds to calculate the minimum and maximum integer values within certain bounds. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are n and m, and the output parameters are kmin and kmax.", "input": "", "output": "   subroutine evenbounds( n, m, kmin, kmax )\n\n      implicit none\n      integer, intent(in) :: n, m\n      integer, intent(out) :: kmin, kmax\n\n      ! local variables\n      real, dimension(3) :: btab\n\n      btab = (/ 0.0, real(m)/2.0, -real(m)/2.0 /)\n      kmin = ceiling( maxval( btab ) )\n\n      btab = (/ real(n)/2.0, real(n)-real(m)/2.0, real(n)+real(m)/2.0 /)\n      kmax = floor( minval( btab ) )\n\n   end subroutine\n"}, {"instruction": "Write a Fortran subroutine named oddbounds to calculate the minimum and maximum values based on the input integer parameters n and m. The subroutine has 2 input parameters of type integer, and 2 output parameters of type integer.", "input": "", "output": "   subroutine oddbounds( n, m, kmin, kmax )\n\n      implicit none\n      integer, intent(in) :: n, m\n      integer, intent(out) :: kmin, kmax\n\n      ! local variables\n      real btab(3)\n\n      btab = (/ 0.0, -real(m+1)/2.0, real(m-1)/2.0 /)\n      kmin = ceiling( maxval( btab ) )\n\n      btab = (/ real(n-1)/2.0, real(n)-real(m+1)/2.0, real(n)+real(m-1)/2.0 /)\n      kmax = floor( minval( btab ) )\n\n   end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gaussian to generate an array of normally distributed random numbers using the Box-Muller transform. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "  subroutine gaussian(output, mu, sigma, k, seed)\n    integer, intent(in) :: k, seed\n    real(8), intent(in) :: mu, sigma\n    real(8), intent(out) :: output(k)\n\n    integer :: i, n\n    real(8) :: r, theta\n    real(8), dimension(:), allocatable :: temp\n    integer(4), dimension(:), allocatable :: seed_arr\n\n    ! get random seed array size and fill seed_arr with provided seed\n    call random_seed(size = n)\n    allocate(seed_arr(n))\n    seed_arr = seed\n    call random_seed(put = seed_arr)\n\n    ! create 2k random numbers uniformly from [0,1]\n    if(allocated(temp)) then\n       deallocate(temp)\n    end if\n    allocate(temp(k*2))\n    call random_number(temp)\n\n    ! use box-muller transfrom to create normally distributed variables\n    do i = 1, k\n       r = (-2.0 * log(temp(2*i-1)))**0.5\n       theta = 2 * 3.1415926 * temp(2*i)\n       output(i) = mu + sigma * r * sin(theta)\n    end do\n  end subroutine gaussian\n"}, {"instruction": "Create a Fortran subroutine named recenter_velocities to recenter the velocities of particles. The subroutine takes 5 input parameters: 2 integers (nstep, nat), 2 real*8 arrays (masses, velocities) of dimension nat, and 1 integer array (factors) of dimension nat. It also has 1 output parameter: a real*8 array (velocities_) of dimension (nstep, nat, 3).", "input": "", "output": "subroutine recenter_velocities(velocities, masses, factors, velocities_, nstep, nat)\n    implicit none\n    ! make the center of mass velocity disappear\n    integer, intent(in)                             ::  nstep, nat\n    real*8, intent(in), dimension(nat)              :: masses\n    integer, intent(in), dimension(nat)             :: factors\n    real*8, intent(in),  dimension(nstep, nat, 3)   :: velocities\n    real*8, intent(out), dimension(nstep, nat, 3)   :: velocities_\n    integer                                         :: iat, istep, ipol\n    real*8, dimension(nat)                          :: rel_masses\n    real*8, dimension(3)                            :: com\n    real*8                                          :: m\n\n    do iat=1, nat\n        rel_masses(iat) = dble(factors(iat)) * masses(iat)\n    end do\n\n    m = sum(rel_masses)\n    rel_masses(:) = rel_masses(:) / m\n\n    do istep=1, nstep\n        com(1:3) = 0.d0\n        do iat=1, nat\n            do ipol=1, 3\n                com(ipol) = com(ipol) + rel_masses(iat)*velocities(istep, iat, ipol)\n            end do\n        end do\n\n        do iat=1, nat\n            do ipol=1, 3\n                velocities_(istep, iat, ipol) = velocities(istep, iat, ipol)  - com(ipol)\n            end do\n        end do\n    end do\n\nend subroutine recenter_velocities\n"}, {"instruction": "Create a Fortran subroutine named str_match to find the matching delimiter in a given string. The subroutine takes 2 input parameters of type character(len=*) and integer, and 1 output parameter of type integer.", "input": "", "output": "subroutine str_match(str, ipos, imatch)\r\n    !! this routine finds the delimiter in string `str` that matches the delimiter\r\n    !! in position `ipos` of `str`. the argument `imatch` contains the position of\r\n    !! the matching delimiter. allowable delimiters are (), [], {}, <>.\r\n    \r\n    character(len=*), intent(in) :: str\r\n    integer,          intent(in) :: ipos\r\n    integer,         intent(out) :: imatch\r\n    character(len=1) :: delim1\r\n    character(len=1) :: delim2\r\n    character(len=1) :: ch\r\n    integer :: lenstr\r\n    integer :: istart\r\n    integer :: iend\r\n    integer :: inc\r\n    integer :: idelim2\r\n    integer :: isum\r\n    integer :: i\r\n    \r\n    lenstr = len_trim(str)\r\n\r\n    delim1 = str(ipos:ipos)\r\n\r\n    select case(delim1)\r\n        case('(')\r\n            idelim2=iachar(delim1)+1\r\n            istart=ipos+1\r\n            iend=lenstr\r\n            inc=1\r\n        case(')')\r\n            idelim2=iachar(delim1)-1\r\n            istart=ipos-1\r\n            iend=1\r\n            inc=-1\r\n        case('[','{','<')\r\n            idelim2=iachar(delim1)+2\r\n            istart=ipos+1\r\n            iend=lenstr\r\n            inc=1\r\n        case(']','}','>')\r\n            idelim2=iachar(delim1)-2\r\n            istart=ipos-1\r\n            iend=1\r\n            inc=-1\r\n        case default\r\n            write(*,*) delim1,' is not a valid delimiter'\r\n            return\r\n    end select\r\n\r\n    if (istart < 1 .or. istart > lenstr) then\r\n        write(*,*) delim1,' has no matching delimiter'\r\n        return\r\n    end if\r\n    delim2=achar(idelim2) ! matching delimiter\r\n    \r\n    isum = 1\r\n    do i = istart, iend, inc\r\n        ch=str(i:i)\r\n        if (ch /= delim1 .and. ch /= delim2) cycle\r\n        if (ch == delim1) isum = isum+1\r\n        if (ch == delim2) isum = isum-1\r\n        if (isum == 0) exit\r\n    end do\r\n\r\n    if(isum /= 0) then\r\n        write(*,*) delim1,' has no matching delimiter'\r\n        return\r\n    end if   \r\n\r\n    imatch = i\r\n    \r\n    end subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named space_to_underbar that takes a single input parameter of type character (len=*) and returns a single output parameter of type character (len=*). The subroutine replaces spaces in the input string with underscores and assigns the modified string to the output parameter.", "input": "", "output": "    subroutine space_to_underbar(str, name)\n      character (len=*), intent(in) :: str\n      character (len=*), intent(out) :: name\n      integer :: i, len\n      len = len_trim(str)\n      name = ''\n      do i=1,len\n         if (str(i:i) == ' ') then\n            name(i:i) = '_'\n         else\n            name(i:i) = str(i:i)\n         end if\n      end do\n    end subroutine space_to_underbar\n"}, {"instruction": "Create a Fortran subroutine named \"dvbes12\" to calculate the derivatives of the Bessel functions. The subroutine should have 4 input parameters of type real*8, real*8, real*8, and integer, and one output parameter of type real*8. The subroutine is responsible for computing the derivatives according to specified calculations and logic.", "input": "", "output": "subroutine dvbes12(fj,dj,sm,ri,nt)                                 \n  !-----x----x----x----x----x----x----x----x----x----x----x----x----x----x\n  !-----x calculate the derivatives of the bessel functions.   x----x----x\n  !-----x   dj=dfj/dx where x=sm*ri                                 x----x\n  !-----x                    d.d.koelling                      x----x----x\n  !-----x----x----x----x----x----x----x----x----x----x----x----x----x----x\n  implicit none\n  real*8, intent(in) :: fj(*)                                          \n  real*8, intent(out):: dj(*)\n  real*8, intent(in) :: sm\n  real*8, intent(in) :: ri\n  integer, intent(in):: nt\n  ! locals\n  integer :: l, lm\n  real*8  :: q2, q3, x\n  real*8, parameter :: zup = 1.0d-5\n  x=sm\n  if (x.le.zup) then\n     dj(1)=0.d0\n     dj(2)=1.0/3.d0\n     do l=3,nt                                                      \n        dj(l)=0.d0\n     enddo\n     return\n  end if\n  q2=-1.d0/x                                                         \n  q3=q2                                                             \n  dj(1)=-fj(2)                                                      \n  lm=1                                                              \n  do l=2,nt                                                      \n     q3=q3+q2                                                          \n     dj(l)=fj(lm)+q3*fj(l)                                             \n     lm=lm+1                                                           \n  enddo\n  return                                                            \nend subroutine dvbes12\n"}, {"instruction": "Create a Fortran subroutine named optimal_gridmap to solve the division of a rectangle into discrete grids, ensuring that the number of regions is equal to or greater than the specified minimum. The subroutine takes 2 input parameters of type integer, representing the dimensions of the rectangle and the minimum number of parts, and 1 output parameter of type integer representing the optimal division of the rectangle into regions.", "input": "", "output": "    subroutine optimal_gridmap( rect, min_parts, ticks )\n    ! solves division of a rectangle with rect(1)*rect(2)\n    ! discrete grids into ticks(1)*ticks(2) (>= min_parts)\n    ! regions so that the length of borders is minimal\n    implicit none\n    integer, intent(in)  :: rect(2), min_parts\n    integer, intent(out) :: ticks(2)\n    integer              :: q, qx, qy, nbx, nby,&\n                            length, least \n    ticks = [ min_parts, min_parts ]\n    least = sum(rect)*min_parts\n    do qx = 1, min_parts\n        do qy = 1, min_parts\n            q = qx*qy\n            if( q>=min_parts .and. q-qx<min_parts .and. &\n                           q-qy<min_parts .and. &\n                       qx<=rect(1) .and. qy<=rect(2) ) then\n               if( qx==1 ) then\n                  nbx = 0\n               else\n                  nbx = qx\n               end if\n               if( qy==1 ) then\n                  nby = 0\n               else\n                  nby = qy\n               end if\n               length = nbx*rect(2)+nby*rect(1)\n               if( length<least ) then\n                  least = length\n                  ticks = [qx, qy]\n               end if\n            end if\n        end do\n    end do\n    end subroutine optimal_gridmap\n"}, {"instruction": "Create a Fortran subroutine named cmdprs_dequotestd to remove all quotation marks from a given input string. The subroutine takes 1 input parameter of type character(len=*) and 2 output parameters of type character(len=*) and integer (optional).", "input": "", "output": "  elemental subroutine cmdprs_dequotestd (ssource,sdest,ilength)\n  !<description>\n    ! remove all quotation marks from a string.\n  !</description>\n  \n  !<input>\n    ! a source string.\n    character(len=*), intent(in) :: ssource\n  !</input>\n  \n  !<output>\n    ! destination string. non-escaped quotation marks are removed.\n    character(len=*), intent(out) :: sdest\n    \n    ! optional: length of the string\n    integer, intent(out), optional :: ilength\n  !</output>\n  \n    character(len=len(ssource)) :: stemp\n    integer :: i, idest, ilen\n    character :: squotechar, scurrentchar\n    logical :: bescape\n    \n    ! copy the string, remove leading/trailing spaces.\n    stemp = trim(ssource)\n    \n    ! initialise destination\n    sdest = \"\"\n    \n    ! loop through the string. copy characters.\n    ! replace quotation marks.\n    i = 1\n    idest = 0\n    bescape = .false.\n    squotechar = ' '\n    ilen = len_trim(stemp)\n    do\n      if (i .gt. ilen) exit\n      \n      ! get the current character.\n      scurrentchar = stemp(i:i)\n      \n      if (bescape) then\n      \n        ! switch off escape mode.\n        bescape = .false.\n        \n      else\n        \n        if (scurrentchar .eq. \"\\\") then\n        \n          ! take the next character as it is.\n          bescape = .true.\n          \n          ! ignore the escape char.\n          i = i+1\n          cycle\n        \n        else if ((scurrentchar .eq. \"'\") .or. (scurrentchar .eq. \"\"\"\")) then\n          \n          ! start quoting or stop it. only the current quote char\n          ! triggers off the quoting.\n          if (squotechar .eq. scurrentchar) then\n            squotechar = \" \"\n          else\n            squotechar = scurrentchar\n          end if\n          \n          ! ignore the quotation char.\n          i = i+1\n          cycle\n          \n        end if\n      end if\n\n      ! copy the character and go to the next char.\n      idest = idest+1\n      sdest(idest:idest) = scurrentchar\n\n      i = i+1\n    end do\n    \n    ! from the destination, take the actual substring.\n    if (present(ilength)) then\n      ilength = idest\n    end if\n    \n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios_selection_auto that takes a character array as input and returns an 8-byte integer. The input parameter is of type character(*) and is designated as intent(in). The output parameter is of type integer*8 and is designated as intent(out). This subroutine is designed to provide an automatic selection based on the provided hints.", "input": "", "output": "        subroutine adios_selection_auto (sel, hints)\n            implicit none\n            integer*8,      intent(out)          :: sel\n            character(*),   intent(in)           :: hints\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios_get_attr_int2\" that retrieves an integer attribute from a file. The subroutine should take 2 input parameters of type integer*8 and character(*), and 2 output parameters of type integer*2 and integer.", "input": "", "output": "        subroutine adios_get_attr_int2 (fp, attrname, attr, err)\n            implicit none\n            integer*8,      intent(in)  :: fp\n            character(*),   intent(in)  :: attrname\n            integer*2,      intent(out) :: attr\n            integer,        intent(out) :: err\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named mergearrayint that combines two input integer arrays into a single output array. The subroutine should take 2 input parameters of type integer array and an additional output parameter of type integer array that is allocatable.", "input": "", "output": "subroutine mergearrayint(a,b,c)\n    integer,intent(in)::a(:,:)\n    integer,intent(in)::b(:,:)\n    integer,allocatable,intent(out)::c(:,:)\n    integer i,j,an,am,bn,bm\n\n    if(allocated(c)) deallocate(c)\n    an=size(a,1)\n    am=size(a,2)\n\n    bn=size(b,1)\n    bm=size(b,2)\n\n    if(am/=bm)then\n        print *, \"error :: mergearray, size(a,2)/= size(b,2)\"\n        return\n    endif\n    allocate(c(an+bn,am) )\n    do i=1,an\n        c(i,:)=a(i,:)\n    enddo\n    do i=1,bn\n        c(i+an,:)=b(i,:)\n    enddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch20u8pproperties to calculate various properties related to fluid flow through porous media. The subroutine takes 6 input parameters of type real: fperm, fporosity, fporea, fks, fkf, and fap(8), and produces 4 output parameters of type real: faxw(8), fasw(8), faqinv(8), and fapermeability(8).", "input": "", "output": "subroutine calch20u8pproperties(fperm, fporosity, fporea, fks, fkf, fap, faxw, fasw, faqinv, fapermeability)\n\timplicit none\n\treal, intent(in) :: fperm, fporosity, fporea, fks, fkf, fap(8)\n\treal, intent(out) :: faxw(8), fasw(8), faqinv(8), fapermeability(8)\n\n! main routine \n\tfaxw = 1.\n\tfasw = 1.\n\tfaqinv = 0. + fporosity * fasw / fkf + (fporea - fporosity) * faxw / fks\n\tfapermeability = fperm\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20u8ph to calculate stress-strain equations and stiffness matrix based on the given input parameters. The number of input arguments is 5 and the test_data type is ['integer', 'real', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].", "input": "", "output": "subroutine calch20u8ph(iint, fapermeability, fas, fab, faweight, fah)\n  !dec$ attributes dllexport::calch20u8ph\n\timplicit none\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faweight(iint ** 3), fas(8, iint ** 3), fab(6, 24, iint ** 3), fapermeability(8)\n\treal, intent(out) :: fah(36)\n\treal :: fstiff, fterm, fpermeability\n\tinteger :: i, j, k, m, ks, ix, iy, iz, ir1, ir2, ir3, ic\n\n! main routine \n! calculate stress-strain equations\n! calculate stiffness matrix\n\tm = 0\n\tdo i = 1, 36\n\t\tfah(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tfpermeability = 0.\n\t\t\t\tdo j = 1, 8\n\t\t\t\t\tfpermeability = fpermeability + fapermeability(j) * fas(j, m)\n\t\t\t\tend do\n\t\t\t\tks = 0\n\t\t\t\tfterm = faweight(m) * fpermeability\n\t\t\t\tdo i = 1, 8\n\t\t\t\t\tir1 = 3 * (i - 1) + 1\n\t\t\t\t\tir2 = ir1 + 1\n\t\t\t\t\tir3 = ir1 + 2\n\t\t\t\t\tdo j = i, 8\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tic = 3 * (j - 1) + 1\n\t\t\t\t\t\tfstiff = fab(1, ic, m) * fab(1, ir1, m) + fab(2, ic + 1, m) * fab(2, ir2, m) + &\n\t\t\t\t\t\t\tfab(3, ic + 2, m) * fab(3, ir3, m)\n\t\t\t\t\t\tfah(ks) = fah(ks) + fstiff * fterm\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named calch20u8ps that calculates the element stiffness matrix for a given set of inputs. The number of input arguments is 4 and the test_data type is ['integer', 'real', 'real', 'real']. The number of output arguments is 1 and the test_data type is ['real'].\n\nThe subroutine takes an integer value, a real array of size 8, a real array of size iint cubed, and a real array of size 8 by iint cubed as input. It calculates the element stiffness matrix and stores it in a real array of size 36.\n\nThe main routine initializes the output array to zero and then iterates over the input arrays to calculate and accumulate the element stiffness values. The calculations involve multiplying the elements of the input arrays and updating the corresponding elements of the output array.\n\nThe subroutine does not have any explicit return statement and does not return any values. The output is stored directly in the output array provided as an argument.\n\nPlease note that there are commented lines in the code that are not executed. They can be uncommented to write the output to a file.\n", "input": "", "output": "subroutine calch20u8ps(iint, faxwdivq, fas, faweight, fam)\n  !dec$ attributes dllexport::calch20u8ps\n\timplicit none\n\n\tinteger, intent(in) :: iint\n\treal, intent(in) :: faxwdivq(8), faweight(iint ** 3), fas(8, iint ** 3)\n\treal, intent(out) :: fam(36)\n\tinteger :: i, j, m, ks, ix, iy, iz\n\treal :: fterm, fxwdivq\n\n! main routine\n\tm = 0\n\tdo i = 1, 36\n\t\tfam(i) = 0d0\n\tenddo\n\tdo ix = 1, iint\n\t\tdo iy = 1, iint\n\t\t\tdo iz = 1, iint\n\t\t\t\tm = m + 1\n! add contribution to element stiffness\n\t\t\t\tfxwdivq = 0.\n\t\t\t\tdo j = 1, 8\n\t\t\t\t\tfxwdivq = fxwdivq + faxwdivq(j) * fas(j, m)\n\t\t\t\tend do\n\t\t\t\tks = 0\n\t\t\t\tfterm = faweight(m) * fxwdivq\n\t\t\t\tdo i = 1, 8\n\t\t\t\t\tdo j = i, 8\n\t\t\t\t\t\tks = ks + 1\n\t\t\t\t\t\tfam(ks) = fam(ks) + fterm * fas(i, m) * fas(j, m)\n\t\t\t\t\tenddo\n\t\t\t\tenddo\n\t\t\tenddo\n\t\tenddo\n\tenddo\n\n!\topen(100, file = 'd:\\ganal\\ganalf\\mass3.txt', status = 'new')\n!\tdo i = 1, 300\n!\t\twrite(100, 999) (i), fam(i)\n!\tenddo\n!\tclose(100)\n999 format (i5, f10.5)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"calch20u8pforcesfromporesh\" to calculate the global forces in a finite element analysis. The subroutine takes 3 input parameters: an array of integers named \"pieqlm\" with a size of 1, an array of real numbers named \"pfelementh\" with a size of 36, and an array of real numbers named \"pfp\" with a size of 8. It also has 1 output parameter: an array of real numbers named \"pfglobalforces\" with a size of 1.\n\nInside the subroutine, the local forces vector \"flocalforces\" is initialized to zero. Then, the skyline element matrix \"pfelementh\" is multiplied with the vector \"pfp\" and the result is stored in \"flocalforces\". \n\nNext, the subroutine updates the global loads vector \"pfglobalforces\" by adding the corresponding elements of \"flocalforces\" based on the values in the \"pieqlm\" array.\n\nThe subroutine utilizes implicit typing and operates with a mix of integer and real data types.", "input": "", "output": "subroutine calch20u8pforcesfromporesh(pieqlm, pfelementh, pfp, pfglobalforces)\n\timplicit none\n\n\tinteger, intent(in) :: pieqlm(1)\n\treal, intent(in) :: pfelementh(36), pfp(8)\n\treal, intent(out) :: pfglobalforces(1)\n\n\tinteger :: i, j, irow, iaccr, itemp, idatapos\n\treal :: flocalforces(8)\n\n! main function\n! initialize local forces vector\n\tflocalforces(1) = 0d0\n\tflocalforces(2) = 0d0\n\tflocalforces(3) = 0d0\n\tflocalforces(4) = 0d0\n\tflocalforces(5) = 0d0\n\tflocalforces(6) = 0d0\n\tflocalforces(7) = 0d0\n\tflocalforces(8) = 0d0\n\n! multiply skyline element h with vector pfp and store to flocalforces\n\tidatapos = 1\n\tdo i = 1, 8\n\t\tflocalforces(i) = flocalforces(i) + pfelementh(idatapos) * pfp(i)\n\t\tidatapos = idatapos + 1\n\t\tdo j = i + 1, 8\n\t\t\tflocalforces(i) = flocalforces(i) + pfelementh(idatapos) * pfp(j)\n\t\t\tflocalforces(j) = flocalforces(j) + pfelementh(idatapos) * pfp(i)\n\t\t\tidatapos = idatapos + 1\n\t\tend do\n\tend do\n\n! update the global loads vector (pfglobalforces)\n\titemp = pieqlm(1)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(1)\n\titemp = pieqlm(2)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(2)\n\titemp = pieqlm(3)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(3)\n\titemp = pieqlm(4)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(4)\n\titemp = pieqlm(5)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(5)\n\titemp = pieqlm(6)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(6)\n\titemp = pieqlm(7)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(7)\n\titemp = pieqlm(8)\n\tif (itemp.gt.0) pfglobalforces(itemp) = pfglobalforces(itemp) + flocalforces(8)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named xderiv that performs a numerical differentiation operation on a 2D array of variables. The subroutine takes in four input parameters: nx and ny (both integers), rkx (a 1D array of double precision numbers), and var (a 2D array of double precision numbers). It also has one output parameter, der, which is a 2D array of double precision numbers.\n\nThe subroutine calculates the derivative of the variable array var with respect to the wavenumber ky. It uses the values in the rkx array as multipliers for the differentiation operation. The differentiation is carried out by multiplying each element of var with the corresponding element in rkx and storing the result in the der array.\n\nWithin the subroutine, some additional calculations are performed. The variables nwx, nxp2, kx, ky, dkx, and kxc are declared as integers. The value of nwx is calculated as half of nx. The value of nxp2 is calculated as nx plus 2. The differentiation operation is then carried out in a loop over ky and kx values, where the derivatives are calculated and stored in the der array.\n\nIf the value of nx is an even number, an additional loop is executed to set the derivatives at kxc equal to zero.\n\nIn summary, the xderiv subroutine performs numerical differentiation on a 2D array of variables using wavenumber multiplication. It takes in four input parameters and returns the derivative array as the output parameter.", "input": "", "output": "        subroutine xderiv(nx, ny, rkx, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rkx(nx), var(nx, ny)\n            double precision, intent(out) :: der(nx, ny)\n            integer                       :: nwx, nxp2, kx, ky, dkx, kxc\n\n            nwx = nx / 2\n            nxp2 = nx + 2\n            !carry out differentiation by wavenumber multiplication:\n            do ky = 1, ny\n                der(1, ky) = zero\n                do kx = 2, nx - nwx\n                    dkx = 2 * (kx - 1)\n                    kxc = nxp2 - kx\n                    der(kx,  ky) = -rkx(dkx) * var(kxc, ky)\n                    der(kxc, ky) =  rkx(dkx) * var(kx , ky)\n                enddo\n            enddo\n\n            if (mod(nx, 2) .eq. 0) then\n                kxc = nwx + 1\n                do ky = 1, ny\n                    der(kxc, ky) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"yderiv\" that performs differentiation using wavenumber multiplication. The subroutine takes in four input parameters: \"nx\" and \"ny\" of type integer, \"rky\" of type double precision with dimension ny, and \"var\" of type double precision with dimension nx by ny. It also has one output parameter \"der\" of type double precision with dimension nx by ny.\n\nInside the subroutine, the variables \"nwy\", \"nyp2\", \"kx\", \"ky\", \"kyc\", and \"fac\" are declared. The subroutine first calculates the value of \"nwy\" as ny divided by 2, and \"nyp2\" as ny plus 2.\n\nThen, the subroutine performs the differentiation by wavenumber multiplication. It initializes the array \"der\" with zeros for the first row.\n\nNext, it uses nested do-loops to iterate through the values of \"ky\" from 2 to ny minus \"nwy\". For each \"ky\" value, it calculates the corresponding \"kyc\" value as \"nyp2\" minus \"ky\", and sets \"fac\" as the value of \"rky\" at index 2 times (\"ky\" minus 1).\n\nInside the innermost do-loop, for each \"kx\" value from 1 to nx, the subroutine assigns the negative value of \"fac\" multiplied by \"var\" at indices \"kx\" and \"kyc\" to \"der\" at indices \"kx\" and \"ky\". It also assigns the positive value of \"fac\" multiplied by \"var\" at indices \"kx\" and \"ky\" to \"der\" at indices \"kx\" and \"kyc\".\n\nAfter the nested do-loops, if the value of \"ny\" is even (determined using the modulo operator), the subroutine initializes the elements of \"der\" at index \"kx\" and \"nwy\" plus 1 to zero for each \"kx\" value from 1 to nx.\n\nThis subroutine performs differentiation using wavenumber multiplication and calculates the derivatives of the input array \"var\" with respect to the wavenumbers.", "input": "", "output": "        subroutine yderiv(nx, ny, rky, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rky(ny), var(nx, ny)\n            double precision, intent(out) :: der(nx, ny)\n            integer                       :: nwy, nyp2, kx, ky, kyc\n            double precision              :: fac\n\n            nwy = ny / 2\n            nyp2 = ny + 2\n            !carry out differentiation by wavenumber multiplication:\n            do kx = 1, nx\n                der(kx, 1) = zero\n            enddo\n\n            do ky = 2, ny - nwy\n                kyc = nyp2 - ky\n                fac = rky(2 * (ky - 1))\n                do kx = 1, nx\n                    der(kx,  ky) = -fac * var(kx, kyc)\n                    der(kx, kyc) =  fac * var(kx , ky)\n                enddo\n            enddo\n\n            if (mod(ny, 2) .eq. 0) then\n                kyc = nwy + 1\n                do kx = 1, nx\n                    der(kx, kyc) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named yderiv_fs that performs differentiation by wavenumber multiplication. The subroutine takes four input parameters: nx and ny of integer type, rky of double precision type with size ny, and var of double precision type with size nx by ny. It also has one output parameter: der of double precision type with size nx by 0:ny.\n\nIn the subroutine, set der(kx, 0) and der(kx, ny) to zero for all kx from 1 to nx. Then, for each ky from 1 to ny-1, compute der(kx, ky) by multiplying rky(ky) with var(kx, ky) for all kx from 1 to nx.\n\nEnsure that the subroutine is implemented using the do loop construct to iterate over kx and ky.\n\nUse this subroutine when you need to perform differentiation by wavenumber multiplication in your Fortran program.", "input": "", "output": "        subroutine yderiv_fs(nx, ny, rky, var, der)\n            integer,          intent(in)  :: nx, ny\n            double precision, intent(in)  :: rky(ny), var(nx, ny)\n            double precision, intent(out) :: der(nx, 0:ny)\n            integer                       :: kx, ky\n\n            !carry out differentiation by wavenumber multiplication:\n            do kx = 1, nx\n                der(kx, 0) = zero\n                !the above implies the mean value of der for every kx is zero.\n                der(kx, ny) = zero\n                !der = 0 when ky = ny since var = 0 when ky = ny.\n            enddo\n            do ky = 1, ny - 1\n                do kx = 1, nx\n                    der(kx, ky) = rky(ky) * var(kx, ky)\n                enddo\n            enddo\n        end subroutine\n"}, {"instruction": "Implement a Fortran subroutine named radtrans_rhs_form that calculates the right-hand side (RHS) of a radiation transport equation. The subroutine takes 4 input parameters: an integer neq, an array j of real numbers with dimension neq, an array k of real numbers with dimension 1+neq*(neq-1)/2, and an array i of real numbers with dimension neq. It also has 1 output parameter: an array didlam of real numbers with dimension neq. \n\nThe purpose of the subroutine is to compute the RHS by subtracting the product of k and i from j for each element in the arrays. The computation is performed element-wise, and the results are stored in the array didlam.\n\nPlease note that the code includes a commented section (denoted by \"!\") which checks for a condition \"is_linear_stokes==1\". This condition is currently commented out and does not affect the functionality of the code.", "input": "", "output": "      subroutine radtrans_rhs_form(neq,j,k,didlam,i)\n        integer, intent(in) :: neq\n        real(kind=8), intent(in), dimension(neq) :: j\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(neq) :: didlam\n        real(kind=8), intent(in), dimension(neq) :: i\n      !         write(6,*) 'rhs: ',is_linear_stokes,size(i),size(k),size(j)\n!        if (is_linear_stokes==1) then\n           didlam(1)=j(1)-(k(1)*i(1)+k(2)*i(2)+k(3)*i(3)+k(4)*i(4))\n           didlam(2)=j(2)-(k(2)*i(1)+k(1)*i(2)+k(7)*i(3)-k(6)*i(4))\n           didlam(3)=j(3)-(k(3)*i(1)-k(7)*i(2)+k(1)*i(3)+k(5)*i(4))\n           didlam(4)=j(4)-(k(4)*i(1)+k(6)*i(2)-k(5)*i(3)+k(1)*i(4))\n!        endif\n      end subroutine radtrans_rhs_form\n"}, {"instruction": "Create a Fortran subroutine named radtrans_jac_form to calculate the Jacobian matrix for a radiation transfer problem. The subroutine takes 4 input parameters: 2 integers (neq, nrowpd) and 2 real arrays of kind=8 (j and k). It outputs a real array of kind=8 with dimensions nrowpd and neq (pd).", "input": "", "output": "      subroutine radtrans_jac_form(neq,j,k,nrowpd,pd)\n        integer, intent(in) :: neq, nrowpd\n        real(kind=8), intent(in), dimension(neq) :: j\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(nrowpd,neq) :: pd\n        !      write(6,*) 'jac: ',nrowpd,neq,size(k)\n!        if (is_linear_stokes==1) then\n           pd(1,1)=k(1)\n           pd(1,2)=k(2)\n           pd(1,3)=k(3)\n           pd(1,4)=k(4)\n           pd(2,1)=k(2)\n           pd(2,2)=k(1)\n           pd(2,3)=k(7)\n           pd(2,4)=-k(6)\n           pd(3,1)=k(3)\n           pd(3,2)=-k(7)\n           pd(3,3)=k(1)\n           pd(3,4)=k(5)\n           pd(4,1)=k(4)\n           pd(4,2)=k(6)\n           pd(4,3)=-k(5)\n           pd(4,4)=k(1)\n           pd=-1d0*pd\n!        endif\n!         write(6,*) 'pd: ',pd\n        return\n      end subroutine radtrans_jac_form\n"}, {"instruction": "Create a Fortran subroutine named radtrans_jac_form_sph to calculate the Jacobian matrix for a specific radiation transfer problem. The subroutine takes 5 input parameters of types integer, integer, real(kind=8) arrays of dimension neq, real(kind=8) arrays of dimension neq, and real(kind=8) arrays of dimension 1+neq*(neq-1)/2, and outputs a real(kind=8) array of dimension nrowpd by neq.", "input": "", "output": "      subroutine radtrans_jac_form_sph(neq,j,k,i,nrowpd,pd)\n        integer, intent(in) :: neq, nrowpd\n        real(kind=8), intent(in), dimension(neq) :: j,i\n        real(kind=8), intent(in), dimension(1+neq*(neq-1)/2) :: k\n        real(kind=8), intent(out), dimension(nrowpd,neq) :: pd\n        real(kind=8) :: cphi,sphi,cpsi,spsi\n        !      write(6,*) 'jac: ',nrowpd,neq,size(k)\n!        if (is_linear_stokes==1) then\n        cphi=cos(i(3)); sphi=sin(i(3)); cpsi=cos(i(4)); spsi=sin(i(4))\n        pd(1,1)=-k(1)\n        pd(1,2)=-cphi*spsi*k(2)-sphi*spsi*k(3)-cpsi*k(4)\n        pd(1,3)=-i(2)*(-sphi*spsi*k(2)+cphi*spsi*k(3))\n        pd(1,4)=-i(2)*(cphi*cpsi*k(2)+cpsi*sphi*k(3)-spsi*k(4))\n        pd(2,1)=pd(1,2)\n        pd(2,2)=-k(1)\n        pd(2,3)=i(1)*spsi*(sphi*k(2)-cphi*k(3))+spsi*(cphi*j(3)-sphi*j(2))\n        pd(2,4)=-i(1)*cpsi*(cphi*k(2)+sphi*k(3))+cpsi*(cphi*j(2)+sphi*j(3))-spsi*(j(4)-i(1)*k(4))\n!        pd(3,1)=1d0/i(2)*(sphi/spsi*k(2)-cphi/spsi*k(3))\n        pd(3,1)=1d0/spsi/i(2)*(sphi*k(2)-cphi*k(3))\n!        pd(3,2)=(-cphi*cpsi/spsi*k(5)-cpsi/spsi*sphi*k(6)+k(7))/i(2)-(-cphi/spsi*(i(1)*k(3)-& \n!             j(3)+i(2)*cpsi*k(5))-1d0/spsi*sphi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6))+i(2)*k(7))/i(2)**2.\n        pd(3,2)=1d0/spsi/i(2)**2d0*(cphi*(i(1)*k(3)-j(3))+sphi*(j(2)-i(1)*k(2)))\n!        pd(3,3)=(1d0/spsi*sphi*(i(1)*k(3)-j(3)+i(2)*cpsi*k(5))-cphi/spsi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6)))/i(2)\n        pd(3,3)=1d0/i(2)/spsi*(sphi*(i(1)*k(3)-j(3))+cphi*(i(1)*k(2)-j(2)))+1d0/spsi*(sphi*k(5)-cphi*k(6))\n!        pd(3,4)=(i(2)*cphi*k(5)+cphi*cpsi/spsi/spsi*(i(1)*k(3)-j(3)+i(2)*cpsi*k(5))+i(2)*sphi*k(6)+ &\n!             cpsi/spsi/spsi*sphi*(-i(1)*k(2)+j(2)+i(2)*cpsi*k(6)))/i(2)\n        pd(3,4)=cpsi/spsi/spsi/i(2)*(cphi*(i(1)*k(3)-j(3))-sphi*(i(1)*k(2)-j(2)))+1d0/spsi/spsi*(cphi*k(5)+sphi*k(6))\n        pd(4,1)=(-cphi*cpsi*k(2)-cpsi*sphi*k(3)+spsi*k(4))/i(2)        \n!        pd(4,2)=(-sphi*k(5)+cphi*k(6))/i(2)-(-i(1)*cphi*cpsi*k(2)+spsi*(i(1)*k(4)-j(4))-sphi*(i(1)*cpsi*k(3) &\n!             -cpsi*j(3)+i(2)*k(5))+cphi*(cpsi*j(2)+i(2)*k(6)))/i(2)**2d0\n        pd(4,2)=1d0/i(2)**2d0*(cphi*cpsi*(i(1)*k(2)-j(2))-spsi*(i(1)*k(4)-j(4))+sphi*cpsi*(i(1)*k(3)-j(3)))\n!        pd(4,3)=(i(1)*cpsi*sphi*k(2)-cphi*(i(1)*cpsi*k(3)-cpsi*j(3)+i(2)*k(5))-sphi*(cpsi*j(2)+i(2)*k(6)))/i(2)\n        pd(4,3)=1d0/i(2)*(cpsi*sphi*(i(1)*k(2)-j(2))-cpsi*cphi*(i(1)*k(3)-j(3)))-cphi*k(5)-sphi*k(6)\n!        pd(4,4)=(i(1)*cphi*spsi*k(2)-cphi*spsi*j(2)-sphi*(-i(1)*spsi*k(3)+spsi*j(3))+cpsi*(i(1)*k(4)-j(4)))/i(2)\n        pd(4,4)=1d0/i(2)*(cphi*spsi*(i(1)*k(2)-j(2))+sphi*spsi*(i(1)*k(3)-j(3))+cpsi*(i(1)*k(4)-j(4)))\n!           pd=-1d0*pd\n!        endif\n!         write(6,*) 'pd: ',pd\n        return\n      end subroutine radtrans_jac_form_sph\n"}, {"instruction": "Create a Fortran subroutine named calc_delo_p_single that takes in 5 input parameters of type real(kind=8) and dimension, and outputs 1 parameter of type real(kind=8) and dimension. The input parameters are imatrix (4x4 array), f, g, sp (4-element array), and sp1 (4-element array). The subroutine calculates the value of p using matrix multiplication and arithmetic operations.", "input": "", "output": "      subroutine calc_delo_p_single(imatrix,f,g,sp,sp1,p)\n        real(kind=8), dimension(4,4), intent(in) :: imatrix\n        real(kind=8), intent(in) :: f,g\n        real(kind=8), intent(in), dimension(4) :: sp,sp1\n        real(kind=8), intent(out), dimension(4) :: p\n        p = matmul(imatrix,(f-g)*sp+g*sp1)\n      end subroutine calc_delo_p_single\n"}, {"instruction": "Write a Fortran subroutine named calc_delo_q_single that takes 6 input parameters of the following types: real(kind=8), dimension(4,4), real(kind=8), dimension(4,4), real(kind=8), dimension(4,4), real(kind=8), real(kind=8), real(kind=8). It also has 1 output parameter of type real(kind=8), dimension(4,4). The subroutine computes the matrix multiplication of imatrix and the difference between identity times e and g times kp1. Ensure that the subroutine is defined using Fortran syntax and features.", "input": "", "output": "      subroutine calc_delo_q_single(imatrix,e,f,g,kp1,identity,q)\n        real(kind=8), dimension(4,4), intent(in) :: imatrix,kp1,identity\n        real(kind=8), intent(in) :: e,f,g\n        real(kind=8), dimension(4,4), intent(out) :: q\n        q = matmul(imatrix,identity*e-g*kp1)\n      end subroutine calc_delo_q_single\n"}, {"instruction": "Create a Fortran subroutine named \"icount_this_\" to count the number of non-zero elements in an array. The input parameter is an array of integers, and the output parameter is the count of non-zero elements, both of type integer.", "input": "", "output": "      subroutine icount_this_ ( indx, n )\n      implicit none\n      integer, intent(in)  :: indx(:)\n      integer, intent(out) :: n\n      integer  i,m\n      m=size(indx,1)\n      n=0\n      do i = 1, m\n         if(indx(i)/=0) n=n+1 \n      enddo\n      end subroutine icount_this_\n"}, {"instruction": "Create a Fortran subroutine named submatrix_smdim to calculate the submatrix dimension based on the input metadim, meta, col, and cols. The subroutine takes 4 input parameters of type integer(4) and returns 1 output parameter of type integer(4).", "input": "", "output": "        subroutine submatrix_smdim(metadim,meta,col,cols,smdim)\n        implicit none\n        integer(4),intent(in)   :: metadim,col,cols\n        integer(4),intent(in)   :: meta(metadim,metadim)\n        integer(4),intent(out)   :: smdim\n        integer(4)    :: map(metadim),j\n        integer(4)    :: imap(metadim),is,js,ib,jb,a,b,i,iatom,jatom\n        real(8)       :: svar\n        logical(4)  :: file_exists\n        character(len=100) :: str\n        character(len=100) :: arg\n\n        smdim=0\n        do i=1,metadim\n          do j=col,col+cols-1\n            if(meta(i,j).eq.1)then\n              smdim=smdim+1\n              exit\n            endif\n          enddo\n        enddo\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named getdays to calculate the total number of days from the given year and month. The subroutine should take 2 input parameters of type integer(kind=4) for year (yr) and month (mon), and 1 output parameter of type integer(kind=4) for the total number of days (days).", "input": "", "output": "  subroutine getdays(yr,mon,days)\n\n    !! global namespace\n    integer(kind=4), intent(in)  :: yr\n    integer(kind=4), intent(in)  :: mon\n    integer(kind=4), intent(out) :: days\n\n    !! local namespace\n    integer(kind=4) :: i\n    integer(kind=4) :: cyear\n    integer(kind=4) :: nextlp\n    integer(kind=4) :: yrdiff\n    integer(kind=4), parameter    :: baseyr = 1850\n    integer(kind=4), parameter    :: frstlp = 1852\n    integer(kind=4), dimension(4) :: mon30 = (/4,6,9,11/)\n    integer(kind=4), dimension(7) :: mon31 = (/1,3,5,7,8,10,12/)\n\n    !! make sure some things are cool\n    if (yr < 1850) then\n       stop \"calmod: error: date must be at least 1850.\"\n    end if\n\n    if (mon < 1 .or. mon > 12) then\n       stop \"calmod: error: number of month must be between 1-12.\"\n    end if\n    \n    days = 0\n    yrdiff = yr - baseyr\n    nextlp = frstlp\n    \n    !! first get the number of yearly days\n    do i = 1,yrdiff\n       if (cyear == nextlp) then\n          days = days + 366\n          nextlp = nextlp + 4\n       else\n          days = days + 365\n       end if\n       cyear = baseyr + i\n    end do\n\n    !! now get the number of days from months (not the last)\n    do i = 1,mon-1\n       if (any(mon30 == i)) then\n          days = days + 30\n       else if (any(mon31 == i)) then\n          days = days + 31\n       else if (i == 2) then\n          if (cyear == nextlp) then\n             days = days + 29\n          else\n             days = days + 28\n          end if\n       end if\n    end do\n             \n    return\n    \n  end subroutine getdays\n"}, {"instruction": "Create a Fortran subroutine named rtname to generate a file name for a restart file based on the given id number. The input parameter is of type integer, and the output parameter is of type character with a length of 80.", "input": "", "output": "subroutine rtname(id,fname)\n!\n! this sub creates a file name for a restart file\n!\nimplicit none\n!\ninteger, intent(in) :: id\ncharacter(len=80), intent(out) :: fname\n!\n! create the file name based on the id number\n!\nif(id.lt.   10.and.id.ge.   0) write(fname,1) id\nif(id.lt.  100.and.id.ge.  10) write(fname,2) id\nif(id.lt. 1000.and.id.ge. 100) write(fname,3) id\nif(id.lt.10000.and.id.ge.1000) write(fname,4) id\n!\n! format statements\n!\n1 format('output.lag.000',i1,'.vtu')\n2 format('output.lag.00' ,i2,'.vtu')\n3 format('output.lag.0'  ,i3,'.vtu')\n4 format('output.lag.'   ,i4,'.vtu')\n!\nreturn\n!\nend subroutine rtname\n"}, {"instruction": "Create a Fortran subroutine named \"simplex_projection\" to perform simplex projection on a vector. The subroutine takes 3 input parameters: an integer, a real*8, and a real*8 array of dimension n. The output parameter is a real*8 array of dimension n. The subroutine computes the simplex projection of the input vector and modifies the input vector in place to produce the output.", "input": "", "output": "    subroutine simplex_projection(x,z,d,n)\n    implicit none\n    integer,intent(in)::n\n    real*8,parameter::project_eps = 0.0\n    real*8,intent(in)::d\n    integer,dimension(n)::isselect\n    real*8,dimension(n),intent(in)::z\n    real*8,dimension(n),intent(out)::x\n    real*8::pivot\n    real*8:: sum_k,get_sum\n    real*8,dimension(n)::tempz\n    integer::i,now,pre,counter\n    logical st,loop\n    real*8 dnor\n    integer,dimension(n)::set_i\n    x=0.0\n    pivot=(sum(z)-d)/n\n    loop =  .true.\n    isselect = 1\n    counter = 0\n    do while(loop)\n        pre = sum(isselect)\n        isselect = 0\n        tempz=0\n        do i=1,n\n            if(z(i)>pivot+project_eps) then \n                isselect(i) = 1\n                tempz(i) = z(i)\n            end if\n        end do\n        pivot = (sum(tempz)-1+(n-sum(isselect))*project_eps)/sum(isselect)\n        if (sum(isselect).eq.pre) then \n            loop = .false.\n        else\n            loop = .true.\n        end if\n        counter=counter+1\n        if (counter>100) then \n            write(*,*)  \"warning: the projection method and can not get of loop\"\n            pause\n        end if \n    end do \n    do i =1, n\n        x(i) = max(z(i)-pivot,project_eps)\n    end do\n    return \n\n!     do i=1,n\n!     !\tx(i)=z(i)+(d-sum(z(:)))/(n*1.0)\n!         x(i)=z(i)+(d-get_sum(z(1:n),n))/(n*1.0)\n!     end do \n\t\t\n! 10\tset_i=0\n!     st=.true.\n!     sum_k=0.0\n!     do i=1,n\n!         !if (x(i)>0.0) then\n!         if (x(i) > project_eps) then\n!             set_i(i) = 1\n!             sum_k = sum_k + x(i)\n!         endif \n!         !if (x(i)<0.0) then \n!         if (x(i) < project_eps) then \n!             st =.false.\n!             sum_k = sum_k + project_eps\n!         end if \n!     end do\n!     if (st) then\n!         return\n!     end if \n!     dnor = (sum(set_i(:))*1d0)\n!     do i = 1,n\n!         if (set_i(i)==0) then \n!              !x(i)=0.0\n!             x(i) = project_eps\n!         else if (set_i(i) == 1) then \n!             x(i) = x(i) + (d-sum_k)/dnor\n!         end if \n!     end do \n!     go to 10 \n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named mpas_cross_product_in_r3 that calculates the cross product of two 3D vectors. The subroutine takes 2 input parameters of type real (kind=rkind) representing the two input vectors and 1 output parameter of type real (kind=rkind) representing the resulting cross product vector.", "input": "", "output": "subroutine mpas_cross_product_in_r3(p_1,p_2,p_out)!{{{\n  integer, parameter :: rkind  = selected_real_kind(12)\n  real (kind=rkind), intent(in) :: p_1 (3) !< input: vector 1\n  real (kind=rkind), intent(in) :: p_2 (3) !< input: vector 2\n  real (kind=rkind), intent(out) :: p_out (3) !< output: cross product of vector 1 and vector 2\n\n  p_out(1) = p_1(2)*p_2(3)-p_1(3)*p_2(2)\n  p_out(2) = p_1(3)*p_2(1)-p_1(1)*p_2(3)\n  p_out(3) = p_1(1)*p_2(2)-p_1(2)*p_2(1)\nend subroutine mpas_cross_product_in_r3!}}}\n"}, {"instruction": "Create a Fortran subroutine named compare_sp to compare two arrays of real numbers. The subroutine takes three input parameters of types real, allocatable, real, allocatable, and real, optional. It also has two output parameters of types integer and real.", "input": "", "output": "    subroutine compare_sp(ref, chk, diffcount, maxabsdiff, tol)\n    real, allocatable, intent(in)       :: ref(:), chk(:)\n    integer, intent(out)                :: diffcount\n    real, intent(out)                   :: maxabsdiff\n    real, optional, intent(in)          :: tol\n    \n    integer                             :: i, n\n    real                                :: wtol, diff\n    \n    diffcount = 0\n    maxabsdiff = 0.\n    n = size(ref, 1)\n    \n    if (n /= size(chk, 1)) then\n        diffcount = -1\n        return\n    end if\n    \n    wtol = tolerance\n    if (present(tol)) wtol = tol\n    \n    do i = 1, n\n        diff = abs(ref(i) - chk(i))\n        if (diff > wtol) then \n            diffcount = diffcount + 1\n            maxabsdiff = max(maxabsdiff, diff)\n        end if\n    end do\n    \n    end subroutine compare_sp\n"}, {"instruction": "Create a Fortran subroutine named chebydiff to perform Chebyshev differentiation in space using recursion. The subroutine should have 2 input parameters of type integer and double precision array with dimensions (0:nd-1), and 1 output parameter of double precision array with dimensions (0:nd-1). The subroutine should implement the Chebyshev differentiation algorithm as described in the code.", "input": "", "output": "  subroutine chebydiff(a,da,nd)\r\n!\r\n! differentiate in chebyshev space using the recursion\r\n!\r\n! t_{n+1}'   t_{n-1}'\r\n! -------  - -------    = 2t_n\r\n!  n+1         n-1 \r\n!\r\n  integer, intent(in) :: nd\r\n  double precision, dimension(0:nd-1), intent(in) :: a\r\n  double precision, dimension(0:nd-1), intent(out) :: da\r\n  integer :: k \r\n!\r\n  da=0.d0\r\n  da(nd-2)=dble(2*(nd-1))*a(nd-1)\r\n  do k=nd-3,1,-1\r\n    da(k)=dble(2*(k+1))*a(k+1)+da(k+2)\r\n  end do \r\n  da(0)=a(1)+da(2)/2.d0 \r\n!\r\n  end subroutine chebydiff \r\n"}, {"instruction": "Create a Fortran subroutine named i3da to perform integration in s, u, and v using trapezoid in s, u and a quadrature rule with weights wq in v. The number of input arguments is 5 with test_data types ['integer', 'integer', 'integer', 'double precision, dimension(0:ns-1,0:nu-1,0:nv)', 'double precision, dimension(0:nv)']. The number of output arguments is 1 with test_data type ['double precision'].", "input": "", "output": "  subroutine i3da(f,intf,wq,ns,nu,nv) \r\n!\r\n! integrate in s,u,v - trapezoid in s,u and a quadrature rule with\r\n! weights wq in v \r\n!\r\n  integer, intent(in) :: ns,nu,nv\r\n  double precision, dimension(0:ns-1,0:nu-1,0:nv), intent(in) :: f\r\n  double precision, intent(out) :: intf  \r\n  double precision, dimension(0:nv), intent(in) :: wq\r\n  double precision :: hs,hu\r\n  integer :: ks,ku,kv\r\n!\r\n  hs=2.d0*pi/dble(ns)\r\n  hu=2.d0*pi/dble(nu)\r\n  intf=0.d0\r\n  do kv=0,nv\r\n    do ku=0,nu-1\r\n      do ks=0,ns-1\r\n        intf=intf+wq(kv)*f(ks,ku,kv)\r\n      end do\r\n    end do\r\n  end do\r\n!\r\n  intf=intf*hs*hu\r\n!\r\n  end subroutine i3da\r\n"}, {"instruction": "Create a Fortran subroutine named legendrep to evaluate the standard Legendre polynomial of degrees 0 to n. The subroutine takes 3 input parameters, with the test_data types ['integer', 'integer', 'double precision, dimension(m)'], and 1 output parameter with the test_data type ['double precision, dimension(m,0:n)']. Use the imperative tone in your implementation.", "input": "", "output": "  subroutine legendrep(p,x,n,m)\r\n!\r\n! evaluate the standard legendre polynomial of degrees 0:n\r\n!\r\n  integer, intent(in) :: n,m\r\n  double precision, dimension(m), intent(in) :: x\r\n  double precision, dimension(m,0:n), intent(out) :: p\r\n  integer :: k,j\r\n!\r\n  do j=1,m\r\n    p(j,0)=1.d0\r\n  end do\r\n!\r\n  if (n > 0) then\r\n!\r\n  do j=1,m\r\n    p(j,1)=x(j)\r\n  end do\r\n!\r\n  if (n > 1) then\r\n!\r\n  do k=2,n\r\n    do j=1,m\r\n      p(j,k)=(dble(2*k-1)*x(j)*p(j,k-1)-dble(k-1)*p(j,k-2))/dble(k)\r\n    end do\r\n  end do\r\n!\r\n  end if\r\n!\r\n  end if\r\n!\r\n  end subroutine legendrep \r\n"}, {"instruction": "Create a Fortran subroutine named simple_function. It takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter s is used to compute the output parameter res, which is the result of multiplying s by 10.", "input": "", "output": "subroutine simple_function(s,res)\n  implicit none\n  integer, intent(in) :: s   ! s is an input parameter\n                             ! it cannot be modified\n  integer,intent(out) :: res ! res is an output parameter\n\n  res = 10*s\nend subroutine simple_function\n"}, {"instruction": "Create a Fortran subroutine named invtranspose to calculate the inverse transpose of a 4x4 matrix. The subroutine takes 1 input parameter of type double precision. It returns 2 output parameters, one of type double precision and one of type logical.", "input": "", "output": "    subroutine invtranspose(m, minv, ok_flag)\n\n        implicit none\n\n        double precision, intent(in)  :: m(4,4)\n        double precision, intent(out) :: minv(4,4)\n        logical,          intent(out) :: ok_flag\n\n        double precision, parameter :: eps = 1.0d-10\n        double precision            :: det, cofactor(4,4)\n\n\n        det =  m(1,1)*(m(2,2)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(2,4)*(m(3,2)*m(4,3)- &\n               m(3,3)*m(4,2)))-m(1,2)*(m(2,1)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+ &\n               m(2,4)*(m(3,1)*m(4,3)-m(3,3)*m(4,1)))+m(1,3)*(m(2,1)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(2,2)*(m(3,4)*m(4,1)- &\n               m(3,1)*m(4,4))+m(2,4)*(m(3,1)*m(4,2)-m(3,2)*m(4,1)))-m(1,4)*(m(2,1)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))+ &\n               m(2,2)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))+m(2,3)*(m(3,1)*m(4,2)-m(3,2)*m(4,1)))\n\n        if(abs(det) <= eps)then\n            minv = 0.0d0\n            ok_flag = .false.\n            return\n        end if\n\n    cofactor(1,1) = m(2,2)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(2,3)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(2,4)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))\n    cofactor(1,2) = m(2,1)*(m(3,4)*m(4,3)-m(3,3)*m(4,4))+m(2,3)*(m(3,1)*m(4,4)-m(3,4)*m(4,1))+m(2,4)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))\n    cofactor(1,3) = m(2,1)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(2,2)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+m(2,4)*(m(3,1)*m(4,2)-m(3,2)*m(4,1))\n    cofactor(1,4) = m(2,1)*(m(3,3)*m(4,2)-m(3,2)*m(4,3))+m(2,2)*(m(3,1)*m(4,3)-m(3,3)*m(4,1))+m(2,3)*(m(3,2)*m(4,1)-m(3,1)*m(4,2))\n    cofactor(2,1) = m(1,2)*(m(3,4)*m(4,3)-m(3,3)*m(4,4))+m(1,3)*(m(3,2)*m(4,4)-m(3,4)*m(4,2))+m(1,4)*(m(3,3)*m(4,2)-m(3,2)*m(4,3))\n    cofactor(2,2) = m(1,1)*(m(3,3)*m(4,4)-m(3,4)*m(4,3))+m(1,3)*(m(3,4)*m(4,1)-m(3,1)*m(4,4))+m(1,4)*(m(3,1)*m(4,3)-m(3,3)*m(4,1))\n    cofactor(2,3) = m(1,1)*(m(3,4)*m(4,2)-m(3,2)*m(4,4))+m(1,2)*(m(3,1)*m(4,4)-m(3,4)*m(4,1))+m(1,4)*(m(3,2)*m(4,1)-m(3,1)*m(4,2))\n    cofactor(2,4) = m(1,1)*(m(3,2)*m(4,3)-m(3,3)*m(4,2))+m(1,2)*(m(3,3)*m(4,1)-m(3,1)*m(4,3))+m(1,3)*(m(3,1)*m(4,2)-m(3,2)*m(4,1))\n    cofactor(3,1) = m(1,2)*(m(2,3)*m(4,4)-m(2,4)*m(4,3))+m(1,3)*(m(2,4)*m(4,2)-m(2,2)*m(4,4))+m(1,4)*(m(2,2)*m(4,3)-m(2,3)*m(4,2))\n    cofactor(3,2) = m(1,1)*(m(2,4)*m(4,3)-m(2,3)*m(4,4))+m(1,3)*(m(2,1)*m(4,4)-m(2,4)*m(4,1))+m(1,4)*(m(2,3)*m(4,1)-m(2,1)*m(4,3))\n    cofactor(3,3) = m(1,1)*(m(2,2)*m(4,4)-m(2,4)*m(4,2))+m(1,2)*(m(2,4)*m(4,1)-m(2,1)*m(4,4))+m(1,4)*(m(2,1)*m(4,2)-m(2,2)*m(4,1))\n    cofactor(3,4) = m(1,1)*(m(2,3)*m(4,2)-m(2,2)*m(4,3))+m(1,2)*(m(2,1)*m(4,3)-m(2,3)*m(4,1))+m(1,3)*(m(2,2)*m(4,1)-m(2,1)*m(4,2))\n    cofactor(4,1) = m(1,2)*(m(2,4)*m(3,3)-m(2,3)*m(3,4))+m(1,3)*(m(2,2)*m(3,4)-m(2,4)*m(3,2))+m(1,4)*(m(2,3)*m(3,2)-m(2,2)*m(3,3))\n    cofactor(4,2) = m(1,1)*(m(2,3)*m(3,4)-m(2,4)*m(3,3))+m(1,3)*(m(2,4)*m(3,1)-m(2,1)*m(3,4))+m(1,4)*(m(2,1)*m(3,3)-m(2,3)*m(3,1))\n    cofactor(4,3) = m(1,1)*(m(2,4)*m(3,2)-m(2,2)*m(3,4))+m(1,2)*(m(2,1)*m(3,4)-m(2,4)*m(3,1))+m(1,4)*(m(2,2)*m(3,1)-m(2,1)*m(3,2))\n    cofactor(4,4) = m(1,1)*(m(2,2)*m(3,3)-m(2,3)*m(3,2))+m(1,2)*(m(2,3)*m(3,1)-m(2,1)*m(3,3))+m(1,3)*(m(2,1)*m(3,2)-m(2,2)*m(3,1))\n\n        minv = transpose(cofactor) / det\n\n        ok_flag = .true.\n\n    end subroutine invtranspose\n"}, {"instruction": "Create a Fortran subroutine named pix2ang_ring to calculate the theta and phi coordinates of the nominal pixel center for a given pixel number in the ring scheme, based on the map resolution parameter nside. The subroutine takes 2 input parameters of type integer(kind=4) and returns 2 output parameters of type real(kind=8). The subroutine utilizes conditional statements to determine the pixel location and then computes the corresponding theta and phi coordinates. The subroutine concludes by setting theta to halfpi minus the computed value.", "input": "", "output": "  subroutine pix2ang_ring(nside, ipix, phi, theta)\n    !=======================================================================\n    !     renders theta and phi coordinates of the nominal pixel center\n    !     for the pixel number ipix (ring scheme)\n    !     given the map resolution parameter nside\n    !=======================================================================\n    integer(kind=4), intent(in) :: ipix, nside\n    real(kind=8), intent(out) ::  theta, phi\n\n    integer(kind=4) ::  nl2, nl4, npix, ncap, iring, iphi, ip, ipix1\n    real(kind=8) ::  fodd, hip, fihip\n    !-----------------------------------------------------------------------\n    if (nside<1 .or. nside>ns_max) stop \"nside out of range\"\n    npix = 12*nside**2       ! total number of points\n    if (ipix <0 .or. ipix>npix-1) stop \"ipix out of range\"\n\n    ipix1 = ipix + 1 ! in {1, npix}\n    nl2 = 2*nside\n    ncap = 2*nside*(nside-1) ! points in each polar cap, =0 for nside =1\n\n    if (ipix1 <= ncap) then ! north polar cap -------------\n\n       hip   = ipix1*0.5_8\n       fihip = aint ( hip , kind=8)\n       iring = int( sqrt( hip - sqrt(fihip) ) ) + 1 ! counted from north pole\n       iphi  = ipix1 - 2*iring*(iring - 1)\n\n       theta = acos( 1.0_8 - iring**2 / (3.0_8*nside**2) )\n       phi   = (real(iphi,8) - 0.5_8) * pi/(2.0_8*iring)\n\n    elseif (ipix1 <= nl2*(5*nside+1)) then ! equatorial region ------\n\n       ip    = ipix1 - ncap - 1\n       nl4   = 4*nside\n       iring = int( ip / nl4 ) + nside ! counted from north pole\n       iphi  = modulo(ip,nl4) + 1\n\n       fodd  = 0.5_8 * (1 + modulo(iring+nside,2))  ! 1 if iring+nside is odd, 1/2 otherwise\n       theta = acos( (nl2 - iring) / (1.5_8*nside) )\n       phi   = (real(iphi,8) - fodd) * pi /(2.0_8*nside)\n\n    else ! south polar cap -----------------------------------\n\n       ip    = npix - ipix1 + 1\n       hip   = ip*0.5_8\n       fihip = aint ( hip , kind=8)\n       iring = int( sqrt( hip - sqrt(fihip) ) ) + 1     ! counted from south pole\n       iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1))\n\n       theta = acos( -1.0_8 + iring**2 / (3.0_8*nside**2) )\n       phi   = (real(iphi,8) - 0.5_8) * pi/(2.0_8*iring)\n\n    endif\n    \n\ttheta=halfpi-theta \n\n    return\n  end subroutine pix2ang_ring ! pix2ang_ring\n"}, {"instruction": "Create a Fortran subroutine named conv_hist3d to compute a 3D histogram from input data. The subroutine takes 3 input parameters: a 2D array of real numbers, an optional 1D array of real numbers, and an integer. It produces 2 output parameters: a 3D array of real numbers and an optional 2D array of real numbers.", "input": "", "output": "  subroutine conv_hist3d(data, nbin, weights, hist, edges)\n    real(kind=8), dimension(:,:), intent(in) :: data !! data(ndim, nparts)\n    real(kind=8), dimension(size(data, 2)), &\n         intent(in), optional            :: weights ! weights(nparts)\n    integer, intent(in)                  :: nbin\n\n    real(kind=8), dimension(nbin, nbin, nbin), intent(out)    :: hist\n    real(kind=8), dimension(3, nbin+1), intent(out), optional :: edges\n\n    real(kind=8), dimension(3) :: maxis, minis, spans\n\n    integer :: i, j, k, part_i, ndim, nparts\n\n    ! get the dimensions\n    ndim = size(data, 1)\n    nparts = size(data, 2)\n    ! compute the edges\n    maxis = maxval(data, 2)\n    minis = minval(data, 2)\n    spans = maxis - minis\n\n    do i = 1, nbin + 1\n       edges(:, i) = minis + (maxis - minis) * (i-1) / nbin\n    end do\n    print*, minis, maxis\n\n    print*, nparts\n    ! project the data onto the edges\n    do part_i = 1, nparts\n       ! get the position in the grid\n       i = floor((data(1, part_i) - minis(1)) * nbin / spans(1)) + 1\n       j = floor((data(2, part_i) - minis(2)) * (nbin * 1d0) / spans(2)) + 1\n       k = floor((data(3, part_i) - minis(3)) * nbin / spans(3)) + 1\n\n       ! because of rounding errors, the maxima aren't well found,\n       ! fix that\n       if (data(1, part_i) == maxis(1)) i = nbin\n       if (data(2, part_i) == maxis(2)) j = nbin\n       if (data(3, part_i) == maxis(3)) k = nbin\n\n       ! print*, i,j,k\n       ! todo: linear approximation of density\n       ! increment the histogram\n       if ((i <= 0) .or. (i > nbin) .or. (j <= 0) .or. (j > nbin) .or.&\n            (k <= 0) .or. (k > nbin)) then\n          print*, 'dafuk ?!'\n          print*, (data(:, part_i) - maxis) == 0\n          print*, i, j, k\n       end if\n\n       if (present(weights)) then\n          hist(i, j, k) = hist(i, j, k) + weights(part_i)\n       else\n          hist(i, j, k) = hist(i, j, k) + 1\n       end if\n    end do\n\n    print*, nparts, ndim\n  end subroutine conv_hist3d\n"}, {"instruction": "Create a Fortran subroutine named conv_density to calculate the density distribution of particles in a 3D space. The subroutine takes 2 input parameters: data of type real(kind=8), dimension(:,:), and nbin of type integer. It has 2 output parameters: dens of type real(kind=8), dimension(nbin, nbin, nbin), and edges of type real(kind=8), dimension(3, nbin+1), which is optional.", "input": "", "output": "  subroutine conv_density(data, nbin, dens, edges)\n    real(kind=8), dimension(:,:), intent(in) :: data !! data(ndim, nparts)\n    integer, intent(in)                      :: nbin\n\n    real(kind=8), dimension(nbin, nbin, nbin), intent(out)   :: dens\n    real(kind=8), dimension(3, nbin+1), intent(out), optional:: edges\n\n    real(kind=8), dimension(3) :: maxis, minis, spans\n\n    integer :: i, j, k, part_i, ndim, nparts, i0, j0, k0, imax, jmax, kmax, imin, jmin, kmin\n    real(kind=8) :: ri, rj, rk\n\n    ! get the dimensions\n    ndim = size(data, 1)\n    nparts = size(data, 2)\n    ! compute the bins\n    maxis = maxval(data, 2)\n    minis = minval(data, 2)\n\n    spans = (maxis - minis)\n\n    do i = 1, nbin + 1\n       edges(:, i) = minis + spans * (i-1) / nbin\n    end do\n\n    ! project the data onto the bins\n    do part_i = 1, nparts\n       ! get the position in the grid\n       ri = (data(1, part_i) - minis(1)) * nbin / spans(1) + 0.5\n       rj = (data(2, part_i) - minis(2)) * nbin / spans(2) + 0.5\n       rk = (data(3, part_i) - minis(3)) * nbin / spans(3) + 0.5\n\n       ! the max and min are actually only half in leftmost/rightmost bin\n       ! so the min has ri =  0.5\n       ! and the max has ri = nbin + 0.5\n\n       i0 = floor(ri)\n       j0 = floor(rj)\n       k0 = floor(rk)\n\n       imin = max(1, i0)\n       jmin = max(1, j0)\n       kmin = max(1, k0)\n\n       imax = min(nbin, i0 + 1)\n       jmax = min(nbin, j0 + 1)\n       kmax = min(nbin, k0 + 1)\n\n       do k = kmin, kmax\n          do j = jmin, jmax\n             do i = imin, imax\n                ! add the proportion of the particle in the box\n                dens(i, j, k) = dens(i, j, k) + abs((ri - i)*(rj - j)*(rk - k))\n             end do\n          end do\n       end do\n    end do\n\n    ! convert the number density into a mass density (assuming uniform mass)\n    ! todo: don't assume uniform mass\n    dens = dens * nbin**3 / product(maxis-minis)\n\n  end subroutine conv_density\n"}, {"instruction": "Write a Fortran subroutine named findisi to calculate the interspike intervals from a given set of input data. The input parameter is of type real*8 and intent(in), while the output parameter is of type real*8, allocatable and intent(out).", "input": "", "output": "    subroutine findisi(x, isi)\n        real*8, intent(in) :: x(:)\n        real*8, allocatable, intent(out) :: isi(:)\n        real*8, allocatable :: isidata(:)\n        integer :: i, k, iplus, crosscounter\n        real*8 :: t1, t2, ts, tsa\n\n        t1 = 0\n        t2 = 0\n        ts = 0\n        tsa = 0\n        crosscounter = 0\n        n = size(x, 1) - 1\n        allocate(isidata(1:n)) ! alocando n valores para os isi\n        i = 1\n        do while (x(i) > 0.0d0) ! garantindo que o loop principal come\u00e7ara com x(i)<0\n            i = i + 1\n        end do\n        k = 1\n        do while (i <= n) ! loop principal\n            iplus = i + 1\n            if (x(i) * x(iplus) < 0) then ! cruzou o eixo x = 0\n                if (modulo(crosscounter,2) == 0) then ! como come\u00e7ou abaixo de x = 0, crosscounter par significa subindo\n                    t1 = (dble(i) + dble(iplus)) / 2.0d0\n                else ! crosscounter impar significa descendo\n                    t2 = (dble(i) + dble(iplus)) / 2.0d0\n                    ts = (t1 + t2) / 2.0d0\n                    isidata(k) = ts - tsa\n                    tsa = ts\n                    k = k + 1\n                end if\n                crosscounter = crosscounter + 1\n            end if\n            i = i + 1\n        end do\n        k = k - 1 ! k = total de isi encontraldos\n        allocate(isi(1:(k-1)))\n        isi = isidata(2:k)\n    end subroutine findisi\n"}, {"instruction": "Create a Fortran subroutine named evalk to evaluate a function based on the input parameter. The subroutine takes 1 input parameter of type real(kind=8) and 1 output parameter of type real(kind=8). If the input parameter is greater than or equal to 0, the output parameter is set to 1.0; otherwise, the output parameter is computed based on a specific formula.", "input": "", "output": "subroutine evalk (p, k)\n  real(kind=8), intent(in)  :: p\n  real(kind=8), intent(out) :: k\n  if (p >= 0.0) then\n     k = 1.0\n  else\n     k = 1.0/(1+p**2)\n  end if\nend subroutine evalk\n"}, {"instruction": "Create a Fortran subroutine named proma4 that computes the product of two matrices. It takes 5 input parameters: three 4-byte integers (n1, n2, n3), and two double-precision real arrays (b and c), and produces one output parameter, a double-precision real array a. The subroutine evaluates the matrix product a = b * c where a, b, and c are matrices of appropriate dimensions.", "input": "", "output": "      subroutine proma4(a,b,c,n1,n2,n3)\r\n!********************************************************************\r\n!\r\n!***this routine evaluates a matrix product\r\n!                                            t\r\n!           a(i,j) = b(k,i) * c(k,j)    a = b * c\r\n!\r\n!********************************************************************\r\n      implicit none\r\n\r\n      integer (kind=4),intent(in) :: n1,n2,n3\r\n      real (kind=8),intent(in) :: b(1:n3,1:n1), c(1:n3,1:n3)\r\n      real (kind=8),intent(out) :: a(1:n1,1:n3)\r\n\r\n      a(1:n1,1:n2) = matmul( transpose(b(1:n3,1:n1)), c(1:n3,1:n2) )\r\n      return\r\n\r\n      end subroutine proma4\r\n"}, {"instruction": "Create a Fortran subroutine named get_vdw_ref_params to retrieve van der Waals reference parameters for a given chemical element and rank. The subroutine takes 2 input parameters of type character*8 and integer, and returns 3 output parameters of type real*8. The subroutine calculates and assigns the van der Waals reference parameters based on the provided chemical element and rank. If the default parameters are not available for the given element, a warning message is displayed.", "input": "", "output": "  subroutine get_vdw_ref_params(element, c6, r0, alpha0, rank)\n\n    implicit none\n\n    character*8, intent(in) :: element\n    integer, intent(in) :: rank\n    real*8, intent(out) :: c6, r0, alpha0\n    real*8 :: hartree = 27.211386024367243d0, bohr = 0.5291772105638411d0\n\n    c6 = 0.d0\n    r0 =  0.d0\n    alpha0 = 0.d0\n\n!   these should be in the correct units (enegy in ev, distances in angstrom)\n\n\n    if( element == \"h\" )then\n!     this is the value provided by vasp, for which they give \"private comm.\"\n!     as reference in the ts implementation paper:\n      r0 = 1.64d0\n!     these values are given by chu and dalgarno (j chem phys 121, 4083 [2004])\n      alpha0 = 4.5d0 * bohr**3\n      c6 = 6.5d0 * hartree * bohr**6\n    else if( element == \"c\" )then\n!     this is the value provided by vasp, for which they give \"private comm.\"\n!     as reference in the ts implementation paper:\n      r0 = 1.900d0\n!     this is the one given by grimme (j comput chem 27, 1787 [2006]):\n!      r0 = 1.452d0\n!     these values are given by chu and dalgarno (j chem phys 121, 4083 [2004])\n      alpha0 = 12.d0 * bohr**3\n      c6 = 46.6d0 * hartree * bohr**6\n    else\n      if( rank == 0 )then\n        write(*,*)'                                       |'\n        write(*,*)'warning: default vdw reference parame- |'\n        write(*,*)'ters not available for element:        |'\n        write(*,*)'                                       |'\n        write(*,'(1x,a8,a)') element, '                               |'\n        write(*,*)'                                       |'\n        write(*,*)'you can safely disregard this warning  |'\n        write(*,*)'if your potential does not use van der |'\n        write(*,*)'waals corrections. otherwise, or if you|'\n        write(*,*)'want to overrride the defaults, you    |'\n        write(*,*)'need to provide your own definitions of|'\n        write(*,*)'vdw_c6_ref, vdw_r0_ref and             |'\n        write(*,*)'vdw_alpha0_ref in the input file.      |'\n        write(*,*)'                                       |'\n        write(*,*)'.......................................|'\n      end if\n    end if\n\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named direct to calculate the observer distance and directivity angles for a given set of input parameters. The subroutine takes 9 input parameters of type integer, real(dp), and real(dp) arrays of dimension n, and returns 3 output parameters, each of type real(dp) arrays of dimension n.", "input": "", "output": "subroutine direct(n,xt,yt,zt,c,c1,d,hub,beta,r,theta_e,phi_e)\r\n  implicit none\r\n  integer, parameter :: dp = kind(0.d0)\r\n  ! in\r\n  integer, intent(in) :: n\r\n  real(dp), intent(in) :: xt,yt,zt,hub,beta\r\n  real(dp), dimension(n), intent(in) :: c,c1,d\r\n  ! out\r\n  real(dp), dimension(n), intent(out) :: r,theta_e,phi_e\r\n  ! local\r\n  integer :: i,sign\r\n  real(dp) :: pi,xo,yo,zo,xs,zs,xe_d,ze_d,theta,xe,ze,phi_er\r\n  real(dp), dimension(n) :: c2\r\n  intrinsic sin\r\n  intrinsic cos\r\n  intrinsic atan2\r\n  intrinsic sqrt\r\n  intrinsic abs\r\n  ! constants\r\n  pi = 3.1415926535897932_dp\r\n\r\n  ! distance from pitch-axis to trailing edge\r\n  c2(1:n) = c(1:n)-c1(1:n)\r\n\r\n  ! calculating observer location from hub\r\n  xo = xt ! lateral direction\r\n  yo = yt ! downstream direction\r\n  zo = zt-hub ! height direction\r\n\r\n  do i=1,n\r\n    ! calculating trailing edge position from hub\r\n    xs = sin(beta)*d(i)-cos(beta)*c2(i)\r\n    zs = cos(beta)*d(i)+sin(beta)*c2(i)\r\n\r\n    ! calculating observer position from trailing edge\r\n    xe_d = xo-xs\r\n    ze_d = zo-zs\r\n\r\n    ! rotating observer position with repsect to beta\r\n    theta = pi-beta\r\n    xe = cos(theta)*xe_d+sin(theta)*ze_d\r\n    ze = -sin(theta)*xe_d+cos(theta)*ze_d\r\n\r\n    ! calculating observer distance and directivity angles\r\n    r(i) = sqrt(yo**2+xe**2+ze**2)\r\n    theta_e(i) = atan2(sqrt(yo**2+ze**2),xe)\r\n    phi_e(i) = atan2(yo,ze)\r\n\r\n    ! quadratic smoothing when phi_e is close to 0 or 180 degrees\r\n    if (abs(phi_e(i)) < 5.0_dp*pi/180.0_dp) then\r\n      if (phi_e(i) >= 0.0_dp) then\r\n        sign = 1\r\n      else\r\n        sign = -1\r\n      end if\r\n      phi_er = abs(phi_e(i))*180.0_dp/pi\r\n      phi_er = 0.1_dp*phi_er**2+2.5_dp\r\n      phi_e(i) = sign*phi_er*pi/180.0_dp\r\n    else if (abs(phi_e(i)) > 175.0_dp*pi/180.0_dp) then\r\n      if (phi_e(i) >= 0.0_dp) then\r\n        sign = 1\r\n      else\r\n        sign = -1\r\n      end if\r\n      phi_er = abs(phi_e(i))*180.0_dp/pi\r\n      phi_er = -0.1_dp*(phi_er-180.0_dp)**2+177.5_dp\r\n      phi_e(i) = sign*phi_er*pi/180.0_dp\r\n    end if\r\n\r\n  end do\r\n\r\nend subroutine direct\r\n"}, {"instruction": "Write a Fortran subroutine named easter to calculate the date of Easter (Sunday) using the algorithm by J.-M. Oudin (1940) and reprinted in the explanatory supplement to the astronomical almanac. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer.", "input": "", "output": "subroutine easter(year, day, month)\r\n! u.s. naval observatory astronomical applications department\r\n\r\n!            the date of easter (sunday)\r\n\r\n! the algorithm is due to j.-m. oudin (1940) and is reprinted in the explanatory\r\n! supplement to the astronomical almanac, ed. p. k. seidelmann (1992).\r\n! see chapter 12, \"calendars\", by l. e. doggett.\r\n\r\n! the following are dates of easter from 1980 to 2024:\r\n\r\n! 1980  april  6        1995  april 16        2010  april  4\r\n! 1981  april 19        1996  april  7        2011  april 24\r\n! 1982  april 11        1997  march 30        2012  april  8\r\n! 1983  april  3        1998  april 12        2013  march 31\r\n! 1984  april 22        1999  april  4        2014  april 20\r\n! 1985  april  7        2000  april 23        2015  april  5\r\n! 1986  march 30        2001  april 15        2016  march 27\r\n! 1987  april 19        2002  march 31        2017  april 16\r\n! 1988  april  3        2003  april 20        2018  april  1\r\n! 1989  march 26        2004  april 11        2019  april 21\r\n! 1990  april 15        2005  march 27        2020  april 12\r\n! 1991  march 31        2006  april 16        2021  april  4\r\n! 1992  april 19        2007  april  8        2022  april 17\r\n! 1993  april 11        2008  march 23        2023  april  9\r\n! 1994  april  3        2009  april 12        2024  march 31\r\n\r\n! n.b. the date of easter for the eastern orthodox church may be different.\r\n\r\n! this code assembled by alan miller\r\n! reference web site:\r\n! http://aa.usno.navy.mil/faq/docs/easter.html\r\n! latest revision 8 april 2002\r\n\r\nimplicit none\r\ninteger, intent(in)   :: year\r\ninteger, intent(out)  :: day, month\r\n\r\n! local variables\r\ninteger  :: c, i, j, k, l, n\r\n\r\nc = year / 100\r\nn = year - 19 * ( year / 19 )\r\nk = ( c - 17 ) / 25\r\ni = c - c / 4 - ( c - k ) / 3 + 19 * n + 15\r\ni = i - 30 * ( i / 30 )\r\ni = i - (i / 28) * (1 - (i / 28) * (29 / (i + 1 )) * ( (21 - n) / 11) )\r\nj = year + year / 4 + i + 2 - c + c / 4\r\nj = j - 7 * ( j / 7 )\r\nl = i - j\r\nmonth = 3 + ( l + 40 ) / 44\r\nday = l + 28 - 31 * ( month / 4 )\r\n\r\nreturn\r\nend subroutine easter\r\n"}, {"instruction": "Write a Fortran subroutine named vcd to calculate the values of zvcd based on the input arrays zz and zmaj. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 1 output parameter of type real. The subroutine should be intended to be used imperatively.", "input": "", "output": "    subroutine vcd(zz,zmaj,zvcd,jmax,nmaj)\n\n      implicit none\n\n      integer,intent(in) :: jmax,nmaj\n      real,intent(in) :: zz(jmax), zmaj(nmaj,jmax)\n\n      real,intent(out) :: zvcd(nmaj,jmax)\n\n      integer :: i, j\n      real :: rat\n\n      do i=1,nmaj\n        zvcd(i,jmax) =   zmaj(i,jmax) &\n                       * (zz(jmax)-zz(jmax-1)) &\n                       / alog(zmaj(i,jmax-1)/zmaj(i,jmax))\n        do j=jmax-1,1,-1\n          rat = zmaj(i,j+1) / zmaj(i,j)\n          zvcd(i,j) = zvcd(i,j+1)+zmaj(i,j)*(zz(j)-zz(j+1))/alog(rat)*(1.-rat)\n        enddo\n      enddo\n\n      return\n\n    end subroutine vcd\n"}, {"instruction": "Create a Fortran subroutine named \"a\" that takes two integer input parameters. The input parameters should be declared using the \"intent(in)\" attribute. The subroutine should have one output parameter of type integer, declared using the \"intent(out)\" attribute.", "input": "", "output": "subroutine a(x, y, o)\nimplicit none\n  ! these are input args\n        integer, intent(in) :: x, y ! <- we describe them here\ninteger, intent(out) :: o\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named short_wave_radiation to calculate shortwave radiation values based on given atmospheric and location parameters. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type real: sro and sron.", "input": "", "output": "  subroutine short_wave_radiation(cld,sro,sron) \n    ! ************************************************************************\n    ! **                 s h o r t  w a v e  r a d i a t i o n              **\n    ! **                      from ce-qual-w2 (ver 3.1)                     **\n    ! ************************************************************************\n\n    ! ******* type declaration\n    real, intent(in)    ::  cld \n    real, intent(out)   :: sro, sron\n    integer   :: iday \n    real      :: jday\n    real      :: standard, thour, pmc1, eqtnew, h, decl, sinal, a0, cld10\n  \n    ! ******* input conversions\n    cld10 = cld*10.                ! *** convert from 0-1 (efdc) to 0-10 (w2)\n\n    ! ******* shortwave radiation\n    standard = 15.0*int(ds_long/15.0)\n\n    ! *** day of the year\n    thour    = (timeday-int(timeday))*24.0\n    iday     =  timeday-int(timeday/365.)*365.\n    iday     =  iday+int(int(timeday/365.)/4.)\n    jday     = real(iday)\n    pmc1     = (2.*pi*(jday-1.))/365.\n    eqtnew   =  0.170*sin(4.*pi*(jday-80.)/373.)-0.129*sin(2.*pi*(jday-8.)/355.)\n    h     = 0.2618*(thour-(ds_long-standard)*0.066667+eqtnew-12.0)\n    decl =  0.006918-0.399912*cos(pmc1)  +0.070257*sin(pmc1)-0.006758*cos(2*pmc1)+0.000907*sin(2*pmc1)-0.002697*cos(3*pmc1)+0.001480*sin(3*pmc1)\n    sinal = sin(ds_lat*.017453)*sin(decl)+cos(ds_lat*.017453)*cos(decl)*cos(h)\n    a0    = 57.2958*asin(sinal)\n    \n    if( a0 > 0.0 )then\n      sro  = 2.044*a0+0.1296*a0**2-1.941e-3*a0**3+7.591e-6*a0**4\n      sro  = (1.0-0.0065*cld10**2)*sro*24.0\n      sro  = sro*btu_ft2_day_to_w_m2\n      sron = sro*(1.-refl)                    ! *** adjust for surface reflection\n    else\n      sro  = 0.0\n      sron = 0.0\n    end if\n       \n    return\n    \n  end subroutine short_wave_radiation\n"}, {"instruction": "Write a Fortran subroutine named equilibrium_temperature that takes 4 real input parameters (wspd, td, tair, sron) and returns 2 real output parameters (et, cshe). The subroutine computes the equilibrium temperature and heat exchange coefficient using various conversions and calculations.", "input": "", "output": "  subroutine equilibrium_temperature(wspd, td, tair, sron, et, cshe) \n    !************************************************************************\n    !**             e q u i l i b r i u m  t e m p e r a t u r e           **\n    !**                      from ce-qual-w2 (ver 3.1)                     **\n    !************************************************************************\n\n    ! ******* type declaration\n    real, intent(in)    :: wspd, td, tair, sron \n    real, intent(out)   :: et, cshe\n    real      :: tdew_f, tair_f, wind_2m \n    real      :: wind_mph\n    real      :: sro_br, tstar, beta, fw, ra, etp\n  \n    integer :: j  \n\n    ! ******* input conversions\n\n    ! ******* british units\n    tdew_f   = td*1.8+32.0\n    tair_f   = tair*1.8+32.0\n    wind_mph = wspd*mps_to_mph\n    wind_2m  = wind_mph         ! *** ee7.3 and later apply correction to all winds\n    wind_2m = max(wind_2m, 1.)  ! pmc - apply a minumum to allow surface heat exchange even with calm conditions\n\n    ! *** sron should already be adjusted for shading & reflection\n    sro_br   = sron*w_m2_to_btu_ft2_day \n\n    ! ******* equilibrium temperature and heat exchange coefficient\n    \n    et    = tdew_f\n    tstar = (et+tdew_f)*0.5\n    beta  = 0.255-(8.5e-3*tstar)+(2.04e-4*tstar*tstar)\n    fw    = w_m2_to_btu_ft2_day*afw+bconv*bfw*wind_2m**cfw\n    cshe  = 15.7+(0.26+beta)*fw\n    ra    = 3.1872e-08*(tair_f+459.67)**4\n    etp   = (sro_br+ra-1801.0)/cshe+(cshe-15.7)*(0.26*tair_f+beta*tdew_f)/(cshe*(0.26+beta))\n    j     = 0\n    do while (abs(etp-et) > 0.05 .and. j < 10)\n      et    = etp\n      tstar = (et+tdew_f)*0.5\n      beta  = 0.255-(8.5e-3*tstar)+(2.04e-4*tstar*tstar)\n      cshe  = 15.7+(0.26+beta)*fw\n      etp   = (sro_br+ra-1801.0)/cshe+(cshe-15.7)*(0.26*tair_f+beta*tdew_f)/(cshe*(0.26+beta))\n      j     = j+1\n    end do\n\n    ! ******* si units\n\n    ! *** rhowcpi = 1/rho/cp = 0.2393e-6\n    et   = (et-32.0)*5.0/9.0                 ! *** deg c\n    cshe = cshe*flux_br_to_flux_si*rhowcpi   ! *** m/s\n\n  end subroutine equilibrium_temperature\n"}, {"instruction": "Create a Fortran subroutine named \"boolfromfile\" that reads logical values from a file specified by the input parameter \"filename\" of type character(len=80) and stores them in the output array \"x\" of type logical(kind=4). The subroutine should read up to 20000 logical values from the file and store them in the output array \"x\".", "input": "", "output": "subroutine boolfromfile(filename,x)\n  implicit none\n  character(len=80), intent(in) :: filename   ! input\n  logical(kind=4), intent(out)  :: x(20000)   ! output\n\n  integer :: nrows=20000\n  integer :: i\n\n  open(unit=11, file=filename, action=\"read\")\n  do  i = 1, nrows\n    read(11,*)  x(i)\n  end do\n  close(unit=11)\n\nend subroutine boolfromfile\n"}, {"instruction": "Create a Fortran subroutine named how_many_extra_history_header_items to determine the number of additional history header items based on the given IDs. The subroutine takes 2 input parameters of type integer, id and id_extra. It returns 1 output parameter of type integer, num_cols.", "input": "", "output": "      subroutine how_many_extra_history_header_items(id, id_extra, num_cols)\n      integer, intent(in) :: id, id_extra\n      integer, intent(out) :: num_cols\n      num_cols=0\n      end subroutine how_many_extra_history_header_items\n"}, {"instruction": "Create a Fortran subroutine named load_div. This subroutine takes 2 input parameters of type integer, and 2 output parameters of type integer. The function calculates the values of ir_out and id_out arrays based on the input parameters m and np using a set of mathematical operations.", "input": "", "output": "  subroutine load_div( m, np, ir_out, id_out )\n    implicit none\n    integer,intent(in) :: m, np\n    integer,intent(out) :: ir_out(0:np-1),id_out(0:np-1)\n    integer :: i,ip\n    ir_out=0.0d0\n    do i=1,m\n       ip=mod(i-1,np)\n       ir_out(ip)=ir_out(ip)+1\n    end do\n    do ip=0,np-1\n       id_out(ip)=sum(ir_out(0:ip))-ir_out(ip)\n    end do\n  end subroutine load_div\n"}, {"instruction": "Create a Fortran subroutine named t_times2, which takes one input parameter of type integer and one output parameter of type integer. The subroutine multiplies the input parameter by 2 and assigns the result to the output parameter.", "input": "", "output": "    subroutine t_times2(v_in, v_out) bind(c, name='t_times2')\n        integer, intent(in) :: v_in\n        integer, intent(out) :: v_out\n        !\n        v_out=v_in*2\n    end subroutine t_times2\n"}, {"instruction": "Write a Fortran subroutine named copystring to copy a portion of a character string into another character string. The subroutine takes 2 input arguments of type character(len=*) and integer, and 1 output argument of type character(len=*).", "input": "", "output": " subroutine copystring(oldstring,newstring,lenstring)\n \n!***********************************************************************\n!     \n\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification march 2015\n!     \n!***********************************************************************\n  \n  implicit none\n  \n  character(len=*), intent(in) :: oldstring\n  character(len=*), intent(out) :: newstring\n  integer, intent(in) :: lenstring\n  \n  integer :: i\n  \n  do i=1,lenstring\n    newstring(i:i)=oldstring(i:i)\n  enddo\n  \n  return\n  \n end subroutine copystring\n"}, {"instruction": "Create a Fortran subroutine named hexagonally_close_packed to generate coordinates for a hexagonally close-packed structure. The subroutine takes 6 input parameters of types ['integer', 'integer', 'integer', 'real(8)', 'real(8)', 'logical'] and 3 output parameters of type ['real(8)', 'real(8)', 'real(8)']. The purpose of the subroutine is to calculate the coordinates of the atoms in a hexagonally close-packed structure based on the input parameters.", "input": "", "output": "subroutine hexagonally_close_packed(nx, ny, nz, a, d, center, xs, ys, zs)\n  integer, intent(in) :: nx, ny, nz\n  real(8), intent(in) :: a, d\n  logical, intent(in) :: center\n  real(8), intent(out) :: xs(nx, ny, nz), ys(nx, ny, nz), zs(nx, ny, nz)\n  integer :: i\n  real(8) :: h !< the distance between adjacent rows in the same layer\n  real(8) :: m !< the distance between corresponding rows in adjacent\n               !< layers.\n  xs = 0.0\n  ys = 0.0\n  zs = 0.0\n  !! first create coordinates, then center.\n  !! create first row in first layer\n  xs(:, 1, 1) = [(i * a, i = 0, nx - 1)]\n  !! create other rows in the first layer\n  do i = 3, ny, 2\n     xs(:, i, 1) = xs(:, 1, 1)\n  end do\n  do i = 2, ny, 2\n     xs(:, i, 1) = xs(:, 1, 1) + 0.5 * a\n  end do\n\n  h = sqrt(3.0) / 2 * a\n  do i = 1, ny\n     ys(:, i, 1) = (i - 1) * h\n  end do\n\n  !! add distances between layers\n  do i = 1, nz\n     zs(:, :, i) = (i - 1) * d\n  end do\n\n  !! for every other layer, x and y are the same.\n  !! odd layers:\n  do i = 1, nz, 2\n     xs(:, :, i) = xs(:, :, 1)\n     ys(:, :, i) = ys(:, :, 1)\n  end do\n  m = a / (2 * sqrt(3.0))\n  !! even layers:\n  do i = 2, nz, 2\n     xs(:, :, i) = xs(:, :, 1) + 0.5 * a\n     ys(:, :, i) = ys(:, :, 1) + m\n  end do\n  if (center) then\n     xs = xs - maxval(xs) / 2.0\n     ys = ys - maxval(ys) / 2.0\n     zs = zs - maxval(zs) / 2.0\n  end if\nend subroutine hexagonally_close_packed\n"}, {"instruction": "Create a Fortran subroutine named random_integer to generate a random integer within a specified range. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine random_integer(nrange,irand)\n  implicit none\n  integer, intent(in) :: nrange\n  integer, intent(out) :: irand\n  !local variables\n  real(kind=4) :: tt\n  \n  call random_number(tt)\n\n  irand=nint(tt*real(nrange,kind=4))\n\nend subroutine random_integer\n"}, {"instruction": "Create a Fortran subroutine named exptaylor to calculate the exponential function using Taylor series expansion. The subroutine takes 2 input parameters of type real (kind=8) and integer. It returns 2 output parameters of type real (kind=8) and integer.", "input": "", "output": "subroutine exptaylor(x,nmax,y,nterms)\n!====================================\n    implicit none\n\n    real (kind=8), intent(in) :: x\n    integer, intent(in) :: nmax\n    real (kind=8), intent(out) :: y\n    integer, intent(out) :: nterms\n\n    ! local variables:\n    real (kind=8) :: term, partial_sum\n    integer :: j\n\n    term = 1.\n    partial_sum = term\n\n    do j=1,nmax\n        ! j'th term is  x**j / j!  which is the previous term times x/j:\n        term = term*x/j   \n        ! add this term to the partial sum:\n        partial_sum = partial_sum + term   \n        if (abs(term) < 1.d-16*partial_sum) exit\n        enddo\n     nterms = j       ! number of terms used\n     y = partial_sum  ! this is the value returned\nend subroutine exptaylor\n"}, {"instruction": "Create a Fortran subroutine named read_pgm to read a PGM file and store the image data into an allocatable integer array. The subroutine takes 1 input parameter of type character(len=*) for the filename and 1 output parameter of type integer,allocatable for the image data.", "input": "", "output": "subroutine read_pgm(filename,img)\nimplicit none\ncharacter(len=*), intent(in)       :: filename\n  integer,allocatable, intent(out) :: img(:,:)\n  \n  integer             :: nx, ny, nmax, err\n! read a pgm file\n! do not need to save what i read as i won't use this information\n  open(10, file=filename)\n  read(10,*) \n  read(10,*) \n  read(10,*) nx,ny\n  allocate(img(nx,ny), stat=err)\n  if (err /= 0) stop\n  read(10,*) nmax\n  read(10,*) img\n  close(10)\nend subroutine read_pgm\n"}, {"instruction": "Write a Fortran subroutine named compress_pgm to compress a PGM image by reducing its size.The subroutine takes 2 input arguments of type integer and allocates 1 output argument of type integer, allocatable.The input arguments are img and step, and the output argument is small.", "input": "", "output": "subroutine compress_pgm(img,step, small)\nimplicit none\n  integer, intent(in)               :: img(:,:)\n  integer, intent(in)               :: step\n  integer, allocatable, intent(out) :: small(:,:)\n  \n  integer                           :: nx,ny, nxs, nys, err\n  \n  ! size of main image\n  nx = size(img,1)\n  ny = size(img,2)\n  ! compute size of the reduced image (small)\n  nxs = size(img(1:nx:step,:),1)\n  nys = size(img(:,1:ny:step),2)\n  \n  allocate(small(nxs,nys), stat=err)\n  if (err /= 0) stop \"error when allocatin small\"\n  \n  small(:,:) = img(1:nx:step,1:ny:step)\n  \nend subroutine compress_pgm\n"}, {"instruction": "Create a Fortran subroutine named smsv to find and count the prime numbers less than or equal to a given integer n. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 2, and the test_data type is ['integer, dimension(:)', 'integer'].", "input": "", "output": "      subroutine smsv(n, parr, cnt)\n         ! find and count the prime nos. <= n\n         ! dummy arguments\n         integer, intent(in) :: n\n         integer, intent(out), dimension(:) :: parr\n         integer, intent(out) :: cnt\n         ! local data\n         integer :: i, j\n         logical, dimension(n) :: sv\n         ! processing\n         sv(1) = .false.\n         sv(2:) = .true.\n         do i = 2, int(sqrt(real(n)))\n            do j = i*i, n, i\n               sv(j) = .false.\n            end do\n         end do\n         cnt = 0\n         do i = 2, n\n            if (sv(i)) then\n               cnt = cnt+1\n               parr(cnt) = i\n            end if\n         end do\n      end subroutine smsv\n"}, {"instruction": "Create a Fortran subroutine called \"cmpseg\" to compute the segmented sieve of Eratosthenes. The subroutine takes 4 input parameters of type integer and integer array, and 1 output parameter of type logical array. The input parameters are lo, hi, n, and p (an array of size n), and the output parameter is s (an array of size hi-lo+1).", "input": "", "output": "      subroutine cmpseg(lo, hi, n, p, s)\n         ! dummy argumentes\n         integer, intent(in) :: lo, hi, n\n         integer, intent(in), dimension(n) :: p\n         logical, intent(out), dimension(hi-lo+1) :: s\n         ! local data\n         integer :: i, j, k\n         ! processing\n         s = .true.\n         do i = 1, n\n            j = (lo/p(i))*p(i)\n            !j = lo-mod(lo, p(i))\n            if (j < lo) j = j+p(i)\n            do k = j, hi, p(i)\n               s(k-lo+1) = .false.\n            end do\n         end do\n      end subroutine cmpseg\n"}, {"instruction": "Write a Fortran subroutine named \"ciarlet\" to compute the inelasticity based on the given input parameters. The number of input parameters is 2 with data type ['real*8 ', 'real*8 '], and the number of output parameters is 1 with data type ['real*8 '].", "input": "", "output": "subroutine ciarlet(psi,invc,matpar) !! page 259, computation inelasticity\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(:)\n\treal*8 :: e, nu , lambda, mu, j, i1\n\t\n\te = matpar(1) \n\tnu = matpar(2)\n \n\tlambda = e*nu/((1.0d0 + nu)*(1.0d0 - 2.0d0*nu))\n\tmu = 0.5d0*e/(1.0d0 + nu)\n\t\n\tj = dsqrt(invc(3)) ! j\n\ti1 = invc(1)\n\t\n\tpsi = 0.25d0*(j*j-1.0d0) - (0.5d0*lambda + mu)*dlog(j) + 0.5d0*mu*(i1 - 3.0d0)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrixregularisation to perform matrix regularization. The subroutine takes 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are invc(:) and matpar(4), while the output parameter is psi. The subroutine computes the value of psi based on the provided input parameters and the defined calculations.", "input": "", "output": "subroutine matrixregularisation(psi,invc,matpar) \n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(4)\n!~  \treal*8 :: c1,c2, c3,c4, i1, j\n!~ \tc1 = matpar(1) \n!~ \tc2 = matpar(2) \n!~ \tc3 = matpar(3) \n!~ \tc4 = matpar(4) \n\t\n!~ \ti1 = invc(1)\n!~ \tj = dsqrt(invc(3))\n\t\n!~ \tif(j>c4) then\n!~ \t\tj = c4\n!~ \tend if \n\n!~ \tif(i1>c3) then\n!~ \t\ti1 = c3\n!~ \tend if \n\t\n!~ \tpsi = c1*(i1 - 3.0d0) + c2*( j*j - 1.0d0 - 2.0d0*dlog(j) )  \n\t\n\t\n\treal*8 :: c1,c2,i1bar,i2bar,j,ri33, c3, c4\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\tc3 = matpar(3)\n\tc4 = matpar(4)\n\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\ti2bar = ri33*ri33*invc(2) ! i2bar\n\n!~ \tif(i1bar > c2) then\n!~ \t\tc1 = 0.0d0\n!~ \tend if\n\n!~ \tif(j > c4) then\n!~ \t\tc3 = 0.0d0\n!~ \tend if\n\n!~ \tc1 = c1/(j**2.0d0)\n!~ \tc3 = c3/(j**2.0d0)\n\t\n\tc1 = c1/j\n\tc3 = c3/j\n\t\n\t\n\tpsi = c1*(i1bar-3.0d0) + c3*(j - 1.0d0)**2.0d0\n\t\nend subroutine \n"}, {"instruction": "Write a Fortran subroutine named mooneyrivlindpsi to calculate the derivatives of psi with respect to i1 and i2. The subroutine takes 2 input parameters of type real*8 and outputs an array of real*8. The input parameters are c and matpar, and the output parameter is dpsi.", "input": "", "output": "subroutine mooneyrivlindpsi(dpsi,c,matpar) ! derivatives of psi with respect to i1 and i2\n \timplicit none\n\treal*8 , intent(out) :: dpsi(:)\n\treal*8 , intent(in) :: c(:,:),matpar(2)\n\treal*8 :: c1,c2\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\tdpsi(1) = c1\n\tdpsi(2) = c2\n\treturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named deriv_x to calculate the first and second derivatives with respect to x, given a 2D array f and a 1D array x. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 2 optional output parameters of type real.", "input": "", "output": "    subroutine deriv_x ( x, f, i, j, dfdx, d2fdx2 )\n    \n        implicit none\n        \n        integer, intent(in) :: i, j\n        real, intent(in) :: f(:,:), x(:)\n        real, intent(out), optional :: dfdx, d2fdx2\n        real :: dx\n    \n        integer :: nx, ny\n    \n        nx    = size ( f, dim = 1 )\n        ny    = size ( f, dim = 2 )\n\n        ! 2d\n        if(nx/=1)then\n\n            if(i .ne. 1 .and. i .ne. nx)then\n\n                dx = ( (x(i)-x(i-1)) + (x(i+1)-x(i)) ) / 2\n                dfdx = (f(i+1, j) - f(i-1, j)) / (2.0 * dx)\n                d2fdx2 = (f(i+1, j) - 2.0 * f(i,j) + f(i-1, j)) / dx**2\n\n            endif\n            \n            if(i .eq. 1)then\n\n                dx = ( (x(i+2)-x(i+1)) + (x(i+1)-x(i)) ) / 2\n                dfdx = (f(i+1, j) - f(i, j)) / dx\n                d2fdx2 = (f(i+2, j) - 2.0 * f(i+1,j) + f(i, j)) / dx**2\n\n            endif\n            \n            if(i .eq. nx)then\n\n                dx = ( (x(i)-x(i-1)) + (x(i-1)-x(i-2)) ) / 2\n                dfdx = (f(i, j) - f(i-1, j)) / dx\n                d2fdx2 = (f(i, j) - 2.0 * f(i-1,j) + f(i-2, j)) / dx**2\n\n            endif\n        !1d\n        else\n\n            dfdx = 0 \n            d2fdx2 = 0 \n\n        endif\n    \n    end subroutine deriv_x\n"}, {"instruction": "Create a Fortran subroutine named deriv_y to compute the first and second derivative of the function f with respect to y. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 2 output parameters of type real, which are optional.", "input": "", "output": "    subroutine deriv_y ( y, f, i, j, dfdy, d2fdy2 )\n\n        implicit none\n\n        integer, intent(in) :: i, j\n        real, intent(in) :: f(:,:), y(:)\n        real, intent(out), optional :: dfdy, d2fdy2\n\n        real :: dy\n        integer :: nx, ny\n\n        nx    = size ( f, dim = 1 )\n        ny    = size ( f, dim = 2 )\n\n        !2d\n        if(ny/=1)then\n            if(j .ne. 1 .and. j .ne. ny)then\n\n                dy = ( (y(j)-y(j-1)) + (y(j+1)-y(j)) ) / 2\n                dfdy = (f(i, j+1) - f(i, j-1)) / (2.0 * dy)\n                d2fdy2 = (f(i, j+1) - 2.0 * f(i,j) + f(i, j-1)) / dy**2\n            endif\n\n            if(j .eq. 1)then\n                dy = ( (y(j+2)-y(j+1)) + (y(j+1)-y(j)) ) / 2\n                dfdy = (f(i, j+1) - f(i, j)) / dy\n                d2fdy2 = (f(i, j+2) - 2.0 * f(i,j+1) + f(i, j)) / dy**2\n            endif\n\n\n            if(j .eq. ny)then\n                dy = ( (y(j)-y(j-1)) + (y(j-1)-y(j-2)) ) / 2\n                dfdy = (f(i, j) - f(i, j-1)) / dy\n                d2fdy2 = (f(i, j) - 2.0 * f(i,j-1) + f(i, j-2)) / dy**2\n            endif\n\n        !1d\n        else\n\n            dfdy = 0 \n            d2fdy2 = 0 \n\n        endif\n\n      end subroutine deriv_y\n"}, {"instruction": "Create a Fortran subroutine named deriv_xy to calculate the second derivative of a 2D function with respect to x and y. The subroutine takes 5 input arguments of types integer, integer, real array, real array, and real array, and 1 optional output argument of type real.", "input": "", "output": "      subroutine deriv_xy ( x, y, f, i, j, d2fdxy)\n\n      implicit none\n\n      integer, intent(in) :: i, j\n      real, intent(in) :: f(:,:), x(:), y(:)\n      real, intent(out), optional :: d2fdxy\n\n      real :: dx, dy\n      integer :: nx, ny\n\n      nx    = size ( f, dim = 1 )\n      ny    = size ( f, dim = 2 )\n\n      d2fdxy = 0.0\n\n      if(nx/=1 .and. ny/=1)then\n\n        if (i /= 1 .and. i /= nx .and. &\n            j /= 1 .and. j /= ny) then\n\n            dx = ( (x(i)-x(i-1)) + (x(i+1)-x(i)) ) / 2\n            dy = ( (y(j)-y(j-1)) + (y(j+1)-y(j)) ) / 2\n\n           d2fdxy = (f(i+1,j+1) - f(i-1,j+1) - f(i+1,j-1) + f(i-1,j-1) ) &\n              / (4.0 * dx * dy)\n\n        endif\n\n      endif\n\n\n      end subroutine deriv_xy\n"}, {"instruction": "```fortran\n  ! Define a Fortran subroutine named gaussinte_w to compute the Gauss-Hermite nodes and weights.\n  ! The subroutine takes 2 input parameters: an integer n and an array of double precision eps, and 2 output parameters: arrays of double precision x and w.\n  ! The subroutine computes the nodes and weights for Gauss-Hermite quadrature using the input integer n and double precision eps.\n  ! The nodes are stored in the array x and the weights are stored in the array w.\n  ! The subroutine uses the imperative tone and reflects the features of Fortran subroutine.\n  subroutine gaussinte_w(n, x, w, eps)\n    integer, intent(in) :: n\n    double precision, intent(out) :: x(1:n), w(1:n)\n    double precision, intent(in) :: eps\n    ...\n  end subroutine gaussinte_w\n```", "input": "", "output": "  subroutine gaussinte_w(n, x, w, eps)\n    integer, intent(in) :: n\n    double precision, intent(out) :: x(1:n), w(1:n)\n    double precision, intent(in) :: eps\n\n    integer :: m, i, l\n    double precision :: npai, tmp, dt\n    double precision :: p0, p1, p2\n    double precision :: q0, q1, q2\n\n    select case (n)\n      case (1)\n        x(1) = 0.0d0\n        w(1) = 2.0d0\n        return\n      case (2)\n        x(1) = -sqrt(1.0d0/3.0d0)\n        w(1) = 1.0d0\n        x(2) = -x(1)\n        w(2) = w(1)\n        return\n      case (3)\n        x(1) = -sqrt(0.6d0)\n        w(1) = 5.0d0/9.0d0\n        x(2) = 0.0d0\n        w(2) = 8.0d0/9.0d0\n        x(3) = -x(1)\n        w(3) = w(1)\n        return\n    end select\n\n    m = n / 2\n    npai = pai / (dble(n) + 0.5d0)\n    do i = 1, m\n      tmp = cos((i - 0.25d0) * npai)\n      dt = tmp\n      do while (abs(dt) > abs(tmp) * eps)\n        p1 = tmp\n        p2 = (3.0d0 * tmp**2 - 1.0d0) * 0.5d0\n        q1 = 1.0d0\n        q2 = 3.0d0 * tmp\n        do l = 3, n\n          p0 = p1\n          p1 = p2\n          p2 = ((l + l - 1) * tmp * p1 - (l-1) * p0) / l\n          q0 = q1\n          q1 = q2\n          q2 = ((l + l - 1) * (tmp * q1 + p1) - (l-1) * q0) / l\n        end do\n        dt = p2 / q2\n        tmp = tmp - dt\n      end do\n      x(i) = tmp\n      w(i) = 2.0d0 / (n * p1 * q2)\n    end do\n\n    if (mod(n, 2) == 1) then\n      tmp = dble(n)\n      do i = 1, m\n        tmp = tmp * (0.5d0 - i) / dble(i)\n      end do\n      x(m+1) = 0.0d0\n      w(m+1) = 2.0d0 / tmp**2\n    end if\n\n    do i = 1, m\n      x(n+1-i) = x(i)\n      x(i) = -x(i) ! reverse order\n      w(n+1-i) = w(i)\n    end do\n  end subroutine gaussinte_w\n"}, {"instruction": "Create a Fortran subroutine named double_scalar_par_max to assign the input real(kind=8) value to the output real(kind=8) value. The number of input arguments is 1 with the test_data type ['real(kind=8)'], and the number of output arguments is 1 with the test_data type ['real(kind=8)']. Use the intent(in) attribute for the input parameter and the intent(out) attribute for the output parameter.", "input": "", "output": "  subroutine double_scalar_par_max(xxl,xxg)\n\n    real(kind=8), intent(out) :: xxg\n    real(kind=8), intent(in) :: xxl\n\n    xxg=xxl\n\n  end subroutine double_scalar_par_max\n"}, {"instruction": "Write a Fortran subroutine named double_scalar_par_sum to assign the value of the input real number to the output real number. The number of input arguments is 1 and the test_data type is real(kind=8). The number of output arguments is 1 and the test_data type is real(kind=8).", "input": "", "output": "  subroutine double_scalar_par_sum(xxl,xxg)\n\n    real(kind=8), intent(out) :: xxg\n    real(kind=8), intent(in) :: xxl\n\n    xxg=xxl\n\n  end subroutine double_scalar_par_sum\n"}, {"instruction": "Write a Fortran subroutine named double_array_par_sum that copies the elements of an input real(kind=8) array xxl to an output real(kind=8) array xxg. The number of input arguments is 2 and the test_data type is [integer, real(kind=8)]. The number of output arguments is 1 and the test_data type is [real(kind=8)].", "input": "", "output": "  subroutine double_array_par_sum(xxl,xxg,n)\n\n    integer, intent(in)::n\n    real(kind=8), intent(out) :: xxg(n)\n    real(kind=8), intent(in) :: xxl(n)\n\n    xxg=xxl\n\n  end subroutine double_array_par_sum\n"}, {"instruction": "Create a Fortran subroutine named dft to perform a Discrete Fourier Transform. The subroutine takes 2 input parameters of type integer and double precision and 1 output parameter of type double precision. The input parameters are m (integer) and f (array of double precision), and the output parameter is fhat (array of double precision). The subroutine calculates the Fourier transform of the input function f and stores the result in fhat, utilizing double precision arithmetic for accuracy. Make sure to include the intent attribute for input and output parameters as per the code provided.", "input": "", "output": "        subroutine dft(m, f, fhat)\r\n            integer,          intent(in)  :: m\r\n            double precision, intent(in)  :: f(m)       ! function in real space\r\n            double precision, intent(out) :: fhat(2*m)  ! function in fourier space\r\n            double precision              :: fac, arg\r\n            integer                       :: k, l\r\n            double precision              :: sfac       ! normalization factor\r\n\r\n            fhat = 0.d0\r\n            fac = twopi / dble(m)\r\n\r\n            do k = 0, m - 1\r\n                do l = 0, m - 1\r\n                    arg = fac * dble(k * l)\r\n                    fhat(k+1)   = fhat(k+1)   + f(l+1) * dcos(arg)\r\n                    fhat(k+1+m) = fhat(k+1+m) - f(l+1) * dsin(arg)\r\n                enddo\r\n            enddo\r\n\r\n            sfac = one / dsqrt(dble(m))\r\n\r\n            fhat = fhat * sfac\r\n\r\n        end subroutine dft\r\n"}, {"instruction": "Create a Fortran subroutine named calc that takes in 4 input parameters: nx (integer), ny (integer), a (2D array of real numbers), and b (2D array of real numbers). It also has 1 output parameter: c (2D array of real numbers). The subroutine performs a computation using the input arrays a and b, and stores the result in the array c. The computation involves adding the corresponding elements of arrays a and b to the elements of array c. The subroutine utilizes OpenACC directives for parallel processing.", "input": "", "output": "  subroutine calc(nx, ny, a, b, c)\n    implicit none\n    integer,intent(in) :: nx,ny\n    real(kind=4),dimension(:,:),intent(in)  :: a,b\n    real(kind=4),dimension(:,:),intent(out) :: c\n    integer :: i,j\n\n    !$acc kernels present(a,b,c)\n    !$acc loop independent\n    do j = 1,ny\n       !$acc loop independent\n       do i = 1,nx\n          c(i,j) = c(i,j) + a(i,j) + b(i,j)\n       end do\n    end do\n    !$acc end kernels\n\n  end subroutine calc\n"}, {"instruction": "Create a Fortran subroutine called init_cpu that initializes a 2D array 'a' with values of 1.0. The subroutine takes two input parameters of type integer, nx and ny, and one output parameter, a, which is a 2D array of real numbers.", "input": "", "output": "  subroutine init_cpu(nx, ny, a)\n    implicit none\n    integer,intent(in) :: nx,ny\n    real(kind=4),dimension(:,:),intent(out)  :: a\n    integer :: i,j\n\n    do j = 1, ny\n       do i = 1, nx\n          a(i,j) = 1.0\n       end do\n    end do\n  end subroutine init_cpu\n"}, {"instruction": "Create a Fortran subroutine named system__getenv to retrieve the value of the specified environment variable. The subroutine should have 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "  subroutine system__getenv( name, value )\n\n    character(*), intent(in)  :: name\n    character(*), intent(out) :: value\n    !----\n    \n    call get_environment_variable( name, value )\n    \n  end subroutine system__getenv\n"}, {"instruction": "Create a Fortran subroutine named \"strassen\" to perform matrix multiplication using the Strassen algorithm. The subroutine takes 3 input parameters of type integer, double precision, and double precision and 1 output parameter of type double precision.", "input": "", "output": "  recursive subroutine strassen (a, b, c, n)\n    integer, intent(in) :: n\n    double precision, intent(in) :: a(n,n), b(n,n)\n    double precision, intent(out) :: c(n,n)\n    double precision :: t(n/2,n/2,7)\n    integer :: k, l\n\n    if (iand (n,1) .ne. 0 .or. n < 64) then\n      c = matmul (a, b)\n      return\n    end if\n    k = n / 2\n    l = n / 2 + 1\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k) + a(l:,l:), b(:k,:k) + b(l:,l:), t(:,:,1), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,:k) + a(l:,l:), b(:k,:k), t(:,:,2), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k), b(:k,l:) - b(l:,l:), t(:,:,3), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,l:), b(l:,:k) - b(:k,:k), t(:,:,4), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,:k) + a(:k,l:), b(l:,l:), t(:,:,5), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(l:,:k) - a(:k,:k), b(:k,:k) + b(:k,l:), t(:,:,6), k)\n!$omp end task\n!$omp task shared (a, b, t)\n    call strassen (a(:k,l:) - a(l:,l:), b(l:,:k) + b(l:,l:), t(:,:,7), k)\n!$omp end task\n!$omp taskwait\n    c(:k,:k) = t(:,:,1) + t(:,:,4) - t(:,:,5) + t(:,:,7)\n    c(l:,:k) = t(:,:,2) + t(:,:,4)\n    c(:k,l:) = t(:,:,3) + t(:,:,5)\n    c(l:,l:) = t(:,:,1) - t(:,:,2) + t(:,:,3) + t(:,:,6)\n  end subroutine strassen\n"}, {"instruction": "Write a Fortran subroutine named `mop1_circles` that calculates fitness values for multiple objectives and violation count. The subroutine takes 3 input parameters of type integer, integer, and real and returns 2 output parameters of type real and integer. The input parameters are `nf` (number of fitness values), `np` (number of individuals), and `indv` (array of individuals). The output parameters are `fit` (array of fitness values) and `viol` (violation count). The subroutine computes fitness values for two objectives based on the input `indv` and assigns them to `fit`. It sets `viol` to 0.", "input": "", "output": "subroutine mop1_circles(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\tfit(1) = indv(1)**2 + indv(2)**2\n\tfit(2) = (indv(1)-2.0)**2 + (indv(2)-2.0)**2\n\tviol = 0\nend subroutine mop1_circles\n"}, {"instruction": "Create a Fortran subroutine named mop2_fonseca to calculate fitness and violation for a multi-objective optimization problem. The subroutine takes 3 input parameters: two integers nf and np, and an array of real numbers indv with size np. It returns 2 output parameters: an array of real numbers fit with size nf and an integer viol.", "input": "", "output": "subroutine mop2_fonseca(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\tfit(1) = 1-exp(-((indv(1)- 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(2) - 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(3) - 1.0/(3.0)**0.5)**2.0));\n\tfit(2) = 1-exp(-((indv(1)+ 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(2) + 1.0/(3.0)**0.5)**2.0 + &\n\t\t\t\t\t(indv(3) + 1.0/(3.0)**0.5)**2.0));\n\tviol = 0\nend subroutine mop2_fonseca\n"}, {"instruction": "Create a Fortran subroutine named \"mop3_poloni\" to calculate the fitness and violation for a multi-objective optimization problem. The subroutine takes 3 input parameters of type integer, integer, and real and returns 2 output parameters of type real and integer. The subroutine performs computations using the input parameters and constants, and assigns the results to the output parameters.", "input": "", "output": "subroutine mop3_poloni(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: \ta1 = 0.873648562314064, &\t!= 0.5*sin(1)-2*cos(1)+sin(2)-1.5*cos(2)\n\t\t\ta2 = 2.748572443268639, &\t!=1.5*sin(1)-cos(1)+2*sin(2)-.5*cos(2)\n\t\t\tx, y ,b1, b2\n\t\n\tx = indv(1)\n\ty = indv(2)\n\tb1 = 0.5*sin(x) - 2.0*cos(x) + sin(y) - 1.5*cos(y)\n\tb2 = 1.5*sin(x) - cos(x) + 2.0*sin(y) - 0.5*cos(y)\n\n\tfit(1) = (1 + (a1-b1)**2 + (a2-b2)**2)\n\tfit(2) = ((x+3)**2 + (y+1)**2)\n\t\n\tviol = 0\nend subroutine mop3_poloni\n"}, {"instruction": "Create a Fortran subroutine named mop5_viennet to evaluate the Viennet multi-objective test problem. This subroutine takes 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer. The input parameters represent the number of functions and the number of decision variables, as well as the array of decision variables. The output parameters represent the array of objective function values and the violation count.", "input": "", "output": "subroutine mop5_viennet(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: x, y, temp\n\n\ty = indv(2)\n\tx = indv(1)\n\ttemp = x**2+y**2\n\t\n\tfit(1) = 0.5 * temp + sin(temp)\n\tfit(2) = (3.0*x-2.0*y+4.0)**2.0/8.0 + &\n\t\t\t (x-y+1.0)**2.0/27.0 + 15.0\n\tfit(3) = 1.0 / (temp+1.0) - 1.1*exp(-temp)\n\n\tviol = 0\nend subroutine mop5_viennet\n"}, {"instruction": "Create a Fortran subroutine named \"zdt3_10d\" to calculate the fitness and violation of a 10-dimensional problem. The subroutine should take 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer.", "input": "", "output": "subroutine zdt3_10d(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: r\n\tinteger::dims = 10, i\n\treal, parameter:: pi = 3.141592653589793\n\n\n\tfit(1) = indv(1)\n\t\n\tr = 0.0\n\t\n\tdo i = 2, dims\n\t\tr = r + indv(i)\n\tend do\n\t\n\tfit(2) = (1.0+9.0*r/(dims-1)) * &\n\t\t\t(1-sqrt(indv(1)/(1.0+9.0*r/(dims-1))) - &\n\t\t\t(indv(1)/(1.0+9.0*r/(dims-1)))*sin(10.0*pi*indv(1)));\n\n\tviol = 0\nend subroutine zdt3_10d\n"}, {"instruction": "Develop a Fortran subroutine named \"mop_c4_tanaka\" that takes 3 input arguments of type integer, integer, and real, and 2 output arguments of type real and integer. The subroutine computes the values of \"fit\" and \"viol\" based on the input \"indv\", \"nf\", and \"np\". Ensure that \"fit(1)\" and \"fit(2)\" are assigned values from \"indv(1)\" and \"indv(2)\" respectively. The \"viol\" variable is set to 0, and then updated to 1 if a certain condition involving \"indv(1)\" and \"indv(2)\" is met.", "input": "", "output": "subroutine mop_c4_tanaka(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal:: a, b\n\t\n\ta = 0.1\n\tb = 16.0\n\n\tfit(1) = indv(1)\n\tfit(2) = indv(2)\n\n\tviol = 0\n\tif (- indv(1)**2.0 - indv(2)**2.0 + 1.0 + &\n\t\ta * cos(b*atan(indv(1)/indv(2)))>0.0) viol = 1\nend subroutine \tmop_c4_tanaka\n"}, {"instruction": "Create a Fortran subroutine named c1 that takes an array of real numbers as input and returns the size of the array as an integer. The input parameter is of type real, dimension(:) and intent(in), and the output parameter is of type integer and intent(out).", "input": "", "output": "          subroutine c1(f,cs)\n            real, dimension(:), intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=size(f)\n          end subroutine c1\n"}, {"instruction": "Create a Fortran subroutine named c2 that takes a 2D array of real numbers as input and returns the size of the array as an integer. The input parameter is of type real, dimension(:,:), and is passed by intent(in). The output parameter is of type integer and is passed by intent(out).", "input": "", "output": "          subroutine c2(f,cs)\n            real, dimension(:,:), intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=size(f)\n          end subroutine c2\n"}, {"instruction": "Create a Fortran subroutine named \"cn\" to assign the value 0 to an integer output parameter \"cs\" based on a single real input parameter \"f\".", "input": "", "output": "          subroutine cn(f,cs)\n            real, intent(in) :: f\n            integer, intent(out) :: cs\n\n            cs=0\n          end subroutine cn\n"}, {"instruction": "Create a Fortran subroutine named niching_func_bound_cons to set boundary constraints for a given function. The subroutine takes 2 input parameters of type integer and outputs a double precision array of dimensions (dims,2). The subroutine uses a select case statement to assign specific boundary values based on the input 'func' and 'dims' values. Ensure proper initialization of the 'bounds' array within the subroutine for different function cases.", "input": "", "output": "      subroutine niching_func_bound_cons(func, dims, bounds)\n\n      implicit none\n\n      integer, intent(in):: func, dims\n      double precision, intent(out), dimension(dims,2):: bounds\n\n      select case(func)\n      case(10)\n       bounds(:,1)=0.0d0\n       bounds(:,2)=1.0d0\n      case(11,12)\n       bounds(:,1)=-6.0d0\n       bounds(:,2)=6.0d0\n      case(13,14,15,16,17,18)\n       bounds(:,1)=0.0d0\n       bounds(:,2)=2.0d0\n      case(20)\n       bounds(:,1)=-100.0d0\n       bounds(:,2)=100.0d0\n      case(21)\n       bounds(:,1)=0.5d0\n       bounds(:,2)=4.5d0\n      case(30:39)\n       bounds(:,1)=-dble(dims+1)\n       bounds(:,2)=dble(dims+1)\n      case default\n       bounds(:,1)=-dble(dims+1)\n       bounds(:,2)=dble(dims+1)\n      end select\n\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"cmmp\" with the following functionality: \n1. Accept 3 input parameters of type integer, integer, and double precision and 2 output parameters of type double precision. \n2. The subroutine computes objective value \"f\" and constraint values \"g\" based on the input values \"n\", \"j\", and \"x\". \n3. The objective value \"f\" is calculated as the sum of squares of the elements in the array \"x\". \n4. The constraint values \"g\" are computed based on the array \"x\" and other calculations using the input parameters.", "input": "", "output": "      subroutine cmmp(n, j, x, f, g)\n      implicit none\n!     from deb and saha, gecco2010\n      integer, intent(in):: n, j\n      double precision, intent(in):: x(n)\n      double precision, intent(out):: f, g(j)\n!     note: l not currently used\n      integer:: i, jj, ii, c\n      integer, allocatable, dimension(:):: cvec\n\n!     objective\n      f=0.0d0\n      do i=1,n\n        f=f+x(i)**2\n      end do\n\n!     constraints\n      allocate(cvec(j*n))\n      ii=0\n      do jj=1,j\n       do i=1,n\n         ii=ii+1\n         cvec(ii)=i\n       end do\n      end do\n      ii=1\n      do jj=1,j\n        ii=ii-1\n        g(jj)=0.0d0\n        do i=1,n\n            ii=ii+1\n            c=cvec(ii)\n            g(jj)=g(jj)+(dble(c)**2 * x(i)**2)\n        end do\n        g(jj)=n**2 - g(jj)\n      end do\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named empirical_relation to calculate the compressional velocity (vpz) and density (rhoz) based on the input shear velocity (vsz). The subroutine takes 1 input parameter of type real(c_float) and returns 2 output parameters of type real(c_float).", "input": "", "output": "subroutine empirical_relation(vsz,vpz,rhoz)bind(c,name=\"empirical_relation\")\n  use,intrinsic :: iso_c_binding\n\n  real(c_float), intent(in) ::  vsz\n  real(c_float),intent(out) ::vpz,rhoz\n\n  vpz=0.9409 + 2.0947*vsz - 0.8206*vsz**2+ &\n          0.2683*vsz**3 - 0.0251*vsz**4\n  rhoz=1.6612*vpz- 0.4721*vpz**2 + &\n          0.0671*vpz**3 - 0.0043*vpz**4 + & \n          0.000106*vpz**5\n  \nend subroutine empirical_relation\n"}, {"instruction": "Write a Fortran subroutine named hinitu to initialize the heap programs with the pointer array t(1) pointing to the top of the heap. The number of input arguments is 2, both of integer type. The number of output arguments is 2, both of integer type. The subroutine initializes the heap with the maximum number of nodes and the number of words per node. Upon completion, it sets the current number of nodes in the heap to 0 and updates the integer array of pointers to the heap nodes. The subroutine uses the imperative tone and Fortran features.", "input": "", "output": "subroutine hinitu(nmax, nwds, n, t)\r\n\r\n!     purpose:\r\n!       initialize the heap programs with t(1) pointing to the top of\r\n!       the heap.   it is called once, at the start.\r\n\r\n!     input:\r\n!     nmax = maximum number of nodes.\r\n!     nwds = number of words per node.\r\n\r\n!     output:\r\n!     n = 0 (to hold current number of nodes in heap)\r\n!     t = integer array of pointers to the heap nodes.\r\n\r\nimplicit none\r\ninteger, intent(in)  :: nmax, nwds\r\ninteger, intent(out) :: n, t(:)\r\n\r\n!     local variable.\r\n\r\ninteger :: i\r\n\r\ndo i = 1, nmax\r\n  t(i) = (i-1)*nwds + 1\r\nend do\r\nn = 0\r\nreturn\r\nend subroutine hinitu\r\n"}, {"instruction": "Create a Fortran subroutine named check_file that takes two input parameters of type integer, nfac and n, and one output parameter of type logical, file_exist. The subroutine checks for the existence of a file named \"file_chk\" and sets file_exist to true if a specific condition is met within the file.", "input": "", "output": "  subroutine check_file( nfac, n, file_exist )\n    implicit none\n    integer,intent(in) :: nfac, n\n    logical,intent(out) :: file_exist\n    integer,parameter :: u=80\n    character(8),parameter :: file_name=\"file_chk\"\n    integer,parameter :: ndata_max=10000\n    integer :: nfac_tmp, n_tmp, i\n    logical :: flag\n    file_exist=.false.\n    inquire( file=file_name, exist=flag )\n    if ( flag ) then\n       open(u,file=file_name,status=\"old\")\n       read(u,*) nfac_tmp\n       if ( nfac_tmp == nfac ) then\n          do i=1,ndata_max\n             read(u,*,end=10) n_tmp\n             if ( n_tmp == n ) then\n                file_exist = .true.\n                exit\n             end if\n          end do\n10        continue\n       end if\n       close(u)\n    end if\n  end subroutine check_file\n"}, {"instruction": "Create a Fortran subroutine named dist to calculate the minimum distance between two 3D points considering periodic boundary conditions. The subroutine takes 3 input parameters of type real(8) for x1, x2, and b, and 1 output parameter of type real(8) for the minimum distance.", "input": "", "output": "        subroutine dist(x1,x2,b,d)\n        implicit none\n        real(8),intent(in)    :: x1(3)\n        real(8),intent(in)    :: x2(3)\n        real(8),intent(in)    :: b(3)\n        real(8),intent(out)   :: d\n        real(8)               :: bd(3)\n        integer(4)    :: i,j,k\n\n        d=huge(d)\n        do i=-1,1\n          do j=-1,1\n            do k=-1,1\n              bd(1)=i*b(1)\n              bd(2)=j*b(2)\n              bd(3)=k*b(3)\n              d=min(d,sqrt(sum((x1-x2+bd)**2)))\n            enddo\n          enddo\n        enddo\n\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named submatrix_smdim_multi that calculates the dimension of a submatrix based on the input metadim, meta, and insm arrays. The number of input parameters is 3 with test_data type ['integer(4)', 'integer(4)', 'integer(4)'], and the number of output parameters is 1 with test_data type ['integer(4)'].", "input": "", "output": "        subroutine submatrix_smdim_multi(metadim,meta,insm,smdim)\n        implicit none\n        integer(4),intent(in)   :: metadim\n        integer(4),intent(in)   :: meta(metadim,metadim)\n        integer(4),intent(in)   :: insm(metadim)\n        integer(4),intent(out)   :: smdim\n        integer(4)    :: is,js,ib,jb,a,b,i,j,iatom,jatom\n\n        smdim=0\n        do i=1,metadim\n          do j=1,metadim\n            if(insm(j).eq.1)then\n              if(meta(i,j).eq.1)then\n                smdim=smdim+1\n                exit\n              endif\n            endif\n          enddo\n        enddo\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named gsffmtnum to format a double precision value based on its size. The subroutine takes 1 input parameter of type double precision and returns 1 output parameter of type character(len=*).", "input": "", "output": "      subroutine gsffmtnum(val, strng)\n!     ******************************************************************\n!     format value based on value size\n!     ******************************************************************\n      implicit none\n      intrinsic abs, int\n! arguments\n      double precision, intent(in) :: val\n      character(len=*), intent(out) :: strng\n! local variables\n      double precision, parameter :: big = 1.0d07, small = 0.01d0\n      double precision :: absval\n!***********************************************************************\n      absval = abs(val)\n      if ( absval<1.0d-5 ) then\n!       write (strng, '(i18)') int(val)\n        strng = ' '\n      elseif ( absval>big .or. absval<small ) then\n        write (strng, '(1pd18.4)') val\n      else\n        write (strng, '(f18.2)') val\n      endif\n      end subroutine gsffmtnum\n"}, {"instruction": "Write a Fortran subroutine named bxv to compute the matrix-vector product y = b * v. The subroutine takes 4 input parameters: n (integer), k (integer), v (real(kind=8) array of dimension n), b (real(kind=8) array of dimension n x k). It produces 1 output parameter: y (real(kind=8) array of dimension n).", "input": "", "output": "    subroutine bxv(k, n, b, v, y)\n!=======================================================================\n!\n!   computes   y = b * v    where b is a symmetric, banded matrix,\n!   in lower-band storage mode,  and v, y are vectors.\n!\n!-----------------------------------------------------------------------\n!\n!   on entry\n!   --------\n!       k       the number of diagonals\n!       n       the order of the matrix\n!       b       the symmetric, banded matrix in column storage mode\n!       v       vector\n!\n!   on exit\n!   -------\n!       y       y = b*v\n!\n!-----------------------------------------------------------------------\n\n       implicit none\n\n       integer, intent(in) :: n, k\n       real(kind=8), dimension(n), intent(in) ::v\n       real(kind=8), dimension(n, k), intent(in) ::b\n       real(kind=8), dimension(n), intent(out) :: y\n\n       ! .. local variables\n\n       integer :: i, j, jp\n\n! ...   contribution from central diagonal (jp=k)\n\n       do i = 1, n\n          y(i) = b(i, k)*v(i)\n       end do\n\n! ...   off diagonal\n\n       do jp = 1, k - 1\n          do i = k - jp + 1, n\n             j = i - k + jp\n             y(i) = y(i) + b(i, jp)*v(j)             ! sub_diagonals\n             y(j) = y(j) + b(i, jp)*v(i)             ! super-diagonals\n          end do\n       end do\n\n    end subroutine bxv\n"}, {"instruction": "Create a Fortran subroutine named setup2 to set up the i-th row of an augmented regression matrix for a weighted least-squares fit of a quadratic function. The subroutine takes 9 input parameters of type real: xk, yk, fk, xi, yi, fi, s1, s2, r, and outputs 1 parameter of type real: row(6).", "input": "", "output": "subroutine setup2(xk,yk,fk,xi,yi,fi,s1,s2,r,row)\r\nreal, intent(in)   :: xk, yk, fk, xi, yi, fi, s1, s2, r\r\nreal, intent(out)  :: row(6)\r\n\r\n!***********************************************************\r\n\r\n!                                                robert renka\r\n!                                        univ. of north texas\r\n!                                              (817) 565-2767\r\n\r\n!   this routine sets up the i-th row of an augmented regression matrix for a\r\n! weighted least-squares fit of a quadratic function q(x,y) to a set of data\r\n! values f, where q(xk,yk) = fk.  the first 3 columns (quadratic terms) are\r\n! scaled by 1/s2 and the fourth and fifth columns (linear terms) are scaled\r\n! by 1/s1.  the weight is (r-d)/(r*d) if r > d and 0 if r <= d, where d\r\n! is the distance between nodes i and k.\r\n\r\n! on input --\r\n\r\n!        xk,yk,fk = coordinates and data value at node k -- interpolated by q.\r\n\r\n!        xi,yi,fi = coordinates and data value at node i.\r\n\r\n!        s1,s2 = reciprocals of the scale factors.\r\n\r\n!        r = radius of influence about node k defining the weight.\r\n\r\n!        row = array of length 6.\r\n\r\n! input parameters are not altered by this routine.\r\n\r\n! on output --\r\n\r\n!        row = vector containing a row of the augmented regression matrix.\r\n\r\n! modules required by setup2 -- none\r\n\r\n! intrinsic function called by setup2 -- sqrt\r\n\r\n!***********************************************************\r\n\r\nreal  :: d, dx, dy, dxsq, dysq, w, w1, w2\r\n\r\n! local parameters -\r\n\r\n! i =         do-loop index\r\n! dx =         xi - xk\r\n! dy =         yi - yk\r\n! dxsq = dx*dx\r\n! dysq = dy*dy\r\n! d =         distance between nodes k and i\r\n! w =         weight associated with the row\r\n! w1 =         w/s1\r\n! w2 =         w/s2\r\n\r\ndx = xi - xk\r\ndy = yi - yk\r\ndxsq = dx * dx\r\ndysq = dy * dy\r\nd = sqrt(dxsq+dysq)\r\nif (d > 0. .and. d < r) then\r\n  w = (r-d) / r / d\r\n  w1 = w / s1\r\n  w2 = w / s2\r\n  row(1) = dxsq * w2\r\n  row(2) = dx * dy * w2\r\n  row(3) = dysq * w2\r\n  row(4) = dx * w1\r\n  row(5) = dy * w1\r\n  row(6) = (fi-fk) * w\r\n  return\r\nend if\r\n\r\n! nodes k and i coincide or node i is outside of the radius of influence.\r\n!   set row to the zero vector.\r\n\r\nrow(1:6) = 0.\r\n\r\nreturn\r\nend subroutine setup2\r\n"}, {"instruction": "Write a Fortran subroutine named matrixinverse to compute the inverse of a square matrix. The subroutine takes 2 input arguments of type integer and real, and 1 output argument of type real. The input arguments are the size of the square matrix and the matrix itself, while the output argument is the inverse of the matrix. The subroutine utilizes forward elimination, row swapping, and back substitution algorithms to compute the inverse.", "input": "", "output": "subroutine matrixinverse(n, a, ia)\n        implicit none\n        ! argument list\n        integer, intent(in)   :: n\n        real, intent(in)  :: a(n,n)\n        real, intent(out) :: ia(n,n)\n        ! local variables\n        integer  :: i,j,ml(1)\n        real :: piv\n        real :: temp(2*n)\n        real :: c(2*n,n)\n\n        c(1:n,:)     = transpose(a)\n        c(n+1:2*n,:) = 0.0\n\n        do i = 1, n\n            c(n+i,i) = 1.0\n        end do\n\n        ! forward elimination and row swapping (if necessary)\n\n        do i = 1, n\n\n            ! if pivot element is zero, then swap rows\n\n            ml = maxloc(abs(c(i,i:n)))\n            j = i - 1 + ml(1)\n            temp   = c(:,j)\n            c(:,j) = c(:,i)\n            c(:,i) = temp\n\n            if (abs(c(i,i)) .le. 1.0e-15) then\n                print *, 'error. matrix is singular!'\n                do j = 1, n\n                    print *, a(j,:)\n                end do\n                stop\n            end if\n\n            piv    = 1.0/c(i,i)\n            c(:,i) = c(:,i)*piv\n\n            do j = i+1, n\n                c(:,j) = c(:,j) - c(i,j)*c(:,i)\n            end do\n        end do\n\n        ! back substitution\n\n        do i = n,1,-1\n            do j = i-1,1,-1\n                c(:,j) = c(:,j) - c(i,j)*c(:,i)\n            end do\n        end do\n\n        ia = transpose( c(n+1:2*n,:) )\n\nend subroutine matrixinverse\n"}, {"instruction": "Create a Fortran subroutine named matrix_exp to calculate the exponential of a matrix. The subroutine takes 4 input parameters of type integer, integer, integer, real*8 and 1 output parameter of type real*8. The input parameters are n, j, k, and m(n,n), while the output parameter is em(n,n).", "input": "", "output": "subroutine matrix_exp(m, n, j, k, em)\n    integer, intent(in)  :: n, j, k\n    real*8, intent(in)   :: m(n,n)\n    real*8, intent(out)   :: em(n,n)\n\n    real *8 :: tc(j+1), sm(n,n)\n    integer p, i\n    tc(1)=1\n    do i=1,j\n       tc(i+1)=tc(i)/dble(i)\n    enddo\n\n    !scale\n    sm=m*(1./2.**k)\n    em=0.\n    do i=1,n\n       em(i,i)=tc(j+1)\n    enddo\n\n    !taylor exp of scaled matrix\n    do p=j,1,-1\n       em=matmul(sm,em);\n       do i=1,n\n          em(i,i)=em(i,i)+tc(p)\n       enddo\n    enddo\n\n    !square\n    do p=1,k\n       em=matmul(em,em)\n    enddo\n\nend subroutine matrix_exp\n"}, {"instruction": "Create a Fortran subroutine named do_loop to assign the same real value to each element of a one-dimensional real array. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real, dimension(:)].", "input": "", "output": "subroutine do_loop( array, value )\n    real, dimension(:), intent(out) :: array\n    real, intent(in)                :: value\n\n    integer                         :: i\n\n    do i = 1,size(array)\n        array(i) = value\n    enddo\nend subroutine do_loop\n"}, {"instruction": "Create a Fortran subroutine named array_op. The subroutine takes 1 input parameter of type real and an output parameter of type real array. The input parameter is marked with intent(in) and the output parameter is marked with intent(out). The subroutine assigns the input value to all elements of the output array.", "input": "", "output": "subroutine array_op( array, value )\n    real, dimension(:), intent(out) :: array\n    real, intent(in)                :: value\n\n    array = value\nend subroutine array_op\n"}, {"instruction": "Create a Fortran subroutine named c_f_pointer_scalar that takes an integer pointer as input and an integer pointer as output. The function should assign the value of the input pointer to the output pointer using the \"=>\" pointer assignment.", "input": "", "output": "    subroutine c_f_pointer_scalar (cptr, fptr)\n\n        integer, pointer , intent(in):: cptr  ! use pointer of any type here\n        integer, pointer , intent(out):: fptr  ! use pointer of any type here\n\n        fptr => cptr\n    end subroutine c_f_pointer_scalar\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_aw_surface_derivative. It takes 4 input arguments of type integer: ia, l, io, and dm. It also has 1 output argument of type real(8) named deriv. This subroutine is meant to be bound to a C function named \"sirius_get_aw_surface_derivative\" and is used to compute the derivative of the augmented wave (AW) basis function on the surface.", "input": "", "output": "        subroutine sirius_get_aw_surface_derivative(ia, l, io, dm, deriv)&\n            &bind(c, name=\"sirius_get_aw_surface_derivative\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: l\n            integer,                 intent(in)  :: io\n            integer,                 intent(in)  :: dm\n            real(8),                 intent(out) :: deriv\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_find_fft_grid_size that calculates the grid size for fast Fourier transform (FFT) based on the given cutoff and lattice vectors. The subroutine takes 2 input parameters of type real(8) and returns 1 output parameter of type integer.", "input": "", "output": "        subroutine sirius_find_fft_grid_size(cutoff, lat_vec, grid_size)&\n            &bind(c, name=\"sirius_find_fft_grid_size\")\n            real(8),                 intent(in)  :: cutoff\n            real(8),                 intent(in)  :: lat_vec\n            integer,                 intent(out) :: grid_size\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sirius_get_band_energies\" that retrieves band energies for a specific k-point, spin, and kset. The subroutine should have 3 input parameters of type integer representing kset_id, ik, and ispn, and 1 output parameter of type real(8) to store the band energies. Use the \"bind\" attribute to ensure compatibility with C.", "input": "", "output": "        subroutine sirius_get_band_energies(kset_id, ik, ispn, band_energies)&\n            &bind(c, name=\"sirius_get_band_energies\")\n            integer,                 intent(in)  :: kset_id\n            integer,                 intent(in)  :: ik\n            integer,                 intent(in)  :: ispn\n            real(8),                 intent(out) :: band_energies\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_energy_fermi to retrieve the Fermi energy for a given k-point set. The subroutine should have 1 input parameter of type integer and 1 output parameter of type real(8). The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [real(8)]. Use the \"bind(c, name=\"sirius_get_energy_fermi\")\" directive to bind the subroutine to a C-compatible name.", "input": "", "output": "        subroutine sirius_get_energy_fermi(kset_id, efermi)&\n            &bind(c, name=\"sirius_get_energy_fermi\")\n            integer,                 intent(in) :: kset_id\n            real(8),                 intent(out) :: efermi\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_gvec_index to retrieve the index of a grid point in the g-vector data structure. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is marked as intent(in) and the output parameter is marked as intent(out).", "input": "", "output": "        subroutine sirius_get_gvec_index(gvec, ig)&\n            &bind(c, name=\"sirius_get_gvec_index\")\n            integer,                  intent(in)  :: gvec(3)\n            integer,                  intent(out) :: ig\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_global_kpoint_index that takes two input parameters of type integer, kset_id and ikloc, and one output parameter of type integer, ik. This subroutine is intended to retrieve the global index of a k-point specified by kset_id and ikloc. Use the bind(c, name=\"sirius_get_global_kpoint_index\") attribute for interoperability with C.", "input": "", "output": "        subroutine sirius_get_global_kpoint_index(kset_id, ikloc, ik)&\n            &bind(c, name=\"sirius_get_global_kpoint_index\")\n            integer,                  intent(in)  :: kset_id\n            integer,                  intent(in) :: ikloc\n            integer,                  intent(out)  :: ik\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_max_num_gkvec to retrieve the maximum number of G+k vectors for a given kset. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The name of the subroutine is sirius_get_max_num_gkvec.", "input": "", "output": "        subroutine sirius_get_max_num_gkvec(kset_id, max_num_gkvec)&\n            &bind(c, name=\"sirius_get_max_num_gkvec\")\n            integer,                 intent(in)  :: kset_id\n            integer,                 intent(out) :: max_num_gkvec\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sirius_get_aw_radial_function\" to retrieve the radial atomic wavefunction for a specific atom, angular momentum, and atomic orbital index. The subroutine should have 3 input parameters of type integer and 1 output parameter of type real(8).", "input": "", "output": "        subroutine sirius_get_aw_radial_function(ia, l, io, f)&\n            &bind(c, name=\"sirius_get_aw_radial_function\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: l\n            integer,                 intent(in)  :: io\n            real(8),                 intent(out) :: f\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_lo_radial_function to retrieve a specific radial function for a given atom and local orbital index. The subroutine should have 2 input parameters of type integer and 1 output parameter of type real(8).", "input": "", "output": "        subroutine sirius_get_lo_radial_function(ia, idxlo, f)&\n            &bind(c, name=\"sirius_get_lo_radial_function\")\n            integer,                 intent(in)  :: ia\n            integer,                 intent(in)  :: idxlo\n            real(8),                 intent(out) :: f\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_beta_projectors_by_kp that takes 6 input parameters: kset_id (integer), vk (real(8)), npw (integer), gvec_k (integer), ld (integer), nkb (integer), and 1 output parameter: vkb (complex(8)). This subroutine is intended to be used with the \"sirius_get_beta_projectors_by_kp\" name in the C language.", "input": "", "output": "        subroutine sirius_get_beta_projectors_by_kp(kset_id, vk, npw, gvec_k, vkb, ld, nkb)&\n            &bind(c, name=\"sirius_get_beta_projectors_by_kp\")\n            integer,                  intent(in)  :: kset_id\n            real(8),                  intent(in)  :: vk\n            integer,                  intent(in)  :: npw\n            integer,                  intent(in)  :: gvec_k\n            complex(8),               intent(out) :: vkb\n            integer,                  intent(in)  :: ld\n            integer,                  intent(in)  :: nkb\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_num_beta_projectors to retrieve the number of beta projectors for a given label. The subroutine takes 1 input parameter of type character array and returns 1 output parameter of type integer. The name of the subroutine is sirius_get_num_beta_projectors.", "input": "", "output": "        subroutine sirius_get_num_beta_projectors(label, num_beta_projectors)&\n            &bind(c, name=\"sirius_get_num_beta_projectors\")\n            character, dimension(*),  intent(in)  :: label\n            integer,                  intent(out) :: num_beta_projectors\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sirius_get_forces to retrieve forces for a given label. The subroutine should take 1 input parameter of type character array with intent in and 1 output parameter of type real(8) with intent out.", "input": "", "output": "        subroutine sirius_get_forces(label, forces)&\n            &bind(c, name=\"sirius_get_forces\")\n            character, dimension(*), intent(in)  :: label\n            real(8),                 intent(out) :: forces\n        end subroutine\n"}, {"instruction": "Provide a Fortran subroutine named sirius_get_stress_tensor that takes a character array as input and outputs a real(8) value. The input parameter should be of type character and of any size, while the output parameter should be of type real(8).", "input": "", "output": "        subroutine sirius_get_stress_tensor(label, s)&\n            &bind(c, name=\"sirius_get_stress_tensor\")\n            character, dimension(*), intent(in)  :: label\n            real(8),                 intent(out) :: s\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"angeul\" to transform a rotation matrix into Euler angles. The subroutine should have 2 input parameters of type real (kind=8) and logical, where the second parameter is optional. It should also have 1 output parameter of type real (kind=8). The subroutine calculates the Euler angles based on the rotation matrix and returns the angles in radians if the optional logical parameter is present.", "input": "", "output": " subroutine angeul( romtx, angls, rad )\r\n !*************************************************************************\r\n !\r\n !     transformation from rotation matrix to euler's angles\r\n !\r\n !              xg = r xn  : ang glob -> nodl\r\n !\r\n !     angls(1) : rotation about z axe to take x axis in x-y plane\r\n !     angls(2) : rotation about x axe to make z and z coincide\r\n !     angls(3) : rotation about z axe to make x-y coincide with x-y plane\r\n !\r\n !*************************************************************************\r\n implicit none\r\n !dummy arguments\r\n real (kind=8), intent(in) :: romtx(3,3)  !rotation matrix (t1,t2,t3)\r\n real (kind=8), intent(out) :: angls(3)   !euler angles\r\n logical, intent(in), optional :: rad     !if present angles returned in rads\r\n !local variables\r\n real (kind=8)  cosda,cosdg,sinda,sindg\r\n real (kind=8), parameter :: pid2  = 1.5707963267948966192313216916398, &   ! pid2 = atan(1d0)*2d0\r\n                             pi    = 3.1415926535897932384626433832795, &   ! pi   = 2d0*pid2\r\n                             facto = 57.295779513082320876798154814105, &   ! facto= 180d0/pi\r\n                             cuzer =1.0d-12\r\n\r\n\r\n if ( romtx(3,3) >= 1d0 ) then          !full positive proyection over z axis\r\n   angls(2) = 0d0                           !second angle is null\r\n else if ( romtx(3,3) <= -1d0) then     !full negative proyection over z axis\r\n   angls(2) = pi                            !second angle is pi\r\n else                                   ! an intermediate angle exist\r\n   angls(2) = acos( romtx(3,3) )            !compute angle\r\n end if\r\n if (angls(2) == 0d0) then              !if t3 is along z axis\r\n   angls(1) = 0d0                           !first angle is null\r\n else\r\n   if ( abs(romtx(2,3)) < cuzer ) then\r\n     if (romtx(1,3) > 0d0) then\r\n        angls(1) = pid2\r\n     else\r\n        angls(1) =-pid2\r\n     end if\r\n   else\r\n     angls(1) = atan( -romtx(1,3)/romtx(2,3) )\r\n     if (romtx(2,3) > 0d0 ) angls(1) = angls(1) + pi  !  cosine of beta negative\r\n   end if\r\n end if\r\n cosda = cos(angls(1))\r\n sinda = sin(angls(1))\r\n cosdg = romtx(1,1)*cosda + romtx(2,1)*sinda\r\n sindg =-romtx(1,2)*cosda - romtx(2,2)*sinda\r\n if (abs(cosdg) < cuzer) then\r\n   if (sindg > 0d0) then\r\n     angls(3) = pid2\r\n   else\r\n     angls(3) =-pid2\r\n   end if\r\n else\r\n   angls(3) = atan( sindg/cosdg )\r\n   if (cosdg < 0.0) angls(3) = angls(3) + pi      ! cosine negative\r\n end if\r\n\r\n ! if code rad is not used in calling\r\n if (.not.present (rad))  angls = angls*facto     ! change radians to degrees\r\n\r\n return\r\n end subroutine angeul\r\n"}, {"instruction": "Create a Fortran subroutine named init_deriv to initialize an array of wavenumbers based on the input domain length and number of wavenumbers. The subroutine takes 2 input parameters of type integer and double precision. It outputs an array of wavenumbers of type double precision. If the domain length is non-zero, the wavenumbers are calculated based on the domain length; otherwise, the subroutine terminates with an error message.", "input": "", "output": "        subroutine init_deriv(n, l, k)\n            integer,          intent(in)  :: n\n            double precision, intent(in)  :: l\n            double precision, intent(out) :: k(n)\n            double precision              :: sc\n            integer                       :: i\n\n            ! define wavenumber array:\n            if (l .ne. zero) then\n                ! define wavenumbers:\n                sc = pi / l\n                do i = 1, n\n                    k(i) = sc * dble(i)\n                enddo\n            else\n                ! catastrophic end to run if wave number definition fails:\n                write(*,*) '**********************************************'\n                write(*,*) ' wavenumber array definition not possible.'\n                write(*,*) ' domain length equal to zero not allowed.'\n                write(*,*) ' stopping...'\n                write(*,*) '**********************************************'\n                stop\n            endif\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named deriv to perform a differentiation operation using wavenumber multiplication. The subroutine takes 4 input parameters: two integers (m and n), an array of double precision numbers (k), and a 2D array of double precision numbers (var). It produces 1 output parameter of type double precision (der).", "input": "", "output": "        subroutine deriv(m, n, k, var, der)\n            integer,          intent(in)  :: m, n\n            double precision, intent(in)  :: k(n), var(m,n)\n            double precision, intent(out) :: der(m,n)\n            integer                       :: nw, np2, i, j, ic\n            double precision              :: ktmp\n\n            nw = n / 2\n            np2 = n + 2\n\n            ! carry out differentiation by wavenumber multiplication:\n            do j=1,m\n                der(j, 1) = zero\n            enddo\n\n            do i = 2, n - nw\n                ktmp = k(2*(i-1))\n                ic = np2 - i\n                do j = 1, m\n                    der(j, i) = -ktmp * var(j,ic)\n                    der(j,ic) =  ktmp * var(j ,i)\n                enddo\n            enddo\n\n            if (mod(n,2) == 0) then\n                ic=nw+1\n                do j = 1, m\n                    der(j,ic) = zero\n                enddo\n            endif\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named struct_sizes to read structural information from a file. The subroutine takes 1 input parameter of type character*80. It has 8 output parameters of types integer, integer, integer, character*4, real*8, real*8, real*8, and real*8. The subroutine reads the structural information from the provided file and outputs the lattice parameters, atomic positions, and other relevant data.", "input": "", "output": "subroutine struct_sizes(nat,nsym,ndif,lattic,aa,bb,cc,alpha,structf)\n  implicit none\n  character*80, intent(in):: structf\n  integer, intent(out)    :: nat, nsym, ndif\n  character*4, intent(out):: lattic\n  real*8, intent(out)      :: aa,bb,cc,alpha(3)\n  !----------- local variables ---------------\n  character*4  :: irel,cform\n  character*80 :: title\n  character*10 :: aname\n  real*8       :: r0,rmt,zz,rotloc(3,3),pos(3)\n  integer      :: iord,ios,mult,jrj,iatnr,isplit,index,i,j,m,jatom\n\n  open(20,file=structf,status='old')\n  read (20,1000) title\n  read (20,1010) lattic,nat,cform,irel\n  read (20,1020) aa,bb,cc,alpha(1),alpha(2),alpha(3)\n\n  if(abs(alpha(1)).lt.1.d-5) alpha(1)=90.\n  if(abs(alpha(2)).lt.1.d-5) alpha(2)=90.\n  if(abs(alpha(3)).lt.1.d-5) alpha(3)=90.\n  \n  index=0\n  do jatom=1,nat\n     index=index+1\n     read(20,1030,iostat=ios) iatnr,( pos(j),j=1,3 ), mult,isplit \n     if(ios /= 0 ) then\n        write(6,*) iatnr,( pos(j),j=1,3 ), mult,isplit\n        write(6,*) 'error in struct file read'\n        stop\n     endif\n     if (mult .eq. 0) then\n        write (6,6000) jatom, index, mult\n        stop\n     endif\n     do m=1,mult-1                                     \n        index=index+1                                            \n        read(20,1031) iatnr,( pos(j),j=1,3)   ! pos -- position inside the unit cell read from case.struct\n     enddo\n     read(20,1050) aname,jrj,r0,rmt,zz ! zz-nuclear charge, jrj--number of radial data points\n     read(20,1051) ((rotloc(i,j),i=1,3),j=1,3)\n  enddo\n  ndif=index\n  read(20,1151) iord\n  nsym=iord\n\n  close(20)\n1000 format(a80)                                                       \n1010 format(a4,23x,i3,1x,a4,/,13x,a4,18x,a4)                                 \n1020 format(6f10.7,10x,f10.7)                                          \n1030 format(4x,i4,4x,f10.7,3x,f10.7,3x,f10.7,/,15x,i2,17x,i2)          \n1031 format(4x,i4,4x,f10.7,3x,f10.7,3x,f10.7)                          \n1050 format(a10,5x,i5,5x,f10.9,5x,f10.5,5x,f10.5)                      \n1051 format(20x,3f10.8)\n1151 format(i4)\n6000 format(///,3x,'error in struct-read : mult(jatom)=0 ...',/, 20x,'jatom=',i3,3x,'index=',i3,3x,'mult=',i3)\nend subroutine struct_sizes\n"}, {"instruction": "Create a Fortran subroutine named centroid to calculate the centroid of a set of points in a multi-dimensional space. The subroutine takes 3 input parameters: n (integer), dim (integer), pos (real(8) array of dimension n,dim), and returns 1 output parameter: ret (real(8) array of dimension dim).", "input": "", "output": "subroutine centroid(pos, ret, n, dim)\n    implicit none\n    integer, intent(in) :: n, dim\n    real(8), dimension(n,dim), intent(in) :: pos\n    real(8), dimension(dim), intent(out) :: ret\n    ret = sum(pos, 1) / real(n)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named crossprod3 to calculate the cross product of two vectors in 3-dimensional space. The subroutine takes 3 input parameters: an integer dim, and two real*8 arrays of dimension dim, r1 and r2. The output is a real*8 array of dimension dim, ret. If the input dimension is not 3, the subroutine prints an error message and stops.", "input": "", "output": "subroutine crossprod3(r1, r2, ret, dim)\n    integer, intent(in) :: dim\n    real(8), dimension(dim), intent(in) :: r1, r2\n    real(8), dimension(dim), intent(out) :: ret\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    ret(1) = r1(2)*r2(3) - r1(3)*r2(2)\n    ret(2) = r1(3)*r2(1) - r1(1)*r2(3)\n    ret(3) = r1(1)*r2(2) - r1(2)*r2(1)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named reimage to perform the re-imaging of positions within a periodic box. The subroutine takes 5 input parameters of types integer, integer, real(8) array with dimensions (npos, dim), real(8) array with dimensions (dim), and real(8) array with dimensions (dim). It also has 1 output parameter of type real(8) array with dimensions (npos, dim).", "input": "", "output": "subroutine reimage(pos, refpos, boxl, reimagedpos, npos, dim)\n    implicit none\n    integer, intent(in) :: npos, dim\n    real(8), dimension(npos, dim), intent(in) :: pos\n    real(8), dimension(dim), intent(in) :: refpos\n    real(8), dimension(dim), intent(in) :: boxl\n    real(8), dimension(npos, dim), intent(out) :: reimagedpos\n    integer :: i\n    real(8), dimension(dim) :: distvec, iboxl\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    do i = 1, npos\n        distvec = pos(i,:) - refpos\n        distvec = distvec - boxl * anint(distvec * iboxl)\n        reimagedpos(i,:) = refpos + distvec\n    enddo            \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named spherepoints to generate points on the surface of a sphere. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type real(8) with dimensions n by 3.", "input": "", "output": "subroutine spherepoints(n, points)\n    implicit none\n    integer, intent(in) :: n\n    real(8), dimension(n,3), intent(out) :: points\n    real(8) :: off, y, phi, r\n    real(8) :: inc \n    real(8), parameter :: pi = 3.1415926535897931d0 \n    integer :: k\n    inc = pi * (3. - sqrt(5.))\n    points = 0.\n    off = 2. / real(n)\n    do k = 1, n\n        y = real(k-1) * off - 1. + (off * 0.5)\n        r = sqrt(max(1. - y*y, 0.))\n        phi = real(k-1) * inc\n        points(k,1) = cos(phi)*r\n        points(k,2) = y\n        points(k,3) = sin(phi)*r\n    enddo\nend subroutine\n"}, {"instruction": "The subroutine named spheresurfaceareas is written in Fortran to calculate the surface areas of spheres and determine their exposure. The subroutine takes 8 input parameters and 2 output parameters. The input parameters are of the types integer, real(8) arrays, logical arrays, and real(8) scalars, while the output parameters are of the types real(8) arrays and logical arrays.", "input": "", "output": "subroutine spheresurfaceareas(pos, radii, points, nexp, boxl, areas, exposed, nsphere, npoints, dim)\n    implicit none\n    integer, intent(in) :: dim\n    real(8), dimension(nsphere, dim), intent(in) :: pos\n    real(8), dimension(nsphere), intent(in) :: radii\n    real(8), dimension(npoints, dim), intent(in) :: points\n    integer, intent(in) :: nexp\n    real(8), dimension(dim), intent(in) :: boxl\n    real(8), dimension(nsphere), intent(out) :: areas\n    logical, dimension(nsphere), intent(out) :: exposed\n    real(8), parameter :: pi = 3.141592653589d0 \n    integer, intent(in) :: nsphere, npoints\n    integer :: i, j, k\n    real(8), dimension(npoints,dim) :: thispoints\n    real(8) :: areaperpoint\n    real(8), dimension(nsphere) :: radiisq\n    real(8), dimension(dim) :: ipos, jpos\n    real(8), dimension(dim) :: distvec, iboxl\n    logical, dimension(npoints) :: tempexposed\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0) \n    areas = 0.\n    exposed = .false.\n    radiisq = radii*radii\n    do i = 1, nsphere\n        ipos = pos(i,:)\n        areaperpoint = 4.*pi*radii(i)**2 / real(npoints)\n        tempexposed = .true.\n        do k = 1, npoints\n            thispoints(k,:) = points(k,:) * radii(i) + ipos\n        enddo\n        do j = 1, nsphere\n            if (i == j) cycle\n            jpos = pos(j,:)\n            distvec = jpos - ipos \n            distvec = distvec - boxl * anint(distvec * iboxl)\n            jpos = ipos + distvec\n            if (.not. any(tempexposed)) exit\n            !first check if spheres are far from each other\n            if (sum((jpos-ipos)**2) > (radii(i) + radii(j))**2) cycle\n            do k = 1, npoints\n                if (.not. tempexposed(k)) cycle\n                if (sum((thispoints(k,:) - jpos)**2) < radiisq(j)) tempexposed(k) = .false.\n            enddo\n        enddo\n        areas(i) = areaperpoint * real(count(tempexposed))\n        if (count(tempexposed) >= nexp) exposed(i) = .true.\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named spherevolumes to calculate the volumes of spheres based on their positions and radii in a given grid. The subroutine takes 5 input parameters of types integer, real(8) arrays, real(8), and integer, and returns 1 output parameter of type real(8) array.", "input": "", "output": "subroutine spherevolumes(pos, radii, dx, volumes, nsphere, dim)\n    implicit none\n    integer, intent(in) :: dim\n    real(8), dimension(nsphere, dim), intent(in) :: pos\n    real(8), dimension(nsphere), intent(in) :: radii\n    real(8),  intent(in) :: dx\n    real(8), dimension(nsphere), intent(out) :: volumes\n    integer, intent(in) :: nsphere\n    real(8), dimension(nsphere) :: radiisq\n    real(8) :: mindistsq, distsq, dv\n    integer :: i,j\n    real(8), dimension(dim) :: pos2, minpos, maxpos\n    if (dim /= 3) then\n        print *, 'expecting three dimensions and found', dim\n        stop\n    endif\n    radiisq = radii*radii\n    volumes = 0.\n    dv = dx*dx*dx\n    minpos = (/minval(pos(:,1) - radii), minval(pos(:,2) - radii), minval(pos(:,3) - radii)/)\n    maxpos = (/maxval(pos(:,1) + radii), maxval(pos(:,2) + radii), maxval(pos(:,3) + radii)/)\n    maxpos = maxpos + dx * 0.5    \n    !first do a coarse grid check to see which spheres are where\n    pos2 = minpos\n    do while (all(pos2 < maxpos))\n        j = 0\n        mindistsq = huge(1.d0)\n        do i = 1, nsphere\n            distsq = sum((pos(i,:) - pos2)**2)\n            if (distsq < mindistsq .and. distsq < radiisq(i)) then\n                mindistsq = distsq\n                j = i\n            endif\n        enddo\n        if (j > 0) volumes(j) = volumes(j) + dv\n        pos2(1) = pos2(1) + dx\n        do i = 1, 2\n            if (pos2(i) >= maxpos(i)) then\n                pos2(i) = minpos(i)\n                pos2(i+1) = pos2(i+1) + dx\n            endif\n        enddo\n    enddo   \nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named radialdist to calculate the radial distribution function (RDF) between two sets of 3D coordinates. The subroutine takes 8 input parameters: pos1 (real(8) array of dimension npos1 x 3), pos2 (real(8) array of dimension npos2 x 3), binwidth (real(8)), totbins (integer), bulkdens (real(8)), boxl (real(8) array of dimension 3), npos1 (integer), and npos2 (integer). It produces 1 output parameter: rdf (real(8) array of dimension totbins).", "input": "", "output": "subroutine radialdist(pos1, pos2, binwidth, totbins, bulkdens, boxl, rdf, npos1, npos2)\n    implicit none\n    real(8), dimension(npos1, 3), intent(in) :: pos1\n    real(8), dimension(npos2, 3), intent(in) :: pos2\n    real(8), intent(in) :: binwidth\n    integer, intent(in) :: totbins\n    ! total number of bins, so max bin value is totbins*binwidth; if larger ignored\n    real(8), intent(in) :: bulkdens\n    real(8), dimension(3), intent(in) :: boxl\n    real(8), dimension(totbins), intent(out) :: rdf\n    integer, intent(in) :: npos1, npos2\n    real(8), parameter :: pi = 3.141592653589d0\n    real(8), dimension(totbins) :: counts\n    real(8), dimension(3) :: ipos, jpos, iboxl, distvec\n    real(8) :: dist\n    integer :: nbin, i, j, k\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    counts = 0.\n    do i = 1, npos2\n        ipos = pos2(i,:)\n        do j = 1, npos1\n            jpos = pos1(j,:)\n            distvec = jpos - ipos\n            distvec = distvec - boxl * anint(distvec * iboxl)\n            dist = sqrt(sum(distvec**2))\n            ! place in correct bin\n            nbin = ceiling(dist / binwidth) ! bin i has all distances less than i but greater than i - 1\n            if (nbin <= totbins) then\n                counts(nbin) = counts(nbin) + 1.\n            endif\n            ! if beyond max of totbins*binwidth, just don't include\n        enddo\n    enddo\n    ! normalize counts correctly\n    do k = 1, totbins\n        rdf(k) = counts(k) / (npos1 * bulkdens * (4./3.) * pi * (binwidth**3) * ((k**3) - ((k-1)**3)))\n    enddo\n    ! gives g(r) for single snapshot... for whole trajectory, do for each frame and average\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named solventshells to determine the solvent shells around particles. The subroutine takes 6 input parameters of types real(8), dimension(npos1, 3), real(8), dimension(npos2, 3), real(8), real(8), integer, and integer. It also has 2 output parameters of types logical, dimension(npos2), and logical, dimension(npos2). The subroutine uses the imperative tone and its purpose is to compute solvent shells based on the positions and distances provided.", "input": "", "output": "subroutine solventshells(pos1, pos2, dist1, dist2, shell1, shell2, npos1, npos2)\n    implicit none\n    real(8), dimension(npos1, 3), intent(in) :: pos1\n    real(8), dimension(npos2, 3), intent(in) :: pos2\n    real(8), intent(in) :: dist1, dist2\n    logical, dimension(npos2), intent(out) :: shell1, shell2\n    integer, intent(in) :: npos1, npos2\n    real(8), dimension(npos1) :: tempdists\n    real(8), dimension(3) :: ipos, jpos\n    integer :: i, j\n    real(8) :: dist1sq, dist2sq\n    shell1 = .false.\n    shell2 = .false.\n    dist1sq = dist1*dist1\n    dist2sq = dist2*dist2\n    do i = 1, npos2\n        ipos = pos2(i,:)\n        tempdists = 0.\n        do j = 1, npos1\n            jpos = pos1(j,:)\n            tempdists(j) = sum((jpos - ipos)**2)\n        enddo\n        if (minval(tempdists) <= dist1sq) then\n            shell1(i) = .true.\n        else if (minval(tempdists) <= dist2sq) then\n            shell2(i) = .true.\n        endif\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"bbhbonds\" to calculate the number of hydrogen bonds between peptide acceptors and donors. The subroutine should have 6 input parameters of type real(8), dimension(npepacc, 3), real(8), dimension(npepdon, 3), real(8), real(8), and integer. It should also have 3 output parameters of type integer, integer, dimension(npepacc), and integer, dimension(npepdon).", "input": "", "output": "subroutine bbhbonds(pepacc, pepdon, distcut, angcut, nbonds, pepaccout, pepdonout, npepacc, npepdon)\n    implicit none\n    real(8), dimension(npepacc, 3), intent(in) :: pepacc\n    real(8), dimension(npepdon, 3), intent(in) :: pepdon\n    real(8), intent(in) :: distcut, angcut\n    integer, intent(out) :: nbonds\n    integer, dimension(npepacc), intent(out) :: pepaccout\n    integer, dimension(npepdon), intent(out) :: pepdonout\n    integer, intent(in) :: npepacc, npepdon\n    real(8) :: distcutsq, cosangcut\n    real(8), parameter :: pi = 3.1415926535897931d0\n    real(8), parameter :: radperdeg = pi / 180.d0\n    integer j, i\n    real(8), dimension(3) :: apos, bondvec1, heavypos, hpos, vecpep\n    real(8) :: bonddist1sq, cosang1\n    nbonds = 0\n    pepaccout = 0\n    pepdonout = 0\n    distcutsq = distcut * distcut\n    cosangcut = cos(angcut * radperdeg)\n    if (mod(npepdon, 2) /= 0) then\n        print *, \"peptide donor position array does not have length of a factor of 2.\"\n        stop\n    endif\n    ! loop over peptide donors (hydrogens with attached heavy atom 1 index behind!)\n    do i = 1, npepdon, 2\n        heavypos = pepdon(i,:)\n        hpos = pepdon(i+1,:)\n        ! loop over peptide acceptors\n        ! could be more efficient by excluding h attached to same heavy atom...\n        ! simpler this way, and ok because will register cosang1 of -1 and not be considered\n        do j = 1, npepacc\n            apos = pepacc(j,:)\n            bondvec1 = apos - hpos\n            bonddist1sq = sum(bondvec1**2)\n            if (bonddist1sq < distcutsq) then\n                vecpep = hpos - heavypos\n                cosang1 = dot_product(bondvec1, vecpep) / sqrt(bonddist1sq * sum(vecpep**2))\n                if (cosang1 > cosangcut) then\n                    nbonds = nbonds + 1\n                    pepdonout(i+1) = pepdonout(i+1) + 1\n                    pepaccout(j) = pepaccout(j) + 1\n                endif\n            endif\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named nearneighbors to determine the neighboring particles within a specified distance range. The subroutine takes 7 input parameters of type real(8), dimension(nsubpos, 3), real(8), dimension(npos, 3), real(8), dimension(3), real(8), real(8), integer, integer and 1 output parameter of type logical, dimension(nsubpos, npos).", "input": "", "output": "subroutine nearneighbors(subpos, pos, boxl, lowcut, highcut, nneighbors, nsubpos, npos)\n    implicit none\n    real(8), dimension(nsubpos, 3), intent(in) :: subpos\n    real(8), dimension(npos, 3), intent(in) :: pos\n    real(8), dimension(3), intent(in) :: boxl\n    real(8), intent(in) :: lowcut, highcut\n    integer, intent(in) :: nsubpos\n    integer, intent(in) :: npos\n    logical, dimension(nsubpos, npos), intent(out) :: nneighbors\n    integer :: i, j\n    real(8), dimension(3) :: iboxl\n    real(8), dimension(3) :: pos1, pos2, distvec\n    real(8) :: lowsq, highsq, distvecsq\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0) \n    lowsq = lowcut*lowcut\n    highsq = highcut*highcut\n    nneighbors = .false.\n    ! loop over all positions in subpos (may be subset of pos)\n    do i = 1, nsubpos\n        pos1 = subpos(i,:)\n        ! loop over all positions in pos\n        do j = 1, npos\n            pos2 = pos(j,:)\n            distvec = pos2 - pos1\n            ! must re-image individually to account for periodicity to be accurate\n            distvec  = distvec - boxl * anint(distvec * iboxl)\n            distvecsq = sum(distvec**2)\n            if ( (distvecsq > lowsq) .and. (distvecsq <= highsq) ) then\n                ! lower cut-off not included... lazy, really, but prevents including same atom\n                nneighbors(i,j) = .true.\n            endif\n        enddo\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"calcsd\" to calculate the squared displacement of coordinates. The subroutine takes 7 input parameters of the types real(8), dimension(npos, 3), real(8), dimension(nprevpos, 3), real(8), dimension(nrefpos, 3), real(8), dimension(3), integer, integer, integer. It also has 2 output parameters of the types real(8), dimension(npos, 3) and real(8), dimension(npos, 3).", "input": "", "output": "subroutine calcsd(pos, prevpos, refpos, boxl, allsd, newpos, npos, nprevpos, nrefpos)\n    implicit none\n    real(8), dimension(npos, 3), intent(in) :: pos\n    real(8), dimension(nprevpos, 3), intent(in) :: prevpos\n    real(8), dimension(nrefpos, 3), intent(in) :: refpos\n    real(8), dimension(3), intent(in) :: boxl\n    integer, intent(in) :: npos, nprevpos, nrefpos\n    real(8), dimension(npos, 3), intent(out) :: allsd\n    real(8), dimension(npos, 3), intent(out) :: newpos\n    real(8), dimension(3) :: iboxl, avec, distvec\n    integer :: i\n    ! first check if npos matches nrefpos, if not quit\n    if (npos /= nrefpos .or. nprevpos /= npos) then\n        print *, 'number of current and reference coordinates must match.', npos, nprevpos, nrefpos\n        stop\n    endif\n    ! set up imaging/unwrapping\n    iboxl = merge(1.d0/boxl, 0.d0, boxl >= 0.d0)\n    ! loop over coordinates, calc squared displacement\n    do i = 1, npos\n        ! first unwrap to find new coordinate without pbcs\n        avec = pos(i,:) - prevpos(i,:)\n        avec = avec - boxl * anint(avec * iboxl)\n        newpos(i,:) = prevpos(i,:) + avec\n        ! now calculate squared displacement from reference\n        distvec = newpos(i,:) - refpos(i,:)\n        allsd(i,:) = distvec**2\n    enddo\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named binongrid to perform binning of spatial points into a 3D histogram. The number of input parameters is 8, consisting of real(8) and integer arrays, representing spatial coordinates and bin sizes. The number of output parameters is 1, an integer array representing the 3D histogram.", "input": "", "output": "subroutine binongrid(opos, xbins, ybins, zbins, outhist, nopos, nx, ny, nz)\n    implicit none\n    real(8), dimension(nopos, 3), intent(in) :: opos\n    real(8), dimension(nx), intent(in) :: xbins\n    real(8), dimension(ny), intent(in) :: ybins\n    real(8), dimension(nz), intent(in) :: zbins\n    integer, intent(in) :: nopos, nx, ny, nz\n    integer, dimension(nx-1, ny-1, nz-1), intent(out) :: outhist\n    real(8) :: binwidth, radsq, thisdistsq\n    integer :: thisxbin, thisybin, thiszbin\n    real(8), dimension(3) :: thisvec\n    integer :: i\n    ! find all bin widths - assumes uniform bins!\n    binwidth = xbins(2) - xbins(1)\n    ! also assumes all binwidths are the same in each dimension, i.e. have cubes\n    if (ybins(2) - ybins(1) /= binwidth .or. zbins(2) - zbins(1) /= binwidth) then\n        print *, 'must break volume into cubes. currently, bin-widths do not match.'\n        stop \n    endif\n    radsq = binwidth*binwidth/4.0d0\n    ! initiate outhist\n    outhist = 0\n    do i = 1, nopos\n        ! find x, y, and z bins - inclusive on left edge, exclusive on right\n        ! not considered if out of bin range\n        thisxbin = floor((opos(i,1) - xbins(1)) / binwidth) + 1\n        ! make sure actually in range of bins\n        if (thisxbin < 1 .or. thisxbin > (nx-1)) then\n            cycle\n        else\n            thisybin = floor((opos(i,2) - ybins(1)) / binwidth) + 1\n            if (thisybin < 1 .or. thisybin > (ny-1)) then\n                cycle\n            else\n                thiszbin = floor((opos(i,3) - zbins(1)) / binwidth) + 1\n                if (thiszbin < 1 .or. thiszbin > (nz-1)) then\n                    cycle\n                else\n                    ! add one to outhist if also in sphere within cube\n                    thisvec(1) = opos(i,1) - (xbins(thisxbin) + binwidth*0.5d0)\n                    thisvec(2) = opos(i,2) - (ybins(thisybin) + binwidth*0.5d0)\n                    thisvec(3) = opos(i,3) - (zbins(thiszbin) + binwidth*0.5d0)\n                    thisdistsq = sum(thisvec*thisvec)\n                    if (thisdistsq <= radsq) then\n                        outhist(thisxbin, thisybin, thiszbin) = outhist(thisxbin, thisybin, thiszbin) + 1\n                    else\n                        cycle\n                    endif\n                endif\n            endif\n        endif\n    enddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named distancemetric1b to calculate the distance metric between two 6-dimensional vectors. The subroutine should take 4 input parameters of type real(8) and dimension(6) for vec1, vec2, rsq, and sintw, and 1 output parameter of type real(8) for dist.", "input": "", "output": "subroutine distancemetric1b(vec1, vec2, rsq, sintw, dist)\n    implicit none\n    real(8), dimension(6), intent(in) :: vec1\n    real(8), dimension(6), intent(in) :: vec2\n    real(8), intent(in) :: rsq, sintw\n    real(8), intent(out) :: dist\n    real(8), dimension(6) :: diffs, dsqvec\n    diffs = (vec2 - vec1)*(vec2 - vec1)\n    dsqvec(1) = diffs(1)\n    dsqvec(2) = diffs(2)\n    dsqvec(3) = diffs(3)\n    dsqvec(4) = rsq*diffs(4)\n    dsqvec(5) = rsq*sin(vec2(4))*sin(vec1(4))*diffs(5)\n    dsqvec(6) = rsq*sintw*diffs(6)\n    dist = sqrt(sum(dsqvec))\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named distancemetric2b to calculate the distance metric between two 12-dimensional vectors. The subroutine takes 4 input parameters of type real(8) and dimension(12): vec1, vec2, rsq, and sintw. It also has 1 output parameter of type real(8) to store the calculated distance.", "input": "", "output": "subroutine distancemetric2b(vec1, vec2, rsq, sintw, dist)\n    implicit none\n    real(8), dimension(12), intent(in) :: vec1\n    real(8), dimension(12), intent(in) :: vec2\n    real(8), intent(in) :: rsq, sintw\n    real(8), intent(out) :: dist\n    real(8), dimension(12) :: diffs, dsqvec\n    diffs = (vec2 - vec1)*(vec2 - vec1)\n    dsqvec(1) = diffs(1)\n    dsqvec(2) = diffs(2)\n    dsqvec(3) = diffs(3)\n    dsqvec(4) = rsq*diffs(4)\n    dsqvec(5) = rsq*sin(vec2(4))*sin(vec1(4))*diffs(5)\n    dsqvec(6) = rsq*sintw*diffs(6)\n    dsqvec(7) = diffs(7)\n    dsqvec(8) = rsq*diffs(8)\n    dsqvec(9) = rsq*diffs(9)\n    dsqvec(10) = rsq*sin(vec2(9))*sin(vec1(9))*diffs(10)\n    dsqvec(11) = rsq*sintw*diffs(11)\n    dsqvec(12) = rsq*sintw*diffs(12)\n    dist = sqrt(sum(dsqvec))\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named vectorcrossproduct to calculate the cross product of two 3D vectors. The subroutine should take 2 input parameters of type real(kind=8) arrays, both of size 3, and 1 output parameter of type real(kind=8) array of size 3. The subroutine should compute the cross product of the input vectors and store the result in the output array.", "input": "", "output": "  subroutine vectorcrossproduct(v1,v2,y)\n\n    implicit none\n\n    real(kind=8), intent(in)  :: v1(3), v2(3)\n    real(kind=8), intent(out) :: y(3)\n\n    y(1) = v1(2)*v2(3) - v1(3)*v2(2)\n    y(2) = v1(3)*v2(1) - v1(1)*v2(3)\n    y(3) = v1(1)*v2(2) - v1(2)*v2(1)\n    \n  end subroutine vectorcrossproduct\n"}, {"instruction": "Create a Fortran subroutine named assemble_system_dirichlet to assemble a linear system for a Dirichlet boundary condition. The subroutine takes 4 input parameters of type real(8), real(8), integer, and logical, and 4 output parameters of type real(8), real(8), real(8) and real(8). The subroutine assembles a banded matrix, computes the right-hand side, and initializes the solution profile. If specified, it also constructs a preconditioner using a sine transform matrix and a diagonal matrix.", "input": "", "output": "  subroutine assemble_system_dirichlet(a, b, npts, v, rhs, u, p, ispreconditioned)\n\n    implicit none\n\n    real(8), intent(in)  :: a, b ! bounds of the domain\n    integer, intent(in)  :: npts ! number of interior points\n    real(8), intent(out) :: v(npts,npts) ! banded matrix\n    real(8), intent(out) :: rhs(npts)\n    real(8), intent(out) :: u(npts)\n    real(8), intent(out) :: p(npts,npts)\n    real(8) :: s(npts,npts), d(npts, npts)\n\n    real(8), parameter :: pi = 3.141592653589793d0\n    real(8)            :: h, alpha\n    integer            :: m, n\n    integer            :: i, j, k\n\n    logical, intent(in) :: ispreconditioned\n    \n    ! h = width / num_interior_pts + 1\n    h = (b-a)/dble(npts+1)\n    v = 0.0d0\n\n    ! size of the linear system = unknowns (interior nodes)\n    m = npts ! nrows\n    n = npts ! ncols\n\n    ! set the inner block\n    rows: do i = 1, m\n       cols: do j = 1, n\n          if (j .eq. i-1) then\n             ! lower triangle\n             v(j,i) = -1.0d0\n          else if (j .eq. i+1) then           \n             ! upper triangle\n             v(j,i) = -1.0d0\n          else if (j .eq. i) then           \n             ! diagonal\n             v(j,i) = 2.0d0\n          else\n             ! skip\n          end if\n       end do cols\n    end do rows\n\n    ! assemble the rhs\n    do i = 1, m\n       rhs(i) = h*h*(2.0d0*dble(i)*h - 0.5d0)\n    end do\n    rhs(1) = rhs(1) + 1.0d0\n    rhs(m) = rhs(m)\n\n    ! initial solution profile use sin function as a first guess\n    do i = 1, m\n       u(i) =  sin(dble(i)*h*pi)\n    end do\n\n    if (ispreconditioned .eqv. .true.) then\n       ! find the sine transform matrix\n       alpha = sqrt(2.0d0/dble(npts+1))\n       do j = 1, m\n          do k = 1, n\n             s(k,j) = alpha*sin(pi*dble(j*k)/dble(npts+1))\n          end do\n       end do\n\n       ! find the diagonal matrix\n       d = matmul(s, matmul(v, s))\n\n       ! invert the digonal matrix easily\n       do j = 1, m\n          d(j,j) = 1.0d0/d(j,j)\n       end do\n\n       ! define the preconditioner\n       p = matmul(s, matmul(d, s))\n    end if\n\nend subroutine assemble_system_dirichlet\n"}, {"instruction": "Write a Fortran subroutine named check_data_format to determine the format of the input data. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter is the unit number for the input data, and the output parameter is the format indicator (1 for 4 data in one line, 0 for 3 data).", "input": "", "output": "subroutine check_data_format( unit, iformat )\n  implicit none\n  integer,intent(in) :: unit\n  integer,intent(out) :: iformat\n  character(100) :: ccc\n  character(1) :: b(4)\n  read(unit,'(a)') ccc\n  backspace(unit)\n  read(ccc,*,end=9) b\n  iformat=1 ! 4 data in one line\n  return\n9 iformat=0 ! 3 data\nend subroutine check_data_format\n"}, {"instruction": "Create a Fortran subroutine named mat_mul_1 to perform matrix multiplication. The subroutine takes 2 input parameters of type real*8, representing matrices mat_a and mat_b, and 1 output parameter of type real*8 representing the result matrix mat_c. The subroutine uses nested do-loops to compute the matrix multiplication.", "input": "", "output": "subroutine mat_mul_1(mat_a,mat_b,mat_c)\n\timplicit none\n\treal*8, intent(in):: mat_a(:,:), mat_b(:,:)\n\treal*8, intent(out) :: mat_c(:,:)\n\tinteger*4:: m,n,o,p,ii,jj,kk\n\treal*8:: cumulative\n\tinteger*4:: shape_a(2), shape_b(2)\n\t\n\tshape_a = shape(mat_a)\n\tshape_b = shape(mat_b)\n\tm = shape_a(1)\n\tn = shape_a(2)\n\to = shape_b(1)\n\tp = shape_b(2)\n\t\n\tdo ii = 1,m\n\t\tdo jj = 1, p\n\t\t\tcumulative = 0.d0\n\t\t\tdo kk = 1, n\n\t\t\t\tcumulative = cumulative + mat_a(ii,kk)*mat_b(kk,jj)\n\t\t\tend do\n\t\t\tmat_c(ii,jj) = cumulative\n\t\tend do\n\tend do\n\t\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named bcnd to handle boundary conditions for a differential equation system. The subroutine takes 7 input parameters of types integer and double precision, and 2 output parameters of type double precision. The purpose of the subroutine is to calculate boundary conditions for periodicity and Floquet eigenvalue/vector boundary relation. Use the imperative tone to implement this functionality.", "input": "", "output": " subroutine bcnd(ndim,par,icp,nbc,u0,u1,fb,ijac,dbc)\n!---------- ----\n\n   implicit none\n   integer, intent(in) :: ndim, icp(*), nbc, ijac\n   double precision, intent(in) :: par(*), u0(ndim), u1(ndim)\n   double precision, intent(out) :: fb(nbc), dbc(nbc,*)\n\n   double precision fm\n\n! periodicity boundary conditions\n   fb(1:6) = u0(1:6) - u1(1:6)\n\n! floquet eigenvalue/vector boundary relation\n   fm = par(4)\n   fb(7:12) = u1(7:12) - fm*u0(7:12)\n\n end subroutine bcnd\n"}, {"instruction": "Create a Fortran subroutine named utility_cart_to_frac to convert from Cartesian to fractional coordinates. The subroutine takes 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are recip_lat(3,3) and cart(3), while the output parameter is frac(3).", "input": "", "output": "  subroutine utility_cart_to_frac(cart,frac,recip_lat)\n    !==================================================================!\n    !                                                                  !\n    !!  convert from cartesian to fractional coordinates\n    !                                                                  !\n    !===================================================================\n    implicit none\n\n    real*8, intent(in)  :: recip_lat(3,3)\n    real*8, intent(out) :: frac(3)\n    real*8, intent(in)  :: cart(3)\n\n    integer :: i\n\n    do i=1,3\n       frac(i)=recip_lat(i,1)*cart(1) + recip_lat(i,2)*cart(2) + recip_lat(i,3)*cart(3)\n    end do\n\n    frac=frac/(2.0*acos(-1.0))\n\n\n  end subroutine utility_cart_to_frac\n"}, {"instruction": "Create a Fortran subroutine named utility_frac_to_cart to convert fractional coordinates to Cartesian coordinates. The subroutine should have 2 input parameters of type real*8, representing the real_lat matrix and the fractional coordinates, and 1 output parameter of type real*8 for the Cartesian coordinates.", "input": "", "output": "  subroutine utility_frac_to_cart(frac,cart,real_lat)\n    !==================================================================!\n    !                                                                  !\n    !!  convert from fractional to cartesian coordinates\n    !                                                                  !\n    !===================================================================\n    implicit none\n\n    real*8, intent(in)  :: real_lat(3,3)\n    real*8, intent(in)  :: frac(3)\n    real*8, intent(out) :: cart(3)\n\n    integer :: i\n\n    do i=1,3\n       cart(i)=real_lat(i,1)*frac(1) + real_lat(i,2)*frac(2) + real_lat(i,3)*frac(3)\n    end do\n\n    return\n\n  end subroutine utility_frac_to_cart   \n"}, {"instruction": "Create a Fortran subroutine named \"mcnp_zaid\" to convert MPACT ZAID to MCNP ZAID and label. The subroutine must take 1 input parameter of type integer and have 2 output parameters, one of type integer and the other of type character with dynamic length. The subroutine should perform the conversion and generate a label based on the input ZAID.", "input": "", "output": "      subroutine mcnp_zaid(izinp, izaid, label)\n      implicit none\n\n      integer, intent(in)  :: izinp            ! mpact zaid\n      integer, intent(out) :: izaid            ! mcnp zaid\n      character(len=*), intent(out) :: label\n\n      integer :: isom, ia, ip\n\n      character(len=1) :: chisom    ! isomer character flag\n\n      character(len=2) :: element_name(100)\n      data element_name / &\n        'h ','he','li','be','b ','c ','n ','o ','f ','ne', &\n        'na','mg','al','si','p ','s ','cl','ar','k ','ca', &\n        'sc','ti','v ','cr','mn','fe','co','ni','cu','zn', &\n        'ga','ge','as','se','br','kr','rb','sr','y ','zr', &\n        'nb','mo','tc','ru','rh','pd','ag','cd','in','sn', &\n        'sb','te','i ','xe','cs','ba','la','ce','pr','nd', &\n        'pm','sm','eu','gd','tb','dy','ho','er','tm','yb', &\n        'lu','hf','ta','w ','re','os','ir','pt','au','hg', &\n        'tl','pb','bi','po','at','rn','fr','ra','ac','th', &\n        'pa','u ','np','pu','am','cm','bk','cf','es','fm' /\n\n!--- start\n\n      label=' '\n      chisom=' '\n\n!--- mpact zaid has an extra digit at the end for the isomer, like \"922350\"\n!--- and adds 500 to the atomic mass for fission products\n\n      izaid=izinp/10\n      isom=izinp-10*izaid   ! isomer flag\n\n      if (izaid.eq.8001) izaid=8016    ! special nomenclature for hydrogen in fuel flag\n\n      ip=izaid/1000         ! number of protons\n      ia=izaid - ip*1000    ! atomic mass\n      if (ia.gt.500) then\n        ia=ia-500           ! remove special mpact nomenclature\n        izaid=izaid-500     ! remove special mpact nomenclature\n      endif\n\n!  at this point zaid is \"clean\" with no special mpact or mcnp notation\n\n!  mpact isomers:\n!  224   47610 1    ag-110m  add 400 to isomer\n!  233   52627 1    te-127m  add 400 to isomer\n!  234   52629 1    te-129m  add 400 to isomer\n!  137   61648 1    pm-148m  add 400 to isomer\n!  178   95242 1    pm-242m  add 400 to stable nuclide!\n\n!--- put in mcnp notation, add 400 to *some* isomers\n\n      if (isom.gt.0) then\n!d      write (0,*) 'debug: isomer ', izaid\n        if (izaid.eq.47110 .or. izaid.eq.52127 .or. izaid.eq.52129 .or. izaid.eq.61148) then\n           izaid=izaid+400\n        elseif (izaid.eq.95242) then   ! do nothing\n           continue\n        else\n           write (*,*) 'zaid = izinp'\n           stop 'unknown isomer in mpact isotope list'\n        endif\n        chisom='m'\n      endif\n\n      if (isom.eq.0 .and. izaid.eq.95242) then\n        izaid=izaid+400   ! add 400 to stable isomer\n      endif\n\n!--- create label\n\n      write (label,'(2a,i0,a)') trim(element_name(ip)), '-', ia, chisom\n\n      return\n      end subroutine mcnp_zaid\n"}, {"instruction": "Create a Fortran subroutine named \"calc_hypotenuse\" that calculates the hypotenuse of a right triangle using the lengths of the other two sides. The subroutine should have 2 input parameters of type real representing the lengths of the two sides, and 1 output parameter of type real representing the length of the hypotenuse.", "input": "", "output": "subroutine calc_hypotenuse ( side_1, side_2, hypotenuse )\r\n!\r\n!  purpose:\r\n!    to calculate the hypotenuse of a right triangle from the two \r\n!    other sides.\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    11/18/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\nreal, intent(in) :: side_1        ! length of side 1 \r\nreal, intent(in) :: side_2        ! length of side 2 \r\nreal, intent(out) :: hypotenuse   ! length of hypotenuse\r\n\r\n! data dictionary: declare local variable types & definitions\r\nreal :: temp                      ! temporary variable\r\n\r\n! calculate hypotenuse\r\ntemp = side_1**2 + side_2**2\r\nhypotenuse = sqrt ( temp )\r\n\r\nend subroutine calc_hypotenuse\r\n"}, {"instruction": "Write a Fortran subroutine named irand to generate an array of random integers within a specified range. The number of input arguments is 3, and the test_data type is [integer, integer, integer]. The number of output arguments is 1, and the test_data type is [integer]. The subroutine should be named \"irand\".", "input": "", "output": "subroutine irand(randseq, n, low, high)\r\ninteger, intent(out)  :: randseq(:)\r\ninteger, intent(in)   :: n, low, high\r\n\r\nreal    :: ran(n)\r\n\r\ncall random_number(ran)\r\nrandseq = low + (high + 1 - low) * ran\r\n\r\nreturn\r\nend subroutine irand\r\n"}, {"instruction": "Create a Fortran subroutine named sys_mkdir to make a sub-directory under the current working directory. The subroutine takes 2 input parameters: dir of type character(len=*) and lendir of type integer. The output parameter ierr is of type integer. If successful, ierr will be zero; otherwise, it will be non-zero.", "input": "", "output": "      subroutine sys_mkdir (dir, lendir, ierr)\n!\n!   this routine makes a sub-dir under the current working directory.\n!   lendir is the length of character string dir;\n!   ierr will be zero if successful, otherwise non-zero;\n!   machine is an optional parameter specifying the name of the system\n!\n!   xinghong he  98-08-21\n!\n!***********************************************************************\n!...translated by pacific-sierra research 77to90  4.3e  14:04:58   1/ 3/07\n!...modified by charlotte froese fischer\n!                     gediminas gaigalas  10/05/17\n!\n!   function 'system' and execute_command_line commented out\n!cjb                                             jacek bieron 2018 june 18\n!\n!-----------------------------------------------\n!   m o d u l e s\n!-----------------------------------------------\n!     use mpi_c\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      character(len=*), intent(in):: dir\n      integer, intent(in):: lendir\n      integer, intent(out):: ierr\n      character(len=255) mkdir_error_message\n!      character(len=*), parameter::iam = 'sun'  ! soly for machine\n!      character(len=len_trim (iam)), optional, intent(out):: machine\n\n!     integer system\n\n      mkdir_error_message = \" no message passed from the shell \"\n      ierr = -999\n\n!cjb\n!     print*, dir(1:lendir)\n!     print*, dir(1:lendir)\n!\n      ierr = system ('mkdir -p -m 775 ' // dir(1:lendir))\n!cjb  use execute_command_line if function 'system' is not supported\n!     call execute_command_line ('mkdir -p -m 775 ' // dir(1:lendir), &\n!                         exitstat=ierr, cmdmsg=mkdir_error_message)\n      if (ierr.ne.0) then\n        print*, ' sys_mkdir error message = ', trim(mkdir_error_message)\n!               ' myid = ', myid\n      endif\n      return\n      end subroutine sys_mkdir\n"}, {"instruction": "Write a Fortran subroutine named invmat that computes the inverse of a real, square matrix. The subroutine takes 3 input parameters: two integers for the dimension and the size of the matrix, and a 2D array of double precision numbers representing the matrix. The subroutine returns the inverse of the matrix as a 2D array of double precision numbers.", "input": "", "output": "  subroutine invmat(al,ai,dimen,npar)\n  integer,intent(in)           :: npar,dimen\n  double precision,intent(in)  :: al(npar,npar)\n  double precision,intent(out) :: ai(npar,npar)\n  double precision             :: h(npar),p,q\n  integer                      :: i1,i2,k,i,j,k8,k9\n      \n\n    ai(1:dimen,1:dimen)=al(1:dimen,1:dimen)\n \n    do i1=1,dimen\n      k=dimen-i1+1\n      p=ai(1,1)\n      do i=2,dimen\n        q=ai(i,1)\n        h(i)=q/p\n        if(i.le.k) h(i)=-q/p\n        do j=2,i\n          k8=i-1\n          k9=j-1\n          ai(k8,k9)=ai(i,j)+q*h(j)\n        enddo \n      enddo \n      ai(dimen,dimen)=1.0/p\n      do i=2,dimen\n        k8=i-1\n        ai(dimen,k8)=h(i)\n      enddo \n   end do \n   do i=1,dimen\n     k8=i-1\n     do j=1,k8\n       ai(j,i)=ai(i,j)\n     enddo \n   enddo \n   return\n end subroutine invmat\n"}, {"instruction": "Create a Fortran subroutine named read_jacobi_matrix to read a matrix of double precision real numbers from a file. The subroutine takes 2 input parameters of type integer, enermax, and parmax, and 1 output parameter derj of type real(8) array with dimensions enermax and parmax. The subroutine reads the matrix from the file 'fort.12' and stores it in the derj array. Remember to use the imperative tone in the instructions.", "input": "", "output": "    subroutine read_jacobi_matrix(enermax,parmax,derj)\n\t  !\n      integer,intent(in)  :: enermax,parmax\n      real(8),intent(out) :: derj(enermax,parmax)\n      integer             :: ie,ipar\n      !\n      open(1, file='fort.12',status='old')\n      !\n      !derj(1,:) = 0 \n      !\n      do ie = 1,enermax \n        !\n        read(1,*)\n        !\n        do ipar = 1,parmax \n          !\n          read(1,*) derj(ie,ipar)\n          !    \n        enddo\n        !\n      enddo\n      !\n      close(1,status='keep')\n      !\n    end subroutine read_jacobi_matrix\n"}, {"instruction": "Create a Fortran subroutine named get_degree_for_index to calculate the degree of each node in a tree based on the given edge indices. Accept 4 input parameters of type integer: index1, index2, number_of_nodes, and number_of_edges. Provide 1 output parameter of type double precision named degree to store the computed degrees for each node.", "input": "", "output": "subroutine get_degree_for_index(index1, index2, number_of_nodes, number_of_edges, degree)\n    ! given the edge index this will compute the degree of each node.\n    !\n    ! parameters\n    ! ----------\n    ! index1, index2 : array\n    !    the index of the edges of a tree, where the '1' and '2' refer to the ends of each edge.\n    ! number_of_nodes : integer\n    !    the array integer length of the nodes used to construct the tree.\n    ! number_of_edges : integer\n    !    the array integer length of the edges forming the constructed tree.\n    !\n    ! returns\n    ! -------\n    ! degree : array\n    !    the degree for each node, i.e. the number of edges attached to each node.\u00df\n\n    implicit none\n\n    integer, intent(in) :: number_of_nodes, number_of_edges\n    integer, intent(in) :: index1(number_of_edges), index2(number_of_edges)\n    double precision, intent(out) :: degree(number_of_nodes)\n\n    integer :: i\n\n    do i = 1, number_of_nodes\n        degree(i) = 0.\n    end do\n\n    do i = 1, number_of_edges\n        degree(index1(i)+1) = degree(index1(i)+1) + 1.\n        degree(index2(i)+1) = degree(index2(i)+1) + 1.\n    end do\n\nend subroutine get_degree_for_index\n"}, {"instruction": "Create a Fortran subroutine named ppnd7. It takes 1 input parameter of type real (sp) and 2 output parameters of type integer and real (sp). The subroutine computes the inverse of the cumulative distribution function for a standard normal distribution. Use the selected_real_kind function to define the real (sp) data type within the subroutine.", "input": "", "output": "  subroutine ppnd7 (p, normal_dev, ifault)\r\n    implicit none\r\n    integer, parameter      :: sp = selected_real_kind(6, 30)\r\n    real (sp), intent(in)   :: p\r\n    integer, intent(out)    :: ifault\r\n    real (sp), intent(out)  :: normal_dev\r\n  end subroutine ppnd7\r\n"}, {"instruction": "Create a Fortran subroutine named maxval_i to find the maximum value and its position in an array of integers. The number of input arguments is 2 and the test_data type is ['integer', 'integer, dimension(nvals)']. The number of output arguments is 2 and the test_data type is ['integer', 'integer, optional'].", "input": "", "output": "   subroutine maxval_i ( array, nvals, value_max, pos_maxval )\r\n   implicit none\r\n\r\n   ! list of calling arguments:\r\n   integer, intent(in) :: nvals                     ! # vals.\r\n   integer, intent(in), dimension(nvals) :: array   ! input data.\r\n   integer, intent(out) :: value_max                ! max value.\r\n   integer, intent(out), optional :: pos_maxval     ! position\r\n   \r\n   !  list of local variables:\r\n   integer :: i                            ! index\r\n   integer :: pos_max                      ! pos of max value\r\n\r\n   ! initialize the values to first value in array.\r\n   value_max = array(1)\r\n   pos_max = 1\r\n \r\n   ! find the extreme values in array(2) through array(nvals).\r\n   do i = 2, nvals\r\n      if ( array(i) > value_max ) then\r\n         value_max = array(i)\r\n         pos_max = i\r\n      end if\r\n   end do\r\n\r\n   ! report the results\r\n   if ( present(pos_maxval) ) then\r\n      pos_maxval = pos_max\r\n   end if\r\n\r\n   end subroutine maxval_i\r\n"}, {"instruction": "Create a Fortran subroutine named \"read_filename\" to read a string value from a file indicated by the file ID. The subroutine takes 1 input parameter of type integer (file_id) and 1 output parameter of type character with a length of 256 (val).", "input": "", "output": "subroutine read_filename(file_id, val)\n  integer, intent(in) :: file_id\n  character(len=256), intent(out) :: val\n\n  read(file_id, '(a)') val\n  val = adjustl(val)\nend subroutine read_filename\n"}, {"instruction": "Create a Fortran subroutine named set_frame that takes a character string as input and produces a framed version of the input string as output. The input parameter is of type 'character(*)' and the output parameter is of type 'character(:), allocatable, dimension(:)'.", "input": "", "output": "subroutine set_frame( text, frame )\n\n  character(*)                                          ,intent(in)     ::    text                            !< character string around which a frame is to be created\n  character(:)  ,allocatable    ,dimension(:)           ,intent(out)    ::    frame                           !< character string representing the framed text\n\n  integer                                                               ::    i\n  integer                                                               ::    maxlen                          ! maximum length of the output character string\n  integer                                                               ::    nlines                          ! number of lines of the frame including the text\n  integer       ,parameter                                              ::    nspace=2                        ! number of character used for spacing before and after the text in the frame\n  integer       ,parameter                                              ::    ntab=2                      ! number of character used for spacing before and after the text in the frame\n  character(*)  ,parameter                                              ::    char_frame='#'                  ! character used for the frame\n  character(3)                                                          ::    char_maxlen                     ! string representing the number of characters in the output string\n  character(3)                                                          ::    char_nspace                     ! string representing the number of blanc characters before and after the text message\n  character(3)                                                          ::    char_ntab\n  character(:)  ,allocatable                                            ::    string                          ! text to be framed (same tha input text but with no blanks at the begining and at the end)\n  character(:)  ,allocatable                                            ::    fmt_ext                         ! format for the external frame, ie. the upper and lower lines of the frame\n  character(:)  ,allocatable                                            ::    fmt_int                         ! format for the internal frame, ie. the text inside the frame\n\n  string        =       trim(adjustl(text))\n  nlines        =       3                                                                                       ! setting the number of lines to 3\n  maxlen        =       len(string) + 2 * (nspace + 1)                                                         ! number of characters in the output string including blanks and the framing characters\n  allocate( character(maxlen) :: frame(nlines) )                                                                ! allocation of dimension and length of the output string\n  write(char_maxlen,\"(i3)\") maxlen                                                                              ! interger-to-string convertion of the length of the output string\n  write(char_nspace,\"(i3)\") nspace                                                                              ! interger-to-string convertion of the number of blanks characters\n  write(char_ntab,\"(i3)\") ntab\n\n!   fmt_ext       =       \"(\" // char_ntab // \"x\" // char_maxlen // \"('\"// char_frame // \"'))\"                                        ! setting the format for the external frame, ie. the upper and lower lines of the frame\n!   fmt_int       =       \"(\" // char_ntab // \"x,'\"//char_frame//\"',\"//char_nspace//\"x,'\"//string//\"',\"//char_nspace//\"x,'\"//char_frame//\"')\"  ! setting the format for the internal frame, ie. the text inside the frame\n\n  fmt_ext       =       \"(\" // char_maxlen // \"('\"// char_frame // \"'))\"                                        ! setting the format for the external frame, ie. the upper and lower lines of the frame\n  fmt_int       =       \"('\"//char_frame//\"',\"//char_nspace//\"x,'\"//string//\"',\"//char_nspace//\"x,'\"//char_frame//\"')\"  ! setting the format for the internal frame, ie. the text inside the frame\n\n  write(frame(1),fmt_ext)                                                                                       ! writing the upper line of the frame\n  do i = 2,nlines-1                                                                                             ! loop on all internal lines\n    write(frame(i),fmt_int)                                                                                     ! writing the middle line of the frame\n  end do                                                                                                        ! end loop on\n  write(frame(nlines),fmt_ext)                                                                                  ! writing the lower line of the frame\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"materialvonmises\" to calculate the updated stresses, updated accumulated plastic strain, and the updated elastic constitutive matrix based on the Von Mises material model. The subroutine takes 4 input parameters of type real and returns 3 output parameters of type real.", "input": "", "output": "subroutine materialvonmises(afdstrains, fepsilonp, afstresses, afprops, afstressesnew, fepsilonpnew, afe)\n  !dec$ attributes dllexport::materialvonmises\n\timplicit none\n    real, intent(in) :: fepsilonp, afdstrains(6), afstresses(6), afprops(5)\n\treal, intent(out) :: afstressesnew(6), fepsilonpnew, afe(6, 6)\n\n\treal :: afstresseselastic(6), afdelastic(6, 6), afstressesdeviatoric(6)\n\tinteger :: k1, k2\n\treal :: ftemp1, ftemp2, ftemp3, fg, fdepsilonp, p_el, p_new, cj2_el, cj2_new\n\n! afprops(1)=e (young's modulus), afprops(2)=nu (poisson's ratio)\n! do not use nu=0.5 (incrompressible solid)\n! evaluate elastic constitutive matrix\n    afdelastic = 0.\n\tftemp1 = afprops(1) * (1. - afprops(2)) / (1. + afprops(2)) / (1. - 2. * afprops(2))\n\tftemp2 = afprops(1) * afprops(2) / (1. + afprops(2)) / (1. - 2. * afprops(2))\n\tftemp3 = afprops(1) / (1. + afprops(2)) / 2.\n\tafdelastic(1, 1) = ftemp1\n\tafdelastic(2, 2) = ftemp1\n\tafdelastic(3, 3) = ftemp1\n\tafdelastic(1, 2) = ftemp2\n\tafdelastic(1, 3) = ftemp2\n\tafdelastic(2, 1) = ftemp2\n\tafdelastic(2, 3) = ftemp2\n\tafdelastic(3, 1) = ftemp2\n\tafdelastic(3, 2) = ftemp2\n\tafdelastic(4, 4) = ftemp3\n\tafdelastic(5, 5) = ftemp3\n\tafdelastic(6, 6) = ftemp3\n\n! evaluate new afstresses tensor and state variable\n! calculate trial (elastic) afstresses state\n\tafstresseselastic = afstresses + matmul(afdelastic, afdstrains)\n! yield function <>0 ?\n! afprops(3)=sigma(y) (initial yield afstresses),\n! afprops(4)=h (hardening modulus for linear hardening)\n! fepsilonp(1)=epsilon(p)_bar (accumulated plastic strain)\n\tcj2_el = ((afstresseselastic(1) - afstresseselastic(2)) ** 2 + (afstresseselastic(2) - afstresseselastic(3)) ** 2 + &\n\t\t(afstresseselastic(3) - afstresseselastic(1)) ** 2) / 6. + afstresseselastic(4) ** 2 + afstresseselastic(5) ** 2 + &\n\t\tafstresseselastic(6) ** 2\n\tftemp1 = sqrt(3. * cj2_el) - (afprops(3) + afprops(4) * fepsilonp)\n\tif (ftemp1 <= 0.) then\n\t\tafstressesnew = afstresseselastic     ! no plastic correction needed\n\t\tafe = afdelastic       ! const. matrix = elastic const. matrix, no change to the accumulated plastic strain\n\telse\n! return mapping\n\t\tfg = afprops(1) / 2. / (1. + afprops(2))    ! fg = shear modulus\n\t\tfdepsilonp = ftemp1 / (3. * fg + afprops(4))\n\t\tfepsilonpnew = fepsilonp + fdepsilonp  ! update accumulated plastic strain\n\t\tftemp1 = fg * fdepsilonp * sqrt(3. / cj2_el)   ! 2. and 1/2. cancel out\n\t\tp_el = (afstresseselastic(1) + afstresseselastic(2) + afstresseselastic(3)) / 3.  ! p_el=mean afstresses (elastic)\n\t\tafstressesnew(1) = afstresseselastic(1) - ftemp1 * (afstresseselastic(1) - p_el)\n\t\tafstressesnew(2) = afstresseselastic(2) - ftemp1 * (afstresseselastic(2) - p_el)\n\t\tafstressesnew(3) = afstresseselastic(3) - ftemp1 * (afstresseselastic(3) - p_el)\n\t\tafstressesnew(4) = afstresseselastic(4) - ftemp1 * afstresseselastic(4)\n\t\tafstressesnew(5) = afstresseselastic(5) - ftemp1 * afstresseselastic(5)\n\t\tafstressesnew(6) = afstresseselastic(6) - ftemp1 * afstresseselastic(6)\n\n! create new jacobian\n\t\tp_new = (afstressesnew(1) + afstressesnew(2) + afstressesnew(3)) / 3.\n\t\tafstressesdeviatoric(1) = afstressesnew(1) - p_new\n\t\tafstressesdeviatoric(2) = afstressesnew(2) - p_new\n\t\tafstressesdeviatoric(3) = afstressesnew(3) - p_new\n\t\tafstressesdeviatoric(4) = afstressesnew(4)\n\t\tafstressesdeviatoric(5) = afstressesnew(5)\n\t\tafstressesdeviatoric(6) = afstressesnew(6)\n\n\t\tcj2_new = ((afstressesnew(1) - afstressesnew(2)) ** 2 + (afstressesnew(2) - afstressesnew(3)) ** 2 + &\n\t\t\t(afstressesnew(3) - afstressesnew(1)) ** 2 ) / 6. + afstressesnew(4) ** 2 + afstressesnew(5) ** 2 + &\n\t\t\tafstressesnew(6) ** 2\n\t\tftemp1 = 3. * fg * fg / (afprops(4) + 3. * fg) / cj2_new\n\t\tdo k1 = 1, 6\n\t\t\tdo k2 = 1, 6\n\t\t\t\tafe(k2, k1) = afdelastic(k2, k1) - ftemp1 * afstressesdeviatoric(k2) * afstressesdeviatoric(k1)\n\t\t\tend do\n\t\tend do\n!\t\tafe = afdelastic       ! const. matrix = elastic const. matrix, no change to the accumulated plastic strain\n\tend if\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named `associate_neighbor_spin` that associates a pointer with a target variable. The subroutine takes 1 input parameter of type 'integer, target' and 1 output parameter of type 'integer, pointer'.", "input": "", "output": "  subroutine associate_neighbor_spin(ptr, spin)\n    integer, pointer, intent(out) :: ptr\n    integer, target , intent(in)  :: spin\n    ptr => spin\n  end subroutine associate_neighbor_spin\n"}, {"instruction": "Write a Fortran subroutine named hello_world to display the rank, size, and hostname for a parallel program. The subroutine takes 2 input arguments of type integer (size and rank) and 1 output argument of type character with variable length.", "input": "", "output": "  subroutine hello_world(size, rank, myhostname)\n    integer, intent(in) :: size, rank\n    character(len = *), intent(out) :: myhostname\n\n    integer :: stat\n    \n    myhostname = \"(no host name)\"\n#ifdef __intel_compiler\n    call get_environment_variable(\"computername\", myhostname)\n#else\n    stat = hostnm(myhostname)\n#endif\n    \n    write(*, *) \"hello world fortran rank:\", rank, \" size:\", size, &\n    & \"hostname:\", trim(myhostname)\n  \n  end subroutine hello_world\n"}, {"instruction": "Write a Fortran subroutine named linspace to generate an array of evenly spaced real(8) numbers. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and produces 1 output parameter of type real(8).", "input": "", "output": "subroutine linspace(n, first, last, a)\nimplicit none\n\n    integer:: i\n    integer, intent(in):: n\n    real(8), intent(in):: first, last\n    real(8), intent(out):: a(n)\n\n    if (n==1) then\n        a(1) = (first + last)/2.0d0\n\n    else\n        do i = 1, n\n\n            a(i) = ( real(n-i, kind=8)*first + real(i-1, kind=8)*last )/ &\n                   real(n-1,kind=8)\n        end do\n\n    end if\n\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named initial to initialize the values of h, uh, and vh based on the specified input parameters. The number of input arguments is 7 with test_data types as ['integer', 'integer', 'real(8)', 'real(8)', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 3 with test_data types as ['real(8)', 'real(8)', 'real(8)'].", "input": "", "output": "subroutine initial(pi, nx, ny, x, y, h, uh, vh, x_length, y_length)\nimplicit none\n\n    integer, intent(in):: nx, ny\n\treal(8), intent(in):: x(nx), y(ny), pi, x_length, y_length\n\treal(8), intent(out):: h(nx,ny), uh(nx,ny), vh(nx,ny)\n\treal(8)::a, x0, y0, sx, sy\n\tinteger:: i, j\n\n    ! sine wave initial condition\n\n\t!h(1:nx, 1:ny) = 2.0d0 + sin(2*pi* x(1:nx))\n\n\t! dam break initial condition\n\t!h = 1.0d0\n\t!h(1:nx/2, :) = 3.0d0\n\n    ! gaussian function\n    a = 3.0d0\n    x0 = x_length/2.0d0\n    y0 = y_length/2.0d0\n    sx = 0.2d0\n    sy = 0.2d0\n\n    do j = 1, ny\n    do i = 1, nx\n        h(i,j) = a*exp(- ( (x(i)-x0)**2 /(2*sx**2) + (y(j)-y0)**2 /(2*sy**2) ) )\n    end do\n    end do\n\n\tuh(1:nx, 1:ny) = 0.0d0\n\tvh(1:nx, 1:ny) = 0.0d0\n\n\nreturn\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named split_str to parse a string and extract a label and a corresponding value. The subroutine takes 1 input parameter of type character *80 and 2 output parameters, one of type character *40 and the other of type real (kind=8).", "input": "", "output": "  subroutine split_str(str,label,val)\n    character *40, intent(out) :: label\n    character *80, intent(in) :: str \n    real (kind=8), intent(out) :: val \n    character strt\n    integer (kind=4) :: ind, slen\n\n    strt = str(1:1)\n\n    if(strt .eq. '!' .or. strt .eq. '#' .or. strt .eq. '/') then\n        label = '!'\n        val = 0\n        return\n    end if\n\n    ind = index(str,'=',.false.)\n\n    if(ind .eq. 0) then\n        label = '!'\n        val = 0\n    end if\n\n    label=str(1:ind-1)\n\n    slen = len_trim(str)\n    read(str(ind+1:slen),*)val\n\n  end subroutine split_str\n"}, {"instruction": "Write a Fortran subroutine named get_field to extract a specific field from an input string. The subroutine takes 2 input parameters of type character(*) and integer, and 3 output parameters of type character(*), integer, and character(*). The input string contains fields separated by one or more spaces, and the subroutine retrieves the nth field and stores it in the output string. Additionally, it returns an error code and message if there are any issues during the extraction process.", "input": "", "output": "subroutine get_field(str_in,str_out,n,err_n,err_msg)\n\n  ! takes an input string str_in in which\n  ! every field is separated one another by one or more spaces.\n  ! gets the n field and store it in str_out.\n\n  character(*), intent(in)  :: str_in\n  character(*), intent(out) :: str_out\n  integer,      intent(in)  :: n\n  integer,      intent(out) :: err_n         ! 0 on success, 1 otherwise\n  character(*), intent(out) :: err_msg       ! message set in case of failure\n  integer, parameter        :: success       = 0\n  integer, parameter        :: failure       = 1\n  integer                   :: i\n  integer                   :: current_field\n  integer                   :: start_field\n  integer                   :: end_field\n  character(1)              :: ch\n  character(3)              :: n_str\n  character(8)              :: istr1\n  character(8)              :: istr2\n  logical                   :: prev_space\n\n  if (n<1) then\n    err_n   = failure\n    err_msg = \"get_field: argument must be a non-zero positive integer\"\n    return\n  end if\n\n  start_field   = -1\n  end_field     = -1\n  current_field =  0\n  prev_space    = .true.\n  do i=1, len_trim(str_in)\n    ch = str_in(i:i)\n\n    if (ch==\" \") then\n      if ((prev_space.eqv..false.).and.(current_field==n)) then\n        end_field = i-1\n        exit\n      end if\n      prev_space = .true.\n    else\n      if (prev_space.eqv..true.) then\n        current_field = current_field+1\n        if (current_field==n) then\n          start_field = i\n        end if\n      end if\n\n      prev_space = .false.\n    end if\n  end do\n\n  if (start_field/=-1) then\n    if (end_field==-1) then\n      end_field = len_trim(str_in)\n    end if\n  else\n    write(n_str,'(i3)') n\n    n_str   = adjustl(n_str)\n    err_n   = failure\n    err_msg = \"get_field: cannot get field \"//trim(n_str)//&\n      &\" from string \"\"\"//trim(str_in)//\"\"\"\"\n    return\n  end if\n\n  if ((end_field-start_field+1)>len(str_out)) then\n    err_n   = failure\n    write(istr1,'(i8)') len(str_out)\n    istr1 = adjustl(istr1)\n    write(istr2,'(i8)') end_field-start_field+1\n    istr2 = adjustl(istr2)\n    err_msg = \"get_field: output string too small (\"//trim(istr1)//&\n      &\") to contain the field (\"//trim(istr2)//\")\"\n    return\n  end if\n\n  str_out = str_in(start_field:end_field)\n  err_n   = success\n\nend subroutine get_field\n"}, {"instruction": "Create a Fortran subroutine named gausspointsandweights to calculate the points and weights for the Gaussian quadrature. The subroutine takes 1 input parameter of type integer and 2 output parameters of type real*8, allocatable. The input parameter specifies the number of points and weights to be calculated.", "input": "", "output": "subroutine gausspointsandweights(x,w,npoints)\n\n\t\tinteger,intent(in) :: npoints\n\t\treal*8, allocatable, intent(out) :: w(:)\n\t\treal*8, allocatable, intent(out) :: x(:)\n\n\t\tallocate(w(npoints))\n\t\tallocate(x(npoints))\n\n\t\tif(npoints .eq. 1) then\n\t\t\tw(1)=2.0\n\t\t\tx(1)=0.0\n\t\tendif\n\n\t\tif(npoints .eq. 2) then\n\t\t\tw(1)=1.0\n\t\t\tw(2)=1.0\n\n\t\t\tx(1)=-1.0/sqrt(3.0)\n\t\t\tx(2)=1.0/sqrt(3.0)\n\t\tendif\n\n\t\tif(npoints .eq. 3) then\n\t\t\tw(1)=5.0/9.0\n\t\t\tw(2)=8.0/9.0\n\t\t\tw(3)=5.0/9.0\n\n\t\t\tx(1)=-sqrt(3.0/5.0)\n\t\t\tx(2)=0.0\n\t\t\tx(3)=sqrt(3.0/5.0)\n\t\tendif\n\n\t\tif(npoints .eq. 4) then\n\t\t\tw(1) = (18.0-sqrt(30.0))/36.0\n\t\t\tw(2) = (18.0+sqrt(30.0))/36.0\n\t\t\tw(3) = (18.0+sqrt(30.0))/36.0\n\t\t\tw(4) = (18.0-sqrt(30.0))/36.0\n\n\t\t\tx(1) = -sqrt((3.0+2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(2) = -sqrt((3.0-2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(3) =  sqrt((3.0-2.0*sqrt(6.0/5.0))/7.0)\n\t\t\tx(4) =  sqrt((3.0+2.0*sqrt(6.0/5.0))/7.0)\n\t\tendif\n\nend subroutine gausspointsandweights\n"}, {"instruction": "Create a Fortran subroutine named gll_gen that generates Gauss-Lobatto-Legendre points and weights. It takes 1 input argument of type integer and 2 output arguments of type real*8, allocatable. The number of input arguments is 1, the test_data type is ['integer'], and the number of output arguments is 2, the test_data type is ['real*8,allocatable', 'real*8,allocatable'].", "input": "", "output": "subroutine gll_gen(x,w,n)\n\n      integer, intent(in) :: n\n      real*8,allocatable, intent(out) :: x(:),w(:)\n\n      real*8 :: dleg(n+1)\n      real*8 :: pi,tol,x_it,xold\n      integer :: maxit,n1,i,j,k\n\n      allocate(x(n+1))\n      allocate(w(n+1))\n\n      pi = acos(-1.)\n\n      tol = 1d-15\n\n      n1 = n+1\n\n      maxit = 1000   ! max iterations for newton-raphson\n  \n      x(1) = -1.d0\n      x(n1) = 1.d0\n \n      do i = 1, n+1\n\n        x_it = -cos(pi * float(i-1) / n) ! initial guess - chebyshev points\n\n        do j = 1, maxit \n\n    \t  xold = x_it\n          dleg(1) = 1.d0\n          dleg(2) = x_it\n\n\t  do k = 2,n  \n\n            dleg(k+1) = (  (2.d0*float(k) - 1.d0) * dleg(k) * x_it &\n                    - (float(k)-1.d0)*dleg(k-1) ) / float(k)\n          \n          enddo\n\n          x_it = x_it - ( x_it * dleg(n1) - dleg(n) ) / &\n                (float(n1) * dleg(n1) ) \n\n          if (abs(x_it - xold) .lt. tol) goto 10\n\n        enddo\n        write(*,*) 'max itertions reached'\n10      continue\n\n        x(i) = x_it\n        w(i) = 2.d0 / (float(n * n1) * dleg(n1)**2 )\n\n      enddo\n\n      return\n\nend subroutine gll_gen\n"}, {"instruction": "Create a Fortran subroutine named mergesort_indirect_i to perform an indirect mergesort on an array of integers. The subroutine takes one input parameter, an integer array of any size, and one output parameter, an integer array of the same size. The subroutine utilizes recursive and contains features to sort the array in ascending order using an indirect sorting method.", "input": "", "output": "  subroutine mergesort_indirect_i( array, iarray)\r\n    integer, dimension(:), intent(in) :: array\r\n    integer, dimension(:), intent(out) :: iarray\r\n\r\n    integer :: tmp((size(array)+1)/2)\r\n    integer :: i, n\r\n\r\n    n = size (array)\r\n    iarray = (/(i,i=1,n)/)\r\n    \r\n    call mg_sort_no_cmp(iarray, tmp)\r\n    \r\n  contains\r\n\r\n    recursive subroutine mg_sort_no_cmp(idx, tmp)\r\n      integer, intent(inout) :: idx(:) \r\n      integer                :: tmp(:)\r\n      \r\n      integer :: n, nh\r\n\r\n      n = size(idx)\r\n      \r\n      if (n .eq. 1) then\r\n\r\n         return\r\n\r\n      else if (n .eq. 2) then\r\n\r\n         if (array(idx(2)) < array(idx(1))) then\r\n            idx(1:2) = idx(2:1:-1)\r\n         end if\r\n\r\n      else\r\n\r\n         nh = (n+1)/2\r\n         call mg_sort_no_cmp(idx(1:nh),tmp)\r\n         call mg_sort_no_cmp(idx(nh+1:),tmp)\r\n         \r\n         if (array(idx(nh+1)) < array(idx(nh))) then\r\n            tmp(1:nh) = idx(1:nh)\r\n            call merge_no_cmp(tmp(1:nh), idx)\r\n         end if\r\n\r\n      end if\r\n\r\n      return\r\n    end subroutine mg_sort_no_cmp\r\n\r\n    subroutine merge_no_cmp(tmp, idx)\r\n      integer, intent(inout) :: idx(:)\r\n      integer, intent(in   ) :: tmp(:) \r\n      \r\n      integer :: n, nh, i, j, k\r\n\r\n      n = size(idx)\r\n      nh = size(tmp)\r\n\r\n      i=1 \r\n      j=nh+1 \r\n      k=1\r\n\r\n      do while (i .le. nh .and. j .le. n)\r\n         if (array(idx(j)) < array(tmp(i))) then\r\n            idx(k) = idx(j)\r\n            j = j+1\r\n         else\r\n            idx(k) = tmp(i)\r\n            i = i+1\r\n         end if\r\n         k = k+1\r\n      end do\r\n\r\n      if (i .le. nh) idx(k:) = tmp(i:nh)\r\n\r\n      return\r\n    end subroutine merge_no_cmp\r\n\r\n  end subroutine mergesort_indirect_i\r\n"}, {"instruction": "Create a Fortran subroutine named chan_pack that takes 5 input parameters of types integer, integer, integer, real, and integer, and 1 output parameter of type real. This subroutine packs elements from a 2D array based on a mask and stores the result in a 2D output array.", "input": "", "output": "subroutine chan_pack(varnd, mask, nstot, nt, var2d, ns)\n\n\timplicit none\n\n\t! external\n\t! --------\n\tinteger, intent(in)  :: nstot, nt, ns\n\treal,    intent(in)  :: varnd(nt,nstot)\n\tinteger, intent(in)  :: mask(nstot)\n\treal,    intent(out) :: var2d(ns,nt)\n\n\t! internal\n\t! --------\n\tinteger :: it\n\n\t! call to pack\n\t! ------------\n\tdo it = 1, nt\n\t\tvar2d(:,it) = pack(varnd(it,:), mask==1)\n\tend do\n\nend subroutine chan_pack\n"}, {"instruction": "Write a Fortran subroutine named load_array1d_character that reads character data from a specified input unit and dynamically allocates memory to store the data. The subroutine takes 1 input parameter of type integer and 1 output parameter of type character(*), allocatable.", "input": "", "output": "  subroutine load_array1d_character(iounit, val)\n    implicit none\n    integer, intent(in)       :: iounit\n    character(*),allocatable, intent(out) :: val(:)\n    logical :: f\n    integer :: lb1, ub1\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      allocate(val(lb1:ub1))\n      read(iounit) val(:)\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named load_array2d_real8 to read data from a specified input unit and allocate it to a 2D real(8) array. The subroutine takes 1 input parameter of type integer, representing the input unit. It also has 1 output parameter of type real(8) array that is allocatable.", "input": "", "output": "  subroutine load_array2d_real8(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    real(8), allocatable, intent(out) :: val(:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      allocate(val(lb1:ub1,lb2:ub2))\n      read(iounit) val(:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named load_array5d_real8 to read data from a specified unit and allocate a 5-dimensional array of real(8) values based on the read data. The subroutine takes 1 input parameter of type integer to specify the input unit, and outputs a real(8) allocatable 5-dimensional array.", "input": "", "output": "  subroutine load_array5d_real8(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    real(8), allocatable, intent(out) :: val(:,:,:,:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    integer :: lb3, ub3\n    integer :: lb4, ub4\n    integer :: lb5, ub5\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      read(iounit) lb3, ub3\n      read(iounit) lb4, ub4\n      read(iounit) lb5, ub5\n      allocate(val(lb1:ub1,lb2:ub2,lb3:ub3,lb4:ub4,lb5:ub5))\n      read(iounit) val(:,:,:,:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named load_array3d_integer to read 3D integer array data from a specified input unit. The subroutine takes 1 input parameter of type integer and allocates memory for the 3D integer array. The output is an allocatable 3D integer array.", "input": "", "output": "  subroutine load_array3d_integer(iounit, val)\n    implicit none\n    integer, intent(in)               :: iounit\n    integer, allocatable, intent(out) :: val(:,:,:)\n    logical :: f\n    integer :: lb1, ub1\n    integer :: lb2, ub2\n    integer :: lb3, ub3\n    read(iounit) f\n    if (f) then\n      read(iounit) lb1, ub1\n      read(iounit) lb2, ub2\n      read(iounit) lb3, ub3\n      allocate(val(lb1:ub1,lb2:ub2,lb3:ub3))\n      read(iounit) val(:,:,:)\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named fpy_get_drange to determine the range of dimensionality for a set of files with specific prefixes and member names. The subroutine takes 2 input parameters of type character(len=*) and returns 1 output parameter of type integer, allocatable.", "input": "", "output": "  subroutine fpy_get_drange(drange, prefix, members)\n    integer, allocatable, intent(out) :: drange(:)\n    character(len=*), intent(in) :: prefix, members(:)\n\n    integer :: d, i, j, k\n    logical :: exists, memexists\n    character(len=:), allocatable :: catstr\n    character(50) :: istr\n    \n    !first, check the dimensionality of the range by checking for a member at the first position.\n    exists = .true.\n    memexists = .false.\n    i = 0\n    d = 0\n    catstr = ''\n\n    do while (i .lt. 7)\n       if (len(catstr) .gt. 0) then\n          catstr = catstr//'.1'\n       else\n          catstr = '1'\n       end if\n\n       memexists = .false.\n       j = 1\n       do while (j .le. size(members) .and. .not. memexists)\n          inquire(file=prefix//catstr//'-'//trim(members(j)), exist=memexists)\n          j = j+1\n       end do\n       \n       i = i + 1\n       if (memexists) then\n          d = i\n       end if\n    end do\n    if (d .eq. 0) return\n    allocate(drange(d))\n\n    do k=1, d\n       i = 1\n       exists = .true.\n       do while(exists)\n          write (istr, *) i\n          catstr = ''\n          \n          do j=1, k\n             if (len(catstr) .gt. 0) catstr = catstr//'.'\n             \n             if (j .lt. k) then\n                catstr = catstr//'1'\n             else\n                catstr = catstr//trim(adjustl(istr))\n             end if\n          end do\n          do j=k, d-1\n             catstr = catstr//'.1'\n          end do\n\n          memexists = .false.\n          j = 1\n          do while (j .le. size(members) .and. .not. memexists)\n             inquire(file=prefix//catstr//'-'//trim(members(j)), exist=memexists)\n             j = j+1\n          end do\n\n          exists = memexists\n          if (exists) then\n             i = i+1\n          else\n             i = i-1\n          end if\n       end do\n       drange(k) = i\n    end do    \n  end subroutine fpy_get_drange\n"}, {"instruction": "Write a Fortran subroutine named \"aslegf\" to compute the next associated Legendre function using a recursive relationship. The subroutine takes 6 input parameters of types integer, integer, integer, real*8, real*8, real*8, and outputs 1 parameter of type real*8. The subroutine computes the next associated Legendre function using the input parameters l, m, sgm, mu, plm1m, and plm, and stores the result in the output parameter plmp1.", "input": "", "output": "subroutine aslegf(l,m,sgm,mu,plm1m,plm,plmp1)\n\n! ---------------------------------------------\n!\n! uses a recursive relationship to compute the\n!  next associated legendre function\n!\n! ---------------------------------------------\n\nimplicit none\n\ninteger, intent(in) :: l, m, sgm\nreal*8, intent(in) :: mu, plm1m, plm\nreal*8, intent(out) :: plmp1\n\nplmp1 = (1.0/sqrt(1.0-mu**2))*((l-m+1)*sgm*mu*plm - (l+m-1)*plm1m)\n\nend subroutine aslegf\n"}, {"instruction": "Write a Fortran subroutine named z_getsettings to determine settings for tightly-packed chasing and aggressive deflation at the start and end. The subroutine takes 1 input parameter of type integer and returns 4 output parameters, all of which are of type integer.", "input": "", "output": "  subroutine z_getsettings(n,m,k,we,ws)\n  ! settings for tightly-packed chasing and aggressive\n  ! deflation at the start and end\n  !___________________________________________________________________________\n    integer, intent(in)             ::  n\n    integer, intent(out)            ::  m, k, we, ws\n\n    if (n .lt. ssth) then\n      k = 1\n      m = 1\n      we = 1\n      ws = 1\n    elseif (n .lt. 60) then\n      k = 4\n      m = 4\n      we = 6\n      ws = 2\n    elseif (n .lt. 180) then\n      k = 10\n      m = 10\n      we = 12\n      ws = 4\n    elseif (n .lt. 1001) then\n      k = 32\n      m = 32\n      we = 34\n      ws = 6\n    elseif (n .lt. 3000) then\n      k = 64\n      m = 64\n      we = 66\n      ws = 12\n    elseif (n .lt. 6000) then\n      k = 128\n      m = 128\n      we = 130\n      ws = 20\n    else\n      k = 256\n      m = 256\n      we = 266\n      ws = 28\n    end if\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named search_bisec that performs a bisection search on an ascending array to find the indices that bracket a given value. The subroutine takes 2 input parameters of type real*8, and an integer array, and returns 2 output parameters of type integer.", "input": "", "output": "      subroutine search_bisec(v,x,lower,upper)\n!     -------------------------------------------------------------\n!     given value v; search an (**ascending order**)  array x(n) \n!     by bisection, returning the indices that bracket value v\n!     -------------------------------------------------------------\n      implicit none\n      real*8, intent(in):: v, x(:)\n      integer :: n,mid\n      integer, intent(out)::lower,upper\n\n      n=size(x)\n      upper=n\n      lower=1\n      \n      do while ((upper - lower) .gt. 1)\n         mid= (upper + lower)/2\n         if ( v .gt. x(mid)) then\n            upper=upper\n            lower=mid\n         else\n            upper=mid\n            lower=lower\n         endif\n      enddo\n\n      return\n      end subroutine \n"}, {"instruction": "Write a Fortran subroutine named \"bracket\" to identify the lower and upper bounds of a non-zero segment within an array. The subroutine takes 3 input arguments of type integer and 2 output arguments of type integer.", "input": "", "output": "    subroutine bracket(sig, ll, hh, llo, hho)\r\n      integer, intent(in) :: ll, hh\r\n      integer, intent(out) :: llo, hho\r\n      integer, intent(in)    :: sig(ll:hh)\r\n\r\n      llo = ll\r\n      hho = hh\r\n      do while ( sig(llo) == 0  .and.  hho-llo >= minwidth/blocking_factor )\r\n         llo = llo + 1\r\n      end do\r\n\r\n      do while ( sig(hho) ==  0  .and. hho-llo >= minwidth/blocking_factor )\r\n         hho = hho - 1\r\n      end do\r\n\r\n    end subroutine bracket\r\n"}, {"instruction": "Create a Fortran subroutine named check_uniqueness_ivec to check the uniqueness between elements of an integer array. The subroutine takes 2 input parameters of type integer: size_vec and ivec(size_vec), and 1 output parameter of type logical: is_unique.", "input": "", "output": "    subroutine check_uniqueness_ivec ( ivec,size_vec,is_unique )        !\n    ! check the uniqueness between integer array elements               !\n    !-------------------------------------------------------------------+\n  \n    implicit none\n    integer, intent(in)     :: size_vec\n    integer, intent(in)     :: ivec(size_vec)\n    logical, intent(out)    :: is_unique\n    \n    integer                 :: b_int,c_int\n    integer                 :: i,j\n    \n    is_unique = .true.\n    \n    baseloop: do i=1,size_vec-1\n        b_int = ivec(i)\n        do j=i+1,size_vec\n            c_int = ivec(j)\n            if ( c_int==b_int ) then\n                is_unique = .false. \n                exit baseloop\n            end if\n        end do\n    end do baseloop\n    \n    \n    end subroutine check_uniqueness_ivec\n"}, {"instruction": "Create a Fortran subroutine named index2e that takes two integer input parameters and returns one integer output parameter. This subroutine computes the one-dimensional index corresponding to the (i, j) position in a lower triangular matrix.", "input": "", "output": "subroutine index2e(i,j,ij)\n  implicit none\n  integer, intent(in)           :: i,j\n  integer, intent(out)          :: ij\n\n  if (i>j)then\n    ij = i*(i+1)/2 + j\n  else\n    ij = j*(j+1)/2 + i\n  endif\n\nend subroutine index2e\n"}, {"instruction": "Write a Fortran subroutine named decompose_1d to divide a one-dimensional array into segments for parallel processing. The subroutine takes 3 input arguments of type integer: total_n, rank, and num_process. It also has 1 output argument of type integer: local_n. The subroutine calculates the local_n, which represents the number of elements to be processed by the current process, based on the total_n and num_process. If the rank is less than the remainder of total_n divided by num_process, local_n is increased by 1.", "input": "", "output": "subroutine decompose_1d(total_n, local_n, rank, num_process)\n    implicit none\n    integer, intent(in) :: total_n, rank, num_process\n    integer, intent(out) :: local_n\n\n    local_n = total_n / num_process\n\n    if (rank < mod(total_n, num_process)) then\n        local_n = local_n + 1\n    endif\n\nend subroutine decompose_1d\n"}, {"instruction": "Write a Fortran subroutine named calcula_perfil to calculate the temperature profile in a furnace. The subroutine takes 7 input parameters of type real: ta, t1, t2, t3, r1, r2, r3. It also has 1 output parameter of type real array with dimension n.", "input": "", "output": "subroutine calcula_perfil(ta, t1, t2, t3, r1, r2, r3,t)\n    implicit none\n\n    real, intent(in) :: ta, t1, t2, t3, r1, r2, r3\n    integer, parameter :: n = 30   ! n\u00famero de elementos finitos\n    real, dimension(n), intent(out) :: t\n\n    real :: l, sor, dx, t_media, tn\n    integer :: p_n1, p_n2, p_n3, i, j ,k\n    real, dimension(n) :: fonte\n\n    l = 2.0         ! comprimento do forno em metros\n    sor = 1.85      ! par\u00e2metro sor\n    p_n1 = n/4      ! posi\u00e7\u00e3o do primeiro sensor de temperatura\n    p_n2 = n/2      ! segundo sensor\n    p_n3 = 3*n/4    ! terceiro sensor\n\n    dx = l/(n+1)\n    t_media = (2*ta + t1 + t2 + t3)/5\n\n    ! valores iniciais da temperatura\n    do i=1, n-1\n        t(i) = t_media\n    enddo\n    t(1) = ta   ! tempa ambiente nas pontas (direichilet)\n    t(n) = ta   ! tempa ambiente nas pontas (direichilet)\n\n    ! valores da fonte\n    do i=1, int(n/3)\n        fonte(i) = r1\n    enddo\n    do i=int(n/3)+1, int(2*n/3)\n        fonte(i) = r2\n    enddo\n    do i=int(2*n/3)+1, n\n        fonte(i) = r3\n    enddo\n\n\n    do j=1, 200\n        do i=2 , n-1\n            if (i == p_n1) then\n                t(i) = t1\n            else if (i == p_n2) then\n                t(i) = t2\n            else if (i == p_n3) then\n                t(i) = t3\n            else\n                tn = (t(i-1) + t(i+1))/2.0 +dx*dx*fonte(i)\n                t(i) = t(i) + sor*( tn - t(i) )\n            end if\n        enddo\n    enddo\n\nend subroutine calcula_perfil\n"}, {"instruction": "Create a Fortran subroutine named make_index_iter that takes two input integer arguments, mx_store and iter_present, and one output integer array argument, index_iter. This subroutine generates an index array based on the values of mx_store and iter_present. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "  subroutine make_index_iter(mx_store, iter_present, index_iter)\n\n    implicit none\n\n    ! passed variables\n    integer, intent(in) :: mx_store\n    integer, intent(in) :: iter_present\n    integer, intent(out) :: index_iter(0:mx_store-1)\n\n    ! local variables\n    integer :: iter\n\n    index_iter(:) = 0\n    if(iter_present < mx_store) then\n       do iter = 0, iter_present-1\n          index_iter(iter)=iter_present-iter\n       enddo\n    else\n       do iter = 0, mx_store-1\n          index_iter(iter)=mod(iter_present-iter-1,mx_store)+1\n       enddo\n    endif\n    return\n  end subroutine make_index_iter\n"}, {"instruction": "Create a Fortran subroutine named rotmat that computes the Givens rotation matrix parameters c and s for given input values a and b. The subroutine takes 2 input arguments of type real*8 and returns 2 output arguments of type real*8.", "input": "", "output": "subroutine rotmat(a,b,c,s)\n\n!----------------------------------------------------\n!\n! compute the givens rotation matrix parameters c, s\n!  for given a, b\n!\n!----------------------------------------------------\n\nimplicit none\nreal*8, intent(in) :: a, b\nreal*8, intent(out) :: c, s\nreal*8 :: temp\n\nif (b == 0.0) then\n   c = 1.0\n   s = 0.0\nelse if (abs(b) > abs(a)) then\n   temp = a/b\n   s = 1.0/sqrt(1.0 + temp**2)\n   c = temp*s\nelse\n   temp = b/a\n   c = 1.0/sqrt(1.0 + temp**2)\n   s = temp*c\nend if\n\nreturn\nend subroutine rotmat\n"}, {"instruction": "Create a Fortran subroutine named get2dpbcwithmod to calculate the periodic boundary conditions for a 2D grid. The subroutine takes 2 input parameters of type integer and returns 4 output parameters of type integer.", "input": "", "output": "\tsubroutine get2dpbcwithmod(pos, lsze, r, u, l, d)\n\t  integer, intent(in) :: pos, lsze\n\t  integer :: lvol\n\t  integer, intent(out) :: r, u, l, d\n\t  lvol = lsze ** 2\n\t  u = pos - lsze\n\t  if(u .le. 0) then\n\t    u = lvol + u\n\t  endif\n\t  d = pos + lsze\n\t  if(d .gt. lvol) then\n\t    d = d - lvol\n\t  endif\n\t  r = pos + 1\n\t  if(mod(pos, lsze) .eq. 0) then\n\t    r = r - lsze\n\t  endif\n\t  l = pos - 1\n\t  if(mod(l, lsze) .eq. 0) then\n\t    l = l + lsze\n\t  endif\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named extremes that takes 2 input arguments: an integer n and an array of real numbers of length n. The subroutine has 4 optional output arguments: a real number representing the maximum value, an integer representing the position of the maximum value, a real number representing the minimum value, and an integer representing the position of the minimum value.", "input": "", "output": "  subroutine extremes(a, n, maxval, pos_maxval, minval, pos_minval)\n  implicit none\n  integer, intent(in) :: n\n  real, intent(in), dimension(n) :: a\n  real, intent(out), optional :: maxval\n  integer, intent(out), optional :: pos_maxval\n  real, intent(out), optional :: minval\n  integer, intent(out), optional :: pos_minval\n  integer :: i\n  real :: real_max\n  integer :: pos_max\n  real :: real_min\n  integer :: pos_min\n\n  real_max = a(1)\n  pos_max = 1\n  real_min = a(1)\n  pos_min = 1\n  do i = 2, n\n    if (a(i) > real_max) then\n      real_max = a(i)\n      pos_max = i\n    else if (a(i) < real_min) then\n      real_min = a(i)\n      pos_min = i\n    end if\n  end do\n\n  if (present(maxval)) then\n    maxval = real_max\n  end if\n  if (present(pos_maxval)) then\n    pos_maxval = pos_max\n  end if\n  if (present(minval)) then\n    minval =  real_min\n  end if\n  if (present(pos_minval)) then\n    pos_minval = pos_min\n  end if\n\n  end subroutine extremes\n"}, {"instruction": "Write a Fortran subroutine named fasta_string2seq to convert a string of characters representing a sequence according to a given alphabet into an array of integers representing the corresponding indices of the characters in the alphabet. The subroutine should have 2 input parameters of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine fasta_string2seq(alphabet, string,seq)\n    ! read a sequence, return an array of integer\n    character(len=*), intent(in)  :: alphabet\n    character(len=*), intent(in)  :: string\n    integer,          intent(out) :: seq(:)\n    integer :: i\n\n    seq = [(index(trim(alphabet), string(i:i)), i = 1, len_trim(string))]\n\n  end subroutine fasta_string2seq\n"}, {"instruction": "Create a Fortran subroutine named \"ordered_dithering3x3\" to perform ordered dithering on an input matrix of quantized values. The subroutine takes 3 input parameters of type integer, integer, and integer array of dimension (0:h-1, 0:l-1), and 1 output parameter of type integer array of dimension (0:3*h-1, 0:3*l-1). The subroutine implements an ordered dithering algorithm by mapping the quantized values to a 3x3 pattern and placing the corresponding pattern in the output array.", "input": "", "output": "    subroutine ordered_dithering3x3(quantized, h, l, returnparam)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: quantized\n      integer, dimension(0:3*h-1, 0:3*l-1), intent(out) :: returnparam\n\n      integer, dimension(3,3) :: selectedlevel\n      integer :: i, j, k, r, xs, xf, ys, yf\n      integer level\n\n      k = 0\n      r = 0\n\n      do i = 0, h-1\n        do j = 0, l-1\n          level = quantized(i,j)\n          select case (level)\n            case (1)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 0, 0, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case (2)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 0, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case(3)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 0, 0 /)\n            case (4)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 0 /)\n              selectedlevel(3,:) = (/ 0, 1, 0 /)\n            case (5)\n              selectedlevel(1,:) = (/ 0, 0, 0 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 0, 1, 0 /)\n            case(6)\n              selectedlevel(1,:) = (/ 0, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 0, 1 /)\n            case (7)\n              selectedlevel(1,:) = (/ 0, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 0 /)\n            case (8)\n              selectedlevel(1,:) = (/ 1, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 0 /)\n            case (9)\n              selectedlevel(1,:) = (/ 1, 0, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 1 /)\n            case default\n              selectedlevel(1,:) = (/ 1, 1, 1 /)\n              selectedlevel(2,:) = (/ 1, 1, 1 /)\n              selectedlevel(3,:) = (/ 1, 1, 1 /)\n          end select\n          xs = i + k\n          xf = xs + 3\n          ys = j + r\n          yf = ys + 3\n          returnparam(xs:xf, ys:yf) = selectedlevel\n          r = r + 2\n        end do\n          r = 0\n          k = k + 2\n      end do\n    end subroutine ordered_dithering3x3\n"}, {"instruction": "Write a Fortran subroutine named ordered_comb4_iterator to generate a binary matrix based on a masked matrix. The subroutine takes 3 input parameters of type integer, integer, and integer, dimension(0:h-1, 0:l-1), and 1 output parameter of type integer, dimension(0:h-1, 0:4*l-1).", "input": "", "output": "    subroutine ordered_comb4_iterator(masked, h, l, binary)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: masked\n      integer, dimension(0:h-1, 0:4*l-1), intent(out) :: binary\n\n      integer :: i, j, r\n      integer, dimension(0:15, 4) :: level\n\n      level(0, :) = (/ 0, 0, 0, 0 /)\n      level(1, :) = (/ 0, 0, 0, 1 /)\n      level(2, :) = (/ 0, 0, 1, 0 /)\n      level(3, :) = (/ 0, 0, 1, 1 /)\n      level(4, :) = (/ 0, 1, 0, 0 /)\n      level(5, :) = (/ 0, 1, 0, 1 /)\n      level(6, :) = (/ 0, 1, 1, 0 /)\n      level(7, :) = (/ 0, 1, 1, 1 /)\n      level(8, :) = (/ 1, 0, 0, 0 /)\n      level(9, :) = (/ 1, 0, 0, 1 /)\n      level(10, :) = (/ 1, 0, 1, 0 /)\n      level(11, :) = (/ 1, 0, 1, 1 /)\n      level(12, :) = (/ 1, 1, 0, 0 /)\n      level(13, :) = (/ 1, 1, 0, 1 /)\n      level(14, :) = (/ 1, 1, 1, 0 /)\n      level(15, :) = (/ 1, 1, 1, 1 /)\n\n      do i = 0, h - 1\n        r = 0\n        do j = 0, l - 1\n          binary(i, j+r:j+r+3) = level(masked(i, j), :)\n          r = r + 3\n        end do\n      end do\n    end subroutine ordered_comb4_iterator\n"}, {"instruction": "Write a Fortran subroutine named ordered_comb3_iterator to generate a new array based on the input array and parameters. The number of input arguments is 3 with the test_data type ['integer', 'integer', 'integer, dimension(0:h-1, 0:l-1)']. The number of output arguments is 1 with the test_data type ['integer, dimension(0:h-1, 0:3*l-1)'].", "input": "", "output": "    subroutine ordered_comb3_iterator(masked, h, l, returnparam)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: masked\n      integer, dimension(0:h-1, 0:3*l-1), intent(out) :: returnparam\n\n      integer :: i, j, r\n      integer, dimension(0:7, 3) :: level\n      integer, dimension(0:h-1, 0:3*l-1) :: binary\n\n      level(0, :) = (/ 0, 0, 0 /)\n      level(1, :) = (/ 0, 0, 1 /)\n      level(2, :) = (/ 0, 1, 0 /)\n      level(3, :) = (/ 0, 1, 1 /)\n      level(4, :) = (/ 1, 0, 0 /)\n      level(5, :) = (/ 1, 0, 1 /)\n      level(6, :) = (/ 1, 1, 0 /)\n      level(7, :) = (/ 1, 1, 1 /)\n      do i = 0, h - 1\n        r = 0\n        do j = 0, l - 1\n          binary(i, j+r:j+r+2) = level(masked(i, j), :)\n          r = r + 2\n        end do\n      end do\n      returnparam = binary\n    end subroutine ordered_comb3_iterator\n"}, {"instruction": "Create a Fortran subroutine named realise_iid that computes the realized shock of an iid process. The subroutine should have 3 input parameters of type integer, integer, and real(8) for agents, periods, and param_value respectively. The output parameter should be an integer array of dimension (agents, periods) for shocks.", "input": "", "output": "subroutine realise_iid(agents, periods, param_value, shocks)\n  ! computes the realised shock of an iid process\n\n  implicit none\n\n  integer, intent(in) :: agents, periods\n  integer :: ind_ag, ind_p\n  integer, dimension(agents, periods), intent(out) :: shocks\n  real(8), intent(in) :: param_value\n  real(8), dimension(agents, periods) :: aux_shocks\n\n  shocks = 0\n\n  call random_number(aux_shocks)\n\n  do ind_ag = 1, agents\n  do ind_p = 1, periods\n    if (aux_shocks(ind_ag,ind_p).le.param_value) then\n      shocks(ind_ag,ind_p) = 1\n    end if\n  end do\n  end do\nend subroutine realise_iid\n"}, {"instruction": "Create a Fortran subroutine named random_integers to generate a matrix of random integers. The subroutine takes 4 input parameters of type integer: rows, columns, lb, and ub. It also has 1 output parameter, an integer matrix of dimension (rows, columns). The subroutine utilizes the random_number function to populate an auxiliary real matrix and then converts the real values to integers within the specified range [lb, ub].", "input": "", "output": "subroutine random_integers(rows, columns, lb, ub, int_matrix)\n  ! returns a int_matrix(rows, columns) of random integer number numbers in [lb,ub]\n  integer, intent(in) :: rows, columns, lb, ub\n  integer, dimension(rows, columns), intent(out) :: int_matrix\n  real(8), dimension(rows, columns) :: aux_mat\n\n  call random_number(aux_mat)\n\n  int_matrix = lb + floor(real(ub+1-lb)*aux_mat)\nend subroutine random_integers\n"}, {"instruction": "Write a Fortran subroutine named linint to perform linear interpolation. The subroutine takes 4 input parameters: an integer (n), an array of double precision (xa), an array of double precision (ya), and a double precision (x). It produces 2 output parameters: both of double precision type (y, m).", "input": "", "output": "  subroutine linint(xa,ya,n,x,y,m)\r\n    implicit none\r\n    integer, intent(in) :: n\r\n    double precision, intent(in) :: xa(n),ya(n),x\r\n    double precision, intent(out) :: y,m\r\n\r\n    integer :: jlo,jhi,k\r\n    double precision :: b\r\n\r\n    jlo=1  \r\n    jhi=n\r\n\r\n    !determine which two xa location that x lies between\r\n    do\r\n      k=(jhi+jlo)/2\r\n\r\n      if(xa(k).gt.x)then\r\n        jhi=k\r\n      else\r\n        jlo=k\r\n      endif\r\n\r\n      if (jhi-jlo == 1) exit\r\n    enddo\r\n\r\n    !calculate the slope and intersect\r\n    m = ( ya(jlo) - ya(jhi) )/ ( xa(jlo) - xa(jhi) )\r\n    b = ya(jlo) - m*xa(jlo)\r\n\r\n    !linearly interpolate y\r\n    y = m*x + b\r\n\r\n    return\r\n\r\n  end subroutine linint\r\n"}, {"instruction": "Create a Fortran subroutine named assigncomplex. The subroutine takes 1 input parameter of type real*8 and returns 1 output parameter of type real*8. The purpose of this subroutine is to assign the input real number to the output real variable.", "input": "", "output": "subroutine assigncomplex(realmat,complexf)\n  implicit none\n  real*8,intent(out) :: realmat\n  real*8,intent(in) :: complexf\n  realmat=complexf\nend subroutine assigncomplex\n"}, {"instruction": "Write a Fortran subroutine named assigncomplexmat to copy the values of a complex matrix to a real matrix. The subroutine takes 3 input arguments of types integer, integer, and real*8, and 1 output argument of type real*8.", "input": "", "output": "subroutine assigncomplexmat(realmat,complexf,m,n)\n  implicit none\n  integer,intent(in) :: n,m\n  real*8,intent(out) :: realmat(m,n)\n  real*8,intent(in) :: complexf(m,n)\n  realmat(:,:)=complexf(:,:)\nend subroutine assigncomplexmat\n"}, {"instruction": "Write a Fortran subroutine named assigncomplexvec that takes two input parameters of type integer and real*8, and one output parameter of type real*8. The input parameter m is of type integer and is used to specify the size of the arrays. The input parameter complexf is an array of real*8 values. The output parameter realmat is also an array of real*8 values and is assigned the values from the complexf array.", "input": "", "output": "subroutine assigncomplexvec(realmat,complexf,m)\n  implicit none\n  integer,intent(in) :: m\n  real*8,intent(out) :: realmat(m)\n  real*8,intent(in) :: complexf(m)\n  realmat(:)=complexf(:)\nend subroutine assigncomplexvec\n"}, {"instruction": "Create a Fortran subroutine named assignrealvec to copy the elements of a real*8 array into another real*8 array. The subroutine should take 2 input parameters of type integer and real*8, and 1 output parameter of type real*8. The input parameters are m (integer) and realmat (real*8 array), and the output parameter is complexf (real*8 array).", "input": "", "output": "subroutine assignrealvec(complexf,realmat,m)\n  implicit none\n  integer,intent(in) :: m\n  real*8,intent(in) :: realmat(m)\n  real*8,intent(out) :: complexf(m)\n  complexf(:)=realmat(:)\nend subroutine assignrealvec\n"}, {"instruction": "Create a Fortran subroutine named assigncomplexvec that takes two input parameters: an integer m and an array of complex*16 numbers complexf of length m. The subroutine outputs a 2xM real*8 matrix realmat. The first row of realmat contains the real parts of the complex numbers, and the second row contains the imaginary parts of the complex numbers.", "input": "", "output": "subroutine assigncomplexvec(realmat,complexf,m)\n  implicit none\n  integer,intent(in) :: m\n  complex*16,intent(in) :: complexf(m)\n  real*8,intent(out) :: realmat(2,m)\n  realmat(1,:)=real(complexf(:),8);  realmat(2,:)=imag(complexf(:))\nend subroutine assigncomplexvec\n"}, {"instruction": "Create a Fortran subroutine named assignrealvec. The subroutine takes 2 input arguments with test_data types ['integer', 'real*8'] and 1 output argument with a test_data type of ['complex*16']. The subroutine computes the complex values by adding the real parts of the input matrix with the product of the imaginary unit and the second row of the input matrix.", "input": "", "output": "subroutine assignrealvec(complexf,realmat,m)\n  implicit none\n  integer,intent(in) :: m\n  complex*16,intent(out) :: complexf(m)\n  real*8,intent(in) :: realmat(2,m)\n  complexf(:)=realmat(1,:)+realmat(2,:)*(0d0,1d0)\nend subroutine assignrealvec\n"}, {"instruction": "Create a Fortran subroutine named checkelementconvexity to determine the convexity of an element based on its vertices' coordinates and vertex indices. The subroutine takes 4 input parameters of type integer, integer array, real(8) array, and real(8) array, and returns 1 output parameter of type integer.", "input": "", "output": "  pure subroutine checkelementconvexity(nvertex,vertex,x,y,convexnode)\n    integer,intent(in)           :: nvertex,vertex(:)\n    real(8),intent(in)           :: x(:),y(:)\n    integer,intent(out)          :: convexnode\n\n    !local variables\n    integer :: indx,iff,ibb\n    real(8) :: crossproduct\n\n    !initialize\n    convexnode =  0\n\n    !if element is triangular it cannot be convex\n    if (nvertex .eq. 3) return\n\n    !check if element is convex\n    !walking along the cell faces in the counter-clockwise direction and generating vectors between vertices,\n    !if cross product of two vectors joining at a vertex is negative we are turning right (internal angle greater than 180),\n    !otherwise we are turning left (what we want)\n    do indx=1,4\n      iff=indx+1  ;  if (iff.gt.4) iff=1\n      ibb=indx-1  ;  if (ibb.lt.1) ibb=4\n      crossproduct =  (x(indx)-x(ibb))*(y(iff)-y(indx)) &\n                    + (y(ibb)-y(indx))*(x(iff)-x(indx))\n      if (crossproduct .le. 0.0) then\n        convexnode = vertex(indx)\n        exit\n      end if\n   end do\n\n  end subroutine checkelementconvexity\n"}, {"instruction": "Create a Fortran subroutine named \"recons_stencil\" that takes 2 input parameters of type integer and logical, and 3 output parameters of type integer. The subroutine's purpose is to generate stencil indices for a reconstruction procedure based on material interfaces. The input parameter \"ie\" represents the cell index, and \"matint_cell\" is a logical array indicating the presence of material interfaces around the cell. The output parameters \"lefte\", \"righte\", and \"skew\" represent the stencil indices for the left, right, and skew directions, respectively. The subroutine modifies these indices based on the presence of material interfaces and the cell index.", "input": "", "output": "subroutine recons_stencil(ie, matint_cell, lefte, righte, skew)\n\ninteger, intent(in) :: ie\nlogical, intent(in) :: matint_cell(-2:2)\n\ninteger, intent(out) :: lefte, righte, skew\n\n  ! 0. default central stencil\n  lefte = ie-1\n  righte = ie+1\n  skew = 0\n  ! only for interior cells, try to modify the limiting stencil according to\n  ! material interfaces\n  if ((ie.gt.1) .and. (ie.lt.imax)) then\n    ! 1. for material interface cells\n    if (matint_cell(0)) then\n      ! if this is the only material interface cell in the vicinity, diffuse\n      ! the interface\n      if (.not.matint_cell(-1) .and. .not.matint_cell(1)) then\n        lefte = ie-1\n        righte = ie+1\n        skew = 0\n      ! if the left cell is not an interface cell, extend stencil to right,\n      ! but only if the right cell is an interface cell\n      else if (.not.matint_cell(-1) .and. matint_cell(2)) then\n        lefte = ie+2\n        skew = 1\n      ! if the right cell is not an interface cell, extend stencil to left,\n      ! but only if the left cell is an interface cell\n      else if (.not.matint_cell(1) .and. matint_cell(-2)) then\n        righte = ie-2\n        skew = -1\n      end if\n    ! 2. for 'pure' cells\n    else\n      if (matint_cell(-1) .and. matint_cell(1)) then\n        lefte = ie-1\n        righte = ie+1\n        skew = 0\n      else if (matint_cell(-1) .and. .not.matint_cell(2)) then\n        lefte = ie+2\n        skew = 1\n      else if (matint_cell(1) .and. .not.matint_cell(-2)) then\n        righte = ie-2\n        skew = -1\n      end if\n    end if\n  end if\n\nend subroutine recons_stencil\n"}, {"instruction": "Write a Fortran subroutine named open_grib_f that opens a grib file for writing and returns the file unit number. The subroutine takes 1 input argument of type character(len=*) and returns 1 output argument of type integer.", "input": "", "output": "  subroutine open_grib_f(fname,funit)\n   \n    ! opens a grib file for writing and returns the funit\n    implicit none\n    character(len=*),intent(in)      :: fname\n    integer,intent(out)                :: funit\n    logical                            :: opened \n    unitloop: do funit=7,1023\n      inquire(unit=funit,opened=opened) \n      if (.not.opened) exit unitloop\n    enddo unitloop\n    open(file=fname,unit=funit,access='direct',form='unformatted',&\n         recl=1) \n    return\n  end subroutine open_grib_f\n"}, {"instruction": "Create a Fortran subroutine named equivalence_array1d that identifies the unique points in a given array based on a specified tolerance. The subroutine takes 4 input parameters of type integer, integer, double precision, and double precision. It also returns 2 output parameters of type integer and double precision. The input parameters are d0, d1, array, and tol, while the output parameters are npts and eq_array. The subroutine works by comparing points in the input array to identify unique points within the specified tolerance.", "input": "", "output": "subroutine equivalence_array1d(d0, d1, array, tol, npts, eq_array)\n    !> equivalence points of an array.\n    !> d0 - dimension 1 of array (number of points).\n    !> d1 - dimension 2 of array (3 for dehomogenized array,\n    !> 4 for homogeneous array).\n    !> array - input array.\n    !> tol - tolerance.\n    !> npts - number of unique points.\n    !> eq_array - array of unique points.\n    \n    !f2py intent(in) d0, d1, array, tol\n    !f2py intent(out) npts, eq_array\n    !f2py depend(d0, d1) array, eq_array\n    \n    ! input\n    integer, intent(in) :: d0, d1\n    double precision, intent(in) ::  tol\n    double precision, intent(in) :: array(d0, d1)\n    \n    ! output\n    integer, intent(out) :: npts\n    double precision, intent(out) :: eq_array(d0, d1)\n    \n    ! working\n    logical :: unique\n    integer :: i, j, k\n    double precision :: dist, v(d1)\n    \n    eq_array(:, :) = 0.0d0\n    eq_array(1, :) = array(1, :)\n    npts = 1\n    do i = 2, d0\n        unique = .true.\n        do j = 1, npts\n            v = eq_array(j, :) - array(i, :)\n            dist = 0.0d0\n            do k = 1, d1\n                dist = dist + v(k) * v(k)\n            end do\n            dist = dsqrt(dist)\n            if (dist .le. tol) then\n                unique = .false.\n                exit\n            end if\n        end do\n        if (unique .eqv. .true.) then\n            npts = npts + 1\n            eq_array(npts, :) = array(i, :)\n        end if\n    end do\nend subroutine equivalence_array1d\n"}, {"instruction": "Write a Fortran subroutine named tsort to perform a topological sort on a directed acyclic graph. The subroutine takes 3 input parameters of type integer, integer, and integer array of dimension nd, and returns 2 output parameters, one of type integer array of dimension nl, and another of type integer.", "input": "", "output": "subroutine tsort(nl,nd,idep,iord,no)\n\n  implicit none\n\n  integer,intent(in) :: nl\n  integer,intent(in) :: nd\n  integer,dimension(nd,2),intent(in) :: idep\n  integer,dimension(nl),intent(out) :: iord\n  integer,intent(out) :: no\n\n  integer :: i,j,k,il,ir,ipl,ipr,ipos(nl)\n\n  do i=1,nl\n    iord(i)=i\n    ipos(i)=i\n  end do\n  k=1\n  do\n    j=k\n    k=nl+1\n    do i=1,nd\n      il=idep(i,1)\n      ir=idep(i,2)\n      ipl=ipos(il)\n      ipr=ipos(ir)\n      if (il==ir .or. ipl>=k .or. ipl<j .or. ipr<j) cycle\n      k=k-1\n      ipos(iord(k))=ipl\n      ipos(il)=k\n      iord(ipl)=iord(k)\n      iord(k)=il\n    end do\n    if (k<=j) exit\n  end do\n  no=j-1\n\nend subroutine tsort\n"}, {"instruction": "Create a Fortran subroutine named arr_2_int_int32 to convert an array of integers into a single integer. The subroutine takes 1 input parameter of type integer array and returns 1 output parameter of type integer.", "input": "", "output": "    pure subroutine arr_2_int_int32(arr, n)\n        integer, intent(in) :: arr(:)\n        integer, intent(out) :: n\n        integer :: i, tmp, l\n\n        l = size(arr, dim=1)\n        tmp = 0\n\n        do i = 1, l\n            tmp = tmp*10 + arr(i)\n        end do\n\n        n = tmp\n    end subroutine arr_2_int_int32\n"}, {"instruction": "Create a Fortran subroutine named score_board to analyze a game board and compute the score based on specific rules. The subroutine takes 3 input parameters of type integer, dimension(100), integer, dimension(100,5,5), and integer, and 2 output parameters of type integer.", "input": "", "output": "      subroutine score_board(board, index, numbers, i, score)\n        integer, dimension(100), intent(in) :: numbers\n        integer, dimension(100,5,5), intent(in) :: board\n        integer, intent(in) :: index\n        integer, intent(out) :: i, score\n        integer, dimension(5,5) :: called\n        integer :: n\n\n        score = 0\n\n        do j = 1, 5\n           do k = 1, 5\n              called(j,k) = 0\n              score = score + board(index,j,k)\n           end do\n        end do\n\n        do i = 1, 100\n           n = numbers(i)\n           do j = 1, 5\n              do k = 1, 5\n                 if (board(index,j,k) == n) then\n                    called(j,k) = 1\n                    score = score - board(index,j,k)\n                    if (called(j,1) + called(j,2) + called(j,3) + called(j,4) + called(j,5) == 5) then\n                       print*, \"row\"\n                       return\n                    else if (called(1,k) + called(2,k) + called(3,k) + called(4,k) + called(5,k) == 5) then\n                       print*, \"col\"\n                       return\n                    end if\n                 end if\n              end do\n           end do\n        end do\n      end subroutine score_board\n"}, {"instruction": "Create a Fortran subroutine named snowalb_bats_glacier to calculate the snow albedo for a glacier surface. The subroutine takes 3 input parameters: an integer (nband), and two real numbers (cosz, fage). It returns 2 output parameters: two real arrays of size 2 (albsnd, albsni). The subroutine computes the snow albedo for direct and diffuse solar radiation based on the provided inputs.", "input": "", "output": "  subroutine snowalb_bats_glacier (nband,cosz,fage,albsnd,albsni)\n  implicit none\n  integer,intent(in) :: nband\n  real,intent(in) :: cosz\n  real,intent(in) :: fage\n  real, dimension(1:2),intent(out) :: albsnd\n  real, dimension(1:2),intent(out) :: albsni\n  real :: fzen\n  real :: cf1\n  real :: sl2\n  real :: sl1\n  real :: sl\n  real, parameter :: c1 = 0.2\n  real, parameter :: c2 = 0.5\n        albsnd(1: nband) = 0.\n        albsni(1: nband) = 0.\n        sl=2.0\n        sl1=1./sl\n        sl2=2.*sl\n        cf1=((1.+sl1)/(1.+sl2*cosz)-sl1)\n        fzen=amax1(cf1,0.)\n        albsni(1)=0.95*(1.-c1*fage)\n        albsni(2)=0.65*(1.-c2*fage)\n        albsnd(1)=albsni(1)+0.4*fzen*(1.-albsni(1))\n        albsnd(2)=albsni(2)+0.4*fzen*(1.-albsni(2))\n  end subroutine snowalb_bats_glacier\n"}, {"instruction": "Write a Fortran subroutine named ell_house to compute a Householder vector v and a beta value based on the input vector x. The number of input arguments is 2, with test_data types ['integer', 'real(kind(1.d0))']. The number of output arguments is 2, with test_data types ['real(kind(1.d0))', 'real(kind(1.d0))'].", "input": "", "output": "subroutine ell_house( n, x, v, beta )\n\n!  determine a householder vector v based on x.\n!  the orthogonal matrix p = i - beta * v * v^t has the\n!  property: px = |x| * e_1.\n\n!  from golub & van loan algorithm 5.1.1\n\ninteger, intent(in)           :: n\nreal(kind(1.d0)), intent(in)  :: x(n)\nreal(kind(1.d0)), intent(out) :: v(n), beta\n\nreal(kind(1.d0)) :: sigma, mu\n\nv    = 0.d0\nbeta = 0.d0\nif( n <= 1 ) return\n\nsigma  = sum( x(2:n)*x(2:n) )\nv(1)   = 1.d0\nv(2:n) = x(2:n)\n\nif( sigma == 0.d0 ) then\n   beta = 0.d0\nelse\n   mu = sqrt( x(1)**2 + sigma )\n   if( x(1) < 0.d0 ) then\n      v(1) = x(1) - mu\n   else\n      v(1) = -sigma / ( x(1) + mu )\n   endif\n\n   beta = 2.*v(1)**2 / (sigma+v(1)**2)\n   v    = v / v(1)\nendif\n\nreturn\n\nend subroutine ell_house\n"}, {"instruction": "Create a Fortran subroutine named getuniquearraycomponents to extract unique elements from an input integer array and store them in an allocatable integer array. The number of input parameters is 1 with the test_data type ['integer'], and the number of output parameters is 1 with the test_data type ['integer,allocatable'].", "input": "", "output": "  subroutine getuniquearraycomponents(arrayin,arrayout)\n    integer,intent(in)              :: arrayin(:)\n    integer,allocatable,intent(out) :: arrayout(:)\n    \n    !local variables\n    integer :: n,workarray(size(arrayin)),indx,ivalue\n    \n    !initialize\n    n            = 1\n    workarray(1) = arrayin(1)\n    do indx=2,size(arrayin)\n      ivalue = arrayin(indx)\n      if (.not. any(workarray(1:n) .eq. ivalue)) then\n        n = n + 1\n        workarray(n) = ivalue\n      end if\n    end do\n    \n    !allocate memory for return array and store data\n    allocate (arrayout(n))\n    arrayout = workarray(1:n)\n    \n  end subroutine getuniquearraycomponents\n"}, {"instruction": "Write a Fortran subroutine named convertid_to_index_scalar that takes two integer input parameters and one integer output parameter. The input parameters are id and allids(:), and the output parameter is index. The subroutine should find the index of the given id in the array allids and assign the index to the output parameter. If id is not found, the output parameter should be 0.", "input": "", "output": "  subroutine convertid_to_index_scalar(id,allids,index)\n    integer,intent(in)  :: id,allids(:)\n    integer,intent(out) :: index\n    \n    !local variables\n    integer :: indx\n    \n    !initialize\n    index = 0\n    \n    if (id .eq. 0) return\n    \n    do indx=1,size(allids)\n        if (id .eq. allids(indx)) then\n            index = indx\n            exit\n        end if\n    end do\n    \n  end subroutine convertid_to_index_scalar\n"}, {"instruction": "Create a Fortran subroutine named pw_integ to calculate the integral of the plane wave in the interstitials. The subroutine takes 9 input parameters of types: integer, real*8, real*8, real*8, integer, real*8, integer, integer, integer. There is 1 output parameter of type complex*16.", "input": "", "output": "subroutine pw_integ(ipwint, gind, glen, vmt, rmt, pos, mult, nk, nat, ndf)\n  ! this function calculated integral of the plane wave in the interstitials\n  ! for all vectors in gind array with length glen:\n  !  integrate[ exp(i g\\vr), {\\vr in interstitials}]\n  ! \n  ! we could use  function int1ipw from for_vxcnn.f90, which does the same thing, but for\n  ! a single vector\n  implicit none\n  complex*16, intent(out) :: ipwint(nk)\n  integer, intent(in)     :: gind(nk,3)\n  real*8, intent(in)      :: glen(nk)\n  real*8, intent(in)      :: vmt(nat)\n  real*8, intent(in)      :: rmt(nat)\n  integer, intent(in)     :: mult(nat)\n  real*8, intent(in)      :: pos(3,ndf)\n  integer, intent(in)     :: nk, nat, ndf\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  integer    :: ippw, i, idf, iat, ki(3), ieq\n  real*8     :: ak, x, j1, intmod!, pk\n  complex*16 :: integc\n  complex*16 :: phase, two_pi_i\n  two_pi_i = 2.0d0*pi*cmplx(0.d0,1.d0,8)\n  ipwint = 0\n  do ippw=1,nk\n     !i = indx(ippw)+1\n     i = ippw\n     ki = gind(i,:)  ! ki=(i0,i1,i2)\n     ak = glen(i)    ! ak=|kc|\n     !print *, ippw, i, ki, ak\n     if (ak < 1e-10) then\n        integc = 0\n        do iat=1,nat\n           integc = integc + vmt(iat)*mult(iat)\n        end do\n        ipwint(ippw) = 1.d0 - integc\n     else\n        integc = 0\n        idf = 0\n        do iat=1,nat\n           phase = 0\n           do ieq=1,mult(iat)\n              idf = idf + 1\n              !pk = dot_product(pos(:,idf),ki)*2.d0*pi\n              !phase = phase + dcmplx( cos(pk), sin(pk) )\n              phase = phase + exp(two_pi_i * dot_product(pos(:,idf),ki))\n           end do\n           x = ak * rmt(iat)                    ! kr[iat] = |kc|*rmt[iat]\n           j1 = (sin(x)/x-cos(x))/x             ! spherical_bessel == (sin(x)/x-cos(x))/x\n           intmod = vmt(iat) * 3*j1/x           ! intmod[iat] = j1*3*vmt/kr\n           integc = integc + intmod * phase\n        end do\n        ipwint(ippw) = -integc\n     end if\n  end do\nend subroutine pw_integ\n"}, {"instruction": "Create a Fortran subroutine named count_number_pw to calculate the number of plane waves and the number of plane waves within a certain range. The subroutine takes 4 input parameters of type integer, real*8, and real*8, and 2 output parameters of type integer.", "input": "", "output": "subroutine count_number_pw(npw2apw, ngindx, ng, kmax, gmax, br2)\n  implicit none\n  integer, intent(out) :: npw2apw, ngindx\n  integer, intent(in)  :: ng(3)\n  real*8,  intent(in)  :: br2(3,3)\n  real*8,  intent(in)  :: kmax, gmax\n  !\n  real*8  :: ki(3), kc(3), kk\n  integer :: i1, i2, i3\n  npw2apw = 0\n  ngindx = 0\n  do i1=-ng(1),ng(1)\n     do i2=-ng(2),ng(2)\n        do i3=-ng(3),ng(3)\n           ki(1) = i1\n           ki(2) = i2\n           ki(3) = i3\n           kc = matmul(br2,ki)\n           kk = sqrt(dot_product(kc,kc))\n           if ( kk < 2.*kmax+4) npw2apw = npw2apw + 1\n           if ( kk < gmax ) ngindx = ngindx + 1\n        enddo\n     enddo\n  enddo\nend subroutine count_number_pw\n"}, {"instruction": "Create a Fortran subroutine named getindices to determine the neighboring indices of a given index in an array. The subroutine takes 2 input parameters of type integer and returns 3 output parameters of type integer. The subroutine computes the previous, current, and next indices based on the given index and the size of the array.", "input": "", "output": "    subroutine getindices(idx, nx, xb, xc, xf)\n        implicit none\n        integer, intent(in) :: idx, nx\n        integer, intent(out) :: xb, xc, xf\n\n        if( idx == 1) then\n            xb = nx\n            xc = idx\n            xf = idx+1\n        else if(idx == nx) then\n            xb = idx-1\n            xc = idx\n            xf = 1\n        else\n            xb = idx-1\n            xc = idx\n            xf = idx+1\n        endif\n    end subroutine getindices\n"}, {"instruction": "Create a Fortran subroutine named string_out_assumed_len that takes an integer as input and returns two strings of assumed length as output. The input parameter is of type integer, and the output parameters are of type character(len=*). The function assigns the strings 'string a' and 'string b' to the output parameters s1 and s2, respectively.", "input": "", "output": "  subroutine string_out_assumed_len(s1,x,s2)\n    character(len=* ), intent(out) :: s1,s2\n    integer, intent(in) :: x ! dummy\n    s1 = 'string a'\n    s2 = 'string b'\n  end subroutine string_out_assumed_len\n"}, {"instruction": "Create a Fortran subroutine named \"choleskysolve\" to solve a system of linear equations using the Cholesky factorization method. The subroutine takes 3 input parameters of types integer, real(8) arrays of dimension n x n, and real(8) array of dimension n. It produces 1 output parameter of type real(8) array of dimension n.", "input": "", "output": "subroutine choleskysolve(n, l, b, x)\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n),   intent(in)  :: b\n   real(8), dimension(n),   intent(out) :: x\n\n   ! declare the local variables.\n   integer :: i, j\n\n   ! initialize.\n   x = b\n\n   ! solve l y = b using forward elimination.\n   do i = 1, n\n      do j = 1, i-1\n         x(i) = x(i) - l(i,j)*x(j)\n      end do\n      x(i) = x(i) / l(i,i)\n   end do\n\n   ! solve l' x = y using back substitution.\n   do i = n, 1, -1\n      do j = i+1, n\n         x(i) = x(i) - l(j,i)*x(j)\n      end do\n      x(i) = x(i) / l(i,i)\n   end do\nend subroutine choleskysolve\n"}, {"instruction": "Create a Fortran subroutine named choleskyinverse to calculate the inverse of a matrix using the Cholesky decomposition method. The subroutine takes 2 input parameters: an integer n and a real(8) matrix l of dimension n x n. It produces 1 output parameter: a real(8) matrix ainv of dimension n x n.", "input": "", "output": "subroutine choleskyinverse(n, l, ainv)\n\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n,n), intent(out) :: ainv\n\n   ! declare the local variables.\n   integer :: i, k\n   real(8), dimension(n,n) :: u\n\n   ! initialize.\n   u = transpose(l)\n\n   ! invert u in place.\n   do k = 1, n\n      u(k,k) = 1.0_8/u(k,k)\n\n      do i = 1, k-1\n         u(i,k) = -u(k,k) * dot_product( u(i,i:k-1), u(i:k-1, k) )\n      end do\n   end do\n\n   ! a = l l' = l u --> ainv = uinv linv = uinv (uinv)'\n   ainv = matmul(u, transpose(u))\n\nend subroutine choleskyinverse\n"}, {"instruction": "Create a Fortran subroutine named \"rspdinv\" that computes the inverse of a symmetric positive definite matrix using Cholesky decomposition. The subroutine takes 2 input parameters: an integer \"n\" and a real(8) 2D array \"l\" of size n x n. It produces 1 output parameter: a real(8) 2D array \"ainv\" of size n x n.", "input": "", "output": "subroutine rspdinv(n, l, ainv)\n\n   ! declare the arguments.\n   integer,                 intent(in)  :: n\n   real(8), dimension(n,n), intent(in)  :: l\n   real(8), dimension(n,n), intent(out) :: ainv\n\n   ! declare the local variables.\n   integer :: i, k\n   real(8), dimension(n,n) :: u\n\n   ! compute the cholesky decomposition.\n   ! call choleskydecomposition(n, a, l)\n   u = transpose(l)\n\n   ! invert u in place.\n   do k = 1, n\n      u(k,k) = 1.0_8/u(k,k)\n\n      do i = 1, k-1\n         u(i,k) = -u(k,k) * dot_product( u(i,i:k-1), u(i:k-1, k) )\n      end do\n   end do\n\n   ! a = l l' = l u --> ainv = uinv linv = uinv (uinv)'\n   ainv = matmul(u, transpose(u))\n\nend subroutine rspdinv\n"}, {"instruction": "Create a Fortran subroutine named bar that takes three input arguments of type real, dimension(3,3), real, dimension(3,3), and logical, dimension(3,3), and one output argument of type integer. The subroutine utilizes a do loop to compare elements of the input arrays and assigns a value to the output argument based on the comparison results.", "input": "", "output": "  subroutine bar(a,b,c, lo)\n    real, dimension(3,3), intent(in) :: a,b\n    logical, dimension(3,3), intent(in) :: lo\n    integer, intent(out) :: c\n    real, parameter :: acc = 1e-4\n    integer :: i,j\n    \n    c = 0\n    do i=1,3\n       if (any([abs(a(i,1) - b(i,1)) > acc,  &\n            (j==i+1,j=3,8)])) cycle\n       if (any([abs(a(i,2) - b(i,2)) > acc, &\n            abs(a(i,3) - b(i,3)) > acc, lo(i,:)])) cycle\n       c = c + i\n    end do\n  end subroutine bar\n"}, {"instruction": "Create a Fortran subroutine named count_tree to read and process data from a file. The subroutine takes 2 input parameters of type character(len=256) and logical. It also has 4 output parameters of type integer. The subroutine reads data from the file specified by the input parameter, processes the data, and assigns the results to the output parameters flist_index, slist_index, n_halos_all, and nsteps.", "input": "", "output": "subroutine count_tree(fn, n_halos_all, flist_index, slist_index, nsteps, big_run)\n    implicit none\n    character(len=256), intent(in)::fn\n\n    integer::nfathers, nsons\n    integer, dimension(:), allocatable::nb_of_halos, nb_of_subhalos\n    integer, intent(out)::flist_index, slist_index, n_halos_all, nsteps\n\n    integer(kind=4)::i,j, nhals_now\n    logical, intent(in)::big_run\n\n    open(unit=1,file=fn,status='old',form='unformatted')\n\n    read(1)nsteps\n    allocate(nb_of_halos(1:nsteps))\n    allocate(nb_of_subhalos(1:nsteps))\n    read(1)nb_of_halos(1:nsteps),nb_of_subhalos(1:nsteps)\n\n    n_halos_all = sum(nb_of_halos) + sum(nb_of_subhalos)\n    read(1)!aexp_arr(1:nsteps)\n    read(1)!omega_t_arr(1:nsteps)\n    read(1)!age_univ_arr(1:nsteps)\n    flist_index=0\n    slist_index=0\n    do i=1,nsteps\n        nhals_now=nb_of_halos(i)+nb_of_subhalos(i)\n        do j=1,nhals_now\n            read(1)!id_tmp!i_arr(idx,2) !id!id\n            read(1)!i_arr(idx,3) !bushid\n            read(1)!i_arr(idx,4) !st\n            read(1)!i_arr(idx,5:9) ! hosts\n            read(1)!f_arr(idx,1) ! m\n            read(1)!macc ! macc alone is double\n            read(1)!f_arr(idx,3:5)!xp\n            read(1)!f_arr(idx,6:8)!vp\n            read(1)!f_arr(idx,9:11)!lp\n            read(1)!f_arr(idx,12:15)!abc\n            read(1)!f_arr(idx,16:18)!energy\n            read(1)!f_arr(idx,19)!spin\n            read(1)nfathers!nfathers\n            flist_index = flist_index + nfathers\n\n            read(1)!father id\n            read(1)!father mass\n            read(1)nsons\n            if (nsons .gt. 0) then\n                read(1)!id_tmp!son id\n                !write(*,*)id_tmp\n            endif\n            slist_index = slist_index + nsons\n            read(1)! (r,m,t)_vir, c_vel\n            read(1)! profile\n            if (.not. big_run) then\n                read(1)!id_tmp! particle id\n            endif\n\n        enddo\n    enddo\n    deallocate(nb_of_halos, nb_of_subhalos)\n    close(1)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named setnodg that takes an integer femtype as input and returns an integer nodg as output. The subroutine determines the number of degrees of freedom per node based on the femtype provided. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "\tsubroutine setnodg(femtype,nodg)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tnodg = 3\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tnodg = 4\n\t\t\tcase(3) !! linear quadrangle\n\t\t\t\tnodg = 3\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named setfemtype to determine the finite element type based on the input femtype. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer. The output parameters represent nodg, porder, ngp, isimplex, and ibubble respectively. The subroutine uses a select case statement to assign values to the output parameters based on the input femtype. If the femtype is not supported, the subroutine stops and displays an error message.", "input": "", "output": "\tsubroutine setfemtype(femtype,nodg,porder,ngp,isimplex,ibubble)\n\t\tinteger , intent(in) :: femtype\n\t\tinteger , intent(out) :: nodg,porder,ngp,isimplex,ibubble\n\t\t\n\t\t\n\t\tselect case(femtype)\n\t\t\tcase(1) !! linear triangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(2) !! linear quadrangle\n\t\t\t\tngp = 1\n\t\t\t\tnodg = 4\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 1\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase(3) !! linear triangle with 3 gauss points\n\t\t\t\tngp = 3\n\t\t\t\tnodg = 3\n\t\t\t\tporder = 1\n\t\t\t\tisimplex = 0\n\t\t\t\tibubble = 0\n\t\t\n\t\t\tcase default\n\t\t\t\twrite(*,*) \"femtype = \" , femtype,  \"not supported at moment\"  \n\t\t\t\tstop\n\t\tend select\n\t\t\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named dcm_set that takes one input parameter of type real(8) and returns two output parameters, both of type real(8). This subroutine is designed to compute the direction cosine matrices cbe and ceb based on the input quaternion quat. Use this subroutine to perform the calculation.", "input": "", "output": "subroutine dcm_set(cbe,ceb,quat)\n  real(8),intent(in) :: quat(:)\n  real(8),intent(out) :: cbe(:,:),ceb(:,:)\n  \n  cbe(1,1) = quat(1)*quat(1) - quat(2)*quat(2) - quat(3)*quat(3) + quat(4)*quat(4)\n  cbe(2,1) = 2.0d0*(quat(1)*quat(2) + quat(3)*quat(4))\n  cbe(3,1) = 2.0d0*(quat(1)*quat(3) - quat(2)*quat(4))\n  cbe(1,2) = 2.0d0*(quat(1)*quat(2) - quat(3)*quat(4))\n  cbe(2,2) = quat(2)*quat(2) - quat(1)*quat(1) - quat(3)*quat(3) + quat(4)*quat(4)\n  cbe(3,2) = 2.0d0*(quat(2)*quat(3) + quat(1)*quat(4))\n  cbe(1,3) = 2.0d0*(quat(1)*quat(3) + quat(2)*quat(4))\n  cbe(2,3) = 2.0d0*(quat(2)*quat(3) - quat(1)*quat(4))\n  cbe(3,3) = quat(3)*quat(3) - quat(1)*quat(1) - quat(2)*quat(2) + quat(4)*quat(4)\n\n  ceb(1,1) = quat(1)*quat(1) - quat(2)*quat(2) - quat(3)*quat(3) + quat(4)*quat(4)\n  ceb(2,1) = 2.0d0*(quat(1)*quat(2) - quat(3)*quat(4))\n  ceb(3,1) = 2.0d0*(quat(1)*quat(3) + quat(2)*quat(4))\n  ceb(1,2) = 2.0d0*(quat(1)*quat(2) + quat(3)*quat(4))\n  ceb(2,2) = quat(2)*quat(2) - quat(1)*quat(1) - quat(3)*quat(3) + quat(4)*quat(4)\n  ceb(3,2) = 2.0d0*(quat(2)*quat(3) - quat(1)*quat(4))\n  ceb(1,3) = 2.0d0*(quat(1)*quat(3) - quat(2)*quat(4))\n  ceb(2,3) = 2.0d0*(quat(2)*quat(3) + quat(1)*quat(4))\n  ceb(3,3) = quat(3)*quat(3) - quat(1)*quat(1) - quat(2)*quat(2) + quat(4)*quat(4)\n  \nend subroutine dcm_set\n"}, {"instruction": "Create a Fortran subroutine named matsum to calculate the values of gr and gi. The subroutine takes 7 input parameters of type real*8, real*8, real*8, real*8, real*8, integer, and integer. It returns 2 output parameters of type real*8, real*8.", "input": "", "output": "subroutine matsum(gr, gi, en, iom, x0, dh, wb, nom, nx)\n  implicit none\n  real*8, intent(out) :: gr(nom), gi(nom)\n  real*8, intent(in)  :: en\n  real*8, intent(in)  :: iom(nom)\n  real*8, intent(in)  :: x0(nx)\n  real*8, intent(in)  :: dh(nx)\n  real*8, intent(in)  :: wb(nx)\n  integer, intent(in) :: nom, nx\n  !f2py integer intent(hide), depend(iom)  :: nom=shape(iom,0)\n  !f2py integer intent(hide), depend(x0)   :: nx=shape(x0,0)\n  !real*8 :: simps\n  real*8 :: omn, w1, sumr, sumi\n  integer :: n, k\n  \n  gr=0\n  gi=0\n  do n=1,nom\n     omn = iom(n)\n     sumr=0\n     sumi=0\n     do k=1,nx\n        w1 = wb(k)/(omn**2+(x0(k)+en)**2)\n        sumr = sumr + w1*(x0(k)+en)*dh(k)\n        sumi = sumi + w1*omn*dh(k)\n     enddo\n     gr(n) = -sumr\n     gi(n) = -sumi\n  enddo\nend subroutine matsum\n"}, {"instruction": "Create a Fortran subroutine named \"kramskron\" that takes 8 input parameters of type real*8, real*8, real*8, real*8, real*8, real*8, integer, integer and 1 output parameter of type complex*16. The subroutine calculates the kramers-kronig transformation based on the input parameters frc, om, f0, wb, x0, dhx, en, nom, and nx. Use an imperative tone to define the subroutine.", "input": "", "output": "subroutine kramskron(frc, om, f0, wb, x0, dhx, en, nom, nx)\n  implicit none\n  complex*16, intent(out) :: frc(nom)\n  real*8, intent(in)  :: om(nom)\n  real*8, intent(in)  :: f0(nom)\n  real*8, intent(in)  :: wb(nx)\n  real*8, intent(in)  :: x0(nx)\n  real*8, intent(in)  :: dhx(nx)\n  real*8, intent(in)  :: en\n  integer, intent(in) :: nom, nx\n  !f2py integer intent(hide), depend(om)  :: nom=shape(om,0)\n  !f2py integer intent(hide), depend(x0)  :: nx=shape(x0,0)\n  real*8, parameter :: pi = 3.14159\n  integer :: j, k\n  real*8  :: omj, wj, sums, fre, fri\n  \n  do j=1,nom\n     omj = om(j)\n     wj = f0(j)\n     sums=0\n     do k=1,nx\n        sums = sums + (wb(k)-wj)*dhx(k)/(omj-(x0(k)+en))\n     enddo\n     fre = sums - wj*log(abs((x0(nx)+en-omj)/(omj-x0(1)-en)))\n     fri = -pi*f0(j)\n     frc(j) = dcmplx(fre, fri)\n  enddo\nend subroutine kramskron\n"}, {"instruction": "Create a Fortran subroutine named fnamesnapshot to generate the name of a snapshot to be saved. The subroutine takes 4 input parameters of types character(len=*), integer, integer, and real*8, and produces 1 output parameter of type character(len=200). The subroutine constructs the snapshot name based on the input parameters, including the continent, population number, xmen value, and time.", "input": "", "output": "subroutine fnamesnapshot(continent,popno,xmen,t,output)\n  ! makes the name of the snapshot to save.\n  character(len=*),intent(in)  :: continent\n  character(len=200),intent(out) :: output\n  integer, intent(in) :: popno, t\n  real*8, intent(in)  :: xmen\n\n  write(output,\"(a)\") trim(continent)\n  write(output,\"(a,a,i6.6)\") trim(output), '_p', int(popno/1000.d0)\n  write(output,\"(a,a,f0.6)\") trim(output), '_x', xmen*1000.d0\n  write(output,\"(a,a,i6.6)\") trim(output), '_t', int(t/100.d0)\nend subroutine fnamesnapshot\n"}, {"instruction": "Create a Fortran subroutine named compute_mder_legacy that takes in 3 input parameters of types real*8, integer*8, and integer*8, and 3 output parameters of types integer*8, dimension(3*n), integer*8, dimension(3*n), and real*8, dimension(3*n). The subroutine calculates the derivative matrix and residual vector based on the input parameters using the finite difference method for a given value of s.", "input": "", "output": "subroutine compute_mder_legacy(s,n,der,i,j,f)\n  real*8, intent(in) :: s\n  integer*8, intent(in) :: n\n  integer*8, intent(in) :: der\n  integer*8, intent(out), dimension(3*n):: i\n  integer*8, intent(out), dimension(3*n):: j\n  real*8, intent(out), dimension(3*n):: f\n  integer*8 :: p\n  real*8 :: factor\n  if (der==0) then\n     factor=1;\n  else\n     factor=0;\n  end if\n  do p = 1, n\n     i(p) = p\n     j(p) = p\n     f(p) = 2.0*factor;\n  end do\n  do p = 1, n-1\n     i(n+p) = p\n     j(n+p) = p+1\n     f(n+p) = -1.0*factor;\n     i(2*n+p) = p+1\n     j(2*n+p) = p\n     f(2*n+p) = -1.0*factor;\n  end do\n  i(2*n)=n;\n  j(2*n)=1;\n  if (der == 0) then\n     f(2*n)=s*s*s;\n  else if (der == 1) then\n     f(2*n)=3*s*s;\n  else if (der == 2) then\n     f(2*n)=3*2*s;\n  else if (der == 3) then\n     f(2*n)=3*2;\n  else\n     f(2*n)=0;\n  end if\n  i(3*n)=1;\n  j(3*n)=n;\n  f(3*n)=-exp(s);\nend subroutine compute_mder_legacy\n"}, {"instruction": "Create a Fortran subroutine named createattributetypestring. It takes 1 input parameter of type integer and 1 output parameter of type character(len=256). The subroutine selects a string representing a specific attribute type based on the input integer value. The recognized attribute types are scalar, vector, tensor, matrix, tensor6, globalid, and notype. If the input integer does not match any recognized attribute type, a warning message is displayed.", "input": "", "output": "subroutine createattributetypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(200)\n   typestring = 'xdmf_attribute_type_scalar'\ncase(201)\n   typestring = 'xdmf_attribute_type_vector'\ncase(202)\n   typestring = 'xdmf_attribute_type_tensor'\ncase(203)\n   typestring = 'xdmf_attribute_type_matrix'\ncase(204)\n   typestring = 'xdmf_attribute_type_tensor6'\ncase(205)\n   typestring = 'xdmf_attribute_type_globalid'\ncase(206)\n   typestring = 'xdmf_attribute_type_notype'\ncase default\n   write(6,'(\"warning: unrecognized attribute type \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createattributetypestring\n"}, {"instruction": "Create a Fortran subroutine named createsettypestring that takes an integer input parameter and returns a character string of length 256. The input parameter is of type integer, and the output parameter is of type character(len=256). The subroutine is designed to select a string representation based on the value of the input parameter, and it handles unrecognized input values with a warning message.", "input": "", "output": "subroutine createsettypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(601)\n   typestring = 'xdmf_set_type_node'\ncase(602)\n   typestring = 'xdmf_set_type_cell'\ncase(603)\n   typestring = 'xdmf_set_type_face'\ncase(604)\n   typestring = 'xdmf_set_type_edge'      \ncase default\n   write(6,'(\"warning: unrecognized set type \",i0,\".\")') typeholder\nend select\n!----------------------------------------------------------------------\nend subroutine createsettypestring\n"}, {"instruction": "Create a Fortran subroutine named createattributecenterstring that takes an integer as input and returns a character string of length 256 as output. The input parameter is of type integer, and the output parameter is of type character. The subroutine selects a specific string based on the input integer value and assigns it to the output string. If the input integer does not match any specified cases, a warning message is printed.", "input": "", "output": "subroutine createattributecenterstring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(100)\n   typestring = 'xdmf_attribute_center_grid'\ncase(101)\n   typestring = 'xdmf_attribute_center_cell'\ncase(102)\n   typestring = 'xdmf_attribute_center_face'\ncase(103)\n   typestring = 'xdmf_attribute_center_edge'\ncase(104)\n   typestring = 'xdmf_attribute_center_node'\ncase default\n   write(6,'(\"warning: unrecognized attribute center \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createattributecenterstring\n"}, {"instruction": "Create a Fortran subroutine named createdatatypestring to convert an integer code representing a data type into a corresponding string. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type character(len=256).", "input": "", "output": "subroutine createdatatypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(0)\n   typestring = 'xdmf_array_type_int8'\ncase(1)\n   typestring = 'xdmf_array_type_int16'\ncase(2)\n   typestring = 'xdmf_array_type_int32'\ncase(3)\n   typestring = 'xdmf_array_type_int64'\ncase(4)\n   typestring = 'xdmf_array_type_uint8'\ncase(5)\n   typestring = 'xdmf_array_type_uint16'\ncase(6)\n   typestring = 'xdmf_array_type_uint32'\ncase(7)\n   typestring = 'xdmf_array_type_float32'\ncase(8)\n   typestring = 'xdmf_array_type_float64'\ncase default\n   write(6,'(\"warning: unrecognized data type \",i0,\".\")') trim(typestring)\nend select\n!----------------------------------------------------------------------\nend subroutine createdatatypestring\n"}, {"instruction": "Create a Fortran subroutine named createtopologytypestring that takes an integer as input and returns a character string of length 256 as output. The subroutine maps the input integer to a corresponding XDMF topology type string and assigns it to the output parameter.", "input": "", "output": "subroutine createtopologytypestring(typeholder, typestring)\nimplicit none\ninteger, intent(in) :: typeholder\ncharacter(len=256), intent(out) :: typestring\n!\nselect case(typeholder)\ncase(500)\n   typestring = 'xdmf_topology_type_polyvertex'\ncase(501)\n   typestring = 'xdmf_topology_type_polyline'\ncase(502)\n   typestring = 'xdmf_topology_type_polygon'\ncase(503)\n   typestring = 'xdmf_topology_type_triangle'\ncase(504)\n   typestring = 'xdmf_topology_type_quadrilateral'\ncase(507)\n   typestring = 'xdmf_topology_type_wedge'\ncase(509)\n   typestring = 'xdmf_topology_type_edge_3'\ncase(510)\n   typestring = 'xdmf_topology_type_triangle_6'\ncase(511)\n   typestring = 'xdmf_topology_type_quadrilateral_8'\ncase(512)\n   typestring = 'xdmf_topology_type_quadrilateral_9'\ncase(515)\n   typestring = 'xdmf_topology_type_wedge_15'\ncase(516)\n   typestring = 'xdmf_topology_type_wedge_18'\ncase default\n   write(6,'(\"warning: unrecognized topology type \",i0,\".\")') typeholder\nend select\n!----------------------------------------------------------------------\nend subroutine createtopologytypestring\n"}, {"instruction": "Create a Fortran subroutine named dimensions_fft to calculate the dimensions and indices required for a real-to-complex Fast Fourier Transform (FFT). It takes 3 input parameters with integer test data types and produces 11 output parameters, all with integer test data types.", "input": "", "output": "subroutine dimensions_fft(n1,n2,n3,nd1,nd2,nd3,n1f,n3f,n1b,n3b,nd1f,nd3f,nd1b,nd3b)\n   implicit none\n   integer, intent(in)::n1,n2,n3\n   integer,intent(out)::nd1,nd2,nd3,n1f,n3f,n1b,n3b,nd1f,nd3f,nd1b,nd3b\n   ! array sizes for the real-to-complex fft: note that n1(there)=n1(here)+1\n   ! and the same for n2,n3.\n   nd1=n1+2\n   nd2=n2+2\n   nd3=n3+2\n   ! n1b>=n1f;   n3f>=n3b\n   n1f=(n1+2)/2 \n   n3f=(n3+1)/2+1\n\n   n1b=(n1+1)/2+1\n   n3b=(n3+2)/2\n\n   nd1f=n1f+1\n   nd3f=n3f+1\n\n   nd1b=n1b+1\n   nd3b=n3b+1\nend subroutine dimensions_fft\n"}, {"instruction": "Create a Fortran subroutine named logical_to_integer that takes a logical input and converts it to an integer output. The subroutine should have 1 input parameter of type logical and 1 output parameter of type integer.", "input": "", "output": "  subroutine logical_to_integer(integervar,logicalvar)\n    !-----------------------------------------------------------------------\n    logical     :: logicalvar\n    integer     :: integervar\n    !-----------------------------------------------------------------------\n    intent(in)  :: logicalvar\n    intent(out) :: integervar\n    !-----------------------------------------------------------------------\n    \n    if (logicalvar) then\n       integervar = 1\n    else\n       integervar = 0\n    end if\n    \n  end subroutine logical_to_integer\n"}, {"instruction": "Create a Fortran subroutine named integer_to_logical to convert an integer to a logical value. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type logical.", "input": "", "output": "  pure elemental subroutine integer_to_logical(logicalvar,integervar)\n    !-----------------------------------------------------------------------\n    logical     :: logicalvar\n    integer     :: integervar\n    !-----------------------------------------------------------------------\n    intent(in)  :: integervar\n    intent(out) :: logicalvar\n    !-----------------------------------------------------------------------\n    \n    if (integervar .eq. 0) then\n       logicalvar = .false.\n    else\n       logicalvar = .true.\n    end if\n    \n  end subroutine integer_to_logical\n"}, {"instruction": "Create a Fortran subroutine named findnodeinlist to search for a specified vertex number in a list of nodes. The subroutine takes 4 input arguments of integer type and 1 output argument of integer type. The input arguments are nodelist (an array of integers), vertexnr (an integer), counter (an integer), and size (an integer). The output argument is index (an integer). When the subroutine is called, it searches for the vertex number in the nodelist. If found, it returns the index of the node; otherwise, it returns -1.", "input": "", "output": "  subroutine findnodeinlist(index,nodelist,vertexnr,counter,size)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    integer                   :: index,size, vertexnr, counter\n    integer                   :: nodelist(size)\n    ! local variable declaration\n    integer                   :: inode\n    !--------------------------------------------------------------------------\n    intent(in)                :: nodelist,vertexnr,counter,size\n    intent(out)               :: index\n    !--------------------------------------------------------------------------\n    do inode = 1, counter\n       if(nodelist(inode).eq.vertexnr) then\n         ! node found in list, so return index\n         index = inode\n         return\n       endif\n    enddo\n    ! obviously the node has not been found, so return -1\n    index = -1\n  end subroutine findnodeinlist\n"}, {"instruction": "Write a Fortran subroutine named zerospolyo2 to calculate the roots of a second degree polynomial equation. The subroutine takes 1 input parameter of type real array and 1 output parameter of type real array. The input parameter represents the coefficients of the polynomial equation, while the output parameter stores the solutions to the equation.", "input": "", "output": "  subroutine zerospolyo2(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(3)\n    real                      :: solution(2)\n    ! local variable declaration\n    real                      :: a,b,c\n    real                      :: d\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    a = coefficients(1)\n    b = coefficients(2)\n    c = coefficients(3)\n    !\n    d = b**2-4*a*c\n    !\n    if(d.lt.0.) then\n        print *, ' d negative in zerospolyo2. no real roots found! '\n        print *, d\n        stop\n    endif\n    !\n    solution(1) = (-b-sqrt(d))/(2.*a)\n    solution(2) = (-b+sqrt(d))/(2.*a)\n    !\n  end subroutine zerospolyo2\n"}, {"instruction": "Create a Fortran subroutine named zerospolyo3 to calculate the roots of a third-degree polynomial equation. The input parameter is an array of real coefficients, and the output parameter is an array of complex solutions. The input parameters consist of 4 real numbers, and the output parameters consist of 3 complex numbers.", "input": "", "output": "  subroutine zerospolyo3(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(4)\n    complex                   :: solution(3)\n    ! local variable declaration\n    complex                   :: a,b,c,d\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    a = cmplx( coefficients(1), 0. )\n    b = cmplx( coefficients(2), 0. )\n    c = cmplx( coefficients(3), 0. )\n    d = cmplx( coefficients(4), 0. )\n    !\n    solution(1) = 1./a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a      &\n                  -c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/6.     & \n                  -2./3.*(3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)   &\n                  *sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)   &\n                  **(1./3.)-b/a/3.\n\n    solution(2) = -1/a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-     &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/12+    &\n                   (3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4* &\n                   c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.) &\n                   /3.-b/a/3+cmplx(0.,1./2.)*sqrt(3.)*(1/a*(36*c*b*a-108*d*a**2-  &\n                   8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2* &\n                   a**2+4*d*b**3)*a)**(1./3.)/6+2./3.*(3*c*a-b**2)/a/(36*c*b*a-   &\n                   108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-18*c*b*a &\n                   *d+27*d**2*a**2+4*d*b**3)*a)**(1./3.))\n\n    solution(3) = -1/a*(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-     &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/12.    &\n                   +(3*c*a-b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*       &\n                   sqrt(4*c**3*a-c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)** &\n                   (1./3.)/3-b/a/3.+cmplx(0.,-1./2.)*sqrt(3.)*(1/a*(36*c*b*a-     &\n                   108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a-c**2*b**2-         &\n                   18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.)/6+2./3.*(3*c*a-  &\n                   b**2)/a/(36*c*b*a-108*d*a**2-8*b**3+12*sqrt(3.)*sqrt(4*c**3*a- &\n                   c**2*b**2-18*c*b*a*d+27*d**2*a**2+4*d*b**3)*a)**(1./3.))\n  end subroutine zerospolyo3\n"}, {"instruction": "Write a Fortran subroutine named \"zerospolyo4\" to find the real roots of a fourth-order polynomial equation. The subroutine takes an array of five real coefficients as input and outputs an array of four real solutions.", "input": "", "output": "  subroutine zerospolyo4(solution,coefficients)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                      :: coefficients(5)\n    real                      :: solution(4)\n    ! local variable declaration\n    real                      :: b,c,d,e\n    complex                   :: a3,b3,c3,d3\n    real                      :: a2,b2,c2,d2\n    real                      :: y,ap,am\n    complex                   :: s, sqrarg\n    !--------------------------------------------------------------------------\n    intent(in)                :: coefficients\n    intent(out)               :: solution\n    !--------------------------------------------------------------------------\n    !\n    ! normalized coefficients of the fourth order polynomial\n    !\n    b = coefficients(2)/coefficients(1)\n    c = coefficients(3)/coefficients(1)\n    d = coefficients(4)/coefficients(1)\n    e = coefficients(5)/coefficients(1)\n    !\n    ! coefficients of the auxilliary third order polynomial\n    !\n    a3 = cmplx(  8.             , 0. )\n    b3 = cmplx( -4.*c           , 0. )\n    c3 = cmplx( 2.*b*d-8*e      , 0. )\n    d3 = cmplx( e*(4*c-b*b)-d*d , 0. )\n    !\n    ! (any) real root of the aux. third order polynomial\n    !\n    s = 1./a3*(36*c3*b3*a3-108*d3*a3**2-8*b3**3+12*sqrt(3.)*sqrt(4*c3**3*a3      &\n        -c3**2*b3**2-18*c3*b3*a3*d3+27*d3**2*a3**2+4*d3*b3**3)*a3)**(1./3.)/6.     & \n        -2./3.*(3*c3*a3-b3**2)/a3/(36*c3*b3*a3-108*d3*a3**2-8*b3**3+12*sqrt(3.)   &\n        *sqrt(4*c3**3*a3-c3**2*b3**2-18*c3*b3*a3*d3+27*d3**2*a3**2+4*d3*b3**3)*a3)   &\n        **(1./3.)-b3/a3/3.\n    !\n    y = real(s)\n    if(abs(aimag(s)).gt.1e-6*abs(y)) then\n        print *, ' real root of aux. poly not real in zerospolyo4! '\n        print *, s\n        stop\n    endif\n    ! aux. variables a+/-\n    ap = sqrt(8.*y+b*b-4*c) \n    am = -ap\n    !\n    ! coefficients of an aux. second order polynomial which yields the final solution \n    !\n    a2 = 1.\n    b2 = 0.5*(b+ap)\n    c2 = y+(b*y-d)/ap\n    !\n    d2 = b2**2-4*a2*c2\n    !\n    if(d2.lt.0.) then\n        print *, ' d2 (using a+) negative in zerospolyo4. no real roots found! '\n        print *, d2\n        stop\n    endif\n    !\n    solution(1) = (-b2-sqrt(d2))/(2.*a2)\n    solution(2) = (-b2+sqrt(d2))/(2.*a2)\n    !\n    a2 = 1.\n    b2 = 0.5*(b+am)\n    c2 = y+(b*y-d)/am\n    !\n    d2 = b2**2-4*a2*c2\n    !\n    if(d2.lt.0.) then\n        print *, ' d2 (using a-) negative in zerospolyo4. no real roots found! '\n        print *, d2\n        stop\n    endif\n    !\n    solution(3) = (-b2-sqrt(d2))/(2.*a2)\n    solution(4) = (-b2+sqrt(d2))/(2.*a2)\n    !\n  end subroutine zerospolyo4\n"}, {"instruction": "Create a Fortran subroutine named matrixinverse2x2 that computes the inverse of a 2x2 matrix. The subroutine takes one input parameter of type real array (2,2) and one output parameter of type real array (2,2). The input parameter represents the original matrix and the output parameter stores the inverse of the matrix. Use the imperative tone in the instruction.", "input": "", "output": "  subroutine matrixinverse2x2(ia,a)\n    !--------------------------------------------------------------------------\n    \n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                        :: ia(2,2)\n    real                        :: a(2,2)\n    ! local variable declaration\n    real                        :: det\n    !--------------------------------------------------------------------------\n    intent(in)                  :: a\n    intent(out)                 :: ia\n    !--------------------------------------------------------------------------\n    !\n    det = a(1,1)*a(2,2)-a(2,1)*a(1,2) \n    \n    ia(1,1) =  a(2,2) / det;        ia(1,2) = -a(1,2) / det;\n    ia(2,1) = -a(2,1) / det;        ia(2,2) =  a(1,1) / det;\n    !\n  end subroutine matrixinverse2x2\n"}, {"instruction": "Create a Fortran subroutine named checkchargesize to read data from a file and perform calculations. The subroutine takes 3 input parameters of types character*100, integer, and integer, and returns 6 output parameters of type integer. The function reads data from a file, performs calculations, and assigns values to the output parameters.", "input": "", "output": "subroutine checkchargesize(file_clmsum,lmmaxx,lmax2,ncom,nrad,lmmax,lmmax1,jri,nat)\n  implicit none\n  character*100, intent(in) :: file_clmsum\n  integer, intent(out):: lmmaxx, lmax2, ncom, nrad\n  integer, intent(out):: lmmax(nat), lmmax1(nat)\n  integer, intent(in) :: jri(nat), nat\n  ! locals\n  real*8, allocatable :: clm(:)\n  integer :: iscf, j, jatom, l, m, lm1\n  \n  open(8, file=file_clmsum, status='old')\n  read(8,2044)  iscf\n  read(8,2043) lmmaxx\n  ncom=0\n  lmax2=0\n  nrad=0\n  do jatom=1,nat\n     nrad=max(nrad,jri(jatom))\n     allocate( clm(jri(jatom) ) )\n     read(8,2000) lmmax(jatom)\n     lmmax1(jatom)=lmmax(jatom)\n     ncom=max(ncom,lmmax1(jatom))\n     do lm1=1,lmmax(jatom)\n        read(8,2010) l,m\n        lmax2=max(lmax2,l)\n        if(m.ne.0) then\n           lmmax1(jatom)=lmmax1(jatom)+1\n           ncom=max(ncom,lmmax1(jatom))\n        endif\n        read(8,2021) ( clm(j), j=1,jri(jatom))\n        read(8,2031)\n     enddo\n     read(8,1980)\n     read(8,2030)\n     deallocate(clm)\n  enddo\n  close(8)\n1980 format(3x)\n2043 format(8x,i4,/)\n2044 format(49x,i3,/)\n2000 format(15x,i3,/,/)\n2010 format(15x,i3,5x,i2,/)\n2021 format(3x,4es19.12)\n2030 format(/,/,/)\n2031 format(/)\n!2071 format(3x,3i5,2es19.12)\nend subroutine checkchargesize\n"}, {"instruction": "Create a Fortran subroutine named read_config_file. The subroutine takes 1 input parameter of type character(*) and 3 output parameters of type integer. When called, the subroutine reads a configuration file specified by the input parameter and assigns the first, last, and k values from the file to the output parameters. If the values do not meet certain conditions, an error message is displayed and the program stops.", "input": "", "output": "   subroutine read_config_file(configfile, first, last, k)\n      character(*), intent(in)  :: configfile\n      integer,      intent(out) :: first, last, k\n\n      integer                   :: in\n\n      open (file=configfile, newunit=in)\n         read(in, *) first, last, k\n      close (in)\n\n      if (.not. (first <= last .and. (k < first .or. k > last))) then\n         write(*,*) 'incorrect settings'\n         stop\n      endif\n   end subroutine read_config_file\n"}, {"instruction": "Write a Fortran subroutine named read_points to read data from a file and store it in a 2D array. The subroutine takes 3 input parameters of types character(len=*), integer, and integer, and 1 output parameter of type real.", "input": "", "output": "    subroutine read_points(fname,rows,cols,points)\n        character(len=*), intent(in) :: fname\n        integer, intent(in) :: rows, cols\n        real, intent(out) :: points(cols,rows)\n        integer :: i,j,unit\n\n        open(newunit=unit,file=fname,status='old')\n\n        do i = 1, rows\n            read(unit,*) (points(j,i),j=1,cols)\n        end do\n\n        close(unit)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named trim_sub_name that extracts the name of a subroutine from a fully qualified subroutine name. The subroutine takes 1 input parameter of type character(len=*) and provides 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine trim_sub_name(sub_name, output)\n    character(len=*), intent(in)  :: sub_name\n    character(len=*), intent(out) :: output\n\n    integer :: ic, slash\n\n    slash = 0 ! if no slash, take whole name\n    do ic = 1, len(sub_name)\n      if(sub_name(ic:ic) == '/') slash = ic\n    enddo\n\n    if(slash >= len(sub_name) - 1) then\n      output = \"\"\n    else\n      output = sub_name(slash + 1:len(sub_name))\n    endif\n\n  end subroutine trim_sub_name\n"}, {"instruction": "Write a Fortran subroutine named inv_m to perform matrix inversion using Gauss-Jordan elimination. The subroutine takes 1 input parameter of type double precision and produces 1 output parameter of type double precision.", "input": "", "output": "recursive subroutine inv_m(a,inv_a)\n!   purpose: inverts a matrix (taken from fortran 90 cooper redwine).\nimplicit none\n\n    integer ::  n\n    double precision, intent(in)  :: a(:,:)\n    double precision, intent(out) :: inv_a(:,:) \n    double precision, allocatable :: temp(:)\n    double precision, allocatable :: c(:,:)\n    integer ::  i, j, m\n    \n    n = size(a,1) \n\tm = size(a,2) \n     \n    if (n/=m) then\n      write(*,*) 'error! matrix is not square. (inv_m)'\n    end if\n\n    allocate(c(n,2*n), temp(2*n))\n\tc(:,1:n) = a      \n\tc(:,n+1:2*n) = 0.0\n    do i=1,n\n      c(i,n+i) = 1.0\n    end do\n\n    ! gauss-jordan elimination\n\n    do j=1,n !loop over first n columns of matrix\n      \n      ! find row index m of element with largest magnitude\n      m = j  ! start on the diagonal\n      do i=j+1,n\n        if (abs(c(i,j)) > abs(c(m,j))) m = i\n      end do\n\n      ! exchange row m with row j\n      temp = c(j,:); c(j,:) = c(m,:); c(m,:) = temp\n\n      c(j,:) = c(j,:)/c(j,j)  ! divide row j by a(j,j)\n\n      do i=1,n  ! loop over each row of matrix\n         ! subtract a(i,j) times row j from row i\n         if (i/=j) c(i,:) = c(i,:)-c(i,j)*c(j,:)\n      end do\n      \n    end do\n    \n    inv_a = c(:,n+1:2*n)\n\t\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named \"rhs\" to compute the right-hand side of a system of differential equations. The subroutine should have 3 input parameters of type double precision, double precision, and logical. The output should consist of 2 arrays of double precision type.", "input": "", "output": "  subroutine rhs(u,par,f,jac,a)\n\n    implicit none\n    double precision, intent(in) :: u(3), par(*)\n    logical, intent(in) :: jac\n    double precision, intent(out) :: f(3), a(3,3)\n\n    double precision x, y, phi\n    double precision nu1, nu2, alpha, beta, omega, c, d, fp, s\n    double precision sphi, x2y2, cphinu, cphinu2\n\n    nu1 = par(1)\n    nu2 = par(2)\n    d = par(3)\n    fp = 4*atan(1.0d0)*d\n    alpha = -1\n    s = -1\n    c = 0\n    omega = 1\n    beta = 0\n\n    x = u(1)\n    y = u(2)\n    phi = u(3)\n\n    sphi = sin(phi)\n    x2y2 = x*x + y*y\n    cphinu = 2*cos(phi)+nu2\n    cphinu2 = cphinu*cphinu\n\n    f(1) = nu1*x - omega*y - (alpha*x - beta*y)*sphi - x2y2*x + d*cphinu2\n    f(2) = nu1*y + omega*x - (alpha*y + beta*x)*sphi - x2y2*y + fp*cphinu2\n    f(3) = nu2 + s*x2y2 + 2.0*cos(phi) + c*x2y2*x2y2\n\n    if(jac)then\n       a(1,1) = nu1 - alpha*sphi - 3*x**2 - y**2\n       a(1,2) = -omega + beta*sphi - 2*x*y\n       a(1,3) = -(alpha*x - beta*y)*cos(phi) - d*4*(2*cos(phi)+nu2)*sphi\n\n       a(2,1) = omega - beta*sphi - 2*x*y\n       a(2,2) = nu1 - alpha*sphi - 3*y**2 - x*x\n       a(2,3) = -(alpha*y + beta*x)*cos(phi) - fp*4*(2*cos(phi) + nu2)*sphi\n\n       a(3,1) = 2*s*x + 4*c*x2y2*x\n       a(3,2) = 2*s*y + 4*c*x2y2*y\n       a(3,3) = -2*sphi\n    endif\n\n  end subroutine rhs\n"}, {"instruction": "Create a Fortran subroutine named datesec that takes a single input parameter of type real(8) and outputs a single parameter of type real(8). The subroutine calculates the number of seconds since January 1, 1978, based on the input date and time values provided.", "input": "", "output": "subroutine datesec(idate, nsec)\n! *#* documentation block - start *#*\n\n!    1 january 1978 (refdate : in days)\n! => coder              : stelios flampouris (stylianos.flampouris@noaa.gov)\n! => abstract/flowchart :\n!\n! [yyyy,mm,dd]-->convert to julian days (jd)-->ndays=jd-refdate-->convert to\n! seconds (ndaysinsec)--> nsec=ndaysinsec+hh*3600+mn*60+ss\n!\n! => history log        :\n! 2016.03.08            : stelios flampouris\n!\n! => input arguments    : idate real array with size 6:\n!                         idate(1)=yyyy   !year\n!                         idate(2)=mm     !month\n!                         idate(3)=dd     !day\n!                         idate(4)=hh     !hour\n!                         idate(5)=mn     !minute\n!                         idate(6)=ss     !second\n!\n! => output arguments   : nsec integer number of seconds\n!\n! => attributes         : machine theia\n!\n! *#* documentation block - end *#*\n!\n   implicit none\n   real(8), intent(in) :: idate(6)\n   real(8), intent(out) :: nsec\n!\n! local parameters\n   real(8), parameter :: refdate = 2443510.\n   real(8) :: jd\n!\n! initializing variables\n   nsec = 0\n   !\n! convert idate(1:3) to jd\n   jd = idate(3) - 32075                                                       &\n                 + 1461 * ( idate(1) + 4800 + (idate(2) - 14) / 12) / 4        &\n                 +  367 * ( idate(2) - 2    - (idate(2) - 14) / 12 * 12) / 12  &\n                 -    3 * ((idate(1) + 4900 + (idate(2) - 14) / 12) / 100) / 4\n!\n! number of days from the reference days\n   jd = jd - refdate\n!\n! number of seconds\n   nsec = (jd* 86400) + (idate(4) * 3600) + (idate(5) * 60) + idate(6)\n!\nend subroutine datesec\n"}, {"instruction": "Create a Fortran subroutine named create_strike_dip_unit_vectors to calculate the strike and dip unit vectors based on a given fault normal vector. The subroutine takes 1 input parameter of type real array and returns 2 output parameters of type real array.", "input": "", "output": "  subroutine create_strike_dip_unit_vectors(n, strike_vector, dip_vector)\n    !> creates strike and dip unit vectors given a fautl normal vector\n    !-------------------------------------------------------------------------!\n    implicit none    \n    ! local variable declaration                                              !\n    real                            :: n(1:3)                                 !< normal vector to fault, pointing away from reference point\n    real                            :: strike_vector(1:3)                     !< strike vector\n    real                            :: dip_vector(1:3)                        !< dip vector\n    real                            :: norm                                   !< norm\n    !-------------------------------------------------------------------------!\n    intent(in)    :: n                                                        !\n    intent(out)   :: strike_vector, dip_vector                                !\n    !-------------------------------------------------------------------------!\n    strike_vector(1) = n(2)/sqrt(n(1)**2+n(2)**2)\n    strike_vector(2) = -n(1)/sqrt(n(1)**2+n(2)**2)\n    strike_vector(3) = 0.0d0\n   \n    dip_vector(1) = -strike_vector(2)*n(3)\n    dip_vector(2) = strike_vector(1)*n(3)\n    dip_vector(3) = strike_vector(2)*n(1) - strike_vector(1)*n(2)\n    norm = 1.0d0/sqrt(dip_vector(1)**2+dip_vector(2)**2+dip_vector(3)**2)\n    dip_vector(1) = dip_vector(1)*norm\n    dip_vector(2) = dip_vector(2)*norm\n    dip_vector(3) = dip_vector(3)*norm\n  end subroutine create_strike_dip_unit_vectors\n"}, {"instruction": "Write a Fortran subroutine named locate_mfmt to locate specific formatting patterns in a file. The subroutine takes 1 input parameter of type integer and returns 3 output parameters: 2 of type integer*2 and 1 of type integer*8, both with a dimension of 1000x2. The input parameter represents a file unit, and the output parameters store information about formatting patterns found in the file.", "input": "", "output": "    subroutine locate_mfmt(u, numsecs, mfmt_list, linerange)\n        implicit none\n        integer, intent(in) :: u\n        integer*2, intent(out) :: numsecs\n        integer*2, dimension(1000,2), intent(out) :: mfmt_list\n        integer*8, dimension(1000,2), intent(out) :: linerange\n\n        character(len=11), dimension(6) :: fields\n\n        integer :: linenr, startlinenr \n        integer*8 :: numrows \n        integer*2 :: az, mf, mt, lastmf, lastmt\n\n        mfmt_list(:,:) = 0\n        linerange(:,:) = 0\n\n        lastmf = 0\n        lastmt = 0\n        numsecs = 0\n        linenr = 0\n        rewind(u)\n        do while (1 == 1)\n            read(u, '(6a11,i4,i2,i3)', end=200) fields, az, mf, mt\n            numrows = numrows + 1\n            linenr = linenr + 1\n            if (lastmt /= mt) then\n                if (lastmt /= 0) then\n                    numsecs = numsecs + int(1,2)\n                    mfmt_list(numsecs,1) = lastmf\n                    mfmt_list(numsecs,2) = lastmt\n                    linerange(numsecs,1) = startlinenr\n                    linerange(numsecs,2) = numrows\n                end if\n\n                if (mt /= 0) then\n                    startlinenr = linenr\n                end if\n                numrows = 0\n            end if\n            lastmf = mf\n            lastmt = mt\n        end do\n        200 continue\n        rewind(u)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"fsub\" to compute the square of each element in the input array \"x\" of length \"n\" and store the results in the output array \"f\". The number of input parameters is 2, where the test_data types are ['integer', 'real(kind=8), dimension(n)']. The number of output parameters is 1, with the test_data type as ['real(kind=8), dimension(n)'].", "input": "", "output": "subroutine fsub(x,n,f)\n  ! compute f(x) = x**2 for all elements of the array x \n  ! of length n.\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), dimension(n), intent(in) :: x\n  real(kind=8), dimension(n), intent(out) :: f\n  f = x**2\nend subroutine fsub\n"}, {"instruction": "Create a Fortran subroutine named get_ang_coeffparams to calculate the total number of angular momentum quantum trips up to a specified maximum angular momentum value. The subroutine takes 1 input argument of type integer and returns 1 output argument of type integer. The input parameter represents the maximum angular momentum value (lmax), and the output parameter (tot_l_trips) holds the total number of angular momentum quantum trips.", "input": "", "output": "  subroutine get_ang_coeffparams(lmax,tot_l_trips)\n\n    implicit none\n\n    integer, intent(out) :: tot_l_trips\n    integer, intent(in) :: lmax\n    integer :: l,i,n_elements_l\n\n    !initialising n_elements_l value to nought\n    tot_l_trips = 0\n    n_elements_l = 0\n    do i = 0,lmax\n       n_elements_l = (i+1)*(i+2)/2\n       tot_l_trips = tot_l_trips + n_elements_l\n    enddo\n\n  end subroutine get_ang_coeffparams\n"}, {"instruction": "Create a Fortran subroutine named fix_signs to ensure that the values of m1dum and m2dum are within certain ranges based on the signs of m1 and m2. The subroutine should take 4 input parameters of type integer (l1, l2, m1, m2) and 4 output parameters of type integer (l1dum, l2dum, m1dum, m2dum). The subroutine should be designed to ensure that m1dum is greater than or equal to 0 and m2dum is less than 0, assuming that m1 and m2 initially have different signs.", "input": "", "output": "  subroutine fix_signs(l1,l2,m1,m2,l1dum,l2dum,m1dum,m2dum)\n    !routine to make sure m1dum.ge.0, m2dum.lt.0\n    !assumes that m1 and m2 differ in sign initially\n    integer, intent(in) :: l1,l2,m1,m2\n    integer, intent(out) :: l1dum,l2dum,m1dum,m2dum\n    if(m1.ge.0) then\n       l1dum = l1; l2dum = l2\n       m1dum = m1; m2dum = m2\n    else\n       l1dum = l2; l2dum = l1\n       m1dum = m2; m2dum = m1\n    endif\n       \n  end subroutine fix_signs\n"}, {"instruction": "Create a Fortran subroutine named dpfcalc to calculate pressure fields based on given input data. The subroutine requires 6 input parameters of type real(kind=8), dimension(mkzh,mix,mjy), real(kind=8), dimension(mix,mjy), integer, integer, integer, and 1 output parameter of type real(kind=8), dimension(mkzh,mix,mjy).", "input": "", "output": "subroutine dpfcalc(prs, sfp, pf, mix, mjy, mkzh, ter_follow)\n\n    real(kind=8), dimension(mkzh,mix,mjy), intent(in) :: prs\n    real(kind=8), dimension(mix,mjy), intent(in) :: sfp\n    real(kind=8), dimension(mkzh,mix,mjy), intent(out) :: pf\n    integer, intent(in) :: ter_follow,mix,mjy,mkzh\n\n    integer :: i,j,k\n    \n    !$omp parallel do collapse(3) schedule(runtime)\n    do j = 1,mjy\n        do i = 1,mix\n            do k = 1,mkzh\n                if (k .eq. mkzh) then\n                    ! terrain-following data\n                    if (ter_follow .eq. 1) then\n                        pf(k,i,j) = sfp(i,j)\n                    ! pressure-level data\n                    else\n                        pf(k,i,j) = .5d0 * (3.d0*prs(k,i,j) - prs(k-1,i,j))\n                    end if\n                else\n                    pf(k,i,j) = .5d0 * (prs(k+1,i,j) + prs(k,i,j))\n                end if\n            end do\n        end do\n    end do\n\n    !$omp end parallel do\n\n    return\n\nend subroutine dpfcalc\n"}, {"instruction": "Write a Fortran subroutine named str to convert an integer to a string. The subroutine takes 2 input parameters of type integer and 1 output parameter of type character with length n. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 1 and the test_data type is ['character(len=n)'].", "input": "", "output": "subroutine str(i, s, n)\n    implicit none\n    character(len=n), intent(out) :: s\n    integer, intent(in) :: i,n\n    write (s, *) i\n    s = adjustl(s)\n    s = trim(s)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"convits\" to convert an integer into a string representation of its individual digits. The number of input arguments is 1, and the test_data type is ['integer']. The number of output arguments is 1, and the test_data type is ['character(len=6)'].", "input": "", "output": "subroutine convits(i, s)\n     implicit none\n     character(len=6), intent(out) ::s\n     integer, intent(in) :: i\n     character(len=1) :: units, tens, hun, taus, ttaus, htaus\n\n     htaus = char(i/100000+48)\n     ttaus = char(mod(i,100000)/10000 +48)\n     taus  = char(mod(i,10000)/1000 +48)\n     \n     hun   = char(mod(i,1000)/100 +48)\n     tens  = char(mod(i,100)/10 + 48)\n     units = char(mod(i,10) +48)\n\n     s = htaus//ttaus//taus//hun//tens//units\n\n     \n\n\nend subroutine \n"}, {"instruction": "Create a Fortran subroutine named slope_z to calculate the slope of a 3D array based on the input arrays r and dz, with optional limit and linear parameters. The number of input arguments is 4 and the test_data type is [real, dimension(:,:,:), real, dimension(:,:,:), logical, optional, logical, optional]. The number of output arguments is 1 and the test_data type is [real, dimension(:,:,:)].", "input": "", "output": " subroutine slope_z ( r, dz, slope, limit, linear )\n real, intent(in),  dimension(:,:,:) :: r, dz\n real, intent(out), dimension(:,:,:) :: slope\n logical, intent(in), optional :: limit, linear\n\n!real    :: grad(size(r,1),size(r,2),2:size(r,3))\n real    :: grad(2:size(r,3))\n real    :: rmin, rmax\n integer :: i, j, k, n\n logical :: limiters, dolinear\n\n  limiters = .true.\n  if (present(limit))  limiters = limit\n  dolinear = .true.\n  if (present(linear)) dolinear = linear\n\n  n = size(r,3)\n\n! compute slope (weighted for unequal levels)\n\n  do j = 1, size(r,2)\n  do i = 1, size(r,1)\n\n     do k = 2, n\n       grad(k) = (r(i,j,k)-r(i,j,k-1))/(dz(i,j,k)+dz(i,j,k-1))\n     enddo\n     if (dolinear) then\n         do k = 2, n-1\n           slope(i,j,k) = (grad(k+1)+grad(k))*dz(i,j,k)\n         enddo\n     else\n         do k = 2, n-1\n           slope(i,j,k) = (grad(k+1)*(2.*dz(i,j,k-1)+dz(i,j,k)) + &\n                           grad(k  )*(2.*dz(i,j,k+1)+dz(i,j,k)))  &\n                          *dz(i,j,k)/(dz(i,j,k-1)+dz(i,j,k)+dz(i,j,k+1))\n         enddo\n     endif\n     slope(i,j,1) = 2.*grad(2)*dz(i,j,1)\n     slope(i,j,n) = 2.*grad(n)*dz(i,j,n)\n\n   ! apply limiters to slope\n     if (limiters) then\n        do k = 1, n\n          if (k >= 2 .and. k <= n-1) then\n            rmin = min(r(i,j,k-1), r(i,j,k), r(i,j,k+1))\n            rmax = max(r(i,j,k-1), r(i,j,k), r(i,j,k+1))\n            slope(i,j,k) = sign(1.,slope(i,j,k)) *  &\n                   min( abs(slope(i,j,k)), 2.*(r(i,j,k)-rmin), 2.*(rmax-r(i,j,k)) )\n          else\n         !else if (k == 1) then               ! always slope=0\n         !  rmin = min(r(i,j,k), r(i,j,k+1))\n         !  rmax = max(r(i,j,k), r(i,j,k+1))\n         !else if (k == n) then\n         !  rmin = min(r(i,j,k-1), r(i,j,k))\n         !  rmax = max(r(i,j,k-1), r(i,j,k))\n            slope(i,j,k) = 0.\n          endif\n        enddo\n     endif\n\n  enddo\n  enddo\n\n end subroutine slope_z\n"}, {"instruction": "Write a Fortran subroutine named sub1 that takes an integer as input and returns an integer as output. The input parameter should be specified with the \"intent(in)\" attribute, and the output parameter should be specified with the \"intent(out)\" attribute. The subroutine should set the output parameter to the value 1.", "input": "", "output": "subroutine sub1(x1,x2)\ninteger, intent(in)  :: x1\ninteger, intent(out) :: x2\nx2 = 1\nend subroutine sub1\n"}, {"instruction": "Create a Fortran subroutine named basefun, which takes 3 input parameters of type double precision, integer, and double precision, and 2 output parameters of type double precision and integer. This subroutine is designed to find functions that are positive on a given x in the grid_x.", "input": "", "output": "subroutine basefun(grid_x,npx,x,vals,inds)\n\nimplicit none\n\n! functions that are positive on a given x in the grid_x\n\ndouble precision,intent(in) :: x\ninteger , intent(in):: npx\ndouble precision, intent(in) :: grid_x (npx)\ndouble precision, intent(out) ::vals(2)\ninteger ,intent(out) ::inds(2)\ninteger :: i,ju,jl,jm\n\nif(npx .lt. 2) then\n\n    inds(1)=1\n    inds(2)=1\n    vals(1)=1.0d0\n    vals(2)=0.0d0\n\n\nelse\n    jl=1     !\n    ju=npx   !\n\n    do\n\n        if (ju-jl<=1) exit\n            jm=(ju+jl)/2\n        if (x>=grid_x(jm)) then\n            jl=jm\n        else\n            ju=jm\n        endif\n\n    end do\n\n        i=jl+1\n        vals(2)=( x-grid_x(i-1) )/(grid_x(i)-grid_x(i-1))\n        !vals(1)=( grid_x(i)-x )/(grid_x(i)-grid_x(i-1))\n        vals(2)=max(0.0d0,min(1.0d0,vals(2)))\n        vals(1)=1.0d0-vals(2)\n        inds(2)=i\n        inds(1)=i-1\nendif\nend subroutine basefun\n"}, {"instruction": "Write a Fortran subroutine named f_c that calculates the damping function for dispersive interactions at short range. The subroutine takes one input parameter of type 'double precision' named r and two output parameters of type 'double precision' named long_range and long_range_diff. \n\nInside the subroutine, if the input value of r is greater than a predefined value rc_exp, set the value of long_range to 1.0 and long_range_diff to 0.0. Otherwise, calculate the value of dist_frac using the formula rc_exp/r - 1.0. \n\nThen, calculate the value of long_range by taking the exponential of -(dist_frac)**2 and calculate the value of long_range_diff using the formula 2.0*dist_frac*rc_exp*long_range/(r*r).", "input": "", "output": "         subroutine f_c(r, long_range, long_range_diff)\n            ! calculates the damping function for the dispersive interactions \n            ! at short range. \n            !\n            ! args:\n            !    r: the separation of the atoms.\n            !    long_range: the value of the damping function.\n            !    long_range_diff: the differential of the damping function \n            !       with respect to r.\n\n            double precision, intent(in) :: r\n            double precision, intent(out) :: long_range\n            double precision, intent(out) :: long_range_diff\n\n            double precision dist_frac\n\n            if (r > rc_exp) then\n               long_range = 1.0d0\n               long_range_diff = 0.0d0\n            else\n               dist_frac = rc_exp/r - 1.0d0\n               long_range = dexp(-(dist_frac)**2)\n               long_range_diff = 2.0d0*dist_frac*rc_exp*long_range/(r*r)\n            end if\n\n         end subroutine\n"}, {"instruction": "Write a Fortran subroutine named sg_longrange to calculate the long-range correction to the total potential and virial pressure. The subroutine takes 3 input parameters: rc (cut-off radius), natoms (number of atoms in the system), and volume (volume of the system box), all of type double precision and integer. It also has 2 output parameters: pot_lr (tail correction to the sg interaction potential) and vir_lr (tail correction to the sg virial pressure), both of type double precision.\n\nThe subroutine uses the tail correction formula from Martyna and Hughes (Journal of Chemical Physics, 110, 3275, 1999) with a sharp cut-off and no smoothing function. It assumes rc > rc_exp and neglects the contribution of the repulsive potential and the dispersion damping function in the long-range correction terms.\n\nInside the subroutine, the variables onr3, onr5, onr6, onr7, and prefactor are declared as double precision. The values of onr3, onr5, onr6, and onr7 are computed based on rc. The prefactor is calculated using tau, natoms, and volume.\n\nThe tail correction values for the sg interaction potential and virial pressure are computed using the prefactor and the calculated onr3, onr5, onr6, and onr7. The final values are assigned to pot_lr and vir_lr using the calculated values and constants c_6_int, c_8_int, c_9_int, and c_10_int.\n\nEnd the subroutine after assigning the values to pot_lr and vir_lr.\n\nMake sure to call this subroutine from the main program to calculate the long-range correction.", "input": "", "output": "         subroutine sg_longrange(rc, natoms, volume, pot_lr, vir_lr)\n            ! calculates the long range correction to the total potential and\n            ! virial pressure.\n            !\n            ! uses the tail correction for a sharp cut-off, with no smoothing\n            ! function, as derived in martyna and hughes, journal of chemical\n            ! physics, 110, 3275, (1999).\n            !\n            ! note that we will assume that rc > rc_exp, and that \n            ! exp(alpha - beta*rc - delta*rc**2) << 0, so we can neglect the\n            ! contribution of the repulsive potential and the dispersion \n            ! damping function in the long range correction terms.\n            !\n            ! args:\n            !    rc: the cut-off radius.\n            !    natoms: the number of atoms in the system.\n            !    volume: the volume of the system box.\n            !    pot_lr: the tail correction to the sg interaction potential.\n            !    vir_lr: the tail correction to the sg virial pressure.\n\n            double precision, intent(in) :: rc\n            integer, intent(in) :: natoms\n            double precision, intent(in) :: volume\n            double precision, intent(out) :: pot_lr\n            double precision, intent(out) :: vir_lr\n\n            double precision onr3, onr5, onr6, onr7, prefactor\n\n            onr3 = 1/(rc*rc*rc)\n            onr6 = onr3*onr3\n            onr5 = onr6*rc\n            onr7 = onr6/rc\n            prefactor = tau*natoms*natoms/volume\n\n            pot_lr = prefactor*(-c_6_int*onr3 - c_8_int*onr5 + c_9_int*onr6 - c_10_int*onr7)\n            vir_lr = prefactor*(-c_6*onr3 - c_8*onr5 + c_9*onr6 - c_10*onr7)/3 + pot_lr\n\n         end subroutine\n"}, {"instruction": "Write a Fortran subroutine called recfil1 that performs recursive filtering on an input array. The subroutine takes 4 input parameters: n (integer), nml (integer), x (real*8 array), and h (real*8 array). It also has 1 output parameter: y (real*8 array).\n\nThe purpose of this subroutine is to apply a recursive filter to the input array x and store the filtered values in the output array y. The filter coefficients are provided in the array h. The direction of filtering (forward or backward) is determined by the value of nml.\n\nTo implement the filtering, the subroutine initializes some variables and iterates over the input array x. At each iteration, it applies the recursive filter equation to compute the filtered value and stores it in the corresponding position of the output array y. The iteration direction is controlled by the value of nml.\n\nMake sure to call this subroutine with appropriate input and output arrays to perform recursive filtering on the data.\n\n", "input": "", "output": "subroutine recfil1(x, y, n, h, nml)\n  implicit none\n  integer, intent(in) :: n, nml\n  real*8, intent(in) :: x(n), h(4)\n  real*8, intent(out) :: y(n)\n\n  integer :: j, jd, i\n  real*8 :: a, aa, b, bb, u1, u2, u3, v1, v2, v3\n\n  if(nml .ge. 0) then\n    j = 1\n    jd = 1\n  else\n    j = n\n    jd = -1\n  endif\n\n  a = h(1)\n  aa = h(2)\n  b = h(3)\n  bb = h(4)\n  u1 = 0.0d0\n  u2 = 0.0d0\n  v1 = 0.0d0\n  v2 = 0.0d0\n\n  do i = 1, n\n    u3 = u2\n    u2 = u1\n    u1 = x(j)\n    v3 = v2\n    v2 = v1\n    v1 = u1 + a * u2 + aa * u3 - b * v2 - bb * v3\n    y(j) = v1\n    j = j + jd\n  enddo\n\n  return\nend subroutine recfil1\n"}, {"instruction": "Write a Fortran subroutine named spline that calculates the second derivatives of a set of data points using the spline interpolation method. The subroutine takes 5 input parameters: n (integer), x (real(8) array), y (real(8) array), yp1 (real(8)), and ypn (real(8)). The output parameter is y2 (real(8) array). \n\nThe subroutine begins by allocating memory for arrays a, b, c, and f. It then computes the differences between consecutive x-values and stores them in array a. It calculates the coefficients of the second derivative equations and stores them in arrays b and c. It calculates the right-hand side of the equations and stores them in array f. \n\nNext, it performs the Gaussian elimination method to solve the system of equations for the second derivatives. It updates arrays b and f iteratively using forward substitution. Finally, it calculates the values of the second derivatives and stores them in array y2.\n\nThe subroutine deallocates the memory and completes its execution.\n\nEnsure the test_data type for the input parameters is ['integer', 'real(8) array', 'real(8) array', 'real(8)', 'real(8)'], and for the output parameter is ['real(8) array'].", "input": "", "output": "  subroutine spline( x,y,n,yp1,ypn,y2 )\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: x(n),y(n),yp1,ypn\n    real(8),intent(out) :: y2(n)\n    real(8),allocatable :: a(:),b(:),c(:),f(:)\n    integer :: i\n    allocate( a(n), b(n), c(n), f(n) )\n    a=0.0d0 ; b=0.0d0 ; c=0.0d0 ; f=0.0d0\n    do i=2,n-1\n       a(i) = x(i) - x(i-1)\n    end do\n    do i=2,n-1\n       b(i) = ( x(i+1) - x(i-1) )*2.0d0\n    end do\n    do i=2,n-2\n       c(i) = x(i+1) - x(i)\n    end do\n    do i=2,n-1\n       f(i) = 6.0d0*( (y(i+1)-y(i))/(x(i+1)-x(i)) &\n                    - (y(i)-y(i-1))/(x(i)-x(i-1)) )\n    end do\n    do i=3,n-1\n       b(i) = b(i) - a(i)*c(i-1)/b(i-1)\n       f(i) = f(i) - a(i)*f(i-1)/b(i-1)\n    end do\n    y2(:)=0.0d0\n    y2(n-1) = f(n-1)/b(n-1)\n    do i=n-2,2,-1\n       y2(i) = ( f(i) - c(i)*y2(i+1) )/b(i)\n    end do\n    deallocate( f, c, b, a )\n  end subroutine spline\n"}, {"instruction": "Create a Fortran subroutine named \"rcopy\" that copies the elements of an input real array \"f\" to an output real array \"g\" of the same size. The number of input parameters is 2 with the test_data types ['real', 'integer'], and the number of output parameters is 1 with the test_data type as ['real'].", "input": "", "output": "subroutine rcopy(f, g, n)\nreal, intent(in) :: f(n)\nreal, intent(out) :: g(n)\ninteger, intent(in) :: n\ninteger :: i\n!$omp parallel do schedule(static) private(i)\ndo i = 1, n\n    g(i) = f(i)\nend do\n!$omp end parallel do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named tensor_norm to calculate the norm of a tensor based on the given input arrays and indices. The subroutine takes 5 input parameters of type real, real, integer, integer, and integer, and 1 output parameter of type real.", "input": "", "output": "subroutine tensor_norm(f, w1, w2, i1, i2, di)\nreal, intent(out) :: f(:,:,:)\nreal, intent(in) :: w1(:,:,:,:), w2(:,:,:,:)\ninteger, intent(in) :: i1(3), i2(3), di(3)\ninteger :: n(3), j, k, l\nn = (/size(f,1), size(f,2), size(f,3)/)\nif (any(i1 < 1 .or. i2 > n)) stop 'error in tensor_norm'\n!$omp parallel do schedule(static) private(j, k, l)\ndo l = i1(3), i2(3), di(3)\ndo k = i1(2), i2(2), di(2)\ndo j = i1(1), i2(1), di(1)\n    f(j,k,l) = &\n    ( w1(j,k,l,1) * w1(j,k,l,1) &\n    + w1(j,k,l,2) * w1(j,k,l,2) &\n    + w1(j,k,l,3) * w1(j,k,l,3) ) &\n    + 2.0 * &\n    ( w2(j,k,l,1) * w2(j,k,l,1) &\n    + w2(j,k,l,2) * w2(j,k,l,2) &\n    + w2(j,k,l,3) * w2(j,k,l,3) )\nend do\nend do\nend do\n!$omp end parallel do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named test0 that takes two input arrays, ix and e_x, of type real and integer, respectively, and returns an output array, esss, of type real. The subroutine assigns the elements of ix indexed by e_x to esss.", "input": "", "output": "subroutine test0(esss,ix, e_x)\n  real(kind=kind(1.0d0)), dimension(:), intent(out) :: esss\n  real(kind=kind(1.0d0)), dimension(:), intent(in) :: ix\n  integer(kind=kind(1)), dimension(:), intent(in) :: e_x\n  esss = ix(e_x)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named squares to calculate the square of a real number. The subroutine has 1 input parameter of type real with intent(in), and 1 output parameter of type real with intent(out).", "input": "", "output": "  subroutine squares(x, y)\n    real :: x, y\n    intent(in) :: x\n    intent(out) :: y\n    y = x * x\n  end subroutine squares\n"}, {"instruction": "Create a Fortran subroutine named findklistlength to determine the length of a k-point list in a file. The subroutine takes 1 input parameter of type integer. It has 3 output parameters consisting of 2 integers and 1 character array of length 67.", "input": "", "output": "subroutine findklistlength(itape,numkpt,errmsg,info)\n  implicit none\n  integer,      intent(in)  :: itape\n  integer,      intent(out) :: info, numkpt\n  character*67, intent(out) :: errmsg\n  ! locals\n  character*10 :: kname\n  integer :: kindex, ios, n_k_p\n  errmsg=''\n  if((itape.lt.1).or.(itape.gt.100)) then ! is itape valid unit?\n     info = 8\n     write (errmsg,'(\"invalid k-point file on unit \",i3)') itape\n     return\n  endif\n  !\n  n_k_p = 0\n  kindex = 0\n  do\n     kindex = kindex + 1\n     read (itape,'(a10)',iostat=ios) kname\n     if(ios.ne.0) then  ! something wrong....\n        info = 8\n        write (errmsg,'(\"invalid k-point file on unit \",i3)') itape\n        return\n     endif\n     if (kname .eq. 'end       ') then  ! reached the end\n        info = 0\n        numkpt = kindex - 1\n        rewind(itape)\n        return\n     endif\n     ! modification to for the k.p method: do not calculate lapw1 for those kpoints with kname=' kp '; these states will instead be calculated in lapwkp \n     if(kname(1:4).eq.' kp ') then\n        kindex=kindex-1  ! these points will instead be calculated in lapwkp\n        n_k_p = n_k_p+1\n     endif\n  end do\nend subroutine findklistlength\n"}, {"instruction": "Create a Fortran subroutine named readklist to read and process k-point data from a file. The subroutine takes 2 input parameters of type integer. It also has 8 output parameters consisting of character*10, real*8, real*8, real*8, real*8, character*3, character*67, and integer data types.", "input": "", "output": "subroutine readklist(itape,numkpt,kname,k3,weight,ipgr,e1,e2,errmsg,info)\n  implicit none\n  integer,      intent(in)  :: itape, numkpt\n  character*10, intent(out) :: kname(numkpt)\n  real*8,       intent(out) :: weight(numkpt), k3(3,numkpt) !sx(numkpt), sy(numkpt), sz(numkpt)\n  real*8,       intent(out) :: e1, e2\n  character*3,  intent(out) :: ipgr(numkpt)\n  character*67, intent(out) :: errmsg\n  integer,      intent(out) :: info\n  ! locals\n  integer :: kindex, ios, isx, isy, isz, idv\n  real*8  :: e1_, e2_\n  logical :: newform\n  !\n  weight(:)=0.0d0\n  k3(:,:)=0.d0\n  \n  if (numkpt.le.0) then\n     info = 8\n     write (errmsg,'(\"empty k-point file on unit \",i3)') itape\n     return\n  endif\n  \n  kindex = 1\n  read (itape,5101,iostat=ios) kname(kindex), isx, isy, isz, idv, weight(kindex), e1, e2, ipgr(kindex)\n  \n  if(ios==0) then   ! this is the new form of case.klist\n     newform=.true.\n  else              ! must be the old form of case.klist, which had smaller #digits\n     rewind(itape)\n     read (itape,5100,iostat=ios) kname(kindex), isx, isy, isz, idv,weight(kindex), e1, e2, ipgr(kindex)\n     if (ios.ne.0) then ! it is not even the old format. something wrong....\n        info = 8\n        write (errmsg,'(\"invalid k-point file (2) on unit \",i3)') itape\n        return\n     endif\n     newform=.false.\n  endif\n  if (kname(kindex) .eq. 'end       ') then  ! empty k-point file\n     info = 8\n     write (errmsg,'(\"empty k-point file on unit \",i3)') itape\n     return\n  endif\n\n  k3(1,kindex) = dble(isx)/dble(idv)\n  k3(2,kindex) = dble(isy)/dble(idv)\n  k3(3,kindex) = dble(isz)/dble(idv)\n  if(kname(kindex)(1:4).eq.' kp ') kindex=kindex-1  ! modification to for the k.p method\n  \n  do \n     kindex = kindex + 1\n     if(kindex.gt.numkpt) then\n        info=0\n        return\n     end if\n     !        read in k-point to be calculated and energy range\n     if(newform) then\n        read (itape,5101) kname(kindex), isx, isy, isz, idv,weight(kindex), e1_, e2_, ipgr(kindex)\n     else\n        read (itape,5100) kname(kindex), isx, isy, isz, idv,weight(kindex), e1_, e2_, ipgr(kindex)\n     endif\n     if (kname(kindex) .eq. 'end       ') then\n        info = 8\n        write (errmsg,'(\"reached the end of the k-point file on second reading \",i3)') itape\n        return\n     endif\n     k3(1,kindex) = dble(isx)/dble(idv)\n     k3(2,kindex) = dble(isy)/dble(idv)\n     k3(3,kindex) = dble(isz)/dble(idv)\n     if(kname(kindex)(1:4).eq.' kp ') kindex=kindex-1  ! modification to for the k.p method\n  end do\n  return\n5101 format(a10,4i10,3f5.2,a3)\n5100 format(a10,4i5,3f5.2,a3)\nend subroutine readklist\n"}, {"instruction": "Create a Fortran subroutine named \"lowcase\" to transform the uppercase letters in the input string \"str1\" into lowercase letters and store the result in the output string \"str2\". The number of input parameters is 1, with a test_data type of ['character (len=*)'], and the number of output parameters is 1, with a test_data type of ['character (len=*)'].", "input": "", "output": "  subroutine lowcase (str1, str2)\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    ! transform upper case letters in str1 into lower case letters, result is str2\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    implicit none\n    character (len=*),  intent(in) :: str1\n    character (len=*), intent(out) :: str2\n    integer                        :: j,k\n    character (len=*),   parameter :: lc = 'abcdefghijklmnopqrstuvwxyz'\n    character (len=*),   parameter :: uc = 'abcdefghijklmnopqrstuvwxyz'\n    !----- -------- --------- --------- --------- --------- --------- --------- -------\n    str2 = str1\n    do j=1,len_trim(str1)\n       k = index(uc,str1(j:j))\n       if (k > 0) str2(j:j) = lc(k:k)\n    end do\n  end subroutine lowcase\n"}, {"instruction": "Write a Fortran subroutine named test2 with the purpose of adding two arrays and storing the result in another array. The subroutine takes 2 input arrays of real numbers, b and c, and 1 output array a. The number of input parameters is 2 with the test_data type ['real', 'real'], and the number of output parameters is 1 with the test_data type ['real']. Use the imperative tone in the instructions.", "input": "", "output": "subroutine test2(a,b,c)\n  real, intent(out) :: a(:)\n  real, intent(in) :: b(:), c(:)\n a = b + c\nend subroutine test2\n"}, {"instruction": "Create a Fortran subroutine named quadtrafoxieta2xy to perform a coordinate transformation from local coordinates (xi, eta) to global coordinates (x, y) for a 4-node quadrilateral. The subroutine takes 4 input parameters of type real, representing the local coordinates (xi, eta) and the vertex coordinates (x, y). It also has 2 output parameters of type real, representing the transformed global coordinates (xp, yp).", "input": "", "output": "  subroutine quadtrafoxieta2xy(xp,yp,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xp, yp                              ! output: xp, yp       !\n    real        :: xi, eta                             ! input:  xi eta       !\n    real        :: x(4), y(4)                          ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i                                   ! loop index           ! \n    real        :: xiu, etau                           ! modified xi eta zeta !\n    real        :: l01xi, l01eta                       ! lagrangian polynomial!\n    real        :: l11xi, l11eta                       ! lagrangian polynomial!\n    real        :: sf(4)                               ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: xp,yp\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 4-node quadrilateral (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    !\n    ! compute shape functions of 4-node quadrilateral\n    !\n    sf(1) = l01xi * l01eta \n    sf(2) = l11xi * l01eta \n    sf(3) = l11xi * l11eta \n    sf(4) = l01xi * l11eta \n    !\n    ! coordinate transformation from xiu, etau to x, y\n    !\n    xp = 0.\n    yp = 0.\n    !\n    do i = 1,4\n        xp = xp + sf(i) * x(i)\n        yp = yp + sf(i) * y(i)\n    enddo\n    !\n  end subroutine quadtrafoxieta2xy\n"}, {"instruction": "Create a Fortran subroutine named tetratrafoxietazeta2xyz to calculate the coordinates of a point within a tetrahedron based on the barycentric coordinates xi, eta, and zeta. The subroutine takes 6 input parameters of type real (xp, yp, zp, xi, eta, zeta) and 3 output parameters of type real (x, y, z).", "input": "", "output": "  subroutine tetratrafoxietazeta2xyz(xp,yp,zp,xi,eta,zeta,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xp, yp, zp                          ! input:  xp, yp, zp   !\n    real        :: xi, eta, zeta                       ! output: xi eta zeta  !\n    real        :: x(4), y(4), z(4)                    ! vertex coordinates   !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z,xi,eta,zeta\n    intent(out) :: xp,yp,zp\n    !-------------------------------------------------------------------------!\n    !\n    xp = x(1) + (x(2)-x(1))*xi + (x(3)-x(1))*eta + (x(4)-x(1))*zeta\n    yp = y(1) + (y(2)-y(1))*xi + (y(3)-y(1))*eta + (y(4)-y(1))*zeta\n    zp = z(1) + (z(2)-z(1))*xi + (z(3)-z(1))*eta + (z(4)-z(1))*zeta \n    !\n  end subroutine tetratrafoxietazeta2xyz\n"}, {"instruction": "Create a Fortran subroutine named \"hexatrafoxietazetagrad\" to compute the gradient of a coordinate transformation from xi, eta, zeta to x, y, z for an 8-node hexahedron. The subroutine takes 6 input parameters of type real and 1 output parameter of type real.", "input": "", "output": "  subroutine hexatrafoxietazetagrad(grad,xi,eta,zeta,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(3,3)                           ! output:  grad        !\n    real        :: xi, eta, zeta                       ! input: xi eta zeta   !\n    real        :: x(8), y(8), z(8)                    ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i,j                                 ! loop index           ! \n    real        :: l01xi, l01eta, l01zeta              ! lagrangian polynomial!\n    real        :: l11xi, l11eta, l11zeta              ! lagrangian polynomial!\n    real        :: sf(8,0:3)                           ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z,xi,eta,zeta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 8-node hexahedron (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    l01zeta = 1-zeta\n    l11zeta =   zeta\n    !\n    ! compute the shape functions of an 8-node hexahedron\n    !\n    sf(1,0) = l01xi * l01eta * l01zeta\n    sf(2,0) = l11xi * l01eta * l01zeta\n    sf(3,0) = l01xi * l11eta * l01zeta\n    sf(4,0) = l11xi * l11eta * l01zeta\n    sf(5,0) = l01xi * l01eta * l11zeta\n    sf(6,0) = l11xi * l01eta * l11zeta\n    sf(7,0) = l01xi * l11eta * l11zeta\n    sf(8,0) = l11xi * l11eta * l11zeta\n    !\n    ! compute the xi-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,1) = (-1) * l01eta * l01zeta\n    sf(2,1) =        l01eta * l01zeta\n    sf(3,1) = (-1) * l11eta * l01zeta\n    sf(4,1) =        l11eta * l01zeta\n    sf(5,1) = (-1) * l01eta * l11zeta\n    sf(6,1) =        l01eta * l11zeta\n    sf(7,1) = (-1) * l11eta * l11zeta\n    sf(8,1) =        l11eta * l11zeta\n    !\n    ! compute the eta-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,2) = l01xi * (-1) * l01zeta\n    sf(2,2) = l11xi * (-1) * l01zeta\n    sf(3,2) = l01xi        * l01zeta\n    sf(4,2) = l11xi        * l01zeta\n    sf(5,2) = l01xi * (-1) * l11zeta\n    sf(6,2) = l11xi * (-1) * l11zeta\n    sf(7,2) = l01xi        * l11zeta\n    sf(8,2) = l11xi        * l11zeta\n    !\n    ! compute the zeta-derivative of the shape functions of an 8-node hexahedron\n    !\n    sf(1,3) = l01xi * l01eta * (-1)\n    sf(2,3) = l11xi * l01eta * (-1)\n    sf(3,3) = l01xi * l11eta * (-1)\n    sf(4,3) = l11xi * l11eta * (-1)\n    sf(5,3) = l01xi * l01eta  \n    sf(6,3) = l11xi * l01eta  \n    sf(7,3) = l01xi * l11eta  \n    sf(8,3) = l11xi * l11eta  \n    !\n    ! gradient of the coordinate transformation from xi, eta, zeta to x, y, z\n    !\n    grad(:,:) = 0.\n    !\n    do j = 1, 3\n     do i = 1,8\n        grad(1,j) = grad(1,j) + sf(i,j) * x(i)\n        grad(2,j) = grad(2,j) + sf(i,j) * y(i)\n        grad(3,j) = grad(3,j) + sf(i,j) * z(i)\n     enddo\n    enddo\n    !\n  end subroutine hexatrafoxietazetagrad\n"}, {"instruction": "Write a Fortran subroutine named tetratrafoxietazetagrad to calculate the gradient matrix of a tetrahedron defined by its vertex coordinates. The subroutine takes 3 input parameters of type real arrays x, y, and z for the vertex coordinates and provides an output parameter grad of type real 3x3 matrix representing the gradient matrix.", "input": "", "output": "  subroutine tetratrafoxietazetagrad(grad,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(3,3)                           ! output:  grad        !\n    real        :: x(4), y(4), z(4)                    ! vertex coordinates   !\n    ! local variable declaration\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    grad(1,1) = x(2)-x(1); grad(1,2) = x(3)-x(1); grad(1,3) = x(4)-x(1)\n    grad(2,1) = y(2)-y(1); grad(2,2) = y(3)-y(1); grad(2,3) = y(4)-y(1)\n    grad(3,1) = z(2)-z(1); grad(3,2) = z(3)-z(1); grad(3,3) = z(4)-z(1)\n    !\n  end subroutine tetratrafoxietazetagrad\n"}, {"instruction": "Provide a Fortran subroutine named quadtrafoxietagrad to calculate the gradient of a coordinate transformation from xi, eta to x, y. The subroutine takes 4 input parameters of type real and outputs 1 parameter of type real.", "input": "", "output": "  subroutine quadtrafoxietagrad(grad,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(2,2)                           ! output:  grad        !\n    real        :: xi, eta                             ! input: xi eta        !\n    real        :: x(4), y(4)                          ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i,j                                 ! loop index           ! \n    real        :: l01xi, l01eta                       ! lagrangian polynomial!\n    real        :: l11xi, l11eta                       ! lagrangian polynomial!\n    real        :: sf(4,0:2)                           ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 4-node square (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    !\n    ! compute the shape functions of an 4-node square\n    !\n    sf(1,0) = l01xi * l01eta\n    sf(2,0) = l11xi * l01eta\n    sf(3,0) = l11xi * l11eta\n    sf(4,0) = l01xi * l11eta\n    !\n    ! compute the xi-derivative of the shape functions of an 4-node square\n    !\n    sf(1,1) = (-1) * l01eta\n    sf(2,1) =        l01eta\n    sf(3,1) =        l11eta\n    sf(4,1) = (-1) * l11eta\n    !\n    ! compute the eta-derivative of the shape functions of an 4-node square\n    !\n    sf(1,2) = l01xi * (-1)\n    sf(2,2) = l11xi * (-1)\n    sf(3,2) = l11xi\n    sf(4,2) = l01xi\n    !\n    ! gradient of the coordinate transformation from xi, eta  to x, y \n    !\n    !         dx/dxi\n    ! | dx/dxi     dx/deta |\n    ! | dy/dxi     dy/deta |\n    !\n    grad(:,:) = 0.\n    !\n    do j = 1, 2\n     do i = 1,4\n        grad(1,j) = grad(1,j) + sf(i,j) * x(i)\n        grad(2,j) = grad(2,j) + sf(i,j) * y(i)\n     enddo\n    enddo\n    !\n  end subroutine quadtrafoxietagrad\n"}, {"instruction": "Write a Fortran subroutine named tritrafoxietagrad to calculate the gradient of a mapping from the parent element to the physical element. There are 4 input parameters of type real and 1 output parameter of type real. The input parameters are xi, eta, x(3), y(3), and the output parameter is grad(2,2).", "input": "", "output": "  subroutine tritrafoxietagrad(grad,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: grad(2,2)                           ! output:  grad        !\n    real        :: xi, eta                             ! input: xi eta        !\n    real        :: x(3), y(3)                          ! vertex coordinates   !\n    ! local variable declaration\n     !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: grad\n    !-------------------------------------------------------------------------!\n    !\n    !         dx/dxi\n    ! | dx/dxi     dx/deta |\n    ! | dy/dxi     dy/deta |\n    grad(1,1) = x(2)     - x(1)\n    grad(1,2) = x(3)     - x(1)\n    grad(2,1) = y(2)     - y(1)\n    grad(2,2) = y(3)     - y(1)\n\n  end subroutine tritrafoxietagrad\n"}, {"instruction": "Create a Fortran subroutine named tritrafochi2xieta to transform the chi value to xi and eta coordinates based on the given element orientation. The subroutine takes 3 input arguments of types real, real, and integer, and returns 2 output arguments of types real and real.", "input": "", "output": "  subroutine tritrafochi2xieta(xi,eta,chi,iside,ineighborside)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xi, eta                             ! output: xi eta       !\n    real        :: chi                                 ! input:  chi          !\n    integer     :: iside, ineighborside                ! element orientation  !\n    ! local variable declaration\n    real        :: chi1                                ! intermediate results !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: chi, iside, ineighborside\n    intent(out) :: xi,eta\n    !-------------------------------------------------------------------------!\n    !\n    select case(ineighborside)\n    ! inside the element itself\n    case(0) \n        select case(iside)\n        case(1)\n          xi   = chi\n          eta  = 0.\n        case(2)\n          xi   = 1.-chi\n          eta  = chi \n        case(3)\n          xi   = 0. \n          eta  = 1.-chi\n        end select\n        !\n        return\n    ! inside the neighbor\n    case(1)\n      chi1 = 1.-chi\n      xi   = chi1\n      eta  = 0.\n    case(2)\n      chi1 = 1.-chi\n      xi   = 1.-chi1\n      eta  = chi1 \n    case(3)\n      chi1 = 1.-chi\n      xi   = 0. \n      eta  = 1.-chi1\n    end select\n    !\n    return\n    !\n  end subroutine tritrafochi2xieta\n"}, {"instruction": "Create a Fortran subroutine named spacetimebasis to calculate the space and time degrees of freedom for a tensor-product approach based on the given space-time degree of freedom and the total number of degrees of freedom. The subroutine should have 2 input parameters of type integer and 2 output parameters of type integer. The input parameters are idegfrst and ndegfr, and the output parameters are idegfr_xi and idegfr_tau.", "input": "", "output": "  subroutine spacetimebasis(idegfr_xi,idegfr_tau,idegfrst,ndegfr)\n    !-------------------------------------------------------------------------!\n    \n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    integer         :: idegfr_xi,idegfr_tau,idegfrst,ndegfr\n    !-------------------------------------------------------------------------!\n    intent(in)      :: idegfrst,ndegfr\n    intent(out) :: idegfr_xi,idegfr_tau\n    !-------------------------------------------------------------------------!\n    ! input is the number of the space-time degree of freedom\n    ! output is the pair of numbers of the space and the time degrees of freedom\n    ! for the tensor-product approach\n    idegfr_tau = ceiling(real(idegfrst)/real(ndegfr))\n    idegfr_xi  = idegfrst - (ndegfr)*(idegfr_tau-1) \n  end subroutine spacetimebasis\n"}, {"instruction": "Define a Fortran subroutine named angle_vector_vector_2d to calculate the angle between two 2D vectors. The subroutine takes 2 input parameters of type real array for the vectors v1 and v2, and 1 output parameter of type real for the angle theta.", "input": "", "output": "  subroutine angle_vector_vector_2d(theta,v1,v2)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: theta                               ! output:  angle       !\n    real        :: v1(2), v2(2)                        ! input :  vectors     !\n    ! local variable declaration\n    real        :: v1_aux(2), v2_aux(2)                ! auxiliary vectors    !\n    real        :: v1_mod, v2_mod                      ! module of vectors    !\n    real        :: theta1, theta2                      ! angles to the x axe  !\n    real        :: cos_theta1, cos_theta2              ! cos(theta)           !\n    real, parameter :: pi=3.141592653589793            ! constant pi\n    !-------------------------------------------------------------------------!\n    intent(in)  :: v1,v2\n    intent(out) :: theta\n    !-------------------------------------------------------------------------!\n    !\n    ! normalize the vectors\n    v1_mod = sqrt(v1(1)**2+v1(2)**2);\n    v1_aux = v1 / v1_mod;\n    v2_mod = sqrt(v2(1)**2+v2(2)**2);\n    v2_aux = v2 / v2_mod;\n        \n    cos_theta1 = (v1(1));   ! cos(theta) of vector 1 respect to [1,0]\n    cos_theta2 = (v2(1));   ! cos(theta) of vector 2 respect to [1,0]\n    \n    theta1 = acos(cos_theta1);\n    theta2 = acos(cos_theta2);\n    \n    ! if the rotation is higher than (pi rad) 2*pi-theta\n    if (v1(2)<0) theta1 = 2*pi-theta1;\n    if (v2(2)<0) theta2 = 2*pi-theta2;\n    \n    theta = theta2-theta1;\n\n  end subroutine angle_vector_vector_2d\n"}, {"instruction": "Create a Fortran subroutine named mirror_p_atline to calculate the mirror point of a given point about a given line. The subroutine takes 3 input parameters of type real arrays and produces 1 output parameter of type real array.", "input": "", "output": "  subroutine mirror_p_atline(p_new,p_old,a,b)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: p_new(2)                                  ! output:  vector      !\n    real        :: p_old(2), a(2), b(2)                ! input :  vectors     !\n    ! local variable declaration\n    real        :: t,d(2)                              ! auxiliary vectors    !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: p_old, a, b\n    intent(out) :: p_new\n    !-------------------------------------------------------------------------!\n    !\n    ! mirror point at line               \n    \n    t    = ((p_old(1) - a(1)) * b(1) + (p_old(2) - a(2)) * b(2)) / (b(1)**2+b(2)**2)\n    d(1) = p_old(1) - a(1) - t*b(1)\n    d(2) = p_old(2) - a(2) - t*b(2)\n\n    p_new(1) = p_old(1) - 2*d(1)\n    p_new(2) = p_old(2) - 2*d(2)\n\n  end subroutine mirror_p_atline\n"}, {"instruction": "Create a Fortran subroutine named c_eval_ijkl to calculate a single real value based on the input integer values ishell, jshell, kshell, lshell, and ntint. The input parameters are of type integer(kind=c_int64_t) and the output parameter is a real value of kind=c_double.", "input": "", "output": "        subroutine c_eval_ijkl(ishell, jshell, kshell, lshell, tint, ntint) bind(c)\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int64_t), intent(in)::ishell\n            integer(kind=c_int64_t), intent(in)::jshell\n            integer(kind=c_int64_t), intent(in)::kshell\n            integer(kind=c_int64_t), intent(in)::lshell\n            real(kind=c_double), intent(out)::tint(1)\n            integer(kind=c_int64_t), intent(in)::ntint\n        end subroutine c_eval_ijkl\n"}, {"instruction": "Write a Fortran subroutine named c_get_overlap that takes an integer input parameter of kind c_int64_t and an array output parameter of real type with kind c_double. This subroutine is intended to be used in a C program, as indicated by the \"bind(c)\" attribute.", "input": "", "output": "        subroutine c_get_overlap(nbas, aooverlap) bind(c)\n            use iso_c_binding\n            implicit none\n            integer(kind=c_int64_t), intent(in)::nbas\n            real(kind=c_double), intent(out)::aooverlap(1,1)\n        end subroutine c_get_overlap\n"}, {"instruction": "Create a Fortran subroutine named getspherepart to calculate the spherical partitions based on the provided inputs. The subroutine takes 2 input parameters of type integer, and 1 output parameter of type real*8.", "input": "", "output": "subroutine getspherepart(myid,numprocs,arange)\n!\ninteger, intent(in) :: myid\ninteger, intent(in) :: numprocs\nreal*8, intent(out) :: arange(4)\n!\ninteger :: i,nc,j,k\nreal*8 :: ap,thetap,delta,ai,a,thpolar\nreal*8, allocatable :: y(:)\ninteger, allocatable :: m(:)\nreal*8 :: pi\n!\n! begin\n!\npi=acos(-1.)\nap=4*pi/numprocs\n!\nthetap=asin(1-2.0/numprocs)\nthpolar=pi*0.5-thetap\n!\nnc=nint((pi-2*thpolar)/sqrt(ap))\ndelta=(pi-2*thpolar)/nc\n!\nallocate(y(nc),m(nc))\n!\ndo i=1,nc\n   ai=2*pi*(sin(thetap-(i-1)*delta)-sin(thetap-i*delta))\n   y(i)=ai/ap\nenddo\n!\na=0\ndo i=1,nc\n   m(i)=nint(y(i)+a)\n   a=a+(y(i)-m(i))\nenddo\n!\nk=1\nif (myid==k) then\n  arange(1)=thetap\n  arange(2)=pi*0.5\n  arange(3)=0.\n  arange(4)=2*pi\nendif\n!\ndo i=1,nc\n   do j=1,m(i)\n     k=k+1\n     if (myid==k) then\n        arange(1)=thetap-i*delta\n\tarange(2)=arange(1)+delta\n        arange(3)=(j-1)*2*pi/m(i)\n        arange(4)=arange(3)+2*pi/m(i)\n\treturn\n     endif\n   enddo\nenddo\n!\nk=numprocs\nif (myid==k) then\n  arange(1)=-pi*0.5\n  arange(2)=-thetap\n  arange(3)=0.\n  arange(4)=2*pi\nendif\n!\n!\nreturn\nend subroutine getspherepart\n"}, {"instruction": "Create a Fortran subroutine named \"stiff3\" to calculate the analytical stiffness matrix of a 3-node triangle in plane strain. The subroutine should take 3 input parameters of type real(iwp) and provide 1 output parameter of type real(iwp).", "input": "", "output": "subroutine stiff3(km,coord,ym,pr)\n implicit none\n!\n!      analytical stiffness matrix of a 3-node triangle in plane strain\n!\n integer,parameter::iwp=selected_real_kind(15)\n integer::i,j\n real(iwp),intent(in)::coord(3,2),ym,pr\n real(iwp),intent(out)::km(6,6)\n real(iwp)::x1,y1,x2,y2,x3,y3,cf\n real(iwp)::d1=1._iwp,d2=2._iwp,d3=3._iwp,d4=4._iwp,d5=5._iwp,d6=6._iwp\n x1=coord(1,1)\n y1=coord(1,2)\n x2=coord(2,1)\n y2=coord(2,2)\n x3=coord(3,1)\n y3=coord(3,2)\ncf=ym/(d1+pr)/(-d1+d2*pr)/(-x1*y2+x1*y3-x2*y3+y1*x2-y1*x3+y2*x3)/d4\n!-----------------------------------------------------------------------\n km(1,1)=(-d2*y2**2+d4*y2*y3-d2*y3**2+d2*pr*y2**2-d4*pr*y2*y3+            &\n   d2*pr*y3**2-x2**2+d2*x2**2*pr+d2*x2*x3-d4*x2*x3*pr-x3**2+d2*x3**2*pr)*cf\n km(1,2)=(x2-x3)*(y2-y3)*cf\n km(1,3)=-(d2*y2*y3-d2*y2*y1-d2*y3**2+d2*y3*y1-d2*pr*y2*y3+d2*pr*y2*y1+   &\n   d2*pr*y3**2-d2*pr*y3*y1-x2*x1+d2*x2*x1*pr+x2*x3-d2*x2*x3*pr+x3*x1-     &\n   d2*x3*x1*pr-x3**2+d2*x3**2*pr)*cf\n km(1,4)=-(d2*pr*x1*y2-d2*pr*x1*y3-d2*pr*y2*x3-x2*y3+d2*x2*y3*pr+y1*x2-   &\n   d2*y1*x2*pr+y3*x3-y1*x3+d2*y1*x3*pr)*cf\n km(1,5)=-(d2*y2*y1-d2*y2**2-d2*y3*y1+d2*y2*y3-d2*pr*y2*y1+d2*pr*y2**2+   &\n   d2*pr*y3*y1-d2*pr*y2*y3+x2*x1-d2*x2*x1*pr-x2**2+d2*x2**2*pr-x3*x1+     &\n   d2*x3*x1*pr+x2*x3-d2*x2*x3*pr)*cf\n km(1,6)=(d2*pr*x1*y2-d2*pr*x1*y3+d2*x2*y3*pr+y1*x2-d2*y1*x2*pr-y2*x2-    &\n   y1*x3+d2*y1*x3*pr+y2*x3-d2*pr*y2*x3)*cf\n!-----------------------------------------------------------------------\n km(2,2)=(-d2*x2**2+d4*x2*x3-d2*x3**2+d2*x2**2*pr-d4*x2*x3*pr+d2*x3**2*pr-&\n   y2**2+d2*pr*y2**2+d2*y2*y3-d4*pr*y2*y3-y3**2+d2*pr*y3**2)*cf\n km(2,3)=(d2*x2*y3*pr-d2*y1*x2*pr+d2*y1*x3*pr-x1*y2+d2*pr*x1*y2+y2*x3-    &\n   d2*pr*y2*x3+x1*y3-d2*pr*x1*y3-y3*x3)*cf\n km(2,4)=-(-d2*x2*x1+d2*x2*x3+d2*x3*x1-d2*x3**2+d2*x2*x1*pr-d2*x2*x3*pr-  &\n   d2*x3*x1*pr+d2*x3**2*pr+y2*y3-d2*pr*y2*y3-y2*y1+d2*pr*y2*y1-y3**2+     &\n   d2*pr*y3**2+y3*y1-d2*pr*y3*y1)*cf\n km(2,5)=(d2*y1*x2*pr-d2*y1*x3*pr+d2*pr*y2*x3+x1*y2-d2*pr*x1*y2-y2*x2-    &\n   x1*y3+d2*pr*x1*y3+x2*y3-d2*x2*y3*pr)*cf\n km(2,6)=(-d2*x2*x1+d2*x2**2+d2*x3*x1-d2*x2*x3+d2*x2*x1*pr-d2*x2**2*pr-   &\n   d2*x3*x1*pr+d2*x2*x3*pr-y2*y1+d2*pr*y2*y1+y2**2-d2*pr*y2**2+y3*y1-     &\n   d2*pr*y3*y1-y2*y3+d2*pr*y2*y3)*cf\n!-----------------------------------------------------------------------\n km(3,3)=(-d2*y3**2+d4*y3*y1-d2*y1**2+d2*pr*y3**2-d4*pr*y3*y1+d2*pr*y1**2-&\n   x1**2+d2*x1**2*pr+d2*x3*x1-d4*x3*x1*pr-x3**2+d2*x3**2*pr)*cf\n km(3,4)=(x1-x3)*(-y3+y1)*cf\n km(3,5)=-(d2*y3*y1-d2*y2*y3-d2*y1**2+d2*y2*y1-d2*pr*y3*y1+d2*pr*y2*y3+   &\n   d2*pr*y1**2-d2*pr*y2*y1-x1**2+d2*x1**2*pr+x2*x1-d2*x2*x1*pr+x3*x1-     &\n   d2*x3*x1*pr-x2*x3+d2*x2*x3*pr)*cf\n km(3,6)=-(-d2*pr*x1*y3+d2*x2*y3*pr-d2*y1*x2*pr+y1*x1-x1*y2+d2*pr*x1*y2-  &\n   y1*x3+d2*y1*x3*pr+y2*x3-d2*pr*y2*x3)*cf\n!-----------------------------------------------------------------------\n km(4,4)=(-d2*x1**2+d4*x3*x1-d2*x3**2+d2*x1**2*pr-d4*x3*x1*pr+d2*x3**2*pr-&\n   y3**2+d2*pr*y3**2+d2*y3*y1-d4*pr*y3*y1-y1**2+d2*pr*y1**2)*cf\n km(4,5)=(d2*pr*x1*y2+d2*y1*x3*pr-d2*pr*y2*x3+x1*y3-d2*pr*x1*y3-x2*y3+    &\n   d2*x2*y3*pr-y1*x1+y1*x2-d2*y1*x2*pr)*cf\n km(4,6)=-(-d2*x1**2+d2*x2*x1+d2*x3*x1-d2*x2*x3+d2*x1**2*pr-d2*x2*x1*pr-  &\n   d2*x3*x1*pr+d2*x2*x3*pr+y3*y1-d2*pr*y3*y1-y2*y3+d2*pr*y2*y3-y1**2+     &\n   d2*pr*y1**2+y2*y1-d2*pr*y2*y1)*cf\n!-----------------------------------------------------------------------\n km(5,5)=(-d2*y1**2+d4*y2*y1-d2*y2**2+d2*pr*y1**2-d4*pr*y2*y1+d2*pr*y2**2-&\n   x1**2+d2*x1**2*pr+d2*x2*x1-d4*x2*x1*pr-x2**2+d2*x2**2*pr)*cf\n km(5,6)=(x1-x2)*(y1-y2)*cf\n!-----------------------------------------------------------------------\n km(6,6)=(-d2*x1**2+d4*x2*x1-d2*x2**2+d2*x1**2*pr-d4*x2*x1*pr+d2*x2**2*pr-&\n   y1**2+d2*pr*y1**2+d2*y2*y1-d4*pr*y2*y1-y2**2+d2*pr*y2**2)*cf\n!-----------------------------lower triangle----------------------------\n km(2,1)=km(1,2)\n km(3,1)=km(1,3)\n km(3,2)=km(2,3)\n km(4,1)=km(1,4)\n km(4,2)=km(2,4)\n km(4,3)=km(3,4)\n km(5,1)=km(1,5)\n km(5,2)=km(2,5)\n km(5,3)=km(3,5)\n km(5,4)=km(4,5)\n km(6,1)=km(1,6)\n km(6,2)=km(2,6)\n km(6,3)=km(3,6)\n km(6,4)=km(4,6)\n km(6,5)=km(5,6)\nreturn\nend subroutine stiff3\n"}, {"instruction": "Create a Fortran subroutine named \"fmplat\" to calculate the second derivatives of a plate bending element. The subroutine takes 4 input parameters of type real(iwp), real(iwp), real(iwp), and integer, and returns 3 output parameters of type real(iwp), real(iwp), and real(iwp).", "input": "", "output": "subroutine fmplat(d2x,d2y,d2xy,points,aa,bb,i)\r\n!\r\n\n! plate bending elements.\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::points(:,:),aa,bb\r\n real(iwp),intent(out)::d2x(:),d2y(:),d2xy(:)\r\n integer,intent(in)::i\r\n real(iwp)::x,e,xp1,xp12,xp13,ep1,ep12,ep13,p1,q1,p2,q2,p3,q3,p4,q4,dp1,  &\r\n   dq1,dp2,dq2,dp3,dq3,dp4,dq4,d2p1,d2p2,d2p3,d2p4,d2q1,d2q2,d2q3,d2q4,   &\r\n   pt25=0.25_iwp,pt375=0.375_iwp,pt5=0.5_iwp,pt75=0.75_iwp,one=1.0_iwp,   &\r\n   opt5=1.5_iwp,d3=3.0_iwp\r\n x=points(i,1)\r\n e=points(i,2)\r\n xp1=x+one\r\n xp12=xp1*xp1\r\n xp13=xp12*xp1\r\n ep1=e+one\r\n ep12=ep1*ep1\r\n ep13=ep12*ep1\r\n p1=one-pt75*xp12+pt25*xp13\r\n q1=one-pt75*ep12+pt25*ep13\r\n p2=pt5*aa*xp1*(one-xp1+pt25*xp12)\r\n q2=pt5*bb*ep1*(one-ep1+pt25*ep12)\r\n p3=pt25*xp12*(d3-xp1)\r\n q3=pt25*ep12*(d3-ep1)\r\n p4=pt25*aa*xp12*(pt5*xp1-one)\r\n q4=pt25*bb*ep12*(pt5*ep1-one)\r\n dp1=opt5*xp1*(pt5*xp1-one)\r\n dq1=opt5*ep1*(pt5*ep1-one)\r\n dp2=aa*(pt5-xp1+pt375*xp12)\r\n dq2=bb*(pt5-ep1+pt375*ep12)\r\n dp3=opt5*xp1*(one-pt5*xp1)\r\n dq3=opt5*ep1*(one-pt5*ep1)\r\n dp4=pt5*aa*xp1*(pt75*xp1-one)\r\n dq4=pt5*bb*ep1*(pt75*ep1-one)\r\n d2p1=opt5*x\r\n d2p2=pt25*aa*(d3*x-one)\r\n d2p3=-d2p1\r\n d2p4=pt25*aa*(d3*x+one)\r\n d2q1=opt5*e\r\n d2q2=pt25*bb*(d3*e-one)\r\n d2q3=-d2q1\r\n d2q4=pt25*bb*(d3*e+one)\r\n d2x(1)=d2p1*q1\r\n d2x(2)=d2p2*q1\r\n d2x(3)=d2p1*q2\r\n d2x(4)=d2p2*q2\r\n d2x(5)=d2p1*q3\r\n d2x(6)=d2p2*q3\r\n d2x(7)=d2p1*q4\r\n d2x(8)=d2p2*q4\r\n d2x(9)=d2p3*q3\r\n d2x(10)=d2p4*q3\r\n d2x(11)=d2p3*q4\r\n d2x(12)=d2p4*q4\r\n d2x(13)=d2p3*q1\r\n d2x(14)=d2p4*q1\r\n d2x(15)=d2p3*q2\r\n d2x(16)=d2p4*q2\r\n d2y(1)=p1*d2q1\r\n d2y(2)=p2*d2q1\r\n d2y(3)=p1*d2q2\r\n d2y(4)=p2*d2q2\r\n d2y(5)=p1*d2q3\r\n d2y(6)=p2*d2q3\r\n d2y(7)=p1*d2q4\r\n d2y(8)=p2*d2q4\r\n d2y(9)=p3*d2q3\r\n d2y(10)=p4*d2q3\r\n d2y(11)=p3*d2q4\r\n d2y(12)=p4*d2q4\r\n d2y(13)=p3*d2q1\r\n d2y(14)=p4*d2q1\r\n d2y(15)=p3*d2q2\r\n d2y(16)=p4*d2q2\r\n d2xy(1)=dp1*dq1\r\n d2xy(2)=dp2*dq1\r\n d2xy(3)=dp1*dq2\r\n d2xy(4)=dp2*dq2\r\n d2xy(5)=dp1*dq3\r\n d2xy(6)=dp2*dq3\r\n d2xy(7)=dp1*dq4\r\n d2xy(8)=dp2*dq4\r\n d2xy(9)=dp3*dq3\r\n d2xy(10)=dp4*dq3\r\n d2xy(11)=dp3*dq4\r\n d2xy(12)=dp4*dq4\r\n d2xy(13)=dp3*dq1\r\n d2xy(14)=dp4*dq1\r\n d2xy(15)=dp3*dq2\r\n d2xy(16)=dp4*dq2\r\nreturn\r\nend subroutine fmplat\r\n"}, {"instruction": "Write a Fortran subroutine named simps that implements the Simpson's rule for numerical integration. The subroutine takes 2 input parameters of type real(8) and 1 output parameter of type real(8). The input parameters represent the grid spacing and the function values at equidistant points, while the output parameter represents the value of the integral.", "input": "", "output": "subroutine simps(dx, func,val)\n    implicit none\n    !!simps works on functions defined at equidistant values of x only\n\n    real(8), intent(in) :: dx      !the grid spacing\n    real(8), intent(in) :: func(:) !the function\n    real(8), intent(out):: val     !the value of the integral\n\n    integer :: n !length of func\n    integer :: i,end\n    real(8) :: endbit\n\n    n = size(func)\n\n    if (mod(n,2)==0) then\n        end =  n-1\n        endbit = (func(n)+func(n-1))*dx/2\n    else\n        end=n\n        endbit=0.d0\n    end if\n\n    val = sum(func(1:end-2:2) + func(3:end:2) + 4*func(2:end-1:2))\n    val = val*dx/3 + endbit\nend subroutine simps\n"}, {"instruction": "Write a Fortran subroutine named trapz to calculate the integral of a function with equidistant values of x. The subroutine takes 2 input arguments of type real(8) for grid spacing (dx) and the function values (func). It also has 1 output argument of type real(8) for the integral value (val). Ensure that the length of the func array is defined as n, and the subroutine uses the trapezoidal rule to compute the integral.", "input": "", "output": "subroutine trapz(dx,func,val)\n    implicit none\n    !!trapz works on functions defined at equidistant values of x only\n\n    real(8), intent(in) :: dx !the grid spacing\n    real(8), intent(in) :: func(:) !the function\n    real(8), intent(out) :: val !the value of the integral\n\n    integer :: n !length of func\n    integer :: i\n\n    val = func(1)+func(n)\n    do i=2,n-1\n        val = val + 2*func(i)\n    end do\n    val = val*dx/2\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named locpt to determine the position of a point relative to a polygonal path and calculate the winding number. The number of input arguments is 5 with the test_data type [real, real, real, real, integer]. The number of output arguments is 2 with the test_data type [integer, integer].", "input": "", "output": "subroutine locpt (x0, y0, x, y, n, l, m)\r\n!-----------------------------------------------------------------------\r\n! given a polygonal line connecting the vertices (x(i),y(i)) (i = 1,...,n)\r\n! taken in this order.  it is assumed that the polygonal path is a loop,\r\n! where (x(n),y(n)) = (x(1),y(1)) or there is an arc from (x(n),y(n)) to\r\n! (x(1),y(1)).  n.b. the polygon may cross itself any number of times.\r\n\r\n! (x0,y0) is an arbitrary point and l and m are variables.\r\n! on output, l and m are assigned the following values ...\r\n\r\n!    l = -1   if (x0,y0) is outside the polygonal path\r\n!    l =  0   if (x0,y0) lies on the polygonal path\r\n!    l =  1   if (x0,y0) is inside the polygonal path\r\n\r\n! m = 0 if (x0,y0) is on or outside the path.  if (x0,y0) is inside the\r\n! path then m is the winding number of the path around the point (x0,y0).\r\n\r\n! fortran 66 version by a.h. morris\r\n! converted to elf90 compatibility by alan miller, 15 february 1997\r\n\r\n!-----------------------\r\n\r\nimplicit none\r\nreal, intent(in)     :: x0, y0, x(:), y(:)\r\ninteger, intent(in)  :: n\r\ninteger, intent(out) :: l, m\r\n\r\n!     local variables\r\ninteger :: i, n0\r\nreal    :: angle, eps, pi, pi2, sum, theta, theta1, thetai, tol, u, v\r\n\r\n!     ****** eps is a machine dependent constant. eps is the\r\n!            smallest number such that 1.0 + eps > 1.0\r\n\r\neps = epsilon(1.0)\r\n\r\n!-----------------------------------------------------------------------\r\nn0 = n\r\nif (x(1) == x(n) .and. y(1) == y(n)) n0 = n - 1\r\npi = atan2(0.0, -1.0)\r\npi2 = 2.0*pi\r\ntol = 4.0*eps*pi\r\nl = -1\r\nm = 0\r\n\r\nu = x(1) - x0\r\nv = y(1) - y0\r\nif (u == 0.0 .and. v == 0.0) go to 20\r\nif (n0 < 2) return\r\ntheta1 = atan2(v, u)\r\n\r\nsum = 0.0\r\ntheta = theta1\r\ndo i = 2, n0\r\n  u = x(i) - x0\r\n  v = y(i) - y0\r\n  if (u == 0.0 .and. v == 0.0) go to 20\r\n  thetai = atan2(v, u)\r\n  \r\n  angle = abs(thetai - theta)\r\n  if (abs(angle - pi) < tol) go to 20\r\n  if (angle > pi) angle = angle - pi2\r\n  if (theta > thetai) angle = -angle\r\n  sum = sum + angle\r\n  theta = thetai\r\nend do\r\n\r\nangle = abs(theta1 - theta)\r\nif (abs(angle - pi) < tol) go to 20\r\nif (angle > pi) angle = angle - pi2\r\nif (theta > theta1) angle = -angle\r\nsum = sum + angle\r\n\r\n!     sum = 2*pi*m where m is the winding number\r\n\r\nm = abs(sum)/pi2 + 0.2\r\nif (m == 0) return\r\nl = 1\r\nif (sum < 0.0) m = -m\r\nreturn\r\n\r\n!     (x0, y0) is on the boundary of the path\r\n\r\n20 l = 0\r\nreturn\r\nend subroutine locpt\r\n"}, {"instruction": "Create a Fortran subroutine named get_cartesian_shell to calculate and return all the functions on the \"l\" cartesian shell. The subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer arrays with unspecified dimensions.", "input": "", "output": "subroutine get_cartesian_shell(l, lpower, mpower, npower)\n! returns all the functions on the \"l\" cartesian shell.\n! the cartesian shell is defined as (x^l, y^m, z^n) where the powers (l, m, n)\n! are given by all combinations of l,m,n <= l so that l+m+n=l. there\n! is exactly (l+1)(l+2)/2 such combinations.\n\n! uses the following ordering:\n! l = 0\n! lpower == [0]\n! mpower == [0]\n! npower == [0]\n! l = 1\n! lpower == [1, 0, 0]\n! mpower == [0, 1, 0]\n! npower == [0, 0, 1]\n! l = 2\n! lpower == [2, 1, 1, 0, 0, 0]\n! mpower == [0, 1, 0, 2, 1, 0]\n! npower == [0, 0, 1, 0, 1, 2]\n! l = 3\n! lpower == [3, 2, 2, 1, 1, 1, 0, 0, 0, 0]\n! mpower == [0, 1, 0, 2, 1, 0, 3, 2, 1, 0]\n! npower == [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]\n! ...\n\ninteger, intent(in) :: l  ! the gaussian orbital number\ninteger, intent(out), dimension(:) :: lpower, mpower, npower\n! the (l, m, n) powers. the arrays must have dimension (l+1)(l+2)/2\ninteger :: i, k, n\ni = 1\ndo k = 0, l\n    do n = 0, k\n        lpower(i) = l - k\n        mpower(i) = k - n\n        npower(i) = n\n        i = i + 1\n    end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two input arrays of real*8 type, vec1 and vec2, along with an integer n specifying the number of elements in the arrays. The subroutine outputs the sum of the arrays in vecout, also of real*8 type.", "input": "", "output": "subroutine add(vec1, vec2, vecout, n)\n  integer, intent(in) :: n\n  real*8, intent(in) :: vec1(n), vec2(n)\n  real*8, intent(out) :: vecout(n)\n  vecout = vec1+vec2\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named funcs_to_am to convert the number of functions to an integer representation. The number of input parameters is 1 of type integer(kind=8), and the number of output parameters is 1 of type integer(kind=8). If the input nfuncs is 1, the output am_i is 0; if nfuncs is 3, am_i is 1; if nfuncs is 5 or 6, am_i is 2; if nfuncs is 7 or 10, am_i is 3; otherwise, an error message is displayed.", "input": "", "output": "  subroutine funcs_to_am(nfuncs, am_i)\n    implicit none\n\n    integer(kind=8), intent(in) :: nfuncs\n    integer(kind=8), intent(out) :: am_i\n\n    if (nfuncs == 1) then\n       am_i = 0\n    else if (nfuncs == 3) then\n       am_i = 1\n    else if (nfuncs == 6 .or. nfuncs == 5) then\n       am_i = 2\n    else if (nfuncs == 10 .or. nfuncs == 7) then\n       am_i = 3\n    else\n       write(*,*) \"error in funcs to am conversion!\"\n       flush(6)\n       stop\n    end if\n\n  end subroutine funcs_to_am\n"}, {"instruction": "Create a Fortran subroutine named para_range that calculates the range of a parameter for parallel processing. The subroutine takes 4 input parameters of type integer (n1, n2, np, irank) and returns 2 output parameters of type integer (ista, iend).", "input": "", "output": " subroutine para_range(n1,n2,np,irank,ista,iend)\n      integer,intent(in) :: n1,n2,np,irank\n      integer,intent(out) :: ista,iend\t  \n      integer iwork1,iwork2\n\t  \n      iwork1 = (n2-n1+1)/np\n      iwork2 = mod(n2-n1+1,np)\n      ista=irank*iwork1+n1+min(irank,iwork2)\n      iend=ista+iwork1-1\n      if(iwork2.gt.irank) then\n        iend=iend+1\n      endif\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dist that calculates the distance matrix between sites based on their coordinates. The subroutine takes 3 input parameters: an integer n, and two arrays of real numbers with dimensions n by 3. It returns a single output parameter, an array of real numbers with dimensions n by n.", "input": "", "output": "subroutine dist(coord1,coord2,n,dist_matrix)\n\n! obtains the distance matrix between sites in pymatgen structure, used to \n! obtain a neighbour list for sites (and is faster than using the\n! python version in pymatgen)\n! args:\n!     coord1 ([[real,real,real],...]): array of site coords\n!     coord2 ([[real,real,real],...]): array of site coords\n!     n (int): number of elements in coord arrays\n! return:\n!     dist_matrix([n x n array of reals]): dist matrix for sites \n\nuse omp_lib\n\nimplicit none\n\ninteger, intent(in) :: n\n\nreal,dimension(n,3),intent(in) :: coord1,coord2\nreal,dimension(n,n),intent(out) :: dist_matrix\ninteger:: i,j\n\n!$omp parallel do private(i,j) shared(coord1,coord2,dist_matrix)\ndo i=1,n\n  do j=1,n\n     dist_matrix(i,j) = ((coord1(i,1)-coord2(j,1))* (coord1(i,1)-coord2(j,1))+&\n                        (coord1(i,2)-coord2(j,2))* (coord1(i,2)-coord2(j,2))+&\n                        (coord1(i,3)-coord2(j,3))* (coord1(i,3)-coord2(j,3)))**0.5\n  end do\nend do\n!$omp end parallel do\n\nend subroutine dist\n"}, {"instruction": "Write a Fortran subroutine named shift_index to shift the index of a site in the unit cell to the corresponding index in the 3x3x3 halo supercell. The subroutine takes 2 input parameters of type integer and integer array of dimension 3, and returns 1 output parameter of type integer.", "input": "", "output": "subroutine shift_index(index_n,shift,new_index)\n\n! shifts the index of a site in the unit cell to the corresponding\n! index in the 3x3x3 halo supercell.\n! used when getting neighbour list for supercell from unit cell neighbour list\n! \n! args:\n!    index_n (int): original index\n!    shift ([int,int,int]): shift to image for which to obatin index eg. [-1,-1,-1]\n!    \n! returns:\n!    new_index (int): index for image site in supercell\n\nimplicit none\n\ninteger, intent(in) :: index_n\ninteger, dimension(3), intent(in):: shift\ninteger, intent(out) :: new_index\n\ninteger::new_x,new_y,new_z\n\nnew_x = modulo((modulo(int(index_n/9),3)+shift(1)),3)\nnew_y = modulo((modulo(int(index_n/3),3)+shift(2)),3)\nnew_z = modulo((modulo(index_n,3)+shift(3)),3)\n\nnew_index = int(27*int(index_n/(27))+(modulo(new_x,3)*9+modulo(new_y,3)*3+modulo(new_z,3)))\nend subroutine shift_index\n"}, {"instruction": "Create a Fortran subroutine named gauss_jacobi to compute the Gauss-Jacobi quadrature nodes and weights for a given interval. The subroutine takes 2 input parameters of type real and provides 2 output parameters of type real. The subroutine uses an iterative method to compute the nodes and weights, ensuring convergence within a specified iteration limit.", "input": "", "output": "  subroutine gauss_jacobi(a,b,xes,weights) \n    use, intrinsic :: iso_fortran_env, only : error_unit\n    real,intent(in) :: a,b \n    real,intent(out):: xes(:),weights(size(xes))\n    integer,parameter :: dk=kind(1.d0)\n    integer :: it,i1,i2,m\n    real :: ab,a_b\n    real(dk) :: o1,o2,o3,q,d,y,yd,f\n    real(dk), parameter :: one=1.d0,two=2.d0,half=0.5d0,quart=0.25d0\n    real(dk), parameter :: pi=3.1415926535897932384626433832795028841971694d0\n    integer , parameter :: nt=20\n    character(len=38), parameter ::message='gauss-jacobi: iteration limit exeeded '\n    m=size(xes);ab=a+b;a_b=a-b;f=fexp();yd=two;it=1\n    do i1=1,m \n       y=cos((half*a + i1 - quart)/(half*(one + a + b) + m)*pi)\n       do it=1,nt\n          d = two + a+b \n          o1 = (a_b + d*y)*half; o2 = one\n          do i2=2,m \n             o3 = o2;o2=o1;d=a+b+2*i2 \n             o1 = (-o3*(two*(a + i2 - 1)*(b + i2 - 1)*d) + o2*((d - one) & \n                  & *(a*a - b*b + d*(d - two)*y)))/(2*i2*(i2 + a+b)*(d - two))\n          enddo\n          q = (m*(a - b - d*y)*o1 + two*(m + a)*(m + b)*o2)/ & \n               & (d*(one - y*y)); yd = y; y = yd - o1/q \n          if(converged())exit\n       enddo\n       xes(i1) = y ; weights(i1) = f*d*2.**(a+b)/(q*o2)                               \n       if(it>nt)write(error_unit,*)message\n    enddo\n    return\n  contains\n    logical function converged()\n      converged = (abs(y - yd)<epsilon(y)*one)\n    end function converged\n    real(dk) function fexp()\n      fexp = exp(log_gamma(a + m) + log_gamma(b + m) & \n           &   - log_gamma(m + one) - log_gamma(m + a + b + one))\n    end function fexp \n  end subroutine gauss_jacobi\n"}, {"instruction": "Write a Fortran subroutine named occupr to calculate the charge density based on a set of input variables. The subroutine takes 6 input parameters of types real*8, complex*16, real*8, real*8, integer, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine occupr(charge, mu, ek, omega, l, nbands, nomega)\n  implicit none\n  real*8, intent(out)    :: charge\n  real*8, intent(in)     :: mu\n  complex*16, intent(in) :: ek(nbands,nomega)\n  real*8, intent(in)     :: omega(nomega)\n  real*8, intent(in)     :: l\n  integer, intent(in)    :: nbands, nomega\n  !f2py integer intent(hide), depend(omega)  :: nomega=shape(omega,0)\n  !f2py integer intent(hide), depend(ek)     :: nbands=shape(ek,0)\n  ! local\n  real*8  :: wdens(nbands), w1, w2, pi\n  integer :: ip, iom\n  pi = acos(-1.0)\n  !print *, 'nbands=', nbands\n  !print *, 'nom=', nomega\n  !print *, 'pi=', pi\n  wdens=0\n  ! for the lowest frequency, integral from -infinity to (om_1+om2_2)/2\n  w1 = l\n  w2 = 0.5*(omega(2)+omega(1))\n  do ip=1,nbands\n     wdens(ip) = aimag(log(w2+mu-ek(ip,1))-log(w1+mu-ek(ip,1)))\n  enddo\n  ! the rest of the frequencies\n  do iom=2,nomega-1\n     w1 = 0.5*(omega(iom)+omega(iom-1))\n     w2 = 0.5*(omega(iom+1)+omega(iom))\n     if (omega(iom+1) .gt. 0.0) w2 = 0.0\n     do ip=1,nbands\n        wdens(ip) = wdens(ip) + aimag(log(w2+mu-ek(ip,iom))-log(w1+mu-ek(ip,iom)))\n     enddo\n     if (omega(iom+1) .gt. 0.0) exit\n  enddo\n  charge = sum(wdens)*(-1/pi)\n  return \nend subroutine occupr\n"}, {"instruction": "Create a Fortran subroutine named \"thetakr\" to calculate the (k,r) angle in radians. The subroutine should have 4 input parameters of type real(kind=8), dimension(:,:), and 1 output parameter of type real(kind=8), dimension(:).", "input": "", "output": "subroutine thetakr(k,v,y,vap,thkr)\n\t!-----------------------------------------------------\n\t! (k,r) angle computation\n\t! calling sequence: call thetakr(k,v,vap,thkr)\n\t! inputs:     k: wave vector in cartesian coordinates.\n\t!             v: position vector in cartesian coordinates at step n.\n\t!             y: magnetic vector\n\t!           vap: position vector in cartesian coordinates at step n+1\n\t! outputs: thkr: (k,r) angle in radian  \n\t!-----------------------------------------------------\n\treal(kind=8), dimension(:,:),intent(in) :: k,v,vap,y\n\treal(kind=8), dimension(:),intent(out)  :: thkr\n\treal(kind=8), dimension(3,size(thkr))\t:: d\n\treal(kind=8),dimension(size(thkr))      :: normv,normk,normy\n\t\n\td=vap-v\n\tnormv=sqrt(d(1,:)**2+d(2,:)**2+d(3,:)**2)\n\tnormk=sqrt(k(1,:)**2+k(2,:)**2+k(3,:)**2)\n\tnormy=sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\n\twhere ((normv .ne. 0) .and. (normy /= 0.d0))\n\t\tthkr=acos((k(1,:)*d(1,:)+k(2,:)*d(2,:)+k(3,:)*d(3,:))/(normv*normk)) \n\telsewhere\n\t\tthkr=0.d0\n\tend where\n\t\nend subroutine thetakr\n"}, {"instruction": "Create a Fortran subroutine named vphase to compute the phase velocity by taking the reciprocal of the input indices.The number of input arguments is 1 and the test_data type is [real(kind=8), dimension(:)].The number of output arguments is 1 and the test_data type is [real(kind=8), dimension(:)].", "input": "", "output": "subroutine vphase(mu,vp)\n\t!-----------------------------------------------------\n\t! phase velocity calculation\n\t!      vp = c/mu \n\t! calling sequence: call vphase(mu,vp)\n\t! inputs:     mu: indice\n\t! outputs:    vp: phase velocity\n\t!-----------------------------------------------------\n\treal(kind=8), dimension(:), intent(in) \t:: mu\n\treal(kind=8), dimension(:), intent(out) :: vp\n\t\n\tvp = 1.d0/mu\n\nend subroutine vphase\n"}, {"instruction": "Create a Fortran subroutine named fplasma to calculate the plasma frequency using the formula fp = f*sqrt(x). The subroutine takes 2 input parameters of type real(kind=8) and real(kind=8), dimension(:), and 1 output parameter of type real(kind=8), dimension(:). The calling sequence is: call fplasma(f, x, fp), where f is the wave frequency, x is (fp/f)^2, and fp is the plasma frequency.", "input": "", "output": "subroutine fplasma(f,x,fp)\n\t!-----------------------------------------------------\n\t! plasma frequency computation fp = f*sqrt(x)\n\t!\n\t! calling sequence: call fplasma(f,x,fp)\n\t! inputs:     f: wave frequency\n\t!             x: (fp/f)^2\n\t! outputs:   fp: plasma  frequency\n\t!-----------------------------------------------------\n\treal(kind=8), intent(in)  \t\t\t\t:: f\n\treal(kind=8), dimension(:), intent(in)  :: x\n\treal(kind=8), dimension(:), intent(out) :: fp\n\t\n\tfp(:) = f*sqrt(x(:))\n\nend subroutine fplasma\n"}, {"instruction": "Create a Fortran subroutine named fcyclo to compute the cyclotron frequency using the formula fc = f*norm(y). The subroutine takes 2 input parameters of type real(kind=8) and real(kind=8), dimension(:,:), and returns 1 output parameter of type real(kind=8), dimension(:).", "input": "", "output": "subroutine fcyclo(f,y,fc)\n\t!-----------------------------------------------------\n\t! cyclotron frequency calculation fc = f*norm(y)\n\t!\n\t! calling sequence: call fcyclo(f,x,fp)\n\t! inputs:     f: wave frequency\n\t!             y: fc/f\n\t! outputs:   fc: cyclotron frequency\n\t!-----------------------------------------------------\n\treal(kind=8), intent(in)  \t\t\t\t:: f\n\treal(kind=8), dimension(:,:), intent(in):: y\n\treal(kind=8), dimension(:), intent(out) :: fc\n\t\n\tfc(:) = f*sqrt(y(1,:)**2+y(2,:)**2+y(3,:)**2)\n\t\nend subroutine fcyclo\n"}, {"instruction": "Create a Fortran subroutine named weight_avg to compute the weighted average abundance estimate. The subroutine should have 3 input parameters of types integer(kind = 4), real(kind = 8), and real(kind = 8), and 2 output parameters of types real(kind = 8) and real(kind = 8). The subroutine should follow the guidelines for assessing marine mammal stocks and calculate the weighted average by considering the precision of each estimate.", "input": "", "output": "  subroutine weight_avg(n_yrs, n_hat, cv_n, n_avg, cv_avg)\n! ----------------------------------------------------------------------------------------\n! calculate a weighted average abundance estimate. \n! average is weighted by the precision (inverse of the variance) of each estimate.\n! methods follow nmfs (2005) pp. 12-13 \n!  nmfs. 2005. revisions to guidelines for assessing marine mammal stocks. 24 pp.\n!   available at: http://www.nmfs.noaa.gov/pr/pdfs/sars/gamms2005.pdf  \n! ----------------------------------------------------------------------------------------\n    integer(kind = 4), intent(in) :: n_yrs         ! number of years to average over\n    real(kind = 8), intent(in) :: n_hat(1:n_yrs)   ! vector of abundance (point) estimates\n    real(kind = 8), intent(in) :: cv_n(1:n_yrs)    ! vector of corresponding cvs\n    real(kind = 8) :: var_n(1:n_yrs)               ! variances of abundance estimates\n    real(kind = 8) :: weights_tmp(1:n_yrs)         ! inverse of the variances\n    real(kind = 8) :: weights(1:n_yrs)             ! relative precision\n    real(kind = 8) :: weights_sq(1:n_yrs)          ! square of the weights\n    real(kind = 8) :: weight_tot                   ! sum of weights\n    real(kind = 8) :: n_weighted(1:n_yrs)          ! weighted abundance estimates\n    real(kind = 8) :: weighted_var(1:n_yrs)\n    real(kind = 8) :: var_avg\n    real(kind = 8), intent(out) :: n_avg           ! weighted average abundance estimate\n    real(kind = 8), intent(out) :: cv_avg          ! cv of weighted average abundance estimate    \n    \n    var_n = cv_n * n_hat   ! sd of abundance estimates \n    var_n = var_n * var_n  ! variance of abundance estimates\n  \n    weights_tmp = 1.d0 / var_n    ! calculate precision of each abundance estimate (note, vector operation)\n    weight_tot = sum(weights_tmp) ! \n    weights = weights_tmp / weight_tot ! calculate vector of weights\n    \n    n_weighted = weights * n_hat\n    n_avg = sum(n_weighted)\n    \n    weights_sq = weights * weights\n    weighted_var = weights_sq * var_n\n    var_avg = sum(weighted_var)\n    cv_avg = sqrt(var_avg) / n_avg \n    \n    return\n  end subroutine weight_avg\n"}, {"instruction": "Create a Fortran subroutine named avg_n to calculate a weighted average abundance estimate. The subroutine takes 2 input parameters of type real(kind = 8) and outputs 2 parameters of type real(kind = 8).", "input": "", "output": "  subroutine avg_n(n_hat, cv_n, n_avg, cv_avg)\n! ----------------------------------------------------------------------------------------\n! calculate a weighted average abundance estimate. \n! average is weighted by precision (inverse of the variance) of each estimate.\n! methods follow nmfs (2005) pp. 12-13: \n!  nmfs. 2005. revisions to guidelines for assessing marine mammal stocks. \n!  available at: http://www.nmfs.noaa.gov/pr/pdfs/sars/gamms2005.pdf  \n! ----------------------------------------------------------------------------------------  \n    real(kind = 8), allocatable :: var_n(:)\n    real(kind = 8), allocatable :: n_weighted(:)\n    real(kind = 8) :: var_avg    \n    real(kind = 8), intent(out) :: n_avg, cv_avg\n    real(kind = 8) :: weights_tmp, weight_tot, weights, weights_sq, weighted_var\n    real(kind = 8), intent(in) :: n_hat(:), cv_n(:)\n    real(kind = 8), allocatable :: n_hat_tmp(:), cv_n_tmp(:)    \n    \n! debugging\n    n_hat_tmp = [100.d0, 0.d0, 0.d0, 150.d0, 0.d0, 0.d0, 0.d0, 200.d0]  \n    cv_n_tmp =  0.20d0\n    \n    print *, \"hello from `avg_n()`\"\n    print *, \"n_hat_tmp: \", n_hat_tmp\n    print *, \"cv_n_tmp : \", cv_n_tmp\n    stop    \n\n  end subroutine avg_n\n"}, {"instruction": "Create a Fortran subroutine named inxslist that takes 4 input parameters of type integer, character*( * ), integer, and character*( * ), and 1 output parameter of type integer. The subroutine performs a simple search for matching strings from the given string table and string list. The output parameter returns the pointers to the table.", "input": "", "output": "    subroutine inxslist(ntab,stab,nval,sval,indx)\n      implicit none\n      integer, intent(in)\t:: ntab\t\t! size of stab\n      character*(*), intent(in)\t:: stab(ntab)\t! a given string table\n      integer, intent(in)\t:: nval\t\t! size of sval\n      character*(*), intent(in)\t:: sval(nval)\t! a given string list\n      integer, intent(out)\t:: indx(nval)\t! pointers to the table\n\n!\n! !description:\n!\n! !examples:\n!\n! !bugs:\n!   inxslist() performs a simple searching with minimum consideration\n!   of efficiency as a scalar algorithm.  however, it might do well on\n!   a vector/multitask system, such as a cray c90/j90.\n!\n! !see also:\n!\n! !system routines:\n!\n! !files used:\n!\n! !revision history:\n! \t03jan96 - j. guo\t- programmed and added the prolog\n!_______________________________________________________________________\n\n!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n!   locals\n  integer iv,it\n!-----------------------------------------------------------------------\n  indx(1:nval)=0\n  do it=1,ntab\n    do iv=1,nval\n      if(sval(iv) == stab(it)) indx(iv)=it\n    end do\n  end do\n!_______________________________________________________________________\nend subroutine inxslist\n"}, {"instruction": "Create a Fortran subroutine named beam_gm that calculates the coefficients for a specific mathematical operation. The subroutine takes 1 input parameter of type real(iwp) and provides 1 output parameter of type real(iwp).", "input": "", "output": "subroutine beam_gm(gm,ell)\n! used in p46\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::ell\n real(iwp),intent(out)::gm(:,:)\n real(iwp)::pt1=0.1_iwp,opt2=1.2_iwp,two=2.0_iwp,d15=15.0_iwp,d30=30.0_iwp\n gm(1,1)=opt2/ell\n gm(1,2)=pt1\n gm(2,1)=pt1\n gm(1,3)=-opt2/ell\n gm(3,1)=-opt2/ell\n gm(1,4)=pt1\n gm(4,1)=pt1\n gm(2,2)=two*ell/d15\n gm(2,3)=-pt1\n gm(3,2)=-pt1\n gm(2,4)=-ell/d30\n gm(4,2)=-ell/d30\n gm(3,3)=opt2/ell\n gm(3,4)=-pt1\n gm(4,3)=-pt1\n gm(4,4)=two*ell/d15\nreturn\nend subroutine beam_gm\n"}, {"instruction": "Create a Fortran subroutine named foo to determine the lower bound of the first dimension of two arrays. The subroutine should have 2 input parameters of type integer, dimension(:) and integer, dimension(-2:), and 2 output parameters of type integer.", "input": "", "output": "  subroutine foo (a, b, one, m)\n    integer, dimension(:), intent(in) :: a\n    integer, dimension (-2:), intent(in) :: b\n    integer, intent(out) :: one, m\n    one = lbound(a,1)\n    m = lbound(b,1)\n  end subroutine foo\n"}, {"instruction": "Create a Fortran subroutine named a_oio to calculate the pure compound ideal Helmholtz energy and its derivatives. The subroutine takes 6 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are rho, t, rho_c, t_c, n (dimension 7), and v (dimension 7). The output parameter is aoio, which is a 3x3 array of real(8) values.", "input": "", "output": "subroutine a_oio(rho, t, rho_c, t_c, n, v, aoio)\n   ! ideal gas energy\n   ! ----------------\n   ! calculate the pure compound ideal helmholtz enegry and its derivatives\n   !\n   ! input:\n   ! - rho (float): density\n   ! - t (float): temperature\n   ! - rho_c (float): critical density\n   ! - t_c (float): critical temperature\n   ! - n (dimension): n parameters\n   ! - v (dimension): v parameters\n   ! output:\n   ! - aoio: ideal gas helmholtz energy and its derivatives,\n   ! stoikuctured like:\n   ! --------------+------------------+------------------|\n   ! aoio          |     0            |    0             |\n   ! d(aoio)/dd    |     d(aoio)/dt   |    0             |\n   ! d2(aoio)/dd2  |     d2(aoio)/dt2 |    d2(aoio)/dddt |\n   ! ----------------------------------------------------|\n   real(8), intent(in) :: rho, t, rho_c, t_c\n   real(8), intent(in), dimension(7) :: n, v\n   real(8), intent(out) :: aoio(3, 3)\n   real(8) :: r, tr, dr, eps = 1d-10\n\n   r = 8.314510d0 / 8.314472d0\n\n   aoio = 0.d0\n   tr = t_c / t\n   dr = rho / rho_c\n\n   do k = 4, 7\n      if (v(k) > eps) then\n         if (k == 4 .or. k == 6) then\n            aoio(1, 1) = aoio(1, 1) + r * (n(k) * log(abs(dsinh(v(k) * tr))))\n            aoio(2, 2) = aoio(2, 2) + r * (n(k) * v(k) / dtanh(v(k) * tr))\n            aoio(3, 2) = aoio(3, 2) - r * (n(k) * v(k) ** 2 / dsinh(v(k) * tr) ** 2)\n         else\n            aoio(1, 1) = aoio(1, 1) - r * (n(k) * log(dcosh(v(k) * tr)))\n            aoio(2, 2) = aoio(2, 2) - r * (n(k) * v(k) * dtanh(v(k) * tr))\n            aoio(3, 2) = aoio(3, 2) - r * (n(k) * v(k) ** 2 / dcosh(v(k) * tr) ** 2)\n         end if\n      end if\n   end do\n\n   aoio(1, 1) = aoio(1, 1) + log(dr) + r * (n(1) + n(2) * tr + n(3) * log(tr))\n   aoio(2, 1) = 1.d0 / dr\n   aoio(3, 1) = - 1.d0 / dr ** 2\n   aoio(2, 2) = aoio(2, 2) + r * (n(2) + n(3) / tr)\n   aoio(3, 2) = aoio(3, 2) + r * (- n(3) * (t / t_c) ** 2)\n   aoio(3, 3) = 0.d0\nend subroutine a_oio\n"}, {"instruction": "Create a Fortran subroutine named a_oir to calculate the pure compound residual Helmholtz energy and its derivatives. The subroutine has 8 input parameters of type real(8), real(8), integer, integer, real(8) arrays of dimension 24, and integer arrays of dimension 24. The output parameter is a real(8) array of dimension 3x3.", "input": "", "output": "subroutine a_oir(delta, tau, kpol, kexp, n, d, t, c, aoir)\n   ! residual energy\n   ! ---------------\n   ! caculate the pure compound residual helmholtz energy and its derivatives\n   !\n   ! input:\n   ! - delta  (float)         : reduced density\n   ! - tau    (float)         : reduced temperature\n   ! - kpol   (integer)       : number of only polynomial parameters\n   ! - kexp   (integer)       : number of only exponential parameters\n   ! - n      (dimension)     : parameters n\n   ! - d      (dimension)     : parameters d\n   ! - t      (dimension)     : parameters t\n   ! - c      (dimension)     : parameters c\n   ! output:\n   ! - aoir: ideal gas helmholtz energy and its derivatives,\n   ! structured like:\n   ! ---------------+-------------------+-----------------|\n   ! aoir           |      0            |   0             |\n   ! d(aoir)/dd     |      d(aoir)/dt   |   0             |\n   ! d2(aoir)/dd2   |      d2(aoir)/dt2 |   d2(aoir)/dddt |\n   ! -----------------------------------------------------|\n   !\n\n   real(8), intent(in) :: delta, tau\n   integer, intent(in) :: kpol, kexp\n   real(8), dimension(24), intent(in) :: n, t\n   integer, dimension(24), intent(in) :: d, c\n   real(8), dimension(3, 3), intent(out) :: aoir\n   integer :: k\n\n   aoir = 0.d0\n   ! residual helmholtz energy\n   do k = 1, kpol\n        ! !write (0, *) k, n(k), d(k), t(k), c(k)\n      aoir(1, 1) = aoir(1, 1) + &\n                   n(k) * delta ** d(k) &\n                   * tau ** t(k)\n      aoir(2, 1) = aoir(2, 1) + n(k) * d(k) * delta ** (d(k) - 1) * tau ** (t(k))\n      aoir(2, 2) = aoir(2, 2) + &\n                   n(k) * t(k) * delta ** d(k) &\n                   * tau ** (t(k) - 1.d0)\n      aoir(3, 1) = aoir(3, 1) + &\n                   n(k) * d(k) * (d(k) - 1) * delta ** (d(k) - 2) * tau ** t(k)\n      aoir(3, 2) = aoir(3, 2) + &\n                   n(k) * t(k) * (t(k) - 1.d0) &\n                   * delta ** d(k) * tau ** (t(k) - 2.d0)\n      aoir(3, 3) = aoir(3, 3) + &\n                   n(k) * d(k) * t(k) &\n                   * delta ** (d(k) - 1) * tau ** (t(k) - 1.d0)\n   end do\n   do k = kpol + 1, kpol + kexp\n        ! !write (0, *) k, n(k), d(k), t(k), c(k)\n      aoir(1, 1) = aoir(1, 1) + &\n                   n(k) * delta ** d(k) &\n                   * tau ** t(k) &\n                   * exp(- delta ** c(k))\n      ! first derivative with reduced density\n      aoir(2, 1) = aoir(2, 1) + &\n                   n(k) * delta ** (d(k) - 1) &\n                   * (d(k) - c(k) * delta ** c(k)) &\n                   * tau ** t(k) * exp(- delta ** c(k))\n      ! first derivative with reduced temperature\n      aoir(2, 2) = aoir(2, 2) + &\n                   n(k) * t(k) * delta ** d(k) &\n                   * tau ** (t(k) - 1) &\n                   * exp(- delta ** c(k))\n      ! second derivative with reduced density\n      aoir(3, 1) = aoir(3, 1) + &\n                   n(k) * delta ** (d(k) - 2) * ( &\n                   (d(k) - c(k) * delta ** c(k)) &\n                   * (d(k) - 1 - c(k) * delta ** c(k)) &\n                   - c(k) ** 2 * delta ** c(k)) &\n                   * tau ** t(k) * exp(- delta ** c(k))\n      ! second derivative with reduced temperature\n      aoir(3, 2) = aoir(3, 2) + &\n                   n(k) * t(k) * (t(k) - 1.d0) &\n                   * delta ** d(k) * tau ** (t(k) - 2.d0) &\n                   * exp(- delta ** c(k))\n      ! second derivative with reduced temperature and density\n      aoir(3, 3) = aoir(3, 3) + &\n                   n(k) * t(k) * delta ** (d(k) - 1) &\n                   * (d(k) - c(k) * delta ** c(k)) &\n                   * tau ** (t(k) - 1.d0) * exp(- delta ** c(k))\n   end do\n\nend subroutine a_oir\n"}, {"instruction": "Write a Fortran subroutine named ftest that takes 3 input parameters of type integer, integer, and real (dp), and 1 output parameter of type real (dp). The subroutine computes a function value based on the input values and stores the result in the output parameter. The subroutine uses the imperative tone to instruct the computer to perform the calculations.", "input": "", "output": "subroutine ftest(ndim, z, nfun, f)\r\nimplicit none\r\ninteger, parameter     :: dp = selected_real_kind(15, 60)\r\ninteger, intent(in)    :: ndim, nfun\r\nreal (dp), intent(in)  :: z(:)\r\nreal (dp), intent(out) :: f(:)\r\n\r\n! local variables\r\ninteger   :: n\r\nreal (dp) :: sum\r\n\r\nsum = 0\r\ndo n = 1, ndim\r\n  sum = sum + n*z(n)**2\r\nend do\r\nf(1) = exp(-sum/2)\r\nf(2:nfun) = f(1) * z(1:nfun-1)\r\n\r\nreturn\r\nend subroutine ftest\r\n"}, {"instruction": "Create a Fortran subroutine named maxcheck that takes an array of 8-byte real numbers as input and returns the index of the maximum value as output. The subroutine should use the \"intent(in)\" attribute for the input array and the \"intent(out)\" attribute for the output integer.", "input": "", "output": "subroutine maxcheck(array,max)\n  real(8),intent(in) :: array(:)\n  integer,intent(out) :: max\n  integer :: i,arraysize\n  real(8) :: max_temp\n  \n  arraysize = size(array)\n  max_temp = 0.0d0\n  \n  do i = 1,arraysize\n    if (array(i) > max_temp) then\n      max_temp = array(i)\n      max = i\n    end if\n  end do\n  \nend subroutine maxcheck\n"}, {"instruction": "Write a Fortran subroutine named subtrace to perform a specific matrix operation. The subroutine takes 3 input parameters of type real(8), dimension(:,:), allocatable, integer, and integer, and 1 output parameter of type real(8), dimension(:,:), allocatable.", "input": "", "output": "  subroutine subtrace(red_dm,big_dm,bignsites,rednsites)\n   real(8),dimension(:,:),allocatable,intent(out) :: red_dm\n   real(8),dimension(:,:),allocatable,intent(in)  :: big_dm\n   integer                           ,intent(in)  :: bignsites\n   integer                           ,intent(in)  :: rednsites\n   integer         :: i,j,io,jo,iup,idw,jup,jdw\n   integer         :: iimpup,iimpdw,jimpup,jimpdw\n   integer         :: iredup,ireddw,jredup,jreddw\n   integer         :: itrup,itrdw,jtrup,jtrdw\n   integer         :: nbig,nred,dimbig,dimred\n   !\n   nbig=norb*bignsites\n   nred=norb*rednsites\n   !\n   dimbig = 4**nbig\n   dimred = 4**nred\n   !\n   if(size(big_dm(:,1))/=dimbig)stop \"error: nsites is not consistent with the given big_dm\"\n   !\n   allocate(red_dm(dimred,dimred)); red_dm=0.d0\n   !\n   do iup = 1,2**nbig\n      do idw = 1,2**nbig\n           i = iup + (idw-1)*2**nbig\n           iimpup = iup-1\n           iimpdw = idw-1\n           iredup = ibits(iimpup,0,nred)\n           ireddw = ibits(iimpdw,0,nred)\n           itrup  = ibits(iimpup,nred,nbig)\n           itrdw  = ibits(iimpdw,nred,nbig)\n           do jup = 1,2**nbig\n              do jdw = 1,2**nbig\n                    j = jup + (jdw-1)*2**nbig\n                    jimpup = jup-1\n                    jimpdw = jdw-1\n                    jredup = ibits(jimpup,0,nred)\n                    jreddw = ibits(jimpdw,0,nred)\n                    jtrup  = ibits(jimpup,nred,nbig)\n                    jtrdw  = ibits(jimpdw,nred,nbig)\n                    if(jtrup/=itrup.or.jtrdw/=itrdw)cycle\n                    io = (iredup+1) + ireddw*2**nred\n                    jo = (jredup+1) + jreddw*2**nred\n                    red_dm(io,jo) = red_dm(io,jo) + big_dm(i,j)\n              enddo\n           enddo\n      enddo\n   enddo\n   !\n end subroutine subtrace\n"}, {"instruction": "Create a Fortran subroutine named \"pdeeigenvalues\" to calculate the eigenvalues of a partial differential equation (PDE) system. The subroutine takes 2 input parameters of type real and 1 output parameter of type real. The input parameters are \"lambda\" and \"q\" of unspecified length, and \"nv\" of length 3. The output parameter is \"lambda\" of unspecified length.", "input": "", "output": "recursive subroutine pdeeigenvalues(lambda,q,nv)\n  use iso_c_binding\n  implicit none\n  integer, parameter             :: nvar = 59                           ! the number of variables of the pde system \n  type, bind(c) :: tequations\n      real(8)    :: ccz4e=0.1, ccz4ds=0.11, ccz4glmc = 0.75, ccz4glmd = 0.75 \n  end type tequations\n  type(tequations) :: eqn\n  real :: lambda(nvar), nv(3), q(nvar), tempa, tempb\n  intent(in)  :: q,nv\n  intent(out) :: lambda \n  ! local variables \n  real :: lam, mu, irho, vpr(3), cs,c0,uu,alpha\n#if defined(ccz4einstein)  \n    alpha = max( 1.0, exp(q(17)) )*max( 1.0, exp(q(55)) )/min( sqrt(q(1)), sqrt(q(4)), sqrt(q(6)) )     \n#else\n    alpha = 1.0 \n#endif\n    tempa = alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha )\n    tempb = dot_product(q(18:20),nv(:))\n    lambda = 0.0 \n    lambda(1) = -tempa-tempb \n    lambda(2) =  tempa-tempb\n    !lambda(1) = -alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha ) - dot_product(q(18:20),nv(:))   ! max( sqrt(2.0), eqn%ccz4e, eqn%ccz4ds ) + sqrt(sum(q(18:20)**2)) \n    !lambda(2) = +alpha*max(sqrt(2.0), eqn%ccz4e, eqn%ccz4ds, eqn%ccz4glmc/alpha, eqn%ccz4glmd/alpha ) - dot_product(q(18:20),nv(:))   ! max( sqrt(2.0), eqn%ccz4e, eqn%ccz4ds ) + sqrt(sum(q(18:20)**2)) \n    !\nend subroutine pdeeigenvalues\n"}, {"instruction": "Create a Fortran subroutine named set_real to convert a generic input argument to a real output argument. The subroutine takes 1 input parameter of type class(*) and 1 output parameter of type real. Ensure that the input argument is of real type, and if not, stop with an error message.", "input": "", "output": "subroutine set_real(x,y)\r\nclass(*), intent(in)  :: x\r\nreal    , intent(out) :: y\r\nselect type(x)\r\n   type is (real)\r\n      y = x\r\n   class default\r\n      error stop \"need x real in set_real, stopping\"\r\nend select\r\nend subroutine set_real\r\n"}, {"instruction": "Write a Fortran subroutine named random_uniform that generates a random number in the range specified by the input arguments. The number of input arguments is 2 and the test_data type is ['double precision ', 'double precision ']. The number of output arguments is 1 and the test_data type is ['double precision '].", "input": "", "output": "  subroutine random_uniform (a, b, x)\n    double precision , intent(in) :: a, b\n    double precision , intent(out) :: x\n    double precision :: r\n\n    call random_number(r)\n\n    x = (1 - r)*(b - a) + a\n\n  end subroutine random_uniform\n"}, {"instruction": "Create a Fortran subroutine named \"three\" that takes 3 real input parameters and 1 real output parameter. The input parameters are a, b, and c, while the output parameter is d. The subroutine computes the value of d as the result of the expression a divided by the difference between b and c. Ensure to use the \"intent(in)\" attribute for the input parameters and \"intent(out)\" for the output parameter in the subroutine.", "input": "", "output": "    subroutine three(a,b,c,d)\n    implicit none\n\t  real,intent(in) :: a,b,c\n\t  real,intent(out) :: d\n\t  \n\t  d = a/(b-c)\n\n    end subroutine three\n"}, {"instruction": "Create a Fortran subroutine named matrix_sym to perform matrix operations. It takes 5 input parameters: ni, nj, nq of type integer*4, mtlhs of type real*8, dimension(ni,nj), and rhs of type real*8, dimension(nq,ni). It returns 2 output parameters: mtsym of type real*8, dimension(nj,nj), and rhssym of type real*8, dimension(nq,nj). The subroutine calculates symmetric matrices and symmetric right-hand sides based on the input parameters.", "input": "", "output": "subroutine matrix_sym(ni, nj, nq, mtlhs, rhs, mtsym, rhssym)\n!\nimplicit none\n!\ninteger*4, intent(in)::ni, nj, nq\nreal*8, dimension(ni,nj), intent(in):: mtlhs\nreal*8, dimension(nq,ni),    intent(in):: rhs\nreal*8, dimension(nj,nj), intent(out):: mtsym\nreal*8, dimension(nq,nj),   intent(out):: rhssym\n\n!...local\n\ninteger:: im, jm,km, iq\n\n!...zero out\nmtsym  = 0.d0\nrhssym = 0.d0\n\n!...symmetry matrix\ndo im = 1, nj\ndo jm = 1, nj\ndo km = 1, ni\nmtsym(im, jm) = mtsym(im, jm) + mtlhs(km, im)*mtlhs(km, jm)\nenddo\nenddo\nenddo\n\n!...symmetry rhs\ndo iq = 1 ,nq\ndo im = 1, nj\ndo km = 1, ni\nrhssym(iq, im) = rhssym(iq, im) + mtlhs(km, im)*rhs(iq, km)\nenddo\nenddo\nenddo\n\nreturn\nend subroutine matrix_sym\n"}, {"instruction": "Create a Fortran subroutine named define_connect_tensor_2d to generate a 2D connectivity table for tensor-product order polynomial elements. The subroutine takes 4 input parameters of type integer: nex (number of elements in x direction), ney (number of elements in y direction), p (polynomial order of elements), ibc (boundary condition type). It also has 1 output parameter of type integer array which is allocatable: gn (global node number of the local nodes in each element).", "input": "", "output": "subroutine define_connect_tensor_2d(nex, ney, p, ibc, gn)\n! 2d connectivity table for tensor-product order p elements\ninteger, intent(in) :: nex, ney ! number of elements in x and y directions\ninteger, intent(in) :: p ! polynomial order of elements\n! boundary condition: 1 = neumann, 2 = dirichlet, 3 = periodic\ninteger, intent(in) :: ibc\n! gn(i, j, e) is the global node number of the local (i,j) node in e-th element\ninteger, allocatable, intent(out) :: gn(:, :, :)\ninteger :: nodes(nex*p+1, ney*p+1)\ninteger :: inode, ix, iy, iel, iex, iey\n! construct array of global nodes\n! 0 = no associated basis function as in e.g. dirichlet bcs\nnodes = 0\ninode = 0\ndo iy = 1, ney*p+1\n    do ix = 1, nex*p+1\n        if (ibc >= 2 .and. (ix == 1 .or. ix == nex*p+1 .or. &\n                            iy == 1 .or. iy == ney*p+1)) cycle\n        inode = inode + 1\n        nodes(ix, iy) = inode\n    end do\nend do\nif (ibc == 3) then\n    ! now we need to connect the basis functions on the opposite sites of the\n    ! boundary.\n    ! top-bottom sides\n    do ix = 2, nex*p\n        inode = inode + 1\n        nodes(ix, 1)       = inode\n        nodes(ix, ney*p+1) = inode\n    end do\n    ! left-right sides\n    do iy = 2, ney*p\n        inode = inode + 1\n        nodes(1, iy)       = inode\n        nodes(nex*p+1, iy) = inode\n    end do\n    ! corners\n    inode = inode + 1\n    nodes(1, 1)             = inode\n    nodes(1, ney*p+1)       = inode\n    nodes(nex*p+1, 1)       = inode\n    nodes(nex*p+1, ney*p+1) = inode\nend if\n! construct connectivity table of global nodes in each element\nallocate(gn(p+1, p+1, nex*ney))\niel = 0\ndo iex = 1, nex\n    do iey = 1, ney\n        iel = iel + 1 ! element number\n        ix = (iex-1)*p+1 ! lower left corner\n        iy = (iey-1)*p+1\n        ! get global node numbers in element\n        gn(:, :, iel) = nodes(ix:ix+p, iy:iy+p)\n    end do\nend do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named fib to calculate the first n Fibonacci numbers. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['real']. Use the imperative tone in the instruction.", "input": "", "output": "pure subroutine fib(n, a)\n!! calculate first n fibonacci numbers\ninteger, intent(in) :: n\nreal, intent(out) :: a(n)\n\ninteger :: i\n\na(:2) = [0, 1]\n\ndo i = 3,n\n  a(i) = a(i-1) + a(i-2)\nenddo\n\nend subroutine fib\n"}, {"instruction": "Create a Fortran subroutine named get_element_by_charge to retrieve the chemical element symbol based on the input charge. The subroutine takes 1 input parameter of type integer, and returns 1 output parameter of type character (len=*).", "input": "", "output": "subroutine get_element_by_charge(charge, ostr)\n\timplicit none\n!\n\tinteger, intent(in) :: charge\n\tcharacter (len=*), intent(out) :: ostr\n\tinteger :: pos1, pos2, i\n\tcharacter (len=1000) :: elements = &\n\t\t\"h:he:li:be:b:c:n:o:f:ne:na:mg:al:si:p:s:cl:ar:\" // &\n\t\t\"k:ca:sc:ti:v:cr:mn:fe:co:ni:cu:zn:ga:ge:as:se:br:kr:\" // &\n\t\t\"rb:sr:y:zr:nb:mo:tc:ru:rh:pd:ag:cd:in:sn:sb:te:i:xe:\" // &\n\t\t\"cs:ba:la:ce:pr:nd:pm:sm:eu:gd:tb:dy:ho:er:tm:yb:lu:\"  // &\n\t\t\"hf:ta:w:re:os:ir:pt:au:hg:tl:pb:bi:po:at:rn:fr:ra:\"   // &\n\t\t\"ac:th:pa:u:np:pu:am:cm:bk:cf:es:fm:md:no:lr:\"         // &\n\t\t\"rf:db:sg:bh:hs:mt:ds:rg:cn:nh:fl:mc:lv:ts:og:xx\"\n!\n\ti = 0\n\tpos1 = 1\n\tostr = 'xx'\n\t\n\tif ( charge .eq. 0 ) then\n\t\treturn\n\tend if\n\t\n\tdo i = 1, 119\n\t\tpos2 = index(elements(pos1:), \":\")\n\t\tif ( pos2 .ne. 0 ) then\n\t\t\tostr = trim(adjustl(elements(pos1:pos1+pos2-2)))\n\t\t\tif ( i .eq. charge ) then\n\t\t\t\texit\n\t\t\tend if\n\t\t\tpos1 = pos1 + pos2 \n\t\telse\n\t\t\texit\n\t\tend if\n\tend do\n\t\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named hello_fortran that takes an integer and a real number as input arguments, and returns the sum of the two numbers as a real number. The input arguments are of type integer and real, and the output argument is of type real. Within the subroutine, it should display a message containing the received integer and real numbers, and then calculate the sum.", "input": "", "output": "subroutine hello_fortran(number, real_number, total_number)\n  implicit none\n  integer, intent(in)  :: number !input\n  real, intent(in) :: real_number !input\n  real, intent(out) :: total_number ! output\n\n  write(*,*) \"hello from fortran\"\n  write(*,*) \"you gave me the integer: \", number\n  write(*,*) \"you gave me the float: \", real_number\n\n  total_number = number + real_number\n\nend subroutine hello_fortran\n"}, {"instruction": "Create a Fortran subroutine named component2index_band to calculate the index corresponding to a set of four components in a four-dimensional array. The subroutine takes 5 input parameters of type integer (nbands, b1, b2, b3, b4) and returns 1 output parameter of type integer (ind).", "input": "", "output": "subroutine component2index_band(nbands, ind, b1, b2, b3, b4)\n  implicit none\n  integer,intent(in)  :: nbands\n  integer,intent(in)  :: b1, b2, b3, b4\n  integer,intent(out) :: ind\n\n  ind =  nbands**3*(b1-1) + nbands**2*(b2-1) + nbands*(b3-1) + b4\n\nend subroutine component2index_band\n"}, {"instruction": "Write a Fortran subroutine named index2component_band to convert an index to a set of four components. The subroutine takes 2 input parameters of type integer and returns 4 output parameters of type integer.", "input": "", "output": "subroutine index2component_band(nbands, ind, b1, b2, b3, b4)\n  implicit none\n  integer,intent(in)  :: nbands,ind\n  integer,intent(out) :: b1, b2, b3, b4\n  integer             :: tmp1, tmp2, tmp3, ind_tmp\n  integer             :: g1, g2, g3, g4\n\n  ! the proposed back conversion assumes the indices are\n  ! given form 0 to max-1\n  ind_tmp = ind - 1\n  tmp1 = nbands**3\n  tmp2 = nbands**2\n  tmp3 = nbands\n\n  b1 = ind_tmp/tmp1 + 1\n  b2 = (ind_tmp-tmp1*(b1-1))/tmp2 + 1\n  b3 = (ind_tmp-tmp1*(b1-1)-tmp2*(b2-1))/tmp3 + 1\n  b4 = (ind_tmp-tmp1*(b1-1)-tmp2*(b2-1)-tmp3*(b3-1)) + 1\n\nend subroutine index2component_band\n"}, {"instruction": "Write a Fortran subroutine named \"d_getsettings\" that takes an integer input parameter and returns four integer output parameters. The purpose of this subroutine is to determine the values of \"m\", \"k\", \"we\", and \"ws\" based on the value of the input parameter \"n\". \n\nThe subroutine uses an if-else statement to assign values to the output parameters according to specific conditions. If \"n\" is less than the value of \"ssth\", all output parameters are set to 1. If \"n\" is less than 150, the output parameters are set to specific values. Similar rules apply for different ranges of \"n\" values, with different values assigned to the output parameters.\n\nMake sure to declare the input parameter \"n\" as an integer and the output parameters \"m\", \"k\", \"we\", and \"ws\" as integers with the \"intent(in/out)\" attribute to specify their usage.", "input": "", "output": "  subroutine d_getsettings(n,m,k,we,ws)\n    integer, intent(in)             ::  n\n    integer, intent(out)            ::  m, k, we, ws\n\n    if (n .lt. ssth) then\n      k = 1\n      m = 1\n      we = 1\n      ws = 1\n    elseif (n .lt. 150) then\n      k = 4\n      m = 4\n      we = 6\n      ws = 4\n    elseif (n .lt. 250) then\n      k = 8\n      m = 8\n      we = 10\n      ws = 4\n    elseif (n .lt. 501) then\n      k = 16\n      m = 16\n      we = 18\n      ws = 6\n    elseif (n .lt. 1001) then\n      k = 32\n      m = 32\n      we = 34\n      ws = 10\n    elseif (n .lt. 3000) then\n      k = 64\n      m = 64\n      we = 66\n      ws = 16\n    elseif (n .lt. 6000) then\n      k = 128\n      m = 128\n      we = 130\n      ws = 32\n    else\n      k = 256\n      m = 256\n      we = 266\n      ws = 48\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named forward_euler to perform the forward Euler method for numerical integration. The subroutine takes three parameters as input: time_step (real(8)), n (integer), and vec (real(8), dimension(:)). The subroutine computes the values of vec using the forward Euler method and stores the results in vec. The number of input arguments is 2 and the test_data type is ['real(8)', 'integer']. The number of output arguments is 1 and the test_data type is ['real(8), dimension(:)'].", "input": "", "output": "    subroutine forward_euler(time_step, n, vec)\n        \n        implicit none\n        real(8), dimension(:), intent(out)   :: vec\n        real(8), intent(in)                  :: time_step\n        integer, intent(in)                  :: n\n        integer                              :: i\n\n        vec(1) = 1d0\n\n        do i=1, n-1\n        \n            vec(i+1) = vec(i) - 3d0 * vec(i) * time_step\n\n        end do\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine called open_file that takes a filename as input and returns an integer value. The filename should be of type character and have a length of 1024. The subroutine opens the file specified by the filename in \"old\" mode, with unformatted data and read access. The subroutine also checks for any errors that occur during the file opening process. If an error occurs, the subroutine will display an error message and stop the program execution.", "input": "", "output": "subroutine open_file(filename, unt)\n    implicit none\n    character(len=1024), intent(in) :: filename\n    integer, intent(out) :: unt\n    integer :: iost\n    open(unit=unt, file=trim(filename), status='old', form='unformatted', &\n         action='read', iostat=iost)\n    if (iost /= 0) then\n        write(*,*) \"open_file: error when opening file: '\", trim(filename), &\n                   \"' with iostat=\", iost\n        stop 1\n    end if\nend subroutine open_file\n"}, {"instruction": "Write a Fortran subroutine named stdheight_ml that calculates the standard atmospheric height at multiple levels. The subroutine takes 8 input parameters: an integer (nk), three arrays of double precision (p, t, td) with dimension nk, and four double precision values (ps, ts, tds, hin). It also has two output parameters: an array of double precision (h) with dimension nk and a single double precision value (hs).\n\nIn the subroutine, virtual temperatures are calculated at each level using the input temperature and dew point temperature. The height is then computed using the hyposometric equation, which relates temperature, pressure, and height. The calculations are performed for multiple levels, including a surface level.\n\nTo use the subroutine, provide the necessary input values and allocate the required memory for the output arrays. After calling the subroutine, the resulting heights will be stored in the array h, and the surface height will be stored in hs.\n\nMake sure to provide the correct data types and dimensions when using the subroutine.", "input": "", "output": "      subroutine stdheight_ml(p,t,td,ps,ts,tds,hin,nk,h,hs)\n      !f2py threadsafe\n      !f2py intent(out) :: h\n\n      implicit none\n      integer, intent(in) :: nk\n      integer :: k, nk_all, k_all\n      double precision, dimension(nk), intent(in) :: p,t,td\n      double precision, intent(in) :: ps,ts,tds\n      double precision, dimension(nk) :: tv\n      double precision :: tvs\n      double precision :: tin,tdin,e,w\n      double precision, intent(in) :: hin\n      double precision, dimension(nk), intent(out) :: h\n      double precision, intent(out) :: hs\n\n      double precision, parameter :: r=287.04\n      double precision, parameter :: g=-9.80665\n      !integer, parameter :: n = 10\n      double precision, parameter :: eps = 0.6219800858985514\n      !parameter (r=287.04,g=-9.80665)\n      !calculate virtual temperatures at the two levels and the mean of these two values.\n      !calculate height using the hyposometric equation  rdtvmean/g (ln(p1/p2)) = z2-z1\n\n      ! number of levels 3d + surface\n      nk_all = nk + 1\n\n      ! if surface level, use surface temperature\n      tin=ts+273.15\n      !w calculation starting from dewpoint\n      tdin = tds+273.15\n      !e = 6.112*exp((17.67*(tdin-273.15))/(tdin-29.65))\n      e = 6.112*exp((53.49-(6808/tdin)-5.09*log(tdin)))\n      w = eps*(e/(ps-e))\n      !alt w calculation starting from specific humidity\n      ! w = (qs/1000)/(1-(qs/1000))\n      !now calculate tv correctly:\n      tvs = tin*((w+eps)/(eps*(1+w)))\n      !old incorect tv\n      !tvs=tin/(1-0.379*(6.11*10*((7.5*tds)/ &\n      !(237.7+tds))/ps))\n      ! loop along vertical levels 3d = nk\n      do k = 1, nk\n        tin=t(k)+273.15\n        !calculate w for each layer\n        tdin = td(k)+273.15\n        ! e = 6.112*exp((17.67*(tdin-273.15))/(tdin-29.65))\n        e = 6.112*exp((53.49-(6808/tdin)-5.09*log(tdin)))\n\n        w=eps*(e/(p(k)-e))\n        !alt calc w each layer\n        ! w= (qs/1000)/(1-(qs/1000))\n        !calculate virtual temperatures for a surface + 3d element\n        tv(k) = tin*((w+eps)/(eps*(1+w)))\n        !incorrect old method\n        !tv(k)=tin/(1-0.379*(6.11*10*((7.5*td(k))/ &\n        !(237.7+td(k)))/p(k)))\n      enddo\n        !now integrate along the hypsometric equation\n\n      do k_all = 1, nk_all\n        k = k_all-1\n        ! for surface height, that is actually equal to hin (either topography or 2m)\n        if (k_all .eq. 1) then\n          hs=hin\n        elseif (k_all .eq. 2) then\n          ! for k = 2 it uses hs and tvs for the layer below\n          ! variables from 3d use k_all-1 as index\n          ! m = (tv(k)-tvs)/(log(p(k))-log(ps))\n          ! b = tvs-m*log(ps)\n          ! call trapz(m*x+b,log(ps),log(p(k)),tvp,n)\n          ! h(k)=hs-((r/g)*tvp)\n          ! original implementation assuming mean value theorem\n          h(k)=hs+((r*((tv(k)+tvs)/2)/g))*(log(p(k)/ps))\n        else\n          ! for k >= 3 it uses only 3d variables\n          ! variables from 3d use k-1 as index\n          ! m = (tv(k)-tv(k-1))/(log(p(k))-log(p(k-1)))\n          ! b = tv(k)-m*log(p(k))\n          ! call trapz(tv,log(p(k-1)),log(p(k)),tvp,n)\n          ! h(k) = h(k-1)+((r/g)*tvp)\n          h(k)=h(k-1)+((r*((tv(k)+tv(k-1))/2)/g))*(log(p(k)/p(k-1)))\n        endif\n      enddo\n\n      return\n      end subroutine stdheight_ml\n"}, {"instruction": "Provide a Fortran subroutine code named \"filesize\" that calculates the size of a file given its name. The subroutine takes one input parameter of type \"character(*)\" to represent the file name. It also has one output parameter of type \"integer\" to store the file size. \n\nThe subroutine uses the \"stat\" function to obtain the file size and returns -1 if there is an error. The subroutine also includes necessary declarations and checks the status of the \"stat\" function. \n\nMake sure to update the calling routines that use the file unit instead of the file name.", "input": "", "output": "   subroutine filesize ( filename, size )\n\n\n      ! this routine calls the routine stat to obtain the file size\n      ! corresponding to a file name or returns -1 on error.\n\n      ! mlb: warning!!!\n      ! the standard version of the routine uses the file unit instead of file name.\n      ! we need fix the routines that call this one.\n\n\n      ! argument declarations:\n\n   integer, intent(out)         :: size\n\n   character(*), intent(in)     :: filename\n\n\n      ! intrinsic declarations:\n\n   integer(kind=1)              :: stat\n\n\n      ! local declarations:\n\n   integer                      :: statarray(12)\n   integer                      :: status\n\n\n\n   status = stat( filename, statarray )\n\n   if ( status /= 0 ) then\n     size = -1\n   else\n     size = statarray(8)\n   end if\n\n\n   return\n   end subroutine filesize ! ( filename, size )\n"}, {"instruction": "Write a Fortran subroutine named findline that searches for a line of text within a given string. The subroutine takes 2 input parameters: an integer representing the maximum length of the string and a character string to search. It also has 1 output parameter: an integer indicating the location of the end of the string. The subroutine tries to break the line at a blank space, ensuring that the line length does not exceed the maximum length provided. The subroutine is not system-specific but is intended to be called by another subroutine called wrscr().", "input": "", "output": "   subroutine findline ( str , maxlen , strend )\n\n\n      ! this routine finds one line of text with a maximum length of maxlen from the str.\n      ! it tries to break the line at a blank.\n\n      ! this routine isn't system specific, but it is called by wrscr(), which is, so it must be here.\n\n\n   implicit                        none\n\n\n      ! argument declarations:\n\n   integer, intent(in)          :: maxlen                                       ! the maximum length of the string.\n   integer, intent(out)         :: strend                                       ! the location of the end of the string.\n\n   character(*), intent(in)     :: str                                          ! the string to search.\n\n\n      ! local declarations:\n\n   integer         ic\n\n\n\n   strend = maxlen\n\n   if ( len_trim( str ) > maxlen )  then\n\n      ic = index( str(1:maxlen), ' ', back = .true. ) ! find the last space in the line\n\n      if ( ic > 1 ) then ! we don't want to return just one character that's a space, or do we?\n\n         strend = ic-1    ! strend > 0\n         do while ( str(strend:strend) == ' ' )\n            strend = strend - 1\n            if ( strend <= 0 ) then  ! this occurs if everything before ic is a space\n               strend = ic\n               exit\n            endif\n         enddo\n\n      endif ! ic > 1\n\n   endif ! len_trim( str ) > maxlen\n\n\n   return\n   end subroutine findline ! ( str , maxlen , strend )\n"}, {"instruction": "Write a Fortran subroutine named get_command_argument that retrieves the value of a command-line argument based on its position. The subroutine takes 1 input parameter of type integer, which represents the desired argument number. It also has 3 output parameters: an optional integer parameter named length, which returns the length of the argument value, an optional integer parameter named status, which indicates the status of the subroutine, and an optional character parameter named value, which stores the value of the command-line argument.\n\nTo use the subroutine, call it with the desired argument number and provide the optional parameters to retrieve the corresponding values. The length parameter will return the length of the argument value, the status parameter will provide information about the success of the subroutine, and the value parameter will store the value of the command-line argument.\n\nNote that the maximum length permitted for an argument value is set to 500 characters.", "input": "", "output": "   subroutine get_command_argument ( number, value, length, status )\n\n\n      ! this routine returns the string associated with the numberth command-line argument.\n      ! it tries as best it can to mimic the fortran 2000 intrinsic function by the same name.\n\n\n      ! argument declarations.\n\n   integer, optional, intent(out)      :: length                                ! the length of the value of the environment variable.\n   integer, intent(in)                 :: number                                ! the number of the argument desired.\n   integer, optional, intent(out)      :: status                                ! the status indication what happened.\n\n   character(*), optional, intent(out) :: value                                 ! the command line argument.\n\n\n      ! local parameter declarations.\n\n   integer, parameter                  :: maxlen = 500                          ! the maximum length permitted for an environment variable value.\n\n\n      ! local declarations.\n\n   integer                             :: callstat                              ! the status of the intrinsic call.\n\n   character(maxlen)                   :: returnval                             ! the value that will be returned.\n\n\n\n      ! get the argument.\n\n   call getarg ( number, returnval )  !20110512 jm remove 3rd arg for linux port\n\n\n      ! load up the return values.\n\n   if ( present( value  ) )  value  = returnval\n   if ( present( length ) )  length = len_trim( returnval )\n   if ( present( status ) )  status = callstat\n\n\n   return\n   end subroutine get_command_argument ! ( number, value, length, status )\n"}, {"instruction": "Create a Fortran subroutine named ecmat to calculate the element-wise matrix multiplication. The subroutine takes 3 input parameters of type real(iwp), integer, and integer, and 1 output parameter of type real(iwp).", "input": "", "output": "subroutine ecmat(ecm,fun,ndof,nodof)\r\n!\r\n\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::fun(:)\r\n real(iwp),intent(out)::ecm(:,:)\r\n integer,intent(in)::nodof,ndof\r\n integer::nod,i,j\r\n real::nt(ndof,nodof),tn(nodof,ndof),zero=0.0_iwp\r\n nod=ndof/nodof\r\n nt=zero\r\n tn=zero\r\n do i=1,nod \r\n   do j=1,nodof\r\n     nt((i-1)*nodof+j,j)=fun(i)\r\n     tn(j,(i-1)*nodof+j)=fun(i)\r\n   end do\r\n end do\r\n ecm=matmul(nt,tn)\r\nreturn\r\nend subroutine ecmat\r\n"}, {"instruction": "Create a Fortran subroutine named getwords that takes 2 input parameters of type integer and character array and 1 output parameter of type character array. The subroutine extracts words from the given string based on spaces, tabs, commas, semicolons, single quotes, and double quotes.", "input": "", "output": "subroutine getwords ( line, words, numwords )\n\n    ! argument declarations.\n\n    integer, intent(in)          :: numwords                                     !< the number of words to look for.\n\n    character(*), intent(in)     :: line                                         !< the string to search.\n    character(*), intent(out)    :: words(numwords)                              !< the array of found words.\n\n\n        ! local declarations.\n\n    integer                      :: ch                                           ! character position within the string.\n    integer                      :: iw                                           ! word index.\n    integer                      :: nextwhite                                    ! the location of the next whitespace in the string.\n    character(1), parameter       :: tab      = char( 9 ) \n\n\n\n        ! let's prefill the array with blanks.\n\n    do iw=1,numwords\n        words(iw) = ' '\n    end do ! iw\n\n\n        ! let's make sure we have text on this line.\n\n    if ( len_trim( line ) == 0 )  return\n\n\n        ! parse words separated by any combination of spaces, tabs, commas,\n        ! semicolons, single quotes, and double quotes (\"whitespace\").\n\n    ch = 0\n    iw = 0\n\n    do\n\n        nextwhite = scan( line(ch+1:) , ' ,!;''\"'//tab )\n\n        if ( nextwhite > 1 )  then\n\n        iw        = iw + 1\n        words(iw) = line(ch+1:ch+nextwhite-1)\n\n        if ( iw == numwords )  exit\n\n        ch = ch + nextwhite\n\n        else if ( nextwhite == 1 )  then\n\n        ch = ch + 1\n\n        cycle\n\n        else\n\n        exit\n\n        end if\n\n    end do\n\n\n    return\nend subroutine getwords\n"}, {"instruction": "Create a Fortran subroutine named create_variable_mask to generate a logical mask based on a specified value in the input data. The subroutine takes 2 input parameters of type real, dimension(:,:,:), and real, and 1 output parameter of type logical, dimension(:,:), allocatable.", "input": "", "output": "    subroutine create_variable_mask(mask, input_data, mask_value)\n        implicit none\n        logical, dimension(:,:),   intent(out), allocatable  :: mask\n        real,    dimension(:,:,:), intent(in) :: input_data\n        real,                      intent(in) :: mask_value\n\n        integer :: nx, ny\n\n        nx = size(input_data, 2)\n        ny = size(input_data, 3)\n\n        allocate(mask(nx,ny))\n        mask = .true.\n        where(input_data(1,:,:) == mask_value) mask = .false.\n\n    end subroutine create_variable_mask\n"}, {"instruction": "Write a Fortran subroutine named laplace2_ext to perform the Laplacian operation on a 2D array. The subroutine takes one input parameter of type real and produces one output parameter of type real. The subroutine extends the boundary values from the inner region of the input array.", "input": "", "output": "subroutine laplace2_ext(b, a)  ! perform laplacian, then the boundary values are extended out from the inner\nreal,      intent(out) :: b(:,:)\nreal,      intent(in)  :: a(:,:)  ! same size\ninteger    :: nx, nz, ix, iz\nnx = size(a,1)\nnz = size(a,2)\n!$omp parallel do private(ix)   \ndo iz = 2, nz-1\n  do ix = 2, nx-1\n    b(ix,iz) = a(ix-1,iz) + a(ix+1,iz) + a(ix,iz-1) + a(ix,iz+1) - 4.*a(ix,iz)\n  end do\n  b(1, iz) = b(2,   iz)\n  b(nx,iz) = b(nx-1,iz)\nend do\nb(:,1) = b(:,   2)\nb(:,nz)= b(:,nz-1)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named cumsum2d to compute the cumulative sum of a 2D array along a specified dimension. The subroutine takes 2 input parameters: a real array \"a\" and an optional integer \"kdim\" indicating the dimension along which the cumulative sum will be computed. It has 1 output parameter, a real array \"b\" which stores the cumulative sum. The subroutine uses imperative programming to calculate the cumulative sum based on the specified dimension.", "input": "", "output": "subroutine cumsum2d(b,a,kdim)\n! b <--cumulative sum a, along dimension kdim\nreal, intent(out) :: b(:,:)  ! same size as a, space pre-assigned\nreal, intent(in)  :: a(:,:)\ninteger, optional, intent(in) :: kdim ! default 1\ninteger  :: d, j,k, shp(2)\n\nd  = 1;  if(present(kdim))  d = kdim\nshp= shape(a)\n\nif (d==1) then\n  do k = 1, shp(2)\n    b(1,k) = a(1,k)\n    do j=2, shp(1)\n      b(j,k) = b(j-1,k) + a(j,k)\n    end do\n  end do\nelse\n b(:,1) = a(:,1)\n do k = 2, shp(2)\n   b(:,k) = b(:,k-1) + a(:,k)\n end do\nend if\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"binnedseriesnums\" that takes in an integer array \"s\" and an integer \"wintv\" as input and calculates the number of elements falling in each interval and the cumulative sum of the counts. The number of input arguments is 2, and the test_data type is ['integer', 'integer']. The number of output arguments is 2, with test_data type ['integer', 'integer, optional'].", "input": "", "output": "subroutine binnedseriesnums(s, wintv, nss, cmsm0)\n! s is a series\n! intervals are [1, wintv] [1+wintv, 2*wintv] [1+2*wintv, 3*wintv], ...\n! find how many series elements fall in each interval --> nss\n! cumulative sum of 'nss' starting @ 0                --> cmsm0.  \n!   is the displacement of each interval's stored s's relative to the beginning\ninteger, intent(in)  :: s(:), wintv\ninteger, intent(out) :: nss(:)       ! make sure enough length\ninteger, intent(out),   optional ::  cmsm0(:)  \ninteger  :: k, i, l\nl    = size(s)\nnss  = 0  ! init.\ndo k = 1, l\n  i  = (s(k)-1)/wintv + 1  ! find interval index\n  nss(i) = nss(i) + 1\nenddo\nif (present(cmsm0)) then\n  l = size(nss)\n  cmsm0(1) = 0\n  if (l < 2) return\n  cmsm0(2) = nss(1)\n  do k = 3, l\n    cmsm0(k) = cmsm0(k-1) + nss(k-1)\n  enddo\nendif\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named stripsmallprimefactors to factorize a given integer into its smallest prime factors and a remaining prime number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "subroutine stripsmallprimefactors(a, c, b)\n! a = c b, where c = 2^m 3^n 5^o 7^p, b is a prime number > 7\ninteger, intent(in)  :: a\ninteger, intent(out) :: c, b\ninteger  :: prm(4) = (/2,3,5,7/), i, p\nc = 1;  b = a\nouter: do i = 1, 4  ! go through the 4 smallest prime numbers\n  p = prm(i)\n  inner: do\n    if ( (b/p)*p == b ) then\n      b = b/p;  c = c*p\n    else\n      exit inner\n    endif\n  enddo inner \nenddo outer\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named find_indices that takes in an array of logical values and returns the indices of the true elements. The number of input parameters is 1 with the test_data type ['logical'], and the number of output parameters is 2 with the test_data type ['integer', 'integer'].", "input": "", "output": "subroutine find_indices(ind, nfound, crit)\n  integer, intent(out) :: ind(:),  nfound   ! nfound limited by size(ind)\n  logical, intent(in)  :: crit(:)\n  \n  integer  :: nind, k\n  nind = size(ind)\n  nfound = 0\n  do k = 1, size(crit)  ! prefer head\n    if(.not. crit(k)) cycle\n    nfound = nfound + 1\n    ind(nfound) = k\n    if (nfound==nind) exit\n  end do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named grid_location that takes an integer input parameter and returns two integer output parameters. The input parameter represents a position in a grid, and the subroutine calculates the corresponding row (ix) and column (iy) indices of the grid.", "input": "", "output": "  subroutine grid_location(k,ix,iy)\r\n  integer, intent(in)  :: k\r\n  integer, intent(out) :: ix,iy\r\n  !\r\n  if(mod(k,ny)==0) then !right edge\r\n    ix=k/ny\r\n    iy=ny\r\n  else !general case\r\n    ix=k/ny+1\r\n    iy=k-(ix-1)*ny\r\n  endif\r\n  end subroutine grid_location\r\n"}, {"instruction": "Create a Fortran subroutine named vector_product to compute the vector product of two 3-dimensional vectors. It takes 2 input parameters of type real arrays, v1 and v2, and 1 output parameter of type real array, vp.", "input": "", "output": "subroutine vector_product(v1,v2,vp)\n\nimplicit none\n\n! passed variables\nreal,intent(in) :: v1(3)  !< first vector\nreal,intent(in) :: v2(3)  !< second vector\nreal,intent(out) :: vp(3) !< vector product\n\n! local variable\nreal :: r\n\n! vector product\nvp(1) = v1(2)*v2(3)-v1(3)*v2(2)\nvp(2) = v1(3)*v2(1)-v1(1)*v2(3)\nvp(3) = v1(1)*v2(2)-v1(2)*v2(1)\n\n! normalization\nr = sqrt(sum(vp**2))\nif (r>0.0) vp = vp/r\n\nend subroutine vector_product\n"}, {"instruction": "Write a Fortran subroutine named elmat to calculate the elasticity matrix for quadrilateral 4- or 8-node plane strain elements. The subroutine takes 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp) array.", "input": "", "output": "subroutine elmat(area,rho,emm)\r\n!\r\n\n! quadrilateral 4- or 8-node plane strain elements.\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::area,rho  \r\n real(iwp),intent(out)::emm(:,:)\r\n real(iwp)::zero=0.0_iwp,pt2=0.2_iwp,pt25=0.25_iwp\r\n integer::i,ndof\r\n ndof=ubound(emm,1)\r\n emm=zero\r\n select case(ndof)\r\n case(8) \r\n   do i=1,8\r\n     emm(i,i)=pt25*area*rho\r\n   end do\r\n case(16)\r\n   do i=1,16\r\n     emm(i,i)=pt2*area*rho\r\n   end do\r\n   do i=1,13,4\r\n     emm(i,i)=pt25*emm(3,3)\r\n   end do\r\n   do i=2,14,4\r\n     emm(i,i)=pt25*emm(3,3)\r\n   end do                     \r\n case default\r\n   write(*,*)\"wrong number of nodes for rectangular element\"\r\n end select\r\nreturn\r\nend subroutine elmat   \r\n"}, {"instruction": "Create a Fortran subroutine named f_interp1d that takes 6 input parameters: 2 integers, 3 arrays of real(kind=8) with dimensions nz_in, and 1 real(kind=8). The output parameter is an array of real(kind=8) with dimension nz_out. The subroutine calculates the interpolation of values from one vertical coordinate to another and returns the interpolated values in V_out.", "input": "", "output": "subroutine f_interp1d(v_in,z_in,z_out,vmsg,v_out,nz_in,nz_out)\n\n    implicit none\n\n    integer,intent(in) :: nz_in, nz_out\n    real(kind=8),dimension(nz_in),intent(in) :: v_in,z_in\n    real(kind=8),dimension(nz_out),intent(in) :: z_out\n    real(kind=8),dimension(nz_out),intent(out) :: v_out\n    real(kind=8),intent(in) :: vmsg\n\n    integer :: kp,k,im,ip\n    logical :: interp\n    real(kind=8) :: height,w1,w2\n\n    ! does vertical coordinate increase of decrease with increasing k?\n    ! set offset appropriately\n\n    ip = 0\n    im = 1\n    if (z_in(1).gt.z_in(nz_in)) then\n      ip = 1\n      im = 0\n    end if\n\n    do k = 1,nz_out\n      v_out(k) = vmsg\n\n      interp = .false.\n      kp = nz_in\n      height = z_out(k)\n\n      do while ((.not.interp) .and. (kp.ge.2))\n          if (((z_in(kp-im).le.height).and.(z_in(kp-ip).gt.height))) then\n              w2 = (height-z_in(kp-im))/(z_in(kp-ip)-z_in(kp-im))\n              w1 = 1.d0 - w2\n              v_out(k) = w1*v_in(kp-im) + w2*v_in(kp-ip)\n              interp = .true.\n          end if\n          kp = kp - 1\n      end do\n    end do\n\n    return\n\nend subroutine f_interp1d\n"}, {"instruction": "Create a Fortran subroutine named f_computetk to calculate the temperature in Kelvin. The subroutine takes 3 input parameters: an integer nx, an array of real(kind=8) values for pressure with dimension nx, and an array of real(kind=8) values for theta with dimension nx. It returns an array of real(kind=8) values for tk with dimension nx.", "input": "", "output": "subroutine f_computetk(pressure,theta,tk,nx)\n\n    implicit none\n\n    integer, intent(in) :: nx\n    real(kind=8) :: pi\n    real(kind=8), dimension(nx), intent(in) :: pressure\n    real(kind=8), dimension(nx), intent(in) :: theta\n    real(kind=8), dimension(nx), intent(out) :: tk\n\n    integer :: i\n    real(kind=8), parameter :: p1000mb=100000.d0, r_d=287.d0, cp=7.d0*r_d/2.d0\n\n    do i = 1,nx\n        pi = (pressure(i)/p1000mb)**(r_d/cp)\n        tk(i) = pi*theta(i)\n    end do\n\n    return\n\nend subroutine f_computetk\n"}, {"instruction": "Write a Fortran subroutine named f_computetd to calculate the dew point temperature from the input pressure and specific humidity. The subroutine takes 3 input parameters of type integer, real(kind=8) arrays of dimension nx, and returns 1 output parameter of type real(kind=8) array of dimension nx. The subroutine uses an iterative calculation to compute the dew point temperature based on the input pressure and specific humidity values.", "input": "", "output": "subroutine f_computetd(pressure,qv_in,td,nx)\n\n    implicit none\n\n    integer, intent(in) :: nx\n    real(kind=8),dimension(nx),intent(in) :: pressure\n    real(kind=8),dimension(nx),intent(in) :: qv_in\n    real(kind=8),dimension(nx),intent(out) :: td\n\n    real(kind=8) :: qv,tdc\n\n    integer :: i\n\n    do i = 1,nx\n      qv = dmax1(qv_in(i),0.d0)\n      ! vapor pressure\n      tdc = qv*pressure(i)/ (.622d0 + qv)\n\n      ! avoid problems near zero\n      tdc = dmax1(tdc,0.001d0)\n      td(i) = (243.5d0*log(tdc)-440.8d0)/ (19.48d0-log(tdc))\n    end do\n\n    return\n\nend subroutine f_computetd\n"}, {"instruction": "Create a Fortran subroutine named f_computeeth to calculate the equivalent potential temperature for atmospheric data. The subroutine takes 6 input parameters of type real(kind=8), dimension(miy,mjx,mkzh), real(kind=8), dimension(miy,mjx,mkzh), real(kind=8), dimension(miy,mjx,mkzh), integer, integer, and integer. It also has 1 output parameter of type real(kind=8), dimension(miy,mjx,mkzh).", "input": "", "output": "subroutine f_computeeth(qvp,tmk,prs,eth,miy,mjx,mkzh)\n\n    implicit none\n\n    ! input variables\n    ! qvapor [g/kg]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: qvp\n    ! temperature [k]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: tmk\n    ! full pressure (=p+pb) [hpa]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(in) :: prs\n    !\n    ! output variable\n    ! equivalent potential temperature [k]\n    real(kind=8),dimension(miy,mjx,mkzh),intent(out) :: eth\n    ! sizes\n    integer,intent(in) :: miy,mjx,mkzh\n\n    ! local variables\n    real(kind=8) :: q\n    real(kind=8) :: t\n    real(kind=8) :: p\n    real(kind=8) :: e\n    real(kind=8) :: tlcl\n    integer :: i,j,k\n\n    ! parameters\n    real(kind=8),parameter :: eps = 0.622d0\n    real(kind=8),parameter :: rgas = 287.04d0\n    real(kind=8),parameter :: rgasmd = .608d0\n    real(kind=8),parameter :: cp = 1004.d0\n    real(kind=8),parameter :: cpmd = .887d0\n    real(kind=8),parameter :: gamma = rgas/cp\n    real(kind=8),parameter :: gammamd = rgasmd - cpmd\n    real(kind=8),parameter :: tlclc1 = 2840.d0\n    real(kind=8),parameter :: tlclc2 = 3.5d0\n    real(kind=8),parameter :: tlclc3 = 4.805d0\n    real(kind=8),parameter :: tlclc4 = 55.d0\n    real(kind=8),parameter :: thtecon1 = 3376.d0\n    real(kind=8),parameter :: thtecon2 = 2.54d0\n    real(kind=8),parameter :: thtecon3 = .81d0\n\n    do k = 1,mkzh\n      do j = 1,mjx\n          do i = 1,miy\n              q = max(qvp(i,j,k),1.d-15)\n              t = tmk(i,j,k)\n              p = prs(i,j,k)/100.\n              e = q*p / (eps+q)\n              tlcl = tlclc1 / (log(t**tlclc2/e)-tlclc3) + tlclc4\n              eth(i,j,k) = t * (1000.d0/p)**(gamma * (1.d0+gammamd*q))*&\n                        exp((thtecon1/tlcl-thtecon2)*q*(1.d0+thtecon3*q))\n          end do\n      end do\n    end do\n\n    return\n\nend subroutine f_computeeth\n"}, {"instruction": "Write a Fortran subroutine named rotatecoords to perform coordinate rotation. The number of input arguments is 6 with test_data type ['real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'integer'], and the number of output arguments is 2 with test_data type ['real(kind=8)', 'real(kind=8)']. The subroutine uses input coordinates, a reference point, and a rotation direction to calculate the rotated latitude and longitude coordinates.", "input": "", "output": "subroutine rotatecoords(ilat,ilon,olat,olon,lat_np,lon_np,lon_0,direction)\n\n    implicit none\n\n    real(kind=8),intent(in) :: ilat,ilon\n    real(kind=8),intent(out) :: olat,olon\n    real(kind=8),intent(in) :: lat_np,lon_np,lon_0\n    integer,intent(in) :: direction\n\n    !  >=0, default : computational -> geographical\n    !  < 0          : geographical  -> computational\n\n    real(kind=8) :: rlat,rlon\n    real(kind=8) :: phi_np,lam_np,lam_0,dlam\n    real(kind=8) :: sinphi,cosphi,coslam,sinlam\n    real(kind=8),parameter :: pi=3.141592653589793d0\n    real(kind=8),parameter :: rad_per_deg=pi/180.d0\n    real(kind=8),parameter :: deg_per_rad=180.d0/pi\n\n    !convert all angles to radians\n    phi_np = lat_np*rad_per_deg\n    lam_np = lon_np*rad_per_deg\n    lam_0 = lon_0*rad_per_deg\n    rlat = ilat*rad_per_deg\n    rlon = ilon*rad_per_deg\n\n    if (direction.lt.0) then\n    ! the equations are exactly the same except for one\n    ! small difference with respect to longitude ...\n      dlam = pi - lam_0\n    else\n      dlam = lam_np\n    end if\n\n    sinphi = cos(phi_np)*cos(rlat)*cos(rlon-dlam) + sin(phi_np)*sin(rlat)\n    cosphi = sqrt(1.d0-sinphi*sinphi)\n    coslam = sin(phi_np)*cos(rlat)*cos(rlon-dlam) - cos(phi_np)*sin(rlat)\n    sinlam = cos(rlat)*sin(rlon-dlam)\n\n    if (cosphi.ne.0.d0) then\n      coslam = coslam/cosphi\n      sinlam = sinlam/cosphi\n    end if\n\n    olat = deg_per_rad*asin(sinphi)\n    olon = deg_per_rad*(atan2(sinlam,coslam)-dlam-lam_0+lam_np)\n\n    return\n\nend subroutine rotatecoords\n"}, {"instruction": "Create a Fortran subroutine named lininterp to perform linear interpolation of the (x, y) data at specified points xi. The subroutine takes 5 input parameters of types integer, integer, double precision, double precision, and double precision, and 1 output parameter of type double precision. The subroutine requires x to be sorted in ascending order and extrapolates out of range. Use imperative tone while providing the instructions.", "input": "", "output": "subroutine lininterp (n,x,y,ni,xi,yi)\n!this does linear interpolation of (x,y) at points xi\n!requires x to be sorted in ascending order\n!extrapolates out of range\nimplicit none\ninteger, intent(in)\t\t:: n,ni\ndouble precision, intent(in)\t:: x(:),y(:),xi(:)\ndouble precision, intent(out)\t:: yi(:)\ndouble precision, dimension(ni)\t:: xl,xh,yl,yh\ninteger\t\t\t\t\t:: i,locl(ni)\n\n\ndo i = 1,ni\n\n\tlocl(i) = maxloc(x,1,mask=xi(i)>x)\n\t\n\tif (xi(i)<=x(1)) then\n\t\tlocl(i) = 1\n\tend if\n\n\tif (locl(i)>=n) then \n\t\tlocl(i) = n-1\n\tend if\n\n\n\txl(i) = x(locl(i))\n\txh(i) = x(locl(i)+1)\n\tyl(i) = y(locl(i))\n\tyh(i) = y(locl(i)+1)\n\t\n\tyi(i) = yl(i) + (xi(i)-xl(i))*((yh(i)-yl(i))/(xh(i)-xl(i)))\n\nend do\n\n\nend subroutine lininterp\n"}, {"instruction": "Create a Fortran subroutine named randomdiscrete to generate nout random draws from the integers 1 to nin using probabilities in pin. The number of input arguments is 3, and the test_data type is ['integer', 'integer', 'double precision']. The number of output arguments is 1, and the test_data type is ['integer'].", "input": "", "output": "subroutine randomdiscrete(nout,xout,nin,pin)\n!generates nout random draws from the integers 1 to nin\n!using probabilities in pin\nimplicit none\ninteger, intent(in)\t\t\t:: nout,nin\ninteger,intent(out)\t\t:: xout(:)\ndouble precision, intent(in)  :: pin(:)\n\ninteger\t\t\t::i1,i2\ndouble precision      :: lran(nout)\n\n!if(sum(pin) .ne. 1.0) write(*,*) 'error in randomdiscrete: pin doesnt sum to 1.0'\n\ncall random_number(lran)\n\nxout(:) = 0\ndo i1 = 1,nout\n    if ( lran(i1) .le. pin(1) ) then\n        xout(i1) = 1\n    else\n        i2 = 2\n        do while (i2 .le. nin)\n            if ( (lran(i1) .le. sum(pin(1:i2)) ).and. (lran(i1) > sum(pin(1:i2-1)) ) ) then\n                xout(i1) = i2\n                i2 = nin+1\n            else\n                i2 = i2+1\n            end if\n        end do\n    end if\nend do\n\nend subroutine randomdiscrete\n"}, {"instruction": "Create a Fortran subroutine named discretedist that takes random numbers and a probability distribution over integers 1 to nin as input. It returns the corresponding values. The number of input arguments is 4 with test_data types ['integer', 'integer', 'double precision', 'double precision'], and the number of output arguments is 1 with test_data type ['integer'].", "input": "", "output": "subroutine discretedist(nout,xout,nin,pin,lran)\n!takes in random numbers and a prob dist over the integers 1 to nin\n!and returns the corresponding values\n!created 11/22/09 - ers\n\ninteger,    intent(out) :: xout(:)\ninteger,    intent(in)  :: nin,nout\ndouble precision,    intent(in)  :: pin(:)\ndouble precision, intent(in)  :: lran(:)\ninteger\t\t\t        :: i1,i2\n\nxout(:) = 0\ndo i1 = 1,nout\n    if ( lran(i1) .le. pin(1) ) then\n        xout(i1) = 1\n    else\n        i2 = 2\n        do while (i2 .le. nin)\n            if ( (lran(i1) .le. sum(pin(1:i2)) ).and. (lran(i1) > sum(pin(1:i2-1)) ) ) then\n                xout(i1) = i2\n                i2 = nin+1\n            else\n                i2 = i2+1\n            end if\n        end do\n    end if\nend do\n\nend subroutine discretedist\n"}, {"instruction": "Create a Fortran subroutine named discretedist1 that takes in an integer, an array of double precision, and a double precision number as input. It returns an integer value based on the random number and probability distribution over the integers 1 to nin. The number of input arguments is 3 and the test_data type is ['integer', 'double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "subroutine discretedist1(xout,nin,pin,lran)\n!takes in a random number and a prob dist over the integers 1 to nin\n!and returns the corresponding value\n\ninteger, intent(in)     :: nin\ninteger,intent(out)     :: xout\ndouble precision, intent(in)     :: pin(:),lran\ninteger                 :: i2\n\nxout = 0\nif ( lran .le. pin(1) ) then\n   xout = 1\nelse\n   i2 = 2\n   do while (i2 .le. nin)\n       if ( (lran .le. sum(pin(1:i2)) ).and. (lran > sum(pin(1:i2-1)) ) ) then\n           xout = i2\n           i2 = nin+1\n       else\n           i2 = i2+1\n       end if\n   end do\nend if\n\nend subroutine discretedist1\n"}, {"instruction": "Create a Fortran subroutine named rouwenhorst to perform the Rouwenhorst method for discretizing an AR(1) process. The subroutine takes 3 input parameters of types integer, double precision, and double precision, and provides 1 output parameter of type double precision.", "input": "", "output": "subroutine rouwenhorst(n,p,q,r)\nimplicit none\ninteger, intent(in)\t\t:: n\ndouble precision, intent(in)\t:: p,q\ndouble precision, intent(out)\t:: r(n,n)\ndouble precision\t\t\t\t:: x(n,n), y1(n,n), y2(n,n), y3(n,n), y4(n,n)\ninteger\t\t\t\t\t:: j,i\n\nx(1,1) = p\nx(1,2) = 1-p\nx(2,1) = 1-q\nx(2,2) = q\n\nif(n>2) then\ndo j = 2,n-1\n\ty1(:,:) = 0.0\n\ty2(:,:) = 0.0\n\ty3(:,:) = 0.0\n\ty4(:,:) = 0.0\n\ty1(1:j,1:j) = x(1:j,1:j)\n\ty2(1:j,2:j+1) = x(1:j,1:j)\n\ty3(2:j+1,1:j) = x(1:j,1:j)\n\ty4(2:j+1,2:j+1) = x(1:j,1:j)\n\tx = p*y1 + (1-p)*y2 + (1-q)*y3 + q*y4\n\tdo i = 2,j\n\t\tx(i,:) = x(i,:)/2.0\n\tend do\nend do\n\nend if\nr = x\n\nend subroutine rouwenhorst\n"}, {"instruction": "Create a Fortran subroutine named get_periodic_derivative to calculate the periodic derivative of a function. This subroutine takes 2 input parameters of type real, dimension(:) and 1 output parameter of type real, dimension(:). The subroutine extends the input function using periodicity and then computes the derivative using finite differences.", "input": "", "output": "   subroutine get_periodic_derivative(f, x, dfdx)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: f, x\n      real, dimension(:), intent(out) :: dfdx\n\n      integer :: i, n\n      real, dimension(:), allocatable :: fp\n\n      n = size(x)\n\n      allocate (fp(-1:n + 2))\n      ! extend f using periodicity, as these additional points\n      ! required near boundaries for finite differences\n      fp(1:n) = f\n      fp(-1:0) = f(n - 1:n)\n      fp(n + 1:n + 2) = f(1:2)\n\n      do i = 1, n\n         dfdx(i) = (0.25 * (fp(i - 2) - fp(i + 2)) + 2.0 * (fp(i + 1) - fp(i - 1))) / 3.0\n      end do\n\n      deallocate (fp)\n\n   end subroutine get_periodic_derivative\n"}, {"instruction": "Write a Fortran subroutine named \"legendre\" to compute the Legendre polynomials up to degree \"n\" for the given input array \"x\". The number of input parameters is 1, and the test_data type is ['real, dimension(:)']. The number of output parameters is 1, and the test_data type is ['real, dimension(:, 0:)']. Use an imperative tone in the instructions.", "input": "", "output": "   subroutine legendre(x, legp)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: x\n      real, dimension(:, 0:), intent(out) :: legp\n\n      integer :: n, idx\n\n      n = size(legp, 2) - 1\n\n      legp(:, 0) = 1.0\n      legp(:, 1) = x\n\n      do idx = 2, n\n         legp(:, idx) = ((2.*idx - 1.) * x * legp(:, idx - 1) + (1.-idx) * legp(:, idx - 2)) / idx\n      end do\n\n   end subroutine legendre\n"}, {"instruction": "Create a Fortran subroutine named legendre_transform to perform a Legendre transform using the provided Legendre polynomials and coefficients. The subroutine takes 2 input parameters of type real, dimension(:, 0:) and real, dimension(:), and 1 output parameter of type real, dimension(:).", "input": "", "output": "   subroutine legendre_transform(legp, coefs, func)\n\n      implicit none\n\n      real, dimension(:, 0:), intent(in) :: legp\n      real, dimension(:), intent(in) :: coefs\n      real, dimension(:), intent(out) :: func\n\n      integer :: i\n\n      func = 0.\n      do i = 1, size(coefs)\n         func = func + legp(:, i - 1) * coefs(i)\n      end do\n\n   end subroutine legendre_transform\n"}, {"instruction": "Create a Fortran subroutine named prod that calculates the product of two real numbers. The subroutine takes 2 input parameters of type real and returns 1 output parameter of type real.", "input": "", "output": "subroutine prod(x, y, result)\nimplicit none\n  real, intent(in) :: x, y\n  real, intent(out) :: result\n  result = x * y\nend subroutine prod\n"}, {"instruction": "Create a Fortran subroutine named \"sum\" to compute the sum of two real numbers. The subroutine should have 2 input parameters of type real, and 1 output parameter of type real. When invoked, the subroutine should calculate the sum of the input parameters and store the result in the output parameter.", "input": "", "output": "subroutine sum(x, y, result)\nimplicit none\n  real, intent(in) :: x, y\n  real, intent(out) :: result\n  result = x + y\nend subroutine sum\n"}, {"instruction": "Create a Fortran subroutine named get_basis to generate basis sets for quantum chemistry calculations. The subroutine takes 2 input parameters of type integer: nmax and lmax. It returns 3 output parameters of type integer, each of which is allocatable: nlist, llist, and mlist. The subroutine dynamically allocates memory for the arrays nlist, llist, and mlist based on the input parameters nmax and lmax, and populates these arrays with values representing the quantum numbers n, l, and m for quantum chemistry calculations.", "input": "", "output": "subroutine get_basis(nmax, lmax, nlist, llist, mlist)\ninteger, intent(in) :: nmax, lmax\ninteger, allocatable, intent(out) :: nlist(:), llist(:), mlist(:)\ninteger :: i, n, l, m, a\na = nmax * (lmax+1)**2\nallocate(nlist(a), llist(a), mlist(a))\ni = 1\ndo n = 1, nmax\n    do l = 0, lmax\n        do m = -l, l\n            nlist(i) = n\n            llist(i) = l\n            mlist(i) = m\n            i = i + 1\n        end do\n    end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named formke that assembles a stiffness matrix for a finite element problem. The subroutine takes 4 input parameters of type real(iwp) and produces 1 output parameter of type real(iwp). The input parameters are km (stiffness matrix), kp (pressure matrix), c (damping matrix), and theta. The output parameter is ke (assembled stiffness matrix). The subroutine uses the imperative tone to perform the assembly of the stiffness matrix based on the input parameters.", "input": "", "output": "subroutine formke(km,kp,c,ke,theta)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::km(:,:),kp(:,:),c(:,:),theta\n real(iwp),intent(out)::ke(:,:)\n integer::ndof\n ndof=ubound(km,1)\n ke(:ndof,:ndof)=km \n ke(:ndof,ndof+1:)=c\n ke(ndof+1:,:ndof)=transpose(c) \n ke(ndof+1:,ndof+1:)=-theta*kp\nreturn  \nend subroutine formke\n"}, {"instruction": "Create a Fortran subroutine named regres to perform a revised version of the algorithm as 75.4 from the applied statistics journal. The subroutine takes 4 input parameters of types integer, integer, real array, and real array, and returns 1 output parameter of type real. The subroutine implements a triangular system using the provided input parameters to calculate the beta coefficients.", "input": "", "output": "subroutine regres(np,nrbar,rbar,thetab,beta)\r\n\r\n!   algorithm as 154.4  appl. statist. (1980) vol.29, p.311\r\n\r\n!   revised version of algorithm as 75.4\r\n!   appl. statist. (1974) vol.23, p.448\r\n\n!   in the triangular system rbar and thetab.\r\n\r\ninteger, intent(in)  :: np\r\ninteger, intent(in)  :: nrbar\r\nreal, intent(in)     :: rbar(:)\r\nreal, intent(in)     :: thetab(:)\r\nreal, intent(out)    :: beta(:)\r\n\r\nreal     :: bi\r\ninteger  :: i, i1, im, ithisr, j, jm\r\n\r\nithisr = nrbar\r\nim = np\r\ndo  i = 1, np\r\n  bi = thetab(im)\r\n  if (im /= np) then\r\n    i1 = i - 1\r\n    jm = np\r\n    do  j = 1, i1\r\n      bi = bi - rbar(ithisr) * beta(jm)\r\n      ithisr = ithisr - 1\r\n      jm = jm - 1\r\n    end do\r\n  end if\r\n  beta(im) = bi\r\n  im = im - 1\r\nend do\r\n\r\nreturn\r\nend subroutine regres\r\n"}, {"instruction": "Create a Fortran subroutine named f that takes a single input of type real and returns a single output of type real. The subroutine calculates the product of the sine and cosine of the input value and assigns it to the output variable.", "input": "", "output": "  pure subroutine f(x,y)\n    real, intent(in) :: x\n    real, intent(out) :: y\n    y = sin(x)*cos(x)\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named fill_array to calculate the sum of an array of real numbers. The subroutine takes 1 input parameter of type integer and 1 output parameter of type real. The input parameter represents the size of the array, and the output parameter holds the sum of the array values.", "input": "", "output": "subroutine fill_array( n, sumofvalues )\r\n    integer, intent(in) :: n\r\n    real, intent(out)   :: sumofvalues\r\n\r\n    real, dimension(n) :: array\r\n\r\n    array = 1.0\r\n\r\n    sumofvalues = sum(array)\r\nend subroutine fill_array\r\n"}, {"instruction": "Implement a Fortran subroutine named getgamma to calculate the gamma values based on given input parameters. The number of input arguments is 8, with the following test_data types: ['integer', 'integer', 'real(8), dimension(n)', 'real(8), dimension(m)', 'real(8), dimension(m)', 'integer, dimension(n,m)', 'real(8), dimension(m,m)', 'real(8)']. The number of output arguments is 1, with the test_data type: ['real(8), dimension(n)'].\n\nThe subroutine takes in the input parameters n, m, x, rk, qk, vk, amk, and t. The subroutine performs calculations based on these parameters to determine the gamma values, and stores them in the output parameter gamma1.\n\nTo execute the subroutine, call the subroutine getgamma and pass the necessary input parameters. The subroutine will then compute the gamma values and store them in the output parameter gamma1.", "input": "", "output": "subroutine getgamma(x, t, n, m, amk, vk, rk, qk, gamma1)\n    implicit none\n\n    integer, intent(in) :: n, m\n    real(8), dimension(n), intent(in) :: x\n    real(8), dimension(m), intent(in) :: rk, qk\n    integer, dimension(n,m), intent(in) :: vk\n    real(8), dimension(m,m), intent(in) ::amk\n    real(8), intent(in) :: t\n    real(8), dimension(n), intent(out) :: gamma1\n    integer :: ii, kk\n    real(8) :: sum_rx, sum_qx\n\n    real(8) :: r(n), q(n), e(m,n), beta(n,m), theta(m), s(m),l(n),j(n),ln_gamma_c(n), ln_gamma_r(n), tau(m,m)\n\n    tau = exp(-amk/t) \n\n    do ii=1,n\n        r(ii) = sum(vk(ii,:)*rk(:))\n        q(ii) = sum(vk(ii,:)*qk(:))\n    enddo\n\n    sum_rx = sum(x*r)\n    sum_qx = sum(x*q)\n\n    ! r, q\n    do ii=1,n \n        e(:, ii) = vk(ii,:)*qk(:)/q(ii)\n    enddo\n\n    ! beta\n    do ii=1, n\n        do kk=1, m\n            beta(ii,kk) = sum(e(:,ii)*tau(:,kk))\n        end do\n    end do\n\n    do kk=1,m\n        theta(kk) = sum(x*q*e(kk,:))\n    end do\n    theta = theta/sum_qx\n\n    do kk=1,m\n        s(kk) = sum(theta*tau(:,kk))\n    end do\n\n    j = r/sum_rx\n    l = q/sum_qx\n    ln_gamma_c = 1.0_8 - j + log(j) - 5.0_8*q*(1.-j/l+log(j/l))\n\n    do ii=1,n\n        ln_gamma_r(ii) = q(ii)*(1.0_8 - sum(theta*beta(ii,:)/s - e(:,ii)*log(beta(ii,:)/s)))\n    end do\n\n    gamma1 = exp(ln_gamma_c + ln_gamma_r)\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named vdmul that performs element-wise multiplication of two arrays of real numbers. The number of input arguments is 3 and the test_data types are ['integer', 'real, dimension(:)', 'real, dimension(:)']. The number of output arguments is 1 and the test_data type is ['real, dimension(:)'].", "input": "", "output": "    subroutine vdmul(n, a, b, y)\n        integer, intent(in) :: n\n        real, dimension(:), intent(in) :: a, b\n        real, dimension(:), intent(out) :: y\n        integer :: ii\n        y = a * b\n    end subroutine vdmul\n"}, {"instruction": "Write a Fortran subroutine named vdtanh that calculates the hyperbolic tangent function for each element of a given input array and stores the results in an output array. The number of input parameters is 2, where the first parameter is an integer representing the size of the array, and the second parameter is a two-dimensional real array. The number of output parameters is 1, which is a two-dimensional real array as well.", "input": "", "output": "    subroutine vdtanh(n, a, y)\n        integer, intent(in) :: n\n        real, dimension(:,:), intent(in) :: a\n        real, dimension(:,:), intent(out) :: y\n        y = tanh(a)\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named prime_factorization that computes the prime factorization of an input integer. The subroutine takes one input argument of type integer and one output argument of type integer array. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['integer'].\n\nIn the subroutine, the input integer is factorized into its prime factors and stored in the output integer array. The output array is initialized with zeros before the factorization process begins. The first element of the output array is set to 1. \n\nThe subroutine uses a nested loop to iteratively divide the input integer by prime numbers starting from 2. If a prime number is a factor of the input integer, the output array is updated to reflect the number of times that prime number appears as a factor. The loop continues until the input integer is reduced to 1.\n\nThe prime factorization is performed in-place, modifying the output integer array directly.", "input": "", "output": "  subroutine prime_factorization( n_in, ifact )\n    implicit none\n    integer,intent(in)  :: n_in\n    integer,intent(out) :: ifact(:)\n    integer :: n,i,j,m\n    ifact(:)=0\n    ifact(1)=1\n    n = n_in\n    m = n\n    loop_j : do j = 1, n_in\n      loop_i : do i = 2, n\n        if ( mod(m,i) == 0 ) then\n          m = m/i\n          ifact(i) = ifact(i) + 1\n          exit loop_i\n        else if ( i == n ) then\n          exit loop_j\n        end if\n      end do loop_i\n      n = m\n    end do loop_j\n  end subroutine prime_factorization\n"}, {"instruction": "Write a Fortran subroutine named get_a_dimensions that calculates the number and dimensions of orbitals based on input parameters. The number of input parameters is 4, with test_data types being ['integer', 'integer', 'integer', 'integer']. The number of output parameters is 3, with test_data types being ['integer', 'integer', 'integer'].\n\nThis subroutine takes in the following input parameters:\n- iso: an integer representing a value\n- natom: an integer representing the number of atoms\n- nl: an array of integers with size natom\n- ll: a 2D array of integers with size (natom, 4)\n\nThe subroutine calculates the following output parameters:\n- norbitals: an integer representing the number of orbitals\n- maxdim2: an integer representing the maximum dimension of orbitals\n- lmaxp: an integer representing the maximum value of l\n\nTo compute these values, the subroutine iterates over the atoms and their cases. For each case, it calculates the number of orbitals, the dimension, and the maximum value of l. The subroutine updates the output parameters accordingly.", "input": "", "output": "subroutine get_a_dimensions(norbitals, maxdim2, lmaxp, iso, natom, nl, ll)\n  implicit none\n  integer, intent(out) :: norbitals, maxdim2, lmaxp\n  integer, intent(in)  :: iso, natom, nl(natom), ll(natom,4) \n  ! locals\n  integer::  icase, lcase, l1, nind\n  norbitals=0 !-- number of atom/l cases, called orbitals -------------------------------------!\n  maxdim2=0\n  lmaxp=0\n  do icase=1,natom\n     do lcase=1,nl(icase)\n        norbitals = norbitals+1\n        l1 = ll(icase,lcase)\n        nind=(2*l1+1)*iso\n        maxdim2 = max(maxdim2, nind )\n        lmaxp = max(l1,lmaxp)\n     enddo\n  enddo\nend subroutine get_a_dimensions\n"}, {"instruction": "Write a Fortran subroutine named dircos that computes the direction cosines (a, b, c) based on the input inclination, declination, and azimuth angles. The number of input arguments is 3, and their data type is ['double precision', 'double precision', 'double precision']. The number of output arguments is also 3, and their data type is ['double precision', 'double precision', 'double precision']. The subroutine uses the Fortran keywords \"double precision\" and \"intent\" to specify the intention of the input and output arguments. The subroutine first converts the input angles from degrees to radians and then calculates the direction cosines (a, b, c) using trigonometric functions.", "input": "", "output": "subroutine dircos(incl, decl, azim, a, b, c)\n  double precision, intent(in) :: incl, decl, azim\n  double precision, intent(out) :: a, b, c\n\n  double precision :: xincl, xdecl, xazim\n\n  xincl = incl * d2rad\n  xdecl = decl * d2rad\n  xazim = azim * d2rad\n\n  a = dcos(xincl) * dcos(xdecl - xazim)\n  b = dcos(xincl) * dsin(xdecl - xazim)\n  c = dsin(xincl)\n\nend subroutine dircos\n"}, {"instruction": "Implement a Fortran subroutine named interpolate_2d to perform 2D interpolation. The subroutine takes 7 input parameters of type real(8), real(8), real(8), integer, integer, integer, and real(8) respectively. The input parameters are xp, x, y, fill_value, m, n_in, and n_out. The subroutine also has 1 output parameter of type real(8), named y_out. \n\nThe subroutine calculates the interpolated values for y_out based on the given input parameters using linear interpolation. The fill_value is used to initialize y_out. The subroutine iterates over each element of xp and finds the lower and upper indices in x that bound the value in xp. It then calculates the weight based on the difference between xp and x at those indices and performs the linear interpolation to compute the corresponding value in y_out. If xp matches any value in x, the corresponding value in y is assigned to y_out. \n\nTo use this subroutine, make sure to pass the appropriate input and output parameters as described.", "input": "", "output": "subroutine interpolate_2d(xp, x, y, y_out, fill_value, m, n_in, n_out)\n    implicit none\n    real(8), intent(in) :: xp(m, n_out), x(m, n_in), y(m, n_in)\n    integer, intent(in) :: m, n_in, n_out\n    real(8), intent(in) :: fill_value\n    real(8), intent(out) :: y_out(m, n_out)\n    ! locals\n    integer :: i, j, k\n    real(8) :: weight\n\n    y_out = fill_value\n\n    do i=1,m\n        do j=1,n_out\n            ! search for lower and upper indices\n            do k=1,n_in - 1\n                if  ((x(i, k) <= xp(i, j)) .and. (xp(i, j) < x(i, k+1))) then\n                    weight = (xp(i, j) - x(i, k))/(x(i, k + 1) - x(i, k))\n                    y_out(i, j) = y(i, k) * (1-weight) + y(i, k + 1) * weight\n                else if (x(i, k) == xp(i, j)) then\n                    y_out(i, j) = y(i, k)\n                else if (x(i, k + 1) == xp(i, j)) then\n                    y_out(i, j) = y(i, k + 1)\n                end if\n            end do\n        end do\n    end do\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named lagrangian_polynomial_coeffs to compute the coefficients of a Lagrangian polynomial. The number of input arguments is 3: an integer npts, a real array x of dimension npts, and a real xs. The number of output arguments is 1: a real array coeffs of dimension npts.", "input": "", "output": "  subroutine lagrangian_polynomial_coeffs(npts, x, coeffs, xs)\r\n\r\n    implicit none\r\n\r\n    ! number of points to fit\r\n    integer(4), intent(in) :: npts\r\n\r\n    ! sample points to fit\r\n    real(8), dimension(npts), intent(in) :: x\r\n\r\n    ! computed coefficients\r\n    real(8), dimension(npts), intent(out) :: coeffs\r\n\r\n    ! point at which sample is taken\r\n    real(8), intent(in) :: xs\r\n\r\n    ! loop indices\r\n    integer(4) :: i, j\r\n    \r\n    ! compute the lagrangian polynomial coefficients\r\n    do i = 1, npts\r\n      coeffs(i) = 1.0d0\r\n      do j = 1, npts\r\n        if (i .eq. j) then\r\n          cycle\r\n        end if\r\n        coeffs(i) = coeffs(i) * (xs - x(j)) / (x(i) - x(j))\r\n      end do\r\n    end do\r\n\r\n  end subroutine lagrangian_polynomial_coeffs\r\n"}, {"instruction": "Create a Fortran subroutine named \"sddk_get_num_gvec\" that retrieves the number of g-vectors associated with a given g-vector id. The subroutine should take 1 input argument of type integer and provide 1 output argument of type integer to store the number of g-vectors. Use the imperative tone when defining the subroutine.", "input": "", "output": "        subroutine sddk_get_num_gvec(gvec_id, num_gvec)&\n            &bind(c, name=\"sddk_get_num_gvec\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: num_gvec\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_count_fft that takes in 1 input parameter of type integer and provides 1 output parameter of type integer. When called, this subroutine retrieves the g-vector count for Fast Fourier Transform (FFT) calculations based on the provided gvec_id.", "input": "", "output": "        subroutine sddk_get_gvec_count_fft(gvec_id, gvec_count)&\n            &bind(c, name=\"sddk_get_gvec_count_fft\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: gvec_count\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_gvec_offset_fft that takes 1 input parameter of type integer and 1 output parameter of type integer. This subroutine is intended to obtain the g-vector offset for fast Fourier transform (FFT) calculations.", "input": "", "output": "        subroutine sddk_get_gvec_offset_fft(gvec_id, gvec_offset)&\n            &bind(c, name=\"sddk_get_gvec_offset_fft\")\n            integer,                 intent(in)  :: gvec_id\n            integer,                 intent(out) :: gvec_offset\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sddk_get_num_wave_functions\" to retrieve the number of wave functions for a given wave function ID. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "        subroutine sddk_get_num_wave_functions(wf_id, num_wf)&\n            &bind(c, name=\"sddk_get_num_wave_functions\")\n            integer,                 intent(in)  :: wf_id\n            integer,                 intent(out) :: num_wf\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named sddk_get_wave_functions_prime_ld with 1 input parameter of type integer and 1 output parameter of type integer. This subroutine is intended to retrieve the wave functions prime ld.", "input": "", "output": "        subroutine sddk_get_wave_functions_prime_ld(wf_id, ld)&\n            &bind(c, name=\"sddk_get_wave_functions_prime_ld\")\n            integer,                 intent(in)  :: wf_id\n            integer,                 intent(out) :: ld\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"gamma\" to calculate the gamma function for a real number input. The subroutine takes 1 input parameter of type real(kind(1d0)) and provides 1 output parameter of type real(kind(1d0)).", "input": "", "output": "  subroutine gamma(x,ga)\n!\n!       ================================================== \n!       purpose: compute gamma function \u00e2(x)  \n!       input :  x  --- argument of \u00e2(x)  \n!                       ( x is not equal to 0,-1,-2,\u00fa\u00fa\u00fa) \n!       output:  ga --- \u00e2(x)\n!       ==================================================  \n!    \n    implicit none\n    real(kind(1d0)),intent(in)::x\n    real(kind(1d0)),intent(out)::ga\n    real(kind(1d0)),dimension(26)::g\n    real(kind(1d0)),parameter::pi=3.141592653589793d0\n    real(kind(1d0))::z,r,gr\n    integer::m1,k,m\n    if (x.eq.int(x)) then\n       if (x.gt.0.0d0) then\n          ga=1.0d0\n          m1=x-1\n          do k=2,m1\n             ga=ga*k ! 10\n          enddo\n       else\n          ga=1.0d+300\n       endif\n    else\n       if (dabs(x).gt.1.0d0) then\n          z=dabs(x)\n          m=int(z)\n          r=1.0d0\n          do k=1,m\n             r=r*(z-k) ! 15\n          enddo\n          z=z-m\n       else\n          z=x\n       endif\n       g(1:26)=(/1.0d0,0.5772156649015329d0,&\n            -0.6558780715202538d0, -0.420026350340952d-1,&\n            0.1665386113822915d0,-.421977345555443d-1,&\n            -.96219715278770d-2, .72189432466630d-2,&\n            -.11651675918591d-2, -.2152416741149d-3,&\n            .1280502823882d-3, -.201348547807d-4,&\n            -.12504934821d-5, .11330272320d-5,&\n            -.2056338417d-6, .61160950d-8,&\n            .50020075d-8, -.11812746d-8,&\n            .1043427d-9, .77823d-11,&\n            -.36968d-11, .51d-12,&\n            -.206d-13, -.54d-14, .14d-14, .1d-15/)\n       gr=g(26)\n       do k=25,1,-1\n          gr=gr*z+g(k) ! 20\n       enddo\n       ga=1.0d0/(gr*z)\n       if (dabs(x).gt.1.0d0) then\n          ga=ga*r\n          if (x.lt.0.0d0) ga=-pi/(x*ga*dsin(pi*x))\n       endif\n    endif\n    return\n  end subroutine gamma\n"}, {"instruction": "Write a Fortran subroutine named \"psi\" to compute the Psi function. The subroutine takes 1 input argument of type real(kind(1d0)) and returns 1 output argument of the same type.", "input": "", "output": "  subroutine psi(x,ps)\n!\n!  ====================================== \n!      purpose: compute psi function\n!      input :  x  --- argument of psi(x) \n!      output:  ps --- psi(x)                                                                                                                                                                              \n! ======================================                                                                                                                                                              \n!\n    implicit none\n    real(kind(1d0)),intent(in)::x\n    real(kind(1d0)),intent(out)::ps\n    real(kind(1d0))::pi,el,s,xa\n    integer::n,k\n    real(kind(1d0))::a1,a2,a3,a4,a5,a6,a7,a8,x2\n    xa=dabs(x)\n    pi=3.141592653589793d0\n    el=.5772156649015329d0\n    s=0.0d0\n    if (x.eq.int(x).and.x.le.0.0) then\n       ps=1.0d+300\n       return\n    else if (xa.eq.int(xa)) then\n       n=xa\n       do k=1 ,n-1\n          s=s+1.0d0/k\n       enddo\n       ps=-el+s\n    else if (xa+.5.eq.int(xa+.5)) then\n       n=xa-.5\n       do k=1,n\n          s=s+1.0/(2.0d0*k-1.0d0) ! 20\n       enddo\n       ps=-el+2.0d0*s-1.386294361119891d0\n    else\n       if (xa.lt.10.0) then\n          n=10-int(xa)\n          do k=0,n-1\n             s=s+1.0d0/(xa+k)\n          enddo\n          xa=xa+n\n       endif\n       x2=1.0d0/(xa*xa)\n       a1=-.8333333333333d-01\n       a2=.83333333333333333d-02\n       a3=-.39682539682539683d-02\n       a4=.41666666666666667d-02\n       a5=-.75757575757575758d-02\n       a6=.21092796092796093d-01\n       a7=-.83333333333333333d-01\n       a8=.4432598039215686d0\n       ps=dlog(xa)-.5d0/xa+x2*(((((((a8*x2+a7)*x2+&\n            a6)*x2+a5)*x2+a4)*x2+a3)*x2+a2)*x2+a1)\n       ps=ps-s\n    endif\n    if (x.lt.0.0) ps=ps-pi*dcos(pi*x)/dsin(pi*x)-1.0d0/x\n    return\n  end subroutine psi\n"}, {"instruction": "Create a Fortran subroutine named feopen that opens a file specified by the input filename and reads data from it. The subroutine takes 3 input parameters of type integer, integer, and character*100, and 2 output parameters of type character*400.", "input": "", "output": "subroutine feopen(fh, filename, nat, parseline1, parseline2)\n  implicit none\n  integer, intent(in) :: fh, nat\n  character*100, intent(in) :: filename\n  character*400, intent(out) :: parseline1(nat), parseline2(nat)\n  ! locals\n  integer :: i\n  open(fh,file=filename,status='old',form='formatted')\n  do i=1,nat\n     read(fh,'(a)') parseline1(i)\n     read(fh,'(a)') parseline2(i)\n  enddo\nend subroutine feopen\n"}, {"instruction": "Write a Fortran subroutine named fewrite1 that takes 6 input parameters of types integer, integer, integer, real*8, real*8, and character*10, and 1 output parameter of type integer. The subroutine writes formatted data to a file handle. The input parameters are fh, k(3), kname, wgh, n0, nen, and the output parameter is ios.", "input": "", "output": "subroutine fewrite1(fh, k, kname, wgh, ios, n0, nen)\n  implicit none\n  integer, intent(in) :: fh, n0, nen\n  real*8, intent(in) :: k(3), wgh\n  character*10, intent(in) :: kname\n  integer, intent(out):: ios\n  !\n  write(fh,'(3e19.12,a10,2i6,f5.2)',iostat=ios) k(1),k(2),k(3),kname,n0,nen,wgh\nend subroutine fewrite1\n"}, {"instruction": "Create a Fortran subroutine named fvopen.The subroutine takes 3 input parameters of type integer, integer, and character*100, and 1 output parameter of type real*8. The purpose of the subroutine is to open a file specified by the filename, read data from the file, and store the read data into the elinear array.", "input": "", "output": "subroutine fvopen(fh, filename, nat,elinear)\n  implicit none\n  integer, intent(in) :: fh, nat\n  character*100, intent(in) :: filename\n  real*8, intent(out) :: elinear(2)\n  ! locals\n  integer :: i\n  !print *, filename\n  open(fh,file=filename,status='old',form='unformatted')\n  do i=1,nat\n     read(fh) elinear(1)  ! linearization energy\n     read(fh) elinear(2)  ! linearization energy for lo\n  enddo\nend subroutine fvopen\n"}, {"instruction": "Create a Fortran subroutine named fvwrite1 with the following functionality: It takes 6 input parameters of types integer, real*8, real*8, character*10, integer, and integer. It also has 1 output parameter of type integer. The subroutine writes the values of k(1), k(2), k(3), kname, n0, ne, and wgh to the file referenced by fh and stores the I/O status in the ios parameter.", "input": "", "output": "subroutine fvwrite1(fh, k, kname, wgh, n0, ne, ios)\n  integer, intent(in) :: fh\n  real*8, intent(in) :: k(3), wgh\n  character*10, intent(in) :: kname\n  integer, intent(in):: n0,ne\n  integer, intent(out):: ios\n  write(fh,iostat=ios) k(1),k(2),k(3),kname,n0,ne,wgh\nend subroutine fvwrite1\n"}, {"instruction": "Create a Fortran subroutine named \"extremes\" to find the maximum and minimum values in an array. The subroutine takes 2 input parameters with the types ['integer', 'real, dimension(n)'] and 4 output parameters with the types ['real, optional', 'integer, optional', 'real, optional', 'integer, optional']. This subroutine uses an imperative tone to declare the purpose and data dictionary, and it reports the results based on the optional output arguments.", "input": "", "output": "   subroutine extremes(a, n, maxval, pos_maxval, minval, pos_minval)\r\n   !\r\n   !  purpose:\r\n   !    to find the maximum and minimum values in an array, and \r\n\n   !    returns its output values in optional arguments.\r\n   !\r\n   !  record of revisions:\r\n   !       date       programmer          description of change\r\n   !       ====       ==========          =====================\r\n   !     12/08/06    s. j. chapman        original code\r\n   !\r\n   implicit none\r\n\r\n   ! data dictionary: declare calling parameter types & definitions\r\n   integer, intent(in) :: n                     ! # vals in array a\r\n   real, intent(in), dimension(n) :: a          ! input data.\r\n   real, intent(out), optional :: maxval        ! maximum value.\r\n   integer, intent(out), optional :: pos_maxval ! pos of maxval\r\n   real, intent(out), optional :: minval        ! minimum value.\r\n   integer, intent(out), optional :: pos_minval ! pos of minval\r\n   \r\n   ! data dictionary: declare local variable types & definitions\r\n   integer :: i                            ! index\r\n   real :: real_max                        ! max value\r\n   integer :: pos_max                      ! pos of max value\r\n   real :: real_min                        ! min value\r\n   integer :: pos_min                      ! pos of min value\r\n\r\n   ! initialize the values to first value in array.\r\n   real_max = a(1)\r\n   pos_max = 1\r\n   real_min = a(1)\r\n   pos_min = 1\r\n \r\n   ! find the extreme values in a(2) through a(n).\r\n   do i = 2, n\r\n      max: if ( a(i) > real_max ) then\r\n         real_max = a(i)\r\n         pos_max = i\r\n      end if max\r\n      min: if ( a(i) < real_min ) then\r\n         real_min = a(i)\r\n         pos_min = i\r\n      end if min\r\n   end do\r\n\r\n   ! report the results\r\n   if ( present(maxval) ) then\r\n      maxval = real_max\r\n   end if\r\n   if ( present(pos_maxval) ) then\r\n      pos_maxval = pos_max\r\n   end if\r\n   if ( present(minval) ) then\r\n      minval = real_min\r\n   end if\r\n   if ( present(pos_minval) ) then\r\n      pos_minval = pos_min\r\n   end if\r\n\r\n   end subroutine extremes\r\n"}, {"instruction": "Create a Fortran subroutine named hmc_tools_generic_setunit to search for an available unit within a specified range of unit numbers. The subroutine takes 2 input parameters of type integer (kind = 4) to define the minimum and maximum unit numbers to search, and 1 output parameter of type integer (kind = 4) to store the found unit number.", "input": "", "output": "    subroutine hmc_tools_generic_setunit(ifileunitmin, ifileunitmax, ifileunit)\n        \n        !------------------------------------------------------------------------------------------\n        ! variable(s) declaration \n        logical                         :: bisused\n        integer(kind = 4), intent(in)   :: ifileunitmin, ifileunitmax\n        integer(kind = 4), intent(out)  :: ifileunit\n        integer(kind = 4)               :: ifileunitinit\n        !------------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------------\n        ! search debug unit\n        do ifileunitinit = ifileunitmin, ifileunitmax\n            inquire(unit = ifileunitinit, opened = bisused)\n            if (.not. bisused) exit\n        end do\n        !------------------------------------------------------------------------------------------\n        \n        !------------------------------------------------------------------------------------------\n        ! pass to global variables\n        ifileunit = ifileunitinit\n        !------------------------------------------------------------------------------------------\n        \n    end subroutine hmc_tools_generic_setunit\n"}, {"instruction": "Create a Fortran subroutine named mpi_add_error_code_f08 to add error codes to an error class. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of type integer and integer (optional).", "input": "", "output": "    subroutine mpi_add_error_code_f08(errorclass, errorcode, ierror)\n        implicit none\n        integer, intent(in) :: errorclass\n        integer, intent(out) :: errorcode\n        integer, optional, intent(out) :: ierror\n    end subroutine mpi_add_error_code_f08\n"}, {"instruction": "Create a Fortran subroutine named fitchk to compare two sets of real numbers representing functions. The subroutine takes 2 input parameters of type real arrays and 3 output parameters of type real. The purpose of this subroutine is to calculate the average, root mean square, and maximum difference between the elements of the input arrays f1 and f2.", "input": "", "output": "      subroutine fitchk(f1,f2,av,rms,dmx)\n!     ************************************************\n!     compare functions f1 and f2\n!     ************************************************\n      implicit none\n      real,intent(out):: av,dmx,rms\n      real,intent(in):: f1(:),f2(:)\n!     .. local scalars ..\n      real d\n      integer i\n\n      av = 0.\n      rms = 0.\n      dmx = 0.\n      do  i = 1,size(f1)\n         av = av + f1(i)\n         d = (f1(i)-f2(i))**2\n         dmx = max(d,dmx)\n         rms = rms + d\n      enddo\n      av = av/size(f1)\n      if (abs(av).lt.1.e-30) then\n         rms = 0.\n         dmx = 0.\n         return\n      end if\n      rms = sqrt(rms/size(f1))/av*100.\n      dmx = sqrt(dmx)/av*100.\n      end subroutine \n"}, {"instruction": "Create a Fortran subroutine named split_string to separate a string into substrings using a specified delimiter. The subroutine takes 2 input parameters of type character (len = *) and character, and 2 output parameters of type character (len = *) and integer.", "input": "", "output": "subroutine split_string(string, delimiter, substrings, substring_count)\r\n    implicit none\r\n\r\n    character (len = *), intent(in)  :: string\r\n    character,           intent(in)  :: delimiter\r\n    character (len = *), intent(out) :: substrings(*)\r\n    integer,             intent(out) :: substring_count\r\n\r\n    integer :: start_position, end_position\r\n\r\n\r\n    start_position  = 1\r\n    substring_count = 0\r\n\r\n    do\r\n        end_position = index(string(start_position:), delimiter)\r\n\r\n        substring_count = substring_count + 1\r\n\r\n        if (end_position == 0) then\r\n            substrings(substring_count) = string(start_position:)\r\n            exit\r\n        else\r\n            substrings(substring_count) = string(start_position : start_position + end_position - 2)\r\n            start_position = start_position + end_position\r\n        end if\r\n    end do\r\n\r\n\r\n    return\r\nend subroutine split_string\r\n"}, {"instruction": "Create a Fortran subroutine named mult that takes 3 input parameters: two integers and an array of real*8. The output parameter is an array of real*8. The subroutine calculates the square of each element in the input array and sums them up to produce the output array.", "input": "", "output": "subroutine mult(nx, ny, x, y)\n\n  implicit none\n\n  integer, intent(in) :: nx, ny\n  real*8, intent(in) :: x(nx)\n  real*8, intent(out) :: y(ny)\n\n  integer :: i, j\n\n  y(:) = 0.\n\n  do j=1,ny\n    do i=1,nx\n      y(j) = y(j) + x(i)**2\n    end do\n  end do\n\nend subroutine mult\n"}, {"instruction": "Create a Fortran subroutine named int_to_string that takes an integer argument and converts it into an equivalent string. The subroutine should have 1 input parameter with the test_data type ['integer'], and 1 output parameter with the test_data type ['character(len=*)'].", "input": "", "output": "  subroutine int_to_string(arg, str)\r\n    ! converts an integer argument into an equivalent string\r\n    implicit none\r\n    integer, intent(in) :: arg\r\n    character(len=*), intent(out) :: str\r\n    character(len=20) :: tmp   ! to prevent i/o errors\r\n    write(tmp, *) arg\r\n    str = adjustl(tmp)\r\n  end subroutine int_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named real_to_string to convert a real number into a string. The subroutine should take 1 input parameter of type real and produce 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine real_to_string(arg, str)\r\n    ! converts a real argument into a string\r\n    implicit none\r\n    real, intent(in) :: arg\r\n    character(len=*), intent(out) :: str\r\n    character(len=20) :: tmp   ! to prevent i/o errors\r\n    write(tmp, *) arg\r\n    str = adjustl(tmp)\r\n  end subroutine real_to_string\r\n"}, {"instruction": "Create a Fortran subroutine named average to calculate the average of an array of real numbers. The subroutine should have 1 input parameter of type real, dimension(:) and intent(in), and 1 output parameter of type real and intent(out).", "input": "", "output": "\tsubroutine average(inp, avg)\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: avg\n\t  avg = sum(inp) / size(inp)\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"variance\" to calculate the variance of a set of real numbers. The subroutine must take an array of real numbers as input with the test_data type ['real, dimension(:)'] and provide the variance as output with the test_data type ['real'].", "input": "", "output": "\tsubroutine variance(inp, var)\n\t  real :: avg\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: var\n\t  avg = sum(inp) / size(inp)\n\t  var = sum((inp - avg) ** 2) / (size(inp) - 1)\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rawmoment to calculate the raw moment of a given array. The subroutine has 2 input parameters: an integer ord and a real array inp. The output parameter is a real value rwmmt.", "input": "", "output": "\tsubroutine rawmoment(inp, rwmmt, ord)\n\t  integer, intent(in) :: ord\n\t  real, dimension(:), intent(in) :: inp(:)\n\t  real, intent(out) :: rwmmt\n\t  rwmmt = sum(inp ** ord) / size(inp)\n\tend subroutine \n"}, {"instruction": "Create a Fortran subroutine named magneticf to compute the magnetic field vector in Cartesian coordinates. The subroutine takes 1 input parameter of type real(kind=8), dimension(:,:), and produces 1 output parameter of type real(kind=8), dimension(:,:). The subroutine uses the imperative tone to specify the calling sequence and describe the purpose of the inputs and outputs.", "input": "", "output": "subroutine magneticf(v,b)\n\t!----------------------------------------------------------\n\t! magnetic field computation.\n\t! calling sequence: call magneticf(v,b)\n\t! inputs:  v: position vector in cartesian coordinates\n\t! outputs: b: magnetic field vector in cartesian coordinate (tesla)\n\t!----------------------------------------------------------\n\treal(kind=8), dimension(:,:),intent(in)  :: v\n\treal(kind=8), dimension(:,:),intent(out) :: b\n\n\tb(1,:)=0. \n\tb(2,:)=0.\n\tb(3,:)=b0*(v(3,:)/z0b)**(-3)\n\nend subroutine magneticf\n"}, {"instruction": "Create a Fortran subroutine named trans_latlon to convert spherical coordinates (latitude and longitude) to another coordinate system. The subroutine takes 4 input parameters of type real (tph0d, tlm0d, tlm(:), tph(:)) and returns 2 output parameters of type real (alm(:,:), aph(:,:)).", "input": "", "output": "   subroutine trans_latlon (tph0d, tlm0d, tlm, tph, alm, aph)\n\n   real, intent(in)  :: tph0d, tlm0d, tlm(:), tph(:)\n   real, intent(out) :: alm(:,:), aph(:,:)\n\n   real :: dtr, pi, tph0, tlm0, stph0, ctph0, ttph0, cc, ee\n   real, dimension(size(tph)) :: stph, ctph\n   integer :: i, j\n\n!-----------------------------------------------------------------------\n\n    ! scalars\n      pi  = 2.*acos(0.0)\n      dtr  = pi/180.\n      tph0 = tph0d*dtr;  tlm0 = tlm0d*dtr\n      stph0 = sin(tph0); ctph0 = cos(tph0)\n      ttph0 = stph0/ctph0\n\n!     ------- compute actual lat and lon -------\n      stph = sin(tph)\n      ctph = cos(tph)\n      do j = 1, size(aph,2)\n      do i = 1, size(aph,1)\n         cc = ctph(j)*cos(tlm(i))\n         aph(i,j) = asin(ctph0*stph(j)+stph0*cc)\n         ee = cc/(ctph0*cos(aph(i,j))) - tan(aph(i,j))*ttph0\n         ee = min(ee,1.)\n         if (tlm(i) > pi) then\n             alm(i,j) = tlm0-acos(ee)\n         else\n             alm(i,j) = tlm0+acos(ee)\n         endif\n      enddo\n      enddo\n\n!-----------------------------------------------------------------------\n\nend subroutine trans_latlon\n"}, {"instruction": "Create a Fortran subroutine named find_inds_gxp to interpolate the values of an array x to the locations specified by array xv, and store the indices in arrays ix and iy. The subroutine takes 3 input parameters of type real(kind=8), dimension(:) and 2 output parameters of type integer, dimension(size(x)).", "input": "", "output": "      subroutine find_inds_gxp(x,p,xv,ix,iy)\n          real(kind=8), dimension(:), intent(in) :: x,p,xv\n          integer, dimension(size(x)) :: one, two, zero\n          integer, intent(out), dimension(size(x)) :: ix,iy\n          real(kind=8), dimension(size(x)) :: xx\n          integer :: nx\n          two=2; one=1; zero=0\n          nx=size(xv)\n          \n          ! first interpolate to g(x) locations for all p arrays:\n          xx=log(x); ix=int((xx-xv(1))/(xv(nx)-xv(1))*(nx))\n          ix = merge(merge(ix,one,ix.gt.one),nx-1,ix.lt.(nx-1))\n          iy = merge(merge(one,zero,p.gt.3.2d0),two,p.lt.5d0)\n      end subroutine find_inds_gxp\n"}, {"instruction": "Write a Fortran subroutine named ind2sub that calculates the subscripts corresponding to a linear index for an array with given dimensions. The subroutine takes 2 input parameters: an array of integers representing the dimensions of the array and an integer representing the linear index. It produces 1 output parameter: an array of integers representing the subscripts corresponding to the linear index.", "input": "", "output": "subroutine ind2sub(dims,ind,subs)\n    !+ calculate the subscripts `subs` into an array with dimensions `dims`\n    !+ given the corresponding linear index `ind`\n    integer, dimension(:), intent(in)  :: dims\n        !+ dimensions of array\n    integer, intent(in)                :: ind\n        !+ linear index\n    integer, dimension(:), intent(out) :: subs\n        !+ subscripts corresponding to the linear index\n\n    integer :: i, ndims, ind1, ind2\n\n    ind1=ind\n    ndims = size(dims)\n    do i=1,ndims-1\n        ind2 = (ind1-1)/dims(i) + 1\n        subs(i) = ind1 - dims(i)*(ind2-1)\n        ind1 = ind2\n    enddo\n    subs(ndims) = ind1\n\nend subroutine ind2sub\n"}, {"instruction": "Write a Fortran subroutine named time_average to compute the time-averaged flux over a given time interval. The subroutine takes 3 input parameters: an array of real numbers t, an integer it, and a 2D array of real numbers flx. It produces 1 output parameter: an array of real numbers flxavg.", "input": "", "output": "   subroutine time_average(t, it, flx, flxavg)\n\n      implicit none\n\n      real, dimension(:), intent(in) :: t\n      integer, intent(in) :: it\n      real, dimension(:, :), intent(in) :: flx\n      real, dimension(:), intent(out) :: flxavg\n\n      integer :: i, nt\n\n      nt = size(t)\n\n      flxavg = 0.5 * (t(it + 1) - t(it)) * flx(:, it)\n      do i = it + 1, nt - 1\n         flxavg = flxavg + (t(i + 1) - t(i)) * flx(:, i)\n      end do\n      flxavg = flxavg + 0.5 * (t(nt) - t(nt - 1)) * flx(:, nt)\n\n      flxavg = flxavg / (t(nt) - t(it))\n\n   end subroutine time_average\n"}, {"instruction": "Create a Fortran subroutine named get_indices_of_cluster to retrieve the indices of points belonging to a specific cluster. The subroutine takes 2 input parameters of type 'integer, dimension(:)' and 'integer', and 1 output parameter of type 'integer, allocatable, dimension(:)'. Use the imperative tone in your instructions.", "input": "", "output": "    subroutine get_indices_of_cluster(cluster_list,points,i_cluster)\n        implicit none\n        integer, dimension(:), intent(in)                 :: cluster_list\n        integer, intent(out), allocatable, dimension(:)   :: points\n        integer, intent(in)                               :: i_cluster\n\n        integer :: nlive,npoints,j\n\n        nlive = count(cluster_list==i_cluster)\n\n        if(allocated(points)) deallocate(points)\n\n        allocate( points(nlive) )\n\n        npoints=0\n        do j=1,size(cluster_list)\n            if(cluster_list(j)==i_cluster) then\n                npoints = npoints+1\n                points(npoints) = j\n            end if\n        end do\n\n\n    end subroutine get_indices_of_cluster\n"}, {"instruction": "Write a Fortran subroutine named pw_rp to calculate the Riemann solver and the waves. The subroutine takes 7 input parameters of types integer and double precision, and 2 output parameters of type double precision.", "input": "", "output": "subroutine pw_rp(meqn,maux,mwaves,q_l,q_r,aux_l,aux_r,wave,s)\n\n    implicit none\n    integer, intent(in) :: meqn,maux,mwaves\n    double precision, intent(in) :: q_l(1:meqn), q_r(1:meqn)\n    double precision, intent(in) :: aux_l(1:maux), aux_r(1:maux)\n    double precision, intent(out) :: wave(1:meqn,1:mwaves),s(1:mwaves)\n    \n    integer :: p\n    \n    do p=1,mwaves\n        wave(:,p) = q_l(:) + q_r(:)\n        s(p) = (aux_l(p) + aux_r(p)) / 2.d0\n    enddo\n\nend subroutine pw_rp\n"}, {"instruction": "Write a Fortran subroutine named simp to implement Simpson's rule for numerical integration. The subroutine takes 3 input parameters of type real(8), integer(4), and integer(4), and 1 output parameter of type real(8). The input parameters are y, m, and n, while the output parameter is sum.", "input": "", "output": "subroutine simp(y,m,n,sum)\n    implicit none\n!\n!         simpson's rule\n!\n    real(8), intent(in) :: y\n    real(8), intent(out) :: sum\n    integer(4), intent(in) :: m,n\n    integer(4) :: k,k1,k2\n    dimension y(21)\n    sum=0.\n    k1=m+1\n    k2=n-1\n    do k=k1,k2,2\n        sum=sum+y(k-1)+4.*y(k)+y(k+1)\n    end do\n    sum=sum/3.\n    return\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named vecpro to calculate the tridimensional vectorial product of two three-dimensional vectors, v1 and v2, and store the result in v3. The number of input parameters is 2 with the test_data type ['real(kind=8)', 'real(kind=8)'], and the number of output parameters is 1 with the test_data type ['real(kind=8)']. Use the imperative tone in your explanation.", "input": "", "output": "subroutine vecpro(v1,v2,v3)\r\n!*****************************************************************************\r\n!\r\n!**** tridimensional vectorial product of two vectors  v1 x v2 -> v3\r\n!\r\n!*****************************************************************************\r\nimplicit none\r\n\r\n  !--- dummy variables\r\n  real(kind=8),intent(in) :: v1(3), v2(3)\r\n  real(kind=8),intent(out):: v3(3)\r\n\r\n  v3(1) = v1(2)*v2(3) - v1(3)*v2(2)   !first component of vectorial product\r\n  v3(2) = v1(3)*v2(1) - v1(1)*v2(3)   !second component of vectorial product\r\n  v3(3) = v1(1)*v2(2) - v1(2)*v2(1)   !third component of vectorial product\r\n\r\nreturn\r\nend subroutine vecpro\r\n"}, {"instruction": "Write a Fortran subroutine named da_interpolate_3d to perform trilinear interpolation on a 3D field at a specified grid location. The subroutine takes 7 input arguments of type integer, integer, integer, real, real, real, and real, representing the grid dimensions, the x, y, z coordinates, and the 3D field to interpolate. It also takes 1 output argument of type real, representing the interpolated value at the specified location. Use the imperative tone while providing instructions for the subroutine.", "input": "", "output": "subroutine da_interpolate_3d( ni, nj, nk, x, y, z, field, h )\n\n   implicit none\n   integer, intent(in)   :: ni, nj, nk\n   real, intent(in)      :: x, y, z      !  grid location of point.\n   real, intent(in)      :: field(1:ni,1:nj,1:nk) ! field to interpolate.\n   real, intent(out)     :: h            ! interpolated value.\n\n   integer               :: ii, jj, kk   ! grid locators.\n   real                  :: dx, dy, dz   ! interpolation weights.\n   real                  :: h1, h2       ! interpolation values.\n   real                  :: h_below      ! 2d interp values.\n   real                  :: h_above      ! 2d interp values.\n\n   ii = int(x)\n   jj = int(y)\n   kk = int(z)\n\n   dx = x - real(ii)\n   dy = y - real(jj)\n   dz = z - real(kk)\n\n!  2d interpolation on layer below:\n   h1 = ( 1.0 - dx ) * field(ii,jj,kk)   + dx * field(ii+1,jj,kk)\n   h2 = ( 1.0 - dx ) * field(ii,jj+1,kk) + dx * field(ii+1,jj+1,kk)\n   h_below = ( 1.0 - dy ) * h1 + dy * h2\n\n!  2d interpolation on layer above:\n   h1 = ( 1.0 - dx ) * field(ii,jj,kk+1)   + dx * field(ii+1,jj,kk+1)\n   h2 = ( 1.0 - dx ) * field(ii,jj+1,kk+1) + dx * field(ii+1,jj+1,kk+1)\n   h_above = ( 1.0 - dy ) * h1 + dy * h2\n\n!  interpolation in vertical:\n   h = ( 1.0 - dz ) * h_below + dz * h_above\n\nend subroutine da_interpolate_3d\n"}, {"instruction": "Create a Fortran subroutine named compact_support to calculate the compactly-supported correlation based on the Gaspari and Cohn (1999) method. The subroutine takes 5 input parameters of type real: x1, x2, y1, y2, cov_loc_rad, and 1 output parameter of type real: corr.", "input": "", "output": "subroutine compact_support( x1, x2, y1, y2, cov_loc_rad, corr )\n\n!  compact support according to (4.10) of gaspari and cohn (1999).\n\n!  assumes r >=0.\n\n   implicit none\n\n   real, intent(in)     :: x1, x2         ! x values of two points.\n   real, intent(in)     :: y1, y2         ! y values of two points.\n   real, intent(in)     :: cov_loc_rad    ! cut-off correlation > 2c.\n   real, intent(out)    :: corr           ! compactly-supported correlation.\n\n   real                 :: z              ! distance between points.\n   real                 :: r              ! ratio.\n   real                 :: r2, r3, r4, r5 ! powers of r.\n\n   z = sqrt( ( x2 - x1 )**2 + ( y2 - y1)**2 )\n   r = z / cov_loc_rad\n\n   r2 = r * r\n   r3 = r2 * r\n   r4 = r3 * r\n   r5 = r4 * r\n\n   if ( r <= 1.0 ) then\n      corr = -0.25 * r5 + 0.5 * r4 + 0.625 * r3 - 5.0 * r2 / 3.0 + 1\n   else if ( r > 1.0 .and. r < 2.0 ) then\n      corr = r5 / 12.0 - 0.5 * r4 + 0.625 * r3 + 5.0 * r2 / 3.0 - &\n             5.0 * r + 4.0 - 2.0 / ( 3.0 * r )\n\n   else if ( r >= 2.0 ) then\n      corr = 0.0\n   end if\n\nend subroutine compact_support\n"}, {"instruction": "Create a Fortran subroutine named dmatinv3 to compute the inverse of a 3x3 matrix. The input parameter is a 3x3 double precision matrix, and the output parameters are a 3x3 double precision matrix and an integer representing the error status.", "input": "", "output": "    subroutine dmatinv3(a,b,ierr)\n         !! performs a direct calculation of the inverse of a 3\u00d73 matrix.\n         double precision,dimension(3,3), intent(in) :: a  !! matrix\n         double precision,dimension(3,3), intent(out) :: b(3,3)   !! inverse matrix\n         integer, intent(out) :: ierr\n         double precision             :: detinv\n!\n         !integer for error status (0 ... no error, 1 ... singular matrix)\n         ierr = 0\n!\n         !calculate the inverse determinant of the matrix\n         detinv = (a(1,1)*a(2,2)*a(3,3) - a(1,1)*a(2,3)*a(3,2)&\n                   - a(1,2)*a(2,1)*a(3,3) + a(1,2)*a(2,3)*a(3,1)&\n                   + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1))\n!\n         if(detinv.eq.0.d0) then\n           ierr = 1\n           b = 0.d0\n           print *,\"error in dmatinv3: matrix is singular - inverse matrix doesn't exist.\"\n           stop\n         endif\n!\n         detinv = 1/detinv\n!\n         ! calculate the inverse of the matrix\n         b(1,1) = +detinv * (a(2,2)*a(3,3) - a(2,3)*a(3,2))\n         b(2,1) = -detinv * (a(2,1)*a(3,3) - a(2,3)*a(3,1))\n         b(3,1) = +detinv * (a(2,1)*a(3,2) - a(2,2)*a(3,1))\n         b(1,2) = -detinv * (a(1,2)*a(3,3) - a(1,3)*a(3,2))\n         b(2,2) = +detinv * (a(1,1)*a(3,3) - a(1,3)*a(3,1))\n         b(3,2) = -detinv * (a(1,1)*a(3,2) - a(1,2)*a(3,1))\n         b(1,3) = +detinv * (a(1,2)*a(2,3) - a(1,3)*a(2,2))\n         b(2,3) = -detinv * (a(1,1)*a(2,3) - a(1,3)*a(2,1))\n         b(3,3) = +detinv * (a(1,1)*a(2,2) - a(1,2)*a(2,1))\n       end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calch8nablashape to calculate the natural coordinate derivatives of the shape functions. The subroutine takes 3 input parameters of type real (fxi, feta, fzeta) and returns an output parameter of type real array with 24 elements (fads).", "input": "", "output": "subroutine calch8nablashape(fxi, feta, fzeta, fads)\n\timplicit none\n\n\treal, intent(in) :: fxi, feta, fzeta\n\treal, intent(out) :: fads(24)\n\treal, parameter :: fsq125 = 0.35355339059327376220042218105242\n\treal fxip, fetap, fzetap, fxim, fetam, fzetam\n\n! main routine\n\tfxip = (1d0 + fxi) * fsq125\n\tfetap = (1d0 + feta) * fsq125\n\tfzetap = (1d0 + fzeta) * fsq125\n\tfxim = (1d0 - fxi) * fsq125\n\tfetam = (1d0 - feta) * fsq125\n\tfzetam = (1d0 - fzeta) * fsq125\n\n! calculation of natural coordinate derivatives of the shape functions\n! corresponding to xi\n\tfads(1) = - fetam * fzetam\n\tfads(2) = - fads(1)\n\tfads(3) = fetap * fzetam\n\tfads(4) = - fads(3)\n\tfads(5) = - fetam * fzetap\n\tfads(6) = - fads(5)\n\tfads(7) = fetap * fzetap\n\tfads(8) = - fads(7)\n! corresponding to eta\n    fads(9) = - fxim * fzetam\n    fads(10) = - fxip * fzetam\n    fads(11) = - fads(10)\n    fads(12) = - fads(9)\n\tfads(13) = - fxim * fzetap\n\tfads(14) = - fxip * fzetap\n\tfads(15) = - fads(14)\n\tfads(16) = - fads(13)\n! corresponding to zeta\n\tfads(17) = - fxim * fetam\n\tfads(18) = - fxip * fetam\n\tfads(19) = - fxip * fetap\n\tfads(20) = - fxim * fetap\n\tfads(21) = - fads(17)\n\tfads(22) = - fads(18)\n\tfads(23) = - fads(19)\n\tfads(24) = - fads(20)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"lonecelllocate\" that takes a 3D array of logical values as input and outputs another 3D array of logical values. The subroutine aims to identify and mark the lone cells within the input array based on specific conditions. The number of input arguments is 1, and the test_data type is ['logical, dimension(:,:,:)']. The number of output arguments is 1, and the test_data type is ['logical, dimension(:,:,:)'].", "input": "", "output": "    subroutine lonecelllocate( fail, lonecell )\n\n      logical, dimension(:,:,:), intent(in) :: fail\n      logical, dimension(:,:,:), intent(out) :: lonecell\n\n      integer :: i, j, k\n      logical, dimension(3,3,3) :: cornermask\n\n      cornermask = .false.\n      do k = 1, 3, 2\n        do j = 1, 3, 2\n          do i = 1, 3, 2\n            cornermask(i,j,k) = .true.\n          end do\n        end do\n      end do\n      \n      lonecell = .false. \n      do k = 2, size(fail, dim=3) - 1 \n        do j = 2, size(fail, dim=2) - 1\n          do i = 2, size(fail, dim=1) - 1\n\n            if ( .not.fail(i,j,k) ) cycle \n            if ( any( fail(i-1:i+1,j-1:j+1,k-1:k+1) .and. cornermask ) ) cycle\n            lonecell(i,j,k) = .true.\n\n            write(*,*) i,j,k \n\n          end do\n        end do\n      end do\n\n    end subroutine lonecelllocate\n"}, {"instruction": "Create a Fortran subroutine named weno5 to implement the Weighted Essentially Non-Oscillatory (WENO) scheme. The subroutine takes 4 input parameters of type integer and double precision, and 2 output parameters of type double precision. The subroutine calculates the left and right states using the WENO scheme for a given set of input data.", "input": "", "output": "subroutine weno5(q, ql, qr, num_eqn, maxnx, num_ghost)\n\n  implicit none\n\n  integer,          intent(in)  :: num_eqn, maxnx, num_ghost\n  double precision, intent(in)  :: q(num_eqn,maxnx+2*num_ghost)\n  double precision, intent(out) :: ql(num_eqn,maxnx+2*num_ghost), qr(num_eqn,maxnx+2*num_ghost)\n\n  integer :: i, m\n  double precision :: sigma0, &\nsigma1, &\nsigma2, &\nomega1, &\nomega5, &\nomega0, &\nomega4, &\nomega3, &\nomega2, &\nfr1, &\nfr5, &\nfr0, &\nfr4, &\nfr3, &\nfr2, &\nfs0, &\nfs1\n\n  do i = num_ghost-1, maxnx+num_ghost+1\n    do m = 1, num_eqn\n      sigma0 = 3.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      10.333333333333333333333333333333333d0*q(m,i+0)*q(m,i+1) + &\n      3.6666666666666666666666666666666667d0*q(m,i+0)*q(m,i+2) + &\n      8.3333333333333333333333333333333333d0*q(m,i+1)**2 - &\n      6.3333333333333333333333333333333333d0*q(m,i+1)*q(m,i+2) + &\n      1.3333333333333333333333333333333333d0*q(m,i+2)**2\nsigma1 = 4.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      4.3333333333333333333333333333333333d0*q(m,i+0)*q(m,i+1) - &\n      4.3333333333333333333333333333333333d0*q(m,i+0)*q(m,i-1) + &\n      1.3333333333333333333333333333333333d0*q(m,i+1)**2 + &\n      1.6666666666666666666666666666666667d0*q(m,i+1)*q(m,i-1) + &\n      1.3333333333333333333333333333333333d0*q(m,i-1)**2\nsigma2 = 3.3333333333333333333333333333333333d0*q(m,i+0)**2 - &\n      10.333333333333333333333333333333333d0*q(m,i+0)*q(m,i-1) + &\n      3.6666666666666666666666666666666667d0*q(m,i+0)*q(m,i-2) + &\n      8.3333333333333333333333333333333333d0*q(m,i-1)**2 - &\n      6.3333333333333333333333333333333333d0*q(m,i-1)*q(m,i-2) + &\n      1.3333333333333333333333333333333333d0*q(m,i-2)**2\nomega0 = 0.1d0/(1.0e-36 + sigma0)**2\nomega1 = 0.6d0/(1.0e-36 + sigma1)**2\nomega2 = 0.3d0/(1.0e-36 + sigma2)**2\nomega3 = 0.3d0/(1.0e-36 + sigma0)**2\nomega4 = 0.6d0/(1.0e-36 + sigma1)**2\nomega5 = 0.1d0/(1.0e-36 + sigma2)**2\nfr0 = 1.8333333333333333333333333333333333d0*q(m,i+0) - &\n      1.1666666666666666666666666666666667d0*q(m,i+1) + &\n      0.33333333333333333333333333333333333d0*q(m,i+2)\nfr1 = 0.83333333333333333333333333333333333d0*q(m,i+0) - &\n      0.16666666666666666666666666666666667d0*q(m,i+1) + &\n      0.33333333333333333333333333333333333d0*q(m,i-1)\nfr2 = 0.33333333333333333333333333333333333d0*q(m,i+0) + &\n      0.83333333333333333333333333333333333d0*q(m,i-1) - &\n      0.16666666666666666666666666666666667d0*q(m,i-2)\nfr3 = 0.33333333333333333333333333333333333d0*q(m,i+0) + &\n      0.83333333333333333333333333333333333d0*q(m,i+1) - &\n      0.16666666666666666666666666666666667d0*q(m,i+2)\nfr4 = 0.83333333333333333333333333333333333d0*q(m,i+0) + &\n      0.33333333333333333333333333333333333d0*q(m,i+1) - &\n      0.16666666666666666666666666666666667d0*q(m,i-1)\nfr5 = 1.8333333333333333333333333333333333d0*q(m,i+0) - &\n      1.1666666666666666666666666666666667d0*q(m,i-1) + &\n      0.33333333333333333333333333333333333d0*q(m,i-2)\nfs0 = (fr0*omega0 + fr1*omega1 + fr2*omega2)/(omega0 + omega1 + omega2)\nfs1 = (fr3*omega3 + fr4*omega4 + fr5*omega5)/(omega3 + omega4 + omega5)\nql(m,i) = fs0\nqr(m,i) = fs1\n    end do\n  end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named readklist to read data from a file and store it in arrays. The subroutine takes 2 input parameters of type character*100 and integer, and 2 output parameters of type real*8 and integer. The input parameters are used to specify the file to be read and the number of k points. The output parameters store the weights and k vectors read from the file.", "input": "", "output": "subroutine readklist(fklist, nkpt, kvec, wgh)\n  implicit none\n  character*100, intent(in) :: fklist\n  integer, intent(in)       :: nkpt\n  real*8, intent(out)       :: wgh(nkpt)\n  integer, intent(out)      :: kvec(4,nkpt)\n  ! locals\n  integer      :: numkpt, ik, ios\n  character*10 :: kname\n  \n  open(14,file=fklist,status='old',form='formatted')\n  do ik=1,nkpt\n     read (14,'(a10,4i5,3f5.2,a3)',iostat=ios) kname, kvec(1,ik), kvec(2,ik), kvec(3,ik), kvec(4,ik), wgh(ik)\n     !print *, 'kname=', kname, 'kv=', kvec(1,ik), kvec(2,ik), kvec(3,ik), kvec(4,ik)\n     if (kname .eq. 'end       ' .or. ios.ne.0) then\n        print *, 'error in reading ', trim(fklist)\n        exit\n     endif\n  enddo\n  close(14)\nend subroutine readklist\n"}, {"instruction": "Create a Fortran subroutine named \"fobf\" to implement the Fast Ordering by Binary Descent (FOBF) algorithm. The subroutine should take 4 input parameters of types ['double precision, dimension(:,:)', 'integer', 'integer', 'integer'], and 1 output parameter of type ['integer, dimension(nmax)']. The subroutine should be programmed in the imperative tone.", "input": "", "output": "subroutine fobf(features, seed, nmax, nmem, final_ordering)\n\n    implicit none\n\n    double precision, dimension(:,:), intent(in) :: features\n    integer, intent(in) :: seed\n    integer, intent(in) :: nmax\n    integer, intent(in) :: nmem\n    integer, dimension(nmax), intent(out) :: final_ordering\n\n    integer, allocatable, dimension(:) :: ordering\n\n    integer :: nsamples, nfeatures\n    integer :: i, j, k, idx, n, m, p\n    double precision :: maxdist,  d, huge_double\n\n    nsamples = size(features,dim=1)\n    nfeatures = size(features, dim=2)\n\n    ! allocate temporary\n    allocate(ordering(nsamples))\n    huge_double = huge(1.0d0)\n\n    ! initialize the ordering\n    ordering = (/ (i, i = 1, nsamples) /)\n\n    ! the first item will be the seed\n    ordering(seed) = ordering(1)\n    ordering(1) = seed\n\n\n    ! todo: parallelise in some way, ie. threadlocking maxdist\n    ! do the actual algorithm\n    do i = 2, nmax\n        p = ordering(i)\n        maxdist = 0.0d0\n        idx = i\n        do j = i, nsamples\n            n = ordering(j)\n            d = huge_double\n            !$omp parallel do reduction(min:d) private(m)\n            do k = max(1, i - nmem), i-1\n                if (d <= maxdist) then\n                    cycle\n                endif\n                m = ordering(k)\n                d = min(sum((features(n,:) - features(m,:))**2),d)\n            enddo\n            !$omp end parallel do\n\n            ! having this outside the loop is somewhat faster\n            if (d > maxdist) then\n                idx = j\n                maxdist = d\n            endif\n        enddo\n\n        ordering(i) = ordering(idx)\n        ordering(idx) = p\n    enddo\n\n    ! generate output in python format\n    final_ordering = ordering(:nmax) -1\n\n    ! deallocate temporary\n    deallocate(ordering)\n\nend subroutine fobf\n"}, {"instruction": "Create a Fortran subroutine named getlinquadth to calculate the linear and quadratic transformations of the input latent vectors. The subroutine takes 3 input parameters of type real(kind=8) and outputs 2 parameters of type real(kind=8). The linear transformation is computed using matmul(lintheta,thpr), and the quadratic transformation is calculated using a loop over the rows of quadtheta and the matmul function.", "input": "", "output": "subroutine getlinquadth(lintheta,quadtheta,thpr,linth,quadth)\r\nimplicit none\r\n\r\n\r\nreal(kind=8),intent(in)::lintheta(:,:),quadtheta(:,:,:),thpr(:)\r\nreal(kind=8),intent(out)::linth(:),quadth(:,:)\r\n!\trow counts elements of the underlying latent vector.\r\ninteger::row\r\nlinth=matmul(lintheta,thpr)\r\ndo row=1,size(linth)\r\n\tquadth(row,:)=matmul(quadtheta(row,:,:),thpr)\r\nend do\r\nreturn\r\nend subroutine getlinquadth\n"}, {"instruction": "Write a Fortran subroutine named \"pzxc\" to calculate the exchange-correlation energy and its derivative with respect to density. The subroutine takes 1 input parameter of type real(8) and provides 2 output parameters of type real(8).", "input": "", "output": "  subroutine pzxc(trho,exc,dexc_drho)\n    implicit none\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gammau=-0.1423d0,beta1u=1.0529d0\n    real(8),parameter :: beta2u=0.3334d0,au=0.0311d0,bu=-0.048d0\n    real(8),parameter :: cu=0.002d0,du=-0.0116d0\n    real(8),parameter :: const = 0.75d0*(3d0/(2d0*pi))**(2d0/3d0)\n    real(8) :: ttrho,rs,rssq,rsln\n    real(8),intent(in) :: trho\n    real(8),intent(out) :: exc\n    real(8),intent(out) :: dexc_drho\n\n\n    ttrho=trho+1d-10\n    rs=(3d0/(4*pi*ttrho))**(1d0/3d0)\n    exc=-const/rs\n    dexc_drho=exc/(3*ttrho)\n    if (rs>1d0) then\n      rssq=sqrt(rs)\n      exc=exc+gammau/(1d0+beta1u*rssq+beta2u*rs)\n      dexc_drho=dexc_drho+gammau*(0.5d0*beta1u*rssq+beta2u*rs)/(3*ttrho)/(1+beta1u*rssq+beta2u*rs)**2\n    else\n      rsln=log(rs)\n      exc=exc+au*rsln+bu+cu*rs*rsln+du*rs\n      dexc_drho=dexc_drho-rs/(3*ttrho)*(au/rs+cu*(rsln+1)+du)\n    endif\n    return\n  end subroutine pzxc\n"}, {"instruction": "Write a Fortran subroutine named cycle_ints which takes an array of 64-bit integers as input and produces an array of 64-bit integers as output. The subroutine cycles through the input array and assigns the values to the output array in a circular manner.", "input": "", "output": "    subroutine cycle_ints(output, input)\n        integer(8), intent(in) :: input(:)\n        integer(8), intent(out) :: output(:)\n        integer :: i\n\n        do i = 1, size(output, 1)\n            output(i) = input(mod(i - 1, size(input, 1)) + 1)\n        end do\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named psm_to_tdsm_size_mt_eikonal to calculate the perfect number of grid points for a given psm based on specified maximum dx, dy and dt. The subroutine takes 4 input parameters of type real (sizex, sizey, maxdx, maxdy) and returns 2 output parameters of type integer (nx, ny).", "input": "", "output": "    subroutine psm_to_tdsm_size_mt_eikonal( sizex, sizey, maxdx, maxdy, nx, ny)\n    \n      ! given a psm, determine perfect number of grid points\n      ! based on wanted maxdx, maxdy and maxdt\n    \n        real, intent(in) :: sizex,sizey\n        real, intent(in) :: maxdx, maxdy\n        integer, intent(out) :: nx, ny\n  \n        nx = floor(sizex/maxdx) + 1\n      ! need at least 2 points to get partial deriv. depend on length\n        if (nx .le. 1) nx = 2\n      ! a line source may be made with width=0\n        if (sizex .eq. 0.) nx = 1\n        \n        ny = floor(sizey/maxdy) + 1\n      ! need at least 2 points to get partial deriv. depend on width\n        if (ny .le. 1) ny = 2\n      ! a point source (or simultaneous line source) may be made with length=0\n        if (sizey .eq. 0.) ny = 1\n        \n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named xeuc to calculate the Euclidean distance matrix for a set of data points. The subroutine should take 3 input parameters: two integers 'n' and 'd', and a 2D array 'x' of type double precision. Additionally, it should have one output parameter, a 2D array 'euclidean' of type double precision.", "input": "", "output": "      subroutine xeuc(n,d,x,euclidean)\n      implicit none\n      integer, intent(in):: n, d\n      double precision, intent(in):: x(n,d)\n      double precision, intent(out):: euclidean(n,n)\n      integer:: i, j, ii, k\n      double precision:: euc\n      do j=1,n\n        ii=0\n        do i=1,n\n          euc=0.0d0\n          do k=1,d\n            euc=euc+(x(i,k)-x(j,k))**2\n          end do\n          euc=sqrt(euc)\n          euclidean(i,j)=euc\n        end do\n      end do\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named readfields to read and reshape data from a file. The number of input arguments is 1 and the test_data type is ['integer(4)']. The number of output arguments is 2 and the test_data type is ['real(8)', 'real(8)'].", "input": "", "output": " subroutine readfields(timestp,lrfld,varmemsize)\n  implicit none\n  real(8), allocatable    :: torestart(:,:)\n  real(8),    intent(out) :: timestp\n  real(8),    intent(out)  :: lrfld(:,:,:,:)\n  integer(4), intent(in)  :: varmemsize\n  integer(4)              :: datalen,datasize\n  integer(4)              :: matdims(4)\n  integer(4)              :: ferror\n  integer(4)              :: icounter\n\n  matdims=shape(lrfld)\n  datalen=matdims(1)*matdims(2)*matdims(3)\n  datasize=(matdims(4)+1)*datalen*varmemsize\n\n  allocate(torestart(matdims(4)+1,datalen))\n\n  open(unit=1,file=\"restartdata.out\",status='old',form='unformatted',access='direct',iostat=ferror,recl=datasize)\n  read(1,rec=1) torestart\n  close(1)\n  do icounter=1,matdims(4)\n   lrfld(:,:,:,icounter)=reshape(torestart(icounter,:),(/matdims(1),matdims(2),matdims(3)/))\n  end do\n  timestp=torestart(matdims(4)+1,1)\n\n  return\n end subroutine readfields\n"}, {"instruction": "Create a Fortran subroutine named compute_sigma that takes 3 input parameters of type real(kind=dp) array, integer, and integer. The subroutine will produce 1 output parameter of type real(kind=dp) allocatable array. The subroutine initializes the output array sigma with zeros, then populates the diagonal elements with the values from the input array s.", "input": "", "output": "    subroutine compute_sigma(s, nr_rows, nr_cols, sigma)\n        use, intrinsic :: iso_fortran_env, only : dp => real64\n        implicit none\n        real(kind=dp), dimension(:), intent(in) :: s\n        integer, intent(in) :: nr_rows, nr_cols\n        integer :: i, error\n        real(kind=dp), allocatable, dimension(:, :), intent(out) :: sigma\n        allocate(sigma(nr_rows, nr_cols), stat=error)\n        sigma = 0.0_dp\n        do i = 1, min(nr_rows, nr_cols)\n            sigma(i, i) = s(i)\n        end do\n    end subroutine compute_sigma\n"}, {"instruction": "Create a Fortran subroutine named viral_4_eqn to solve a system of four differential equations representing the dynamics of a viral infection. The subroutine takes 11 input parameters of type real and integer, and returns 4 output parameters of type real. The function updates the values of time (t_new), infected individuals in two different stages (i1_new, i2_new), and viral load (v_new) after a specified number of time steps.\n\nThe input parameters are t, i1, i2, v, beta, k, delta_c, p, c, dt, and ntime, representing various parameters of the differential equations. The output parameters are t_new, i1_new, i2_new, and v_new, which represent the updated solution variables after the specified time steps.", "input": "", "output": "subroutine viral_4_eqn(t_new, i1_new, i2_new, v_new, t, i1, i2, v, beta, k, delta_c, p, c, dt, ntime)\n! python call looks like:\n!    t_new, i1_new, i2_new, v_new = viral_4_eqn(t, i1, i2, v, beta, k, delta_c, p, c, dt, ntime)\n\n! *******************************************************************************************\n\n! method and as such the time step size can not be too small e.g. 10 mins or dt = 10. * 60. = 600.\n! don't forget there needs to be a seed of an infected person in the e group.\n! have a look at eqn 2 of modeling-the-viral-dynamics-of-sars-cov-2-infect.pdf\n! *******************************************************************************************\n\n! t_new, i1_new, i2_new, v_new the calculated solution variables after ntime time steps output\n\n\n! dt = time step size\n! ntime = no of time steps\n\n   implicit none\n! dummy variables\n   real, intent(out) :: t_new, i1_new, i2_new, v_new\n   real, intent(in) :: t, i1, i2, v, beta, k, delta_c, p, c, dt\n   integer, intent(in) :: ntime\n\n! local variables\n   integer its, nits, itime ! no of non-linear iterations\n   real t_old, i1_old, i2_old, v_old ! previous time step values of t, i1, i2, v\n\n! execution\n   t_new = t; i1_new = i1; i2_new = i2; v_new = v\n   nits = 3\n\n   do itime = 1, ntime\n      t_old = t_new; i1_old = i1_new; i2_old = i2_new; v_old = v_new\n      \n      do its = 1, nits\n         t_new = t_old + dt * (-beta * v_new * t_new)\n         i1_new = i1_old + dt * (beta * v_new * t_new - k * i1_new)\n         i2_new = i2_old + dt * (k * i1_new - delta_c * i2_new) \n         v_new = v_old + dt * (p * i2_new - c * v_new)\n      end do ! do its = 1, nits\n   end do\n   return\nend subroutine viral_4_eqn\n"}, {"instruction": "Create a Fortran subroutine named trilinearinterpolationpolynomia to calculate trilinear interpolation polynomial coefficients. The subroutine takes one input argument of type real array with dimensions (0:1,0:1,0:1) and one output argument of the same type and dimensions. The input argument is marked as intent(in) and the output argument is marked as intent(out).", "input": "", "output": "subroutine trilinearinterpolationpolynomia(a,f)\r\n        !-------------------------------------------------------------------!\r\n        implicit none\r\n        !-------------------------------------------------------------------!\r\n        real                        :: a   (0:1,0:1,0:1)\r\n        real                        :: f   (0:1,0:1,0:1)\r\n        !-------------------------------------------------------------------!\r\n        intent(out)                 :: a\r\n        intent(in)                  :: f\r\n        !-------------------------------------------------------------------!\r\n        ! local variables\r\n        !-------------------------------------------------------------------!\r\n\r\n        a(0,0,0) =  f(0,0,0)\r\n        a(1,0,0) = -f(0,0,0)+f(1,0,0)\r\n        a(0,1,0) = -f(0,0,0)+f(0,1,0)\r\n        a(0,0,1) = -f(0,0,0)+f(0,0,1)\r\n        a(1,1,0) =  f(0,0,0)-f(0,1,0)-f(1,0,0)+f(1,1,0)\r\n        a(1,0,1) =  f(0,0,0)-f(0,0,1)-f(1,0,0)+f(1,0,1)\r\n        a(0,1,1) =  f(0,0,0)-f(0,0,1)-f(0,1,0)+f(0,1,1)\r\n        a(1,1,1) = -f(0,0,0)+f(1,0,0)+f(0,1,0)+f(0,0,1)-f(1,1,0)-f(1,0,1)-f(0,1,1)+f(1,1,1)\r\n\r\nend subroutine trilinearinterpolationpolynomia\r\n"}, {"instruction": "Write a Fortran subroutine named unmod to perform a modification on an input array of double precision values. The subroutine takes 2 input parameters of type integer and double precision array with a dimension of num_samples. It produces 1 output parameter of type double precision array with a dimension of num_samples. The subroutine modifies the input array based on certain calculations and stores the result in the output array.", "input": "", "output": "  subroutine unmod (x, x_mod, num_samples)\n  integer, intent(in) :: num_samples\n  double precision, dimension(num_samples), intent(in) :: x_mod\n  double precision, dimension(num_samples), intent(out) :: x\n    integer :: i\n    integer :: n\n    double precision :: ph_diff\n    n = 0\n    x = x_mod\n    do i = 2, num_samples\n      x(i) = x(i) + p * n\n      ph_diff = x(i) - x(i-1)\n      if (ph_diff > p2) then\n          n = n-1\n          x(i) = x(i) - p\n      else if (ph_diff < -p2) then\n          n = n+1\n          x(i) = x(i) + p\n      end if\n    end do\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named threshold_data that takes 4 input parameters: an array of double precision numbers of length num_samples, an integer num_samples, a double precision threshold, and an integer n_min. It also has 2 output parameters: an array of integers with dimensions num_samples by 2, and an integer num_segments. The subroutine segments the input data based on the threshold and n_min, and updates the segments array and num_segments accordingly.", "input": "", "output": "  subroutine threshold_data (x, num_samples, threshold, n_min, segments, num_segments)\n  double precision, dimension(num_samples), intent(in) :: x\n  integer, intent(in) :: num_samples\n  double precision, intent(in) :: threshold\n  integer, intent(in) :: n_min\n  integer, dimension(num_samples, 2), intent(out) :: segments\n  integer, intent(out) :: num_segments\n    integer :: n, n0\n    num_segments = 0\n    n0 = 1\n    do n = 1, num_samples\n      if (x(n) < threshold) then\n        if (n-n0 > n_min) then\n          num_segments = num_segments + 1\n          segments(num_segments, 1) = n0\n          segments(num_segments, 2) = n-1\n        end if\n        n0 = n\n      end if\n    end do\n    if (n-n0 > n_min) then\n      num_segments = num_segments + 1\n      segments(num_segments, 1) = n0\n      segments(num_segments, 2) = n-1\n    end if\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"poincare_times_interpolate\" to calculate interpolated return times for a given set of phase values and discrete times. The subroutine takes 5 input parameters of types ['integer, dimension(num_crossings)', 'integer, dimension(num_crossings)', 'integer', 'double precision, dimension(num_samples)', 'integer'], and 2 output parameters of types ['double precision, dimension(num_crossings)', 'double precision, dimension(num_crossings)'].", "input": "", "output": "  subroutine poincare_times_interpolate (idx, ti, num_crossings, x, num_samples, idx_interp, ti_interp)\n\n  ! ti(i) is the discrete time between two crossings\n  ! idx(i) is the index of the step before 0\n  ! x is phase, x[idx(i)] > 0.0\n  ! times are the output where we will store the correct return times (= approx index)\n  ! n: number of approximate zeros that were found\n\n  integer, dimension(num_crossings), intent(in) :: idx, ti\n  integer, intent(in) :: num_crossings\n  double precision, dimension(num_samples), intent(in) :: x\n  integer, intent(in) :: num_samples\n  double precision, dimension(num_crossings), intent(out) :: idx_interp, ti_interp\n\n    integer :: i, j, j1, jj, jj1\n    double precision :: x_j, x_j1, x_jj, x_jj1\n    do i = 1, num_crossings\n      j   = idx(i)     ! index before crossing\n      j1  = idx(i)+1   ! index after crossing\n      jj  = j+ti(i)    ! index before return\n      jj1 = j+ti(i)+1  ! index after return\n\n      !! corresponding phases\n      ! before crossing are close to 'p'\n      x_j   = x(j)-p\n      x_jj  = x(jj)-p\n      ! after crossing are just above zero\n      x_j1  = x(j1)\n      x_jj1 = x(jj1)\n\n      idx_interp(i) = idx(i)- x_j/(x_j1-x_j)\n      ti_interp(i)  = ti(i) + x_j/(x_j1-x_j)-x_jj/(x_jj1-x_jj)\n    end do\n  end subroutine poincare_times_interpolate\n"}, {"instruction": "Create a Fortran subroutine named ini_var. It takes 1 input parameter of type integer and returns 3 output parameters, all of which are of type integer. The subroutine initializes the output parameters lbuf, mxl, and ntestb based on the input parameter lmax(2).", "input": "", "output": "      subroutine ini_var(lbuf, mxl, lmax, ntestb) \n!...translated by pacific-sierra research 77to90  4.3e  12:11:08  11/17/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(out) :: lbuf \n      integer , intent(out) :: mxl \n      integer , intent(out) :: ntestb \n      integer , intent(in) :: lmax(2) \n!-----------------------------------------------\n \n!mrg  lbuf = 96*1027\n      lbuf = 1 \n      mxl = max0(lmax(1),lmax(2)) - 1 \n!. define test level for biotrn : 0 => silence, 1=> just a bit\n!mrg  ntestb = 1\n      ntestb = 15 \n \n      return  \n      end subroutine ini_var \n"}, {"instruction": "Create a Fortran subroutine named set_ncf that takes 3 input arguments of type integer and 2 output arguments of type integer. The input arguments are ncfg, mcfg, and kcfg, and the output arguments are lcfg and ncf. Inside the subroutine, set lcfg to the value of ncfg, ncf(1) to the value of mcfg, and ncf(2) to the value of kcfg. Ensure that the subroutine uses the \"implicit none\" statement to enforce explicit variable declarations.", "input": "", "output": "      subroutine set_ncf(lcfg, ncfg, mcfg, kcfg, ncf) \n!...translated by pacific-sierra research 77to90  4.3e  12:11:08  11/17/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(out) :: lcfg \n      integer , intent(in) :: ncfg \n      integer , intent(in) :: mcfg \n      integer , intent(in) :: kcfg \n      integer , intent(out) :: ncf(2) \n!-----------------------------------------------\n!\n \n      lcfg = ncfg \n      ncf(1) = mcfg \n      ncf(2) = kcfg \n \n      return  \n      end subroutine set_ncf \n"}, {"instruction": "Create a Fortran subroutine named convert_day to convert the day of the year to the month and day. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are iyear and idoy, and the output parameters are imonth and iday.", "input": "", "output": "subroutine convert_day(iyear,idoy,imonth,iday)\n\n\n\n integer, intent(in)   :: iyear\n integer, intent(in)   :: idoy\n integer, intent(out)  :: imonth\n integer, intent(out)  :: iday\n\n integer :: t\n\n t = 0\n if(modulo(iyear, 4) == 0) t = 1\n\n if(modulo(iyear, 400) /= 0 .and. modulo(iyear, 100) == 0) t = 0\n\n iday = idoy\n if(idoy > 59+t) iday = iday + 2 - t\n imonth = ((iday+91)*100)/3055\n iday = (iday+91) - (imonth*3055)/100\n imonth = imonth - 2\n\n if(imonth >= 1 .and. imonth <= 12) return\n write(unit=*,fmt=\"(a,i11,a)\")  &\n \"$$calend: day of the year input =\",idoy,\" is out of range.\"\n stop\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named inrotm to calculate the initial nodal coordinate systems. The subroutine takes 1 input parameter of type real (kind=8) and outputs 1 parameter of the same type.", "input": "", "output": "subroutine inrotm(a,euler)\r\n!***************************************************************\r\n!     calculates the initial nodal coordinate systems\r\n!***************************************************************\r\nimplicit none\r\n\r\nreal (kind=8),intent(in) :: a(3)\r\nreal (kind=8),intent(out) :: euler(9)\r\n\r\nreal (kind=8) :: ca,cb,cg,sa,sb,sg\r\n\r\nif(all(a == 0) ) then\r\n\r\n  euler = (/ 1d0 , 0d0 , 0d0 ,  &\r\n             0d0 , 1d0 , 0d0 ,  &\r\n             0d0 , 0d0 , 1d0 /)\r\n\r\nelse\r\n\r\n  ca = cos(a(1))\r\n  sa = sin(a(1))\r\n  cb = cos(a(2))\r\n  sb = sin(a(2))\r\n  cg = cos(a(3))\r\n  sg = sin(a(3))\r\n\r\n  euler = (/   ca*cg - cb*sa*sg  , ca*cb*sg + cg*sa , sb*sg , &\r\n            - (ca*sg + cb*cg*sa) , ca*cb*cg - sa*sg , cg*sb , &\r\n                   sa*sb         ,      - ca*sb     ,   cb   /)\r\nend if\r\n\r\nreturn\r\nend subroutine inrotm\r\n"}, {"instruction": "Create a Fortran subroutine named \"blk_space\" to calculate the space requirements for the \"blktri\" function. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are \"n\" and \"m\", and the output parameters are \"irwk\" and \"icwk\". The subroutine computes the space requirements based on the values of \"n\" and \"m\" and assigns the results to \"irwk\" and \"icwk\". Use the imperative tone to instruct the creation of this subroutine.", "input": "", "output": "\tsubroutine blk_space(n,m,irwk,icwk)\n\n!       requirements (generous estimate) of blktri for n,m values\n\timplicit none\n\tinteger,intent(in) :: n,m\n\tinteger,intent(out) :: irwk,icwk\n\tinteger :: l,log2n\n!       compute nearest integer greater than or equal to\n!       log base 2 of n+1, i.e., log2n is smallest integer\n!       such that 2**log2n >= n+1\n\tlog2n = 1\n\tdo\n\t   log2n = log2n+1\n\t   if (n+1 <= 2**log2n) exit\n\tend do\n\tl = 2**(log2n+1)\n\tirwk = (log2n-2)*l+5+max0(2*n,6*m)+log2n+2*n\n\ticwk = ((log2n-2)*l+5+log2n)/2+3*m+n\n\treturn\n\tend subroutine blk_space\n"}, {"instruction": "Write a Fortran subroutine named gen_space to calculate the space required for a given pair of integers. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer. The input parameters are n and m, and the output parameter is irwk.", "input": "", "output": "\tsubroutine gen_space(n,m,irwk)\n\n!       requirement (generously) of genbun for the current n,m\n\timplicit none\n\tinteger,intent(in) :: n,m\n\tinteger,intent(out) :: irwk\n\tinteger :: log2n\n!       compute nearest integer greater than or equal to\n!       log base 2 of n+1, i.e., log2n is smallest integer\n!       such that 2**log2n >= n+1\n\tlog2n = 1\n\tdo\n\t   log2n = log2n+1\n\t   if (n+1 <= 2**log2n) exit\n\tend do\n\tirwk = 4*n + (10 + log2n)*m\n\treturn\n\tend subroutine gen_space\n"}, {"instruction": "Create a Fortran subroutine named \"parseline\" that takes a single input of type \"character (len=*)\" and two outputs of type \"character (len=len(line))\". The subroutine should parse the input line to extract keyword-value pairs separated by a colon. If a colon is found, the subroutine should extract the keyword and value, remove any control characters and comments, and return the parsed keyword and value as outputs. If no colon is found, the subroutine should set the keyword output to \"skip\". Remember to include the \"implicit none\" statement and declare all variables.", "input": "", "output": "      subroutine parseline(line,keyword,value)\n      implicit none\n      character (len=*),         intent(in)  :: line\n      character (len=len(line)), intent(out) :: keyword, value\n      character (len=len(line))              :: workingline\n      integer :: i, commentpos, colonpos\n\n!========================================================================!\n!  read keywords and values.                                             !\n!------------------------------------------------------------------------!\n! first, check to see if we have a colon to separate keyword from value  !\n! if there's no colon, we do not have a keyword:value pair.              !\n!========================================================================!\n\n      colonpos = index(line,':')\n      if (colonpos == 0) then\n        keyword = \"skip\"\n        return\n      end if\n\n\n!===============================================!\n!  replace all control characters with spaces.  !\n!===============================================!\n\n      workingline = line\n      do i = 1,len(line)\n       if(iachar(workingline(i:i)) <= 31) workingline(i:i) = ' '\n      end do\n\n\n!===========================================!\n!  keyword is everything before the colon,  !\n!  and value is everything after it.        !\n!===========================================!\n\n      keyword = workingline(1:colonpos-1)\n      value   = workingline(colonpos+1:)\n\n\n!==================================================================!\n!  for both keyword and value, delete everything after a comment.  !\n!==================================================================!\n\n      commentpos  = index(keyword,'!')\n      if(commentpos /= 0) keyword = keyword(1:commentpos-1)\n      commentpos  = index(value,'!')\n      if(commentpos /= 0) value = value(1:commentpos-1)\n\n\n!==================================================!\n!  if the keyword or value is blank, we can skip.  !\n!==================================================!\n\n      if(len_trim(keyword) == 0 .or. len_trim(value) == 0) keyword = \"skip\"\n      return\n      end subroutine parseline\n"}, {"instruction": "Create a Fortran subroutine named func_fort that takes an integer input parameter and returns a double precision output parameter. The subroutine calculates the value of the output parameter based on the input parameter using a do loop and mathematical operations.", "input": "", "output": "    subroutine func_fort(n,d)\n        integer, intent(in) :: n \n        double precision, intent(out) :: d\n        integer :: i\n        d = 0\n        do i=0, n-1\n            d = d + (mod(i,3) - 1) * i\n        end do\n    end subroutine func_fort\n"}, {"instruction": "Create a Fortran subroutine named fill_random that fills an array with random integers based on the specified size and maximum number. The subroutine takes 2 input parameters of type integer: msize and mnumber. It also has 1 output parameter of type integer: array.", "input": "", "output": "subroutine fill_random(msize, mnumber, array)\n    implicit none\n    ! variables\n    integer, intent(in) :: msize\n    integer, intent(in) :: mnumber\n    integer, intent(out) :: array(msize)\n    integer :: i\n\n    ! iterate through the array and fill with random integers capped at mnumber\n    do i = 1, msize\n        array(i) = modulo(irand(), mnumber+1)\n    end do\nend subroutine fill_random\n"}, {"instruction": "Create a Fortran subroutine named cosft_inv to compute the inverse discrete cosine transform (DCT) of a given set of coefficients. The subroutine takes 4 input parameters of type integer, integer, real, and real, and 1 output parameter of type real. The input parameters are n_theta_max, n_theta, a(0:n_theta_max), and theta(n_theta_max), while the output parameter is f(n_theta_max). The subroutine uses the imperative tone and computes the DCT using the given input coefficients and angles.", "input": "", "output": "      subroutine cosft_inv(f, theta, a, n_theta_max, n_theta)\n\n      implicit none\n\n      integer, intent(in) :: n_theta_max, n_theta\n      real, intent(in) :: a(0: n_theta_max), theta(n_theta_max)\n\n      real, intent(out) :: f(n_theta_max)\n\n      integer n, i\n\n\n      do i = 1, n_theta\n         f(i) = 0.0\n         do n = 0, n_theta - 1\n            f(i) = f(i) + a(n) * cos(n * theta(i))\n         end do\n      end do\n\n      return\n\n      end subroutine cosft_inv\n"}, {"instruction": "Create a Fortran subroutine named kern_sqexp to calculate the exponential of the input array xdiff2, and store the results in the output array out. The subroutine takes 2 input parameters: an integer nx and a real(8) array xdiff2 of length nx. It also has 1 output parameter: a real(8) array out of length nx.", "input": "", "output": "subroutine kern_sqexp(nx, xdiff2, out)\n  integer, intent(in) :: nx\n  real(8), intent(in) :: xdiff2(nx)\n  real(8), intent(out) :: out(nx)\n\n  out = exp(-0.5d0*xdiff2)\nend subroutine kern_sqexp\n"}, {"instruction": "Create a Fortran subroutine named discretization_getnodelayer that calculates the node and layer index based on the global node number and the total number of nodes. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine discretization_getnodelayer(nnodes,gnode,inode,ilayer)\n    integer,intent(in)  :: nnodes,gnode\n    integer,intent(out) :: inode,ilayer\n    \n    inode = mod(gnode,nnodes)\n    if (inode .eq. 0) then\n      inode  = nnodes\n      ilayer = gnode/nnodes\n    else\n      ilayer = (gnode/nnodes) + 1\n    end if\n    \n  end subroutine discretization_getnodelayer\n"}, {"instruction": "Create a Fortran subroutine named write_den_header that takes two input parameters of type real*8 and integer, and one output parameter of type character. The subroutine writes the values of thistime and readprop to the header.", "input": "", "output": "subroutine write_den_header(header,thistime,readprop)\n  implicit none\n  character,intent(out) :: header*(*)\n  real*8,intent(in) :: thistime\n  integer,intent(in) :: readprop\n  write(header,*) thistime,readprop\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named write_spf_header that generates a header string based on the input parameters. The number of input parameters is 3 with test_data types ['real*8', 'integer', 'integer'], and the number of output parameters is 1 with a test_data type of ['character'].", "input": "", "output": "subroutine write_spf_header(header,thistime,readprop,ispf)\n  implicit none\n  character,intent(out) :: header*(*)\n  real*8,intent(in) :: thistime\n  integer,intent(in) :: readprop, ispf\n  write(header,*) thistime,readprop,ispf\nend subroutine write_spf_header\n"}, {"instruction": "Create a Fortran subroutine named read_den_header to read and parse the input header string. The subroutine takes 1 input parameter of type character and 2 output parameters of type real*8 and integer, respectively. Use the read statement to parse the header string and assign the values to the output parameters thistime and readprop.", "input": "", "output": "subroutine read_den_header(header,thistime,readprop)\n  implicit none\n  character,intent(in) :: header*(*)\n  real*8,intent(out) :: thistime\n  integer,intent(out) :: readprop\n  read(header,*) thistime,readprop\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named read_spf_header that takes a character input and returns three output parameters. The input parameter is of type character, and the output parameters are of type real*8, integer, and integer. This subroutine reads values from the input string and assigns them to the output parameters thistime, readprop, and ispf, respectively.", "input": "", "output": "subroutine read_spf_header(header,thistime,readprop,ispf)\n  implicit none\n  character,intent(in) :: header*(*)\n  real*8,intent(out) :: thistime\n  integer,intent(out) :: readprop, ispf\n  read(header,*) thistime,readprop,ispf\nend subroutine read_spf_header\n"}, {"instruction": "Write a Fortran subroutine named \"eile\" to determine the minimum, maximum, and median values among three input integers. The subroutine takes 3 input arguments of type integer and returns 3 output arguments of type integer. The subroutine should assign the minimum value to the first output argument, the maximum value to the second output argument, and the median value to the third output argument.", "input": "", "output": "      subroutine eile(ja, jb, jc, jaa, jbb, jcc) \n!...translated by pacific-sierra research 77to90  4.3e  10:10:27  11/16/01  \n!...switches:                     \n      implicit none\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      integer , intent(in) :: ja \n      integer , intent(in) :: jb \n      integer , intent(in) :: jc \n      integer , intent(out) :: jaa \n      integer , intent(out) :: jbb \n      integer , intent(out) :: jcc \n!-----------------------------------------------\n      jaa = ja \n      jcc = ja \n      jaa = min0(jb,jaa) \n      jcc = max0(jb,jcc) \n      jaa = min0(jc,jaa) \n      jcc = max0(jc,jcc) \n      if (ja>jaa .and. ja<jcc) jbb = ja \n      if (jb>jaa .and. jb<jcc) jbb = jb \n      if (jc>jaa .and. jc<jcc) jbb = jc \n      return  \n      end subroutine eile \n"}, {"instruction": "Create a Fortran subroutine named minkowski_add_voxel to calculate the Minkowski functionals for a given lattice. The subroutine takes 7 input parameters of type integer, including an array of dimensions 0:lx-1, 0:ly-1, 0:lz-1. It also returns 4 output parameters, all of which are integers.", "input": "", "output": "subroutine minkowski_add_voxel(lattice,lx,ly,lz,jx,jy,jz,volume,surface,curvature,euler)\nimplicit none\ninteger, intent(in), dimension(0:lx-1,0:ly-1,0:lz-1) :: lattice\ninteger, intent(in) :: lx, ly, lz, jx, jy, jz\ninteger, intent(out) :: volume, surface, curvature, euler\n\ninteger, parameter :: volume_body = 1   ! (a*a*a, where a is lattice displacement)\ninteger, parameter :: surface_body = -6 ! (-6*a*a, open body)\ninteger, parameter :: surface_face = 2  ! (2*a*a, open face)\ninteger, parameter :: curv_body = 3     ! (3*a, open body)\ninteger, parameter :: curv_face = -2    ! (-2*a, open face)\ninteger, parameter :: curv_edge = 1     ! (a, open line)\ninteger, parameter :: euler_body = -1   ! (open body)\ninteger, parameter :: euler_face = 1    ! (open face)\ninteger, parameter :: euler_edge = -1   ! (open line)\ninteger, parameter :: euler_vertex = 1  ! (vertices)\n\ninteger nfaces, nedges, nvert\ninteger i0,j0,k0,jxi,jyi,jzi,jyj,jzj,jzk\ninteger kc1,kc2,kc3,kc7,kc1kc4kc5\n\n! accumulate faces, edges, vertices from adding pixel\nnfaces = 0\nnedges = 0\nnvert = 0\ndo i0 = -1,1,2\n    ! wrap offsets to account for periodic boundaries\n    jxi = modulo(jx+i0,lx)\n    jyi = modulo(jy+i0,ly)\n    jzi = modulo(jz+i0,lz)\n    kc1 = 1-lattice(jxi,jy,jz)\n    kc2 = 1-lattice(jx,jyi,jz)\n    kc3 = 1-lattice(jx,jy,jzi)\n    nfaces = nfaces + kc1 + kc2 + kc3 ! (b.5)\n    do j0 = -1,1,2\n        jyj = modulo(jy+j0,ly)\n        jzj = modulo(jz+j0,lz)\n        kc7 = 1-lattice(jx,jy,jzj)\n        kc1kc4kc5 = kc1*(1-lattice(jxi,jyj,jz))*(1-lattice(jx,jyj,jz))\n        nedges = nedges + kc1kc4kc5 + kc2*(1-lattice(jx,jyi,jzj))*kc7 + kc1*(1-lattice(jxi,jy,jzj))*kc7 ! (b.6)\n        if (kc1kc4kc5.ne.0) then ! whole term (b.7) evaluates to 0 otherwise\n            do k0 = -1,1,2\n                jzk = modulo(jz+k0,lz)\n                nvert = nvert + (1-lattice(jxi,jy,jzk))*(1-lattice(jxi,jyj,jzk))*(1-lattice(jx,jyj,jzk))*(1-lattice(jx,jy,jzk)) ! (b.7, without kc1kc4kc5)\n            end do !k0\n        end if\n    end do ! j0\nend do ! i0\n\nvolume = volume_body\nsurface = surface_body + surface_face*nfaces\ncurvature = curv_body + curv_face*nfaces + curv_edge*nedges\neuler = euler_body + euler_face*nfaces + euler_edge*nedges + euler_vertex*nvert\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named put_line_characters_with_unit to output a string to a specified unit. The subroutine takes 2 input parameters of type integer and character(len=*), and 1 optional output parameter of type integer.", "input": "", "output": "    subroutine put_line_characters_with_unit(unit, string, iostat)\n        ! sec. 3.6.3\n        integer, intent(in) :: unit\n        character(len=*), intent(in) :: string\n        integer, optional, intent(out) :: iostat\n\n        if (present(iostat)) then\n            write(unit, fmt='(a,/)', advance='no', iostat=iostat) string\n        else\n            write(unit, fmt='(a,/)', advance='no') string\n        end if\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named test_simple_character. It takes 2 input parameters of type character, with the first parameter being an array and the second one being optional. The output is a character array of the same size as the input array. The subroutine assigns 'a' to each element of the output array and then assigns the corresponding element from the input array if the optional parameter is '1'; otherwise, it assigns a character based on the index.", "input": "", "output": "subroutine test_simple_character(a,c,b)\n  character, intent(in), dimension(:) :: a\n  character, intent(in), optional :: c\n  character, intent(out), dimension(size(a)) :: b\n  ! local\n  integer :: i\n  b(:) = 'a'\n  do i = 1, size(b)\n     if (present(c) .and. (c .eq. '1')) then\n        b(i) = a(i)\n     else\n        b(i) = char(mod(i,3))\n     end if\n  end do\nend subroutine test_simple_character\n"}, {"instruction": "Create a Fortran subroutine named k_star_func that takes a single input parameter of type real(dp) and returns a single output parameter of type real(dp). This subroutine calculates the wake spread parameter using the formula k_star_ust = 0.3837*ti_ust + 0.003678 based on the niayifar and porte agel (2015, 2016) model.", "input": "", "output": "subroutine k_star_func(ti_ust, k_star_ust)\n                                 \n    implicit none\n        \n    ! define precision to be the standard for a double precision ! on local system\n    integer, parameter :: dp = kind(0.d0)\n    \n    ! in\n    real(dp), intent(in) :: ti_ust\n    \n    ! out  \n    real(dp), intent(out) :: k_star_ust\n    \n    ! calculate wake spread parameter from niayifar and porte agel (2015, 2016)\n    k_star_ust = 0.3837*ti_ust+0.003678\n    \nend subroutine k_star_func\n"}, {"instruction": "Create a Fortran subroutine named vecprod to calculate the cross product of two 3-dimensional vectors. The subroutine should take 2 input parameters of type real*8 and intent(in), and 1 output parameter of type real*8 and intent(out). The number of input arguments is 2 and the test_data type is ['real*8', 'real*8']. The number of output arguments is 1 and the test_data type is ['real*8'].", "input": "", "output": "subroutine vecprod(a,b,c)\n  implicit none\n  real*8, intent(out) :: c(3)\n  real*8, intent(in)  :: a(3), b(3)\n  c(1)=a(2)*b(3)-a(3)*b(2)\n  c(2)=a(3)*b(1)-a(1)*b(3)\n  c(3)=a(1)*b(2)-a(2)*b(1)\nend subroutine vecprod\n"}, {"instruction": "Write a Fortran subroutine named init_matrix to initialize a matrix with random double-precision values. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type double precision. The input parameters are n1 and n2, representing the dimensions of the matrix, and the output parameter is m, which is a 2D array of size n1 x n2. The subroutine utilizes the features of Fortran, including the subroutine keyword and the intent attribute for input and output parameters.", "input": "", "output": "  subroutine init_matrix(n1, n2, m)\n    integer, intent(in) :: n1, n2\n    double precision, intent(out) :: m(n1, n2)\n\n    integer, parameter :: s = 12345\n    integer :: seed_size\n    integer, allocatable :: seed(:)\n\n    call random_seed(size=seed_size)\n    allocate(seed(seed_size))\n    seed = s\n    call random_seed(put=seed)\n    call random_number(m)\n\n    deallocate(seed)\n  end subroutine init_matrix\n"}, {"instruction": "Write a Fortran subroutine named interpx_cf that takes 4 input parameters: dimx, dimy, dimz of type integer, and a1 of type real(8), dimension(dimx,dimy,dimz). It also has 1 output parameter campo_saida of type real(8), dimension(dimx+1,dimy,dimz). The subroutine computes the interpolation of the input data a1 along the x-axis and stores the result in campo_saida. Make sure to use the imperative tone and specify the types and dimensions of the input and output parameters in the instruction.", "input": "", "output": "subroutine interpx_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx+1,dimy,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=1,dimy\n  do i=2,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i-1,j,k))*0.5\n  enddo\n  i=1\n   !campo_saida(i,j,k)=2.*campo_saida(i+1,j,k)-campo_saida(i+2,j,k)\n   campo_saida(i,j,k)=campo_saida(i+1,j,k)\n  i=dimx+1\n   !campo_saida(i,j,k)=2.*campo_saida(i-1,j,k)-campo_saida(i-2,j,k)\n   campo_saida(i,j,k)=campo_saida(i-1,j,k)\n enddo\nenddo\n\nend subroutine interpx_cf\n"}, {"instruction": "Create a Fortran subroutine named interpx_fc that takes four input parameters: dimx, dimy, dimz of type integer, and a1 of type real(8), with a dimension of (dimx,dimy,dimz). It has one output parameter, campo_saida of type real(8) with a dimension of (dimx-1,dimy,dimz). The subroutine computes the average of adjacent elements along the x-axis of the input array a1 and stores the results in campo_saida using a face-centered to center-centered interpolation scheme.", "input": "", "output": "subroutine interpx_fc(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx-1,dimy,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=1,dimy\n  do i=1,dimx-1\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i+1,j,k))*0.5\n  enddo\n enddo\nenddo\n\n\nend subroutine interpx_fc\n"}, {"instruction": "Write a Fortran subroutine named interpy_cf to interpolate the values of a 3D array from the center to the face. The number of input arguments is 4 and the test_data type is [integer, integer, integer, real(8), dimension(dimx,dimy,dimz)]. The number of output arguments is 1 and the test_data type is [real(8), dimension(dimx,dimy+1,dimz)].", "input": "", "output": "subroutine interpy_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx,dimy+1,dimz) :: campo_saida\n\n!a1=campo_entrada\ndo k=1,dimz\n do j=2,dimy\n  do i=1,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i,j-1,k))*0.5\n  enddo\n enddo\nenddo\ndo k=1,dimz\n do i=1,dimx\n  j=1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j+1,k)-campo_saida(i,j+2,k)\n   campo_saida(i,j,k)=campo_saida(i,j+1,k)\n  j=dimy+1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j-1,k)-campo_saida(i,j-2,k)\n   campo_saida(i,j,k)=campo_saida(i,j-1,k)\n enddo\nenddo\n\nend subroutine interpy_cf\n"}, {"instruction": "Write a Fortran subroutine named interpz_cf that takes 4 input arguments: dimx, dimy, dimz (integer), and a1 (real(8) array of dimension dimx,dimy,dimz). It produces 1 output argument: campo_saida (real(8) array of dimension dimx,dimy,dimz+1). The subroutine computes the interpolation of the input array a1 along the z-direction and stores the result in campo_saida. Remember to use the 'intent(in)' and 'intent(out)' attributes for input and output parameters, respectively.", "input": "", "output": "subroutine interpz_cf(a1,dimx,dimy,dimz,campo_saida) !cf --> centro pra face fc--> face pro centro\n\nimplicit none\ninteger :: i, j, k\ninteger, intent(in) :: dimx,dimy,dimz\nreal(8), intent(in), dimension(dimx,dimy,dimz)  :: a1\nreal(8), intent(out), dimension(dimx,dimy,dimz+1) :: campo_saida\n\n!a1=campo_entrada\ndo k=2,dimz\n do j=1,dimy\n  do i=1,dimx\n    campo_saida(i,j,k)=(a1(i,j,k)+a1(i,j,k-1))*0.5\n  enddo\n enddo\nenddo\ndo j=1,dimy\n do i=1,dimx\n  k=1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j,k+1)-campo_saida(i,j,k+2)\n   campo_saida(i,j,k)=campo_saida(i,j,k+1)                \n  k=dimz+1\n   !campo_saida(i,j,k)=2.*campo_saida(i,j,k-1)-campo_saida(i,j,k-2)\n   campo_saida(i,j,k)=campo_saida(i,j,k-1)\n\n enddo\nenddo\n\nend subroutine interpz_cf\n"}, {"instruction": "Create a Fortran subroutine named getpropfromx_crit to calculate thermodynamic properties from the given composition. The subroutine takes 1 input parameter of type real and 4 output parameters of type real. The input parameter is x(4) and the output parameters are tc, vc, zc(2), and pc.", "input": "", "output": "  subroutine getpropfromx_crit(x,tc,vc,zc,pc)\n    real, intent(out) :: tc,vc,zc(2),pc\n    real, intent(in) :: x(4)\n    zc(1) = x(1)\n    zc(2) = max(0.0, 1.0 - zc(1))\n    tc = exp(x(2))\n    vc = exp(x(3))\n    pc = exp(x(4))\n  end subroutine getpropfromx_crit\n"}, {"instruction": "Write a Fortran subroutine named getpropfromx_llve to calculate properties from the input array xx. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 7 and the test_data type is [real, real, real, real, real, real, real].", "input": "", "output": "  subroutine getpropfromx_llve(xx,t,vx,vw,vy,x,w,y)\n    real, intent(out) :: t,vx,vw,vy,x(2),w(2),y(2)\n    real, intent(in) :: xx(10)\n    x(1:2) = exp(xx(1:2))\n    w(1:2) = exp(xx(3:4))\n    y(1:2) = exp(xx(5:6))\n    vx = exp(xx(7))\n    vw = exp(xx(8))\n    vy = exp(xx(9))\n    t = exp(xx(10))\n  end subroutine getpropfromx_llve\n"}, {"instruction": "Write a Fortran subroutine named setx_llve that takes 7 input real arguments (t, vx, vw, vy, x(2), w(2), y(2)) and 1 output real argument (xx(10)). The subroutine computes the natural logarithm of each input argument and assigns the results to the elements of the output array xx.", "input": "", "output": "  subroutine setx_llve(t,vx,vw,vy,x,w,y,xx)\n    real, intent(in) :: t,vx,vw,vy,x(2),w(2),y(2)\n    real, intent(out) :: xx(10)\n    xx(1:2) = log(x)\n    xx(3:4) = log(w)\n    xx(5:6) = log(y)\n    xx(7) = log(vx)\n    xx(8) = log(vw)\n    xx(9) = log(vy)\n    xx(10) = log(t)\n  end subroutine setx_llve\n"}, {"instruction": "Create a Fortran subroutine named copy_file to copy a single file from a source location to a destination location, overwriting the existing destination file if necessary. The subroutine should have 3 input parameters of type character(*), character(*), and logical (optional), and 1 output parameter of type integer (optional).", "input": "", "output": "subroutine copy_file(src, dest, overwrite, status)\n!! copy single file from src to dest\n!! overwrites existing destination file\ncharacter(*), intent(in) :: src, dest\nlogical, intent(in), optional :: overwrite\ninteger, intent(out), optional :: status\n\nif(present(status)) then\n  status = -1\n  return\nendif\n\nerror stop \"error:filesystem:fallback doesn't have copy_file\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mkdir to create a directory with parents if needed. The subroutine takes 1 input parameter of type character(*) and 1 optional output parameter of type integer. If the status output parameter is present, it will be assigned a value of -1. If the status parameter is not present, the subroutine will trigger an error stop with the message \"error:filesystem:fallback doesn't have mkdir\".", "input": "", "output": "subroutine mkdir(path, status)\n!! create a directory, with parents if needed\ncharacter(*), intent(in) :: path\ninteger, intent(out), optional :: status\n\nif(present(status)) then\n  status = -1\n  return\nendif\n\nerror stop \"error:filesystem:fallback doesn't have mkdir\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named create_symlink to handle the creation of a symbolic link. This subroutine takes 2 input arguments of type character, tgt and link. It also has an optional output argument of type integer. If the status argument is present, it will return -1. If the status argument is not present, it will trigger an error with the message \"filesystem:fallback doesn't have create_symlink\".", "input": "", "output": "subroutine create_symlink(tgt, link, status)\ncharacter(*), intent(in) :: tgt, link\ninteger, intent(out), optional :: status\nif (present(status)) then\n  status = -1\n  return\nendif\nerror stop \"filesystem:fallback doesn't have create_symlink\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named chmod_exe to set the owner executable bit for a regular file. The subroutine takes 1 input parameter of type character(*) to specify the file path. It also has 1 optional output parameter of type logical to indicate the success of the operation. If successful, the logical output parameter will be set to true; otherwise, the operation will result in an error.", "input": "", "output": "subroutine chmod_exe(path, ok)\n!! set owner executable bit for regular file\ncharacter(*), intent(in) :: path\nlogical, intent(out), optional :: ok\nerror stop \"filesystem:fallback doesn't have chmod_exe\"\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dcomputewspd to calculate the wind speed from the horizontal wind components. The subroutine takes 4 input parameters: two integers (nx and ny) and two 2D arrays of real(kind=8) type (u and v), and has 1 output parameter: a 2D array of real(kind=8) type (wspd). Remember to use the imperative tone in your instructions.", "input": "", "output": "subroutine dcomputewspd(wspd, u, v, nx, ny)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: wspd\n\n    integer, intent(in) :: nx, ny\n    real(kind=8), dimension(nx,ny), intent(out) :: wspd\n    real(kind=8), dimension(nx,ny), intent(in) :: u, v\n! nclend\n\n    integer i, j\n\n    !$omp parallel do collapse(2) schedule(runtime)\n    do j = 1,ny\n        do i = 1,nx\n            wspd(i,j) = sqrt(u(i,j)*u(i,j) + v(i,j)*v(i,j))\n        end do\n    end do\n    !$omp end parallel do\n\nend subroutine dcomputewspd\n"}, {"instruction": "Create a Fortran subroutine named \"openbinfile\" to open a binary output file. The subroutine should take 3 input arguments of type integer, integer, and character(*) and 1 output argument of type logical.", "input": "", "output": "   subroutine openbinfile ( un, outfile, reclen, error )\n\n\n      ! this routine opens a binary output file.\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the output file.\n   integer, intent(in)          :: reclen                                       ! length of binary record.\n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n   character(*), intent(in)     :: outfile                                      ! name of the output file.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n\n\n      ! open output file.  make sure it worked.\n\n!  open( un, file=trim( outfile ), status='unknown', form='binary' , access='sequential', recl=reclen , iostat=ios )\n   open( un, file=trim( outfile ), status='unknown', form='unformatted' , access='stream', iostat=ios )\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openbinfile ! ( un, outfile, reclen, error )\n"}, {"instruction": "Write a Fortran subroutine named openbininpfile to open a binary input file. The subroutine takes 2 input parameters of types integer and character(*), and 1 output parameter of type logical.", "input": "", "output": "   subroutine openbininpfile ( un, infile, error )\n\n\n      ! this routine opens a binary input file.\n\n   implicit                        none\n\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the input file.\n\n   character(*), intent(in)     :: infile                                       ! name of the input file.\n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n      ! note: do not explicitly declare the precision of this variable [as in\n      !       logical(1)] so that the statements using this variable work with\n      !       any compiler:\n\n\n      ! open input file.  make sure it worked.\n\n!  open( un, file=trim( infile ), status='old', form='binary', iostat=ios, action='read' )\n   open( un, file=trim( infile ), status='old', form='unformatted', access='stream', iostat=ios, action='read' )\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openbininpfile\n"}, {"instruction": "Create a Fortran subroutine named \"openunfinpbefile\" that opens a binary input file with data stored in big endian format. The subroutine should take 3 input parameters of type integer, character(*), and integer, and 1 output parameter of type logical. The input parameters correspond to the logical unit for the input file, the name of the input file, and the size of records in the input file in bytes. The output parameter is a flag indicating whether the open operation failed. Use the imperative tone.", "input": "", "output": "   subroutine openunfinpbefile ( un, infile, reclen, error )\n\n\n      ! this routine opens a binary input file with data stored in big endian format (created on a unix machine.)\n      ! data are stored in reclen-byte records.\n\n   implicit                        none\n\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: un                                           ! logical unit for the input file.\n\n   character(*), intent(in)     :: infile                                       ! name of the input file.\n\n   integer, intent(in)          :: reclen                                       ! size of records in the input file, in bytes. \n\n   logical, intent(out)         :: error                                        ! flag to indicate the open failed.\n\n\n      ! local declarations.\n\n   integer                      :: ios                                          ! i/o status of open.\n\n\n\n      ! open input file.  make sure it worked.\n\n   ! the non-standard convert keyword allows us to read unix binary files, whose bytes are in reverse order (i.e., stored in big endian format).\n\n   ! note: using reclen in bytes requires using the /assume:byterecl compiler option!\n\n   open ( un, file=trim( infile ), status='old', form='unformatted', access='direct', recl=reclen, iostat=ios, &\n                   action='read', convert='big_endian' )                         ! use this for pc systems.\n!                  action='read'  )                                              ! use this for unix systems.\n\n\n   if ( ios /= 0 )  then\n      error = .true.\n   else\n      error = .false.\n   end if\n\n\n   return\n   end subroutine openunfinpbefile\n"}, {"instruction": "Create a Fortran subroutine named get_backward to calculate the backward pass in a neural network. The subroutine takes 7 input parameters of types integer and real*8 and 1 output parameter of type real*8. The input parameters are n_hid, n_obs, steps, mkh, mko, obs, and scaling, while the output parameter is backward. This subroutine computes the backward pass using the given inputs and stores the result in the backward parameter.", "input": "", "output": "subroutine get_backward(n_hid, n_obs, steps, mkh, mko, obs, scaling, backward)\n   implicit none\n   integer, intent(in) :: n_hid\n   integer, intent(in) :: n_obs\n   integer, intent(in) :: steps\n   real*8, intent(in)  :: mkh(n_hid, n_hid)\n   real*8, intent(in)  :: mko(n_obs, n_hid)\n   integer, intent(in) :: obs(steps)\n   real*8, intent(in)  :: scaling(steps)\n   real*8, intent(out) :: backward(steps, n_hid)\n\n   integer :: t\n   backward(steps, :) = scaling(steps)\n\n   do t = steps - 1, 1, -1\n      backward(t, :) = matmul(mko(obs(t+1), :) * backward(t+1, :), mkh) * scaling(t)\n   end do\n\nend subroutine get_backward\n"}, {"instruction": "Write a Fortran subroutine named transposebits that takes three input parameters, where the first two are integers and the third is an integer array. It also has one output parameter of type integer array. The subroutine transposes the bits of the input array elements and stores the result in the output array.", "input": "", "output": "  subroutine transposebits(nsrc, src, ndest, dest)\n    implicit none\n    ! passed parameters\n    integer, intent(in) :: nsrc, ndest\n    integer, dimension(:), intent(in) :: src\n    integer, dimension(:), intent(out) :: dest\n    ! local variables\n    ! src is going to be a small array, so just use automatic arrays\n    integer, dimension(nsrc) :: input ! copy of src\n    integer :: ii, jj, output\n    input = src\n    do ii = ndest, 1, -1\n       output = 0\n       do jj = 1, nsrc\n          output = ishft(output, 1) + mod(input(jj), 2)\n          input(jj) = ishft(input(jj), -1)\n       end do\n       dest(ii) = output\n    end do\n  end subroutine transposebits\n"}, {"instruction": "Create a Fortran subroutine named \"pzxc_sp\" to calculate the exchange-correlation energy and potential for a given density and spin density. The input parameters are two real(8) values for density (trho) and spin density (trho_s), and the output parameters are two real(8) values for the exchange-correlation energy (exc) and two real(8) values for the exchange-correlation potential (vxc_s). Ensure the subroutine utilizes the \"implicit none\" statement and parameter declarations for constants.", "input": "", "output": "  subroutine pzxc_sp(trho,trho_s,exc,vxc_s)\n    implicit none\n    real(8),parameter :: pi=3.141592653589793d0\n    real(8),parameter :: gammau=-0.1423d0,gammap=-0.0843d0\n    real(8),parameter :: beta1u=1.0529d0,beta2u=0.3334d0\n    real(8),parameter :: beta1p=1.3981d0,beta2p=0.2611d0\n    real(8),parameter :: au=0.0311d0,bu=-0.048d0\n    real(8),parameter :: cu=0.002d0,du=-0.0116d0\n    real(8),parameter :: ap=0.01555d0,bp=-0.0269d0\n    real(8),parameter :: cp=0.0007d0,dp=-0.0048d0\n    real(8),parameter :: const = 0.75d0*(3d0/(2d0*pi))**(2d0/3d0)\n    real(8) :: rs,cx\n    real(8) :: zeta,sf,dsf\n    real(8) :: ecu,ecp,vcu,vcp\n    real(8) :: sgnsigma(2)\n    integer :: js\n    real(8),intent(in) :: trho,trho_s(2)\n    real(8),intent(out) :: exc\n    real(8),intent(out) :: vxc_s(2)\n\n    sgnsigma(1)=1.d0\n    sgnsigma(2)=-1.d0\n    rs=(3.d0/(4.d0*pi*trho))**(1.d0/3.d0)\n\n    zeta=(trho_s(1)-trho_s(2))/trho\n    sf=((1.d0+zeta)**(4.d0/3.d0)+(1.d0-zeta)**(4.d0/3.d0)-2.d0)/(2.d0**(4.d0/3.d0)-2.d0)\n! dsf=d(smallf)/d(zeta)\n    dsf=4.d0/3.d0*((1.d0+zeta)**(1.d0/3.d0)-(1.d0-zeta)**(1.d0/3.d0))/(2.d0**(4.d0/3.d0)-2.d0)\n\n    cx=3.d0/4.d0*(3.d0/(2*pi))**(2.d0/3.d0)\n\n    exc=-cx/rs+(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*sf\n    do js=1,2\n      vxc_s(js)=exc-1.d0/3.d0*cx/rs+1.d0/3.d0*(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*sf &\n                             +(-2.d0**(1.d0/3.d0)+1.d0)*cx/rs*(sgnsigma(js)-zeta)*dsf\n    end do\n\n    if ( rs > 1.d0 ) then\n      ecu=gammau/(1.d0+beta1u*sqrt(rs)+beta2u*rs)\n      ecp=gammap/(1.d0+beta1p*sqrt(rs)+beta2p*rs)\n      vcu=gammau*(1.d0+7.d0/6.d0*beta1u*sqrt(rs)+4.d0/3.d0*beta2u*rs)/(1.d0+beta1u*sqrt(rs)+beta2u*rs)**2\n      vcp=gammap*(1.d0+7.d0/6.d0*beta1p*sqrt(rs)+4.d0/3.d0*beta2p*rs)/(1.d0+beta1p*sqrt(rs)+beta2p*rs)**2\n    else \n      ecu=au*log(rs)+bu+cu*rs*log(rs)+du*rs\n      ecp=ap*log(rs)+bp+cp*rs*log(rs)+dp*rs\n      vcu=au*log(rs)+(bu-au/3.d0)+2.d0/3.d0*cu*rs*log(rs)+(2.d0*du-cu)/3.d0*rs\n      vcp=ap*log(rs)+(bp-ap/3.d0)+2.d0/3.d0*cp*rs*log(rs)+(2.d0*dp-cp)/3.d0*rs\n    end if\n  \n    exc=exc+ecu+sf*(ecp-ecu)\n    do js=1,2\n      vxc_s(js)=vxc_s(js)+vcu+sf*(vcp-vcu)+(ecp-ecu)*(sgnsigma(js)-zeta)*dsf\n    end do\n\n    return\n  end subroutine pzxc_sp\n"}, {"instruction": "Write a Fortran subroutine named is_leap to determine whether a given year is a leap year. The subroutine has 1 input parameter of type integer and 1 output parameter of type logical.", "input": "", "output": "  subroutine is_leap(kyear,lyear)\n    !//---------------------------------------------------------------------\n    !// calculates whether kyear is a leap year.\n    !//\n    !// amund sovde haslerud, january 2017\n    !//---------------------------------------------------------------------\n    implicit none\n    !//---------------------------------------------------------------------\n    integer, intent(in) :: kyear\n    logical, intent(out) :: lyear\n    !//---------------------------------------------------------------------\n\n    !// new leap year calculation includes the special century years:\n    if (mod(kyear,4) .ne. 0) then\n       lyear = .false.\n    else if (mod(kyear,100) .ne. 0) then\n       lyear = .true.\n    else if (mod(kyear,400) .ne. 0) then\n       lyear = .false.\n    else\n       lyear = .true.\n    end if\n\n    !//---------------------------------------------------------------------\n  end subroutine is_leap\n"}, {"instruction": "Write a Fortran subroutine named lcm to calculate the least common multiple of two integers using the Euclidean algorithm for finding the greatest common divisor. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine lcm (nn1,nn2,lcm12)\n    !//---------------------------------------------------------------------\n    !// nlcm = least common multiple of n1 & n2 by euclidean algorithm for gcd\n    !//---------------------------------------------------------------------\n    implicit none\n    !//---------------------------------------------------------------------\n    !// input/output\n    integer, intent(in)  :: nn1, nn2\n    integer, intent(out) :: lcm12\n    !// locals\n    integer :: n1, n2, n3, gcd\n    !//---------------------------------------------------------------------\n\n    n1 = nn1\n    n2 = nn2\n    n3 = mod(n1, n2)\n    do while (n3.ne.0)\n       n1 = n2\n       n2 = n3\n       n3 = mod(n1, n2)\n    end do\n    gcd = n2\n    lcm12 = nn1*nn2/gcd\n\n    !//---------------------------------------------------------------------\n  end subroutine lcm\n"}, {"instruction": "Write a Fortran subroutine named dmkldm that takes one input argument of type integer and returns one output argument of type integer. The subroutine computes the value of lda based on the input argument m, which represents the leading dimension of a matrix. If m is less than 0, the subroutine returns without further computation. Otherwise, it calculates lda as m and adjusts lda to be a multiple of 8 if it's not already.", "input": "", "output": "pure subroutine dmkldm(m, lda)\n  implicit none\n\n  integer, intent(in) :: m\n  integer, intent(out) :: lda\n\n  integer :: r\n\n  lda = m\n  if (m .lt. 0) return\n\n  r = mod(lda, 8)\n  if (r .ne. 0) lda = lda + (8 - r)\nend subroutine dmkldm\n"}, {"instruction": "Write a Fortran subroutine named multiply to perform matrix-vector multiplication. The subroutine takes 2 input parameters of type real(8) - a 2D array 'a' and a 1D array 'b', and 1 output parameter of type real(8) - 1D array 'c'.", "input": "", "output": "     subroutine multiply(a,b,c)\n! \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u043d\u0430 \u0432\u0435\u043a\u0442\u043e\u0440 c[m]:=a[m,n]*b[n]\n\treal(8), intent(in)  :: a(:,:),b(:)\n\treal(8), intent(out) :: c(:)\n\tinteger m,n\n\tinteger i,k\n    real(8) :: t\n\n    m=size(a,dim=1);\tn=size(a,dim=2)\n\tif (size(b)/=n .or. size(c)/=m) then\n\t stop 'incompatible size in multiply'\n\tendif\n      \n      do i=1,m\n       t=0.0\n       do k=1,n\n        t=t+a(i,k)*b(k)\n       enddo\n       c(i)=t\n\tenddo\n\n\tend subroutine\n"}, {"instruction": "Create a Fortran subroutine named getskillspecs that takes an array of character strings as input and returns three arrays: one of character strings and two of logical values. The input parameter has a count of 1 and the data type is ['character(len=32)'], while the output parameters have a count of 3 and the data types are ['character(len=32)', 'logical', 'logical']. The subroutine summarizes skill specifications based on input data and assigns corresponding values to the output arrays.", "input": "", "output": "subroutine getskillspecs(factorname,skillname,rasch,raschslope1)\r\nimplicit none\r\ncharacter(len=32),intent(in)::factorname(:)\r\ncharacter(len=32),intent(out)::skillname(:)\r\nlogical,intent(out)::rasch(:),raschslope1(:)\r\n!\tbuffer is a character buffer\r\ncharacter(len=4)::buffer\r\n!\tskill_name is a skill name\r\ncharacter(len=32)::skill_name\r\n!\tio is an input flag.\r\n!\tskill counts skills.\r\ninteger::io,skill\r\n!\trasch_model is for a rasch-type model.\r\n!\trasch_slope_1 is for a rasch-type model with a slope parameter of 1.\r\n!\tif repeat_names, skill names are obtained from factor names.\r\n!\tskill_specs indicates that data are required on individual skills.\r\nlogical::rasch_model,rasch_slope_1,repeat_names,skill_specs\r\nnamelist/allskillspecs/rasch_model,rasch_slope_1,repeat_names,skill_specs\r\nnamelist/skillspecs/skill_name,rasch_model,rasch_slope_1\r\n!\tdefault names.\r\ndo skill=1,size(skillname)\r\n\twrite(buffer,'(i4)') skill\r\n\tskillname(skill)=trim(\"skill\"//adjustl(buffer))\r\nend do\r\n!\tdefaults\r\nrasch_model=.false.\r\nrasch_slope_1=.false.\r\nrepeat_names=.false.\r\nif(size(factorname)==size(skillname))repeat_names=.true.\r\nskill_specs=.false.\r\nread(*,nml=allskillspecs,iostat=io)\r\nif(io/=0)stop \"skill specifications cannot be read.\"\r\nrasch=rasch_model\r\nraschslope1=rasch_slope_1\r\nif(repeat_names)then\r\n\tskill=min(size(factorname),size(skillname))\r\n\tskillname(1:skill)=factorname(1:skill)\r\nend if\t\r\n!\tindividual skills.\r\nif(skill_specs)then\r\n\tdo skill=1,size(skillname)\r\n\t\trasch_model=rasch(skill)\r\n\t\trasch_slope_1=raschslope1(skill)\r\n\t\tskill_name=skillname(skill)\r\n\t\tread(*,nml=skillspecs,iostat=io)\r\n\t\tif(io/=0)stop \"skill specifications cannot be read.\"\r\n\t\trasch(skill)=rasch_model\r\n\t\traschslope1(skill)=rasch_slope_1\r\n\t\tskillname(skill)=skill_name\r\n\tend do\r\nend if\r\n!\traschslope1 implies rasch.\r\nrasch=rasch.or.raschslope1\r\nreturn\r\nend subroutine getskillspecs\r\n"}, {"instruction": "Write a Fortran subroutine named \"foo\" that takes an array of strings as input and assigns the second element of the array to an allocatable string. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['character(len=*), allocatable'].", "input": "", "output": "  subroutine foo (xx,yy)\n  character(len=*), intent(in)               :: xx(:)\n  character(len=*), intent(out), allocatable :: yy(:)\n  if (allocated (yy)) deallocate (yy)\n  allocate (yy(1))\n  yy = xx(2)\n  end subroutine foo\n"}, {"instruction": "Create a Fortran subroutine named calc_distance to calculate the distance vector, scalar distance, and truncated distance between particles i and j. The subroutine should have 5 input parameters of types ['integer(kind=4)', 'integer(kind=4)', 'real(kind=8),dimension(nd,np)', 'integer(kind=4)', 'integer(kind=4)'], and 3 output parameters of types ['real(kind=8),dimension(nd)', 'real(kind=8)', 'real(kind=8)'].", "input": "", "output": "subroutine calc_distance (np, nd, pos, i, j, rij, d, d2)\n!\n!  calculate distance vector, scalar distance and trucated distance\n!  between atoms i and j.\n!  the distance is truncated at pi/2\n!\n    implicit none\n    integer(kind=4),intent(in) :: np                ! number of particles\n    integer(kind=4),intent(in) :: nd                ! number of dimensions\n    real(kind=8),intent(in),dimension(nd,np) :: pos ! positions\n    integer(kind=4),intent(in) :: i                 ! index particle i\n    integer(kind=4),intent(in) :: j                 ! index particle j\n    real(kind=8),intent(out),dimension(nd) :: rij   ! distance vector\n    real(kind=8),intent(out) :: d                   ! distance\n    real(kind=8),intent(out) :: d2                  ! trucated distance\n\n    real ( kind = 8 ), parameter :: pi2 = 3.141592653589793d+00 / 2.0d+00\n\n    rij(1:nd) = pos(1:nd,i) - pos(1:nd,j)\n\n    d = sqrt ( sum ( rij(1:nd)**2 ) )\n\n    !  truncate the distance:\n    d2 = min ( d, pi2 )\nend subroutine calc_distance\n"}, {"instruction": "Create a Fortran subroutine named \"s\" that takes an integer input parameter and returns an integer output parameter. The input parameter should be declared with the \"intent(in)\" attribute, and the output parameter should be declared with the \"intent(out)\" attribute. The subroutine should calculate the sum of the input parameter and a predefined integer value, and then print the result. Finally, the subroutine should assign the value 77 to the output parameter.", "input": "", "output": "  subroutine s(j,k)\n    integer,intent(in)::j\n    integer,intent(out)::k\n    integer::i=1\n    print '(i0)',i+j\n    k=77\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"sistupf\" to solve a system of linear equations using forward substitution. The subroutine takes 3 input parameters: a real 2D array \"a\", a real 1D array \"b\", and an integer 1D array \"l\". It also has 1 output parameter: a real 1D array \"u\".", "input": "", "output": "subroutine sistupf(a, b, l, u)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: u\n\ninteger, dimension(:), intent(in) :: l\n\ninteger :: ln, li\n\ninteger :: n, i, j, p\n\nn = size(b)\n\nln = l(n)\n\nu(n) = b(ln)/a(ln,n)\n\ndo i = n-1, 1, -1\n\n  li = l(i)\n  u(i) = b(li)\n  do j = i+1, n\n    u(i) = u(i) - a(li,j)*u(j)\n  enddo\n\n  u(i) = u(i)/a(li,i)\nenddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named dq that takes three input arrays of type double precision and one output array of type double precision. The input arrays are dqx, gx, and cx, and the output array is dqx. The subroutine computes the values of dqx using the formulas provided in the code. Be sure to specify the intent of each input parameter as \"in\" and the output parameter as \"out.\"", "input": "", "output": "    subroutine dq(dqx, gx, cx, dcx)\n        double precision, intent(out) :: dqx(:)\n        double precision, intent(in)  :: gx(:)\n        double precision, intent(in)  :: cx(:)\n        double precision, intent(in)  :: dcx(:, :)\n        integer :: k, i\n\n        dqx(:) = gx(:)\n\n        do k = 1, m\n            do i = 1, n\n                dqx(i) = dqx(i) + cx(k)*dcx(k, i)/mu\n            end do\n        end do\n    end subroutine dq\n"}, {"instruction": "Write a Fortran subroutine named \"v\" to perform a specific computation. The subroutine takes one input parameter of type \"double precision\" and intent \"in\" and one output parameter of type \"double precision\" and intent \"out\". The input parameter is an array named \"dqx\" and the output parameter is an array named \"vx\". The subroutine computes the values of \"vx\" based on the values of \"dqx\" according to the provided logic.", "input": "", "output": "    subroutine v(vx, dqx)\n        double precision, intent(out) :: vx(:)\n        double precision, intent(in) :: dqx(:)\n        integer i\n\n        do i = 1, n\n            vx(i) = -dqx(i)\n        end do\n\n        do i = n+1, n+m\n            vx(i) = 0.d0\n        end do\n    end subroutine v\n"}, {"instruction": "Write a Fortran subroutine named moments that calculates the average and standard deviation of a dataset. The subroutine takes 3 input parameters of types integer, integer, and double precision array, and 2 output parameters of type double precision.", "input": "", "output": "      subroutine moments(imax, dat, n, ave, sdev)\n      implicit none\n! arguments\n      integer, intent(in) :: imax, n\n      double precision, dimension(imax), intent(in) :: dat\n      double precision, intent(out) :: sdev, ave\n! local variables\n      double precision :: var, s, p\n      integer :: j\n!***********************************************************************\n      sdev = 0.0d0\n      if ( n<2 ) then\n!        print *, 'n must be at least 2'\n!  markstro      stop\n         ave = dat(1)\n         return\n      endif\n      s = 0.0d0\n      do j = 1, n\n        s = s + dat(j)\n      enddo\n      ave = s/n\n      var = 0.0d0\n      do j = 1, n\n        s = dat(j) - ave\n        p = s*s\n        var = var + p\n      enddo\n      var = var/(n-1)\n      sdev = sqrt(var)\n      end subroutine moments\n"}, {"instruction": "Create a Fortran subroutine named pcl2pe to transfer the loop momenta q, q+p1, q+p1+p2, q+p1+p2+p3, etc., to p1, p2, p3, p4, etc. The number of input arguments is 2, and the test_data type is ['integer', 'real(kind(1d0)),dimension(nloopline,0:3)']. The number of output arguments is 1, and the test_data type is ['real(kind(1d0)),dimension(nloopline,0:3)']. Within the subroutine, the loop momenta are utilized to compute the values of p1, p2, p3, p4, etc.", "input": "", "output": "  subroutine pcl2pe(nloopline,pcl,pe)\n    ! transfer the loop momenta q,q+p1,q+p1+p2,q+p1+p2+p3,... \n    ! to p1,p2,p3,p4,... \n    implicit none\n    integer,intent(in)::nloopline\n    real(kind(1d0)),dimension(nloopline,0:3),intent(in)::pcl\n    real(kind(1d0)),dimension(nloopline,0:3),intent(out)::pe\n    integer::i\n    do i=1,nloopline-1\n       pe(i,0:3)=pcl(i+1,0:3)-pcl(i,0:3)\n    enddo\n    pe(nloopline,0:3)=pcl(1,0:3)-pcl(nloopline,0:3)\n    return\n  end subroutine pcl2pe\n"}, {"instruction": "Create a Fortran subroutine named coarsenfield to downsample a 2D field by averaging non-overlapping blocks of elements. The subroutine takes 2 input parameters of type real and integer, and 1 output parameter of type real.", "input": "", "output": "subroutine coarsenfield(field_src, field_dst, ratio)\n  real, intent(in) :: field_src(:,:)\n  real, intent(out) :: field_dst(:,:)\n  integer, intent(in) :: ratio\n\n  integer :: i,j\n  integer :: isub,jsub\n  integer :: im,jm\n\n  integer :: stride\n\n  real :: invnumpoints\n\n  invnumpoints = (1 / dble(ratio))**2\n  stride = ratio - 1\n\n  im = size(field_dst, dim=1)\n  jm = size(field_dst, dim=2)\n\n  ! loop over the coarse grid and average values from the fine grid:\n  do j = 1, jm\n    jsub = (j - 1) * ratio + 1\n    do i = 1, im\n      isub = (i - 1) * ratio + 1\n      field_dst(i,j) = sum(field_src(isub:isub+stride,jsub:jsub+stride)) * invnumpoints\n    end do\n  end do\n\nend subroutine coarsenfield\n"}, {"instruction": "Write a Fortran subroutine named getscales to read and generate scale values for a given range of scores. The number of input arguments is 3 and the test_data type is [integer, integer, integer]. The number of output arguments is 2 and the test_data type is [character(len=*), real(kind=8)]. The subroutine uses the namelist input/output feature and allocatable arrays for scalability.", "input": "", "output": "subroutine getscales(maxscore,minscore,numberscales,scalename,scale)\r\nimplicit none\r\ncharacter(len=*),intent(out)::scalename(:)\r\ninteger,intent(in)::maxscore,minscore,numberscales\r\nreal(kind=8),intent(out)::scale(numberscales,minscore:maxscore)\r\n!\tuse a buffer for counts.\r\ncharacter(len=4)::buffer\r\n!\tcopy of scalename.\r\ncharacter(len=32),allocatable::scalenames(:)\r\n!\ti is an index.\r\n!\tio is flag for input error.\r\ninteger::i,io\r\n!\tscalevalues are values of scale.\r\nreal(kind=8),allocatable::scalevalues(:,:)\r\nnamelist/scales/scalenames,scalevalues\r\nallocate(scalenames(numberscales),scalevalues(numberscales,minscore:maxscore),stat=io)\r\nif(io/=0)stop 'cannot allocate space for scales.'\r\ndo i=minscore,maxscore\r\n\tscalevalues(:,i)=i\r\nend do\r\ndo i=1,numberscales\r\n\twrite(buffer,'(i4)') i\r\n\tscalenames(i)='scale'//trim(adjustl(buffer))\r\nend do\r\nread(*,nml=scales,iostat=io)\r\nif(io/=0) stop 'unable to read scales.'\r\nscalename=scalenames\r\nscale=scalevalues\r\nreturn\r\nend subroutine getscales\r\n"}, {"instruction": "Create a Fortran subroutine named gen_random_numbers_complex to generate an array of complex numbers. The subroutine takes 1 input argument of type integer and produces 1 output argument of type complex(8).", "input": "", "output": "  subroutine gen_random_numbers_complex(n,rand)\n    integer,intent(in) :: n\n    complex(8),intent(out) :: rand(n)\n\n    integer :: i, seedsize\n    integer,allocatable :: seed(:)\n    integer :: zikoku\n    real(8) :: ransu(2*n)\n    \n    call system_clock(count=zikoku)\n    call random_seed(size=seedsize)\n    allocate(seed(seedsize))\n    seed=zikoku\n    call random_seed(put=seed)\n    call random_number(ransu)\n    deallocate(seed)\n    do i=1,n\n       !rand(i)=cmplx(ransu(2*i-1),ransu(2*i),kind(1.d0))\n       !rand(i)=1.d0\n       rand(i)=dble(i)\n    end do\n    \n  end subroutine gen_random_numbers_complex\n"}, {"instruction": "Create a Fortran subroutine named ascii_input to convert an integer to its corresponding ASCII character. The subroutine should take 1 input parameter of type integer(kind=2) and provide 1 output parameter of type character(len=2).", "input": "", "output": "      subroutine ascii_input(ascii,i)\r\n      implicit none\r\n      character(len=2), intent(out) :: ascii\r\n      integer(kind=2), intent(in) :: i\r\n\r\n      ascii = achar(i)\r\n      \r\n      end subroutine ascii_input\r\n"}, {"instruction": "Create a Fortran subroutine named \"latlon\" to convert latitude and longitude values. The subroutine takes 6 input parameters: 4 integers and 2 real numbers. The test_data type is ['integer(kind=4)', 'integer(kind=4)', 'real(kind=4)', 'real(kind=4)', 'real(kind=4)', 'real(kind=4)']. It returns 2 output parameters, both of type real(kind=8) and of dimension nlat and mlon respectively. The subroutine uses imperative tone to calculate the latitudes and longitudes and assigns them to the output parameters.", "input": "", "output": "    subroutine latlon(blat,blon,ydegr,xdegr,nlat,mlon,ylat,xlon)\n\n    implicit none\n\n    !! global namespace\n    integer(kind=4), intent(in) :: nlat\n    integer(kind=4), intent(in) :: mlon\n    real(kind=4),    intent(in) :: ydegr\n    real(kind=4),    intent(in) :: xdegr\n    real(kind=4),    intent(in) :: blat\n    real(kind=4),    intent(in) :: blon\n    real(kind=8),    dimension(nlat), intent(out)  :: ylat\n    real(kind=8),    dimension(mlon), intent(out)  :: xlon\n\n    !! local namespace\n    integer(kind=4)                                :: ilon\n    integer(kind=4)                                :: ilat\n\n    !! longitudes going from -180 to 180\n    do ilon = 1,mlon\n       xlon(ilon) = -blon + (ilon-1)*xdegr\n    end do\n  \n    !! latitudes going from 90 to -90\n    do ilat = 1,nlat\n       ylat(ilat) = blat - ilat*ydegr\n    end do\n\n    return\n    \n  end subroutine latlon\n"}, {"instruction": "Create a Fortran subroutine named modelb_function1 to calculate the square of the input real number and store it in one output parameter, while also copying the input value to another output parameter. The number of input parameters is 1 of type real, and the number of output parameters is 2 of type real.", "input": "", "output": "subroutine modelb_function1(in_val, in_val_copy, out_val)\n  ! only valid if in_val <= 2\n  real, intent(in) :: in_val\n  real, intent(out) :: in_val_copy\n  real, intent(out) :: out_val\n  in_val_copy = in_val\n  out_val = in_val**2\n  print *, \"modelb_function1(\", in_val, \") = \", out_val\nend subroutine modelb_function1\n"}, {"instruction": "Write a Fortran subroutine named get_fathers to retrieve the IDs and masses of the father halos. The subroutine takes 1 input parameter of type integer and outputs 2 parameters: an integer array of dimension nb_of_fathers and a real array of dimension nb_of_fathers.", "input": "", "output": "  subroutine get_fathers(nb_of_fathers, id_fathers, m_fathers)\n    integer, intent(in)                                 :: nb_of_fathers !> number of son of the halo\n    integer, dimension(nb_of_fathers), intent(out)      :: id_fathers     !> id of the father\n    real(kind=4), dimension(nb_of_fathers), intent(out) :: m_fathers      !> mass of the father\n\n    id_fathers = tmp_id_fathers\n    m_fathers = tmp_m_fathers\n  end subroutine get_fathers\n"}, {"instruction": "Create a Fortran subroutine named get_sons. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer array with a size determined by the input parameter. The input parameter represents the number of sons of a halo, and the output parameter contains the ids of the sons of the halo. Use the \"intent(in)\" and \"intent(out)\" keywords to specify the input and output parameters.", "input": "", "output": "  subroutine get_sons(nb_of_sons, id_sons)\n    integer, intent(in)                         :: nb_of_sons!> number of son of the halo\n    integer, dimension(nb_of_sons), intent(out) :: id_sons    !> ids of the son of the halo\n\n    id_sons = tmp_id_sons\n  end subroutine get_sons\n"}, {"instruction": "Create a Fortran subroutine named change_strings to modify input strings by appending 'a' to the end of each string. The subroutine takes 2 input parameters - an integer and a character array of dimension (2, n_strs). It produces 1 output parameter - a character array of dimension (2, n_strs).", "input": "", "output": "subroutine change_strings(strings, n_strs, out_strings)\r\n    implicit none\r\n\r\n    ! inputs\r\n    integer, intent(in) :: n_strs\r\n    character, intent(in), dimension(2,n_strs) :: strings\r\n    character, intent(out), dimension(2,n_strs) :: out_strings\r\n\r\n!f2py integer, intent(in) :: n_strs\r\n!f2py character, intent(in), dimension(2,n_strs) :: strings\r\n!f2py character, intent(out), dimension(2,n_strs) :: strings\r\n\r\n    ! misc.\r\n    integer*4 :: j\r\n\r\n\r\n    do j=1, n_strs\r\n        out_strings(1,j) = strings(1,j)\r\n        out_strings(2,j) = 'a'\r\n    end do\r\n\r\nend subroutine change_strings\r\n"}, {"instruction": "Create a Fortran subroutine named simul to solve a system of linear equations using the Gaussian elimination method. The subroutine takes 4 input parameters of types integer, real array of dimension (ndim,ndim), real array of dimension (ndim), and integer. It returns 2 output parameters of types real array of dimension (ndim) and integer.", "input": "", "output": "subroutine simul ( a, b, soln, ndim, n, error )\nimplicit none\n! data dictionary: declare calling parameter types & definitions\ninteger, intent(in) :: ndim\n! dimension of arrays a and b\nreal, intent(in), dimension(ndim,ndim) :: a\n! array of coefficients (n x n).\n! this array is of size ndim x\n! ndim, but only n x n of the\n! coefficients are being used.\nreal, intent(in), dimension(ndim) :: b\n! input: right-hand side of eqns.\nreal, intent(out), dimension(ndim) :: soln\n! output: solution vector.\ninteger, intent(in) :: n\n! number of equations to solve.\ninteger, intent(out) :: error\nreal, parameter :: epsilon = 1.0e-6 ! a \"small\" number for comparison\n! when determining singular eqns\n! data dictionary: declare local variable types & definitions\nreal, dimension(n,n) :: a1\n! copy of \"a\" which will be\n! destroyed during the solution\nreal :: factor\n! factor to multiply eqn irow by\n! before adding to eqn jrow\ninteger :: irow\n! number of the equation currently\n! being processed\ninteger :: ipeak\n! pointer to equation containing\n! maximum pivot value\ninteger :: jrow\n! number of the equation compared\n! to the current equation\nreal :: temp\n! scratch value\n\nreal, dimension(n) :: temp1\n! scratch array\n! make copies of arrays \"a\" and \"b\" for local use\na1 = a(1:n,1:n)\nsoln = b(1:n)\n! process n times to get all equations...\nmainloop: do irow = 1, n\n! find peak pivot for column irow in rows irow to n\nipeak = irow\nmax_pivot: do jrow = irow+1, n\nif (abs(a1(jrow,irow)) > abs(a1(ipeak,irow))) then\nipeak = jrow\nend if\nend do max_pivot\n! check for singular equations.\nsingular: if ( abs(a1(ipeak,irow)) < epsilon ) then\nerror = 1\nreturn\nend if singular\n! otherwise, if ipeak /= irow, swap equations irow & ipeak\nswap_eqn: if ( ipeak /= irow ) then\ntemp1 = a1(ipeak,1:n)\na1(ipeak,1:n) = a1(irow,1:n)\n! swap rows in a\na1(irow,1:n) = temp1\ntemp = soln(ipeak)\nsoln(ipeak) = soln(irow)\n! swap rows in b\nsoln(irow) = temp\nend if swap_eqn\n\n! multiply equation irow by -a1(jrow,irow)/a1(irow,irow),\n! and add it to eqn jrow (for all eqns except irow itself).\neliminate: do jrow = 1, n\nif ( jrow /= irow ) then\nfactor = -a1(jrow,irow)/a1(irow,irow)\na1(jrow,:) = a1(irow,1:n)*factor + a1(jrow,1:n)\nsoln(jrow) = soln(irow)*factor + soln(jrow)\nend if\nend do eliminate\nend do mainloop\n! end of main loop over all equations. all off-diagonal terms\n! are now zero. to get the final answer, we must divide\n! each equation by the coefficient of its on-diagonal term.\ndivide: do irow = 1, n\nsoln(irow) = soln(irow) / a1(irow,irow)\na1(irow,irow) = 1.\nend do divide\n! set error flag to 0 and return.\nerror = 0\nend subroutine simul\n"}, {"instruction": "Create a Fortran subroutine named spl_derivative_matrix to calculate the derivative matrix for a given set of knots and spline order. The subroutine takes 4 input parameters: n (integer), p (integer), knots (real(8) array), and normalize (optional logical). It outputs a matrix of real(8) values.", "input": "", "output": "  subroutine spl_derivative_matrix(n, p, knots, mat, normalize)\n  implicit none\n    integer,                 intent(in)  :: n\n    integer,                 intent(in)  :: p\n    real(8), dimension(:),   intent(in)  :: knots\n    real(8), dimension(:,:), intent(out) :: mat \n    logical, optional      , intent(in)  :: normalize\n    ! local\n    integer :: i\n    integer :: j \n    real(8) :: alpha\n    logical :: l_normalize\n\n    ! ...\n    l_normalize = .false.\n    if (present(normalize)) then\n      l_normalize = normalize\n    end if\n    ! ...\n\n    ! ...\n    mat = 0.0d0\n    ! ...\n\n    ! ...\n    i = 1\n    mat(i,i)   =  1.0d0 \n\n    if (.not. l_normalize) then\n      alpha      = p * 1.0d0 / (knots(i+p+1) - knots(i)) \n\n      mat(i,i)   =   alpha * mat(i,i)\n    end if\n    ! ...\n\n    ! ...\n    do i = 2, n \n      ! ...\n      mat(i,i)   =  1.0d0 \n      mat(i-1,i) = -1.0d0 \n      ! ...\n\n      ! ...\n      if (.not. l_normalize) then\n        alpha      = p * 1.0d0 / (knots(i+p+1) - knots(i)) \n\n        mat(i,i)   =   alpha * mat(i,i)\n        mat(i-1,i) = - alpha * mat(i-1,i) \n      end if\n      ! ...\n    end do\n    ! ...\n\n  end subroutine spl_derivative_matrix\n"}, {"instruction": "Create a Fortran subroutine named spl_compute_spans to calculate the spans of elements in a spline curve. The subroutine takes 3 input parameters of type integer, integer, and real(kind=8) array, and 1 output parameter of type integer array.", "input": "", "output": "  subroutine spl_compute_spans(p, n, knots, elements_spans)\n  implicit none\n    integer,                    intent(in)  :: n\n    integer,                    intent(in)  :: p\n    real(kind=8), dimension(:), intent(in)  :: knots\n    integer,      dimension(:), intent(out) :: elements_spans\n    ! local variables\n    integer :: i_element\n    integer :: i_knot\n    integer :: i_b\n    integer :: i_e\n\n    ! ...\n    elements_spans = -1 \n    ! ...\n\n    ! ...\n    i_b = lbound(knots, 1)\n    i_e = ubound(knots, 1)\n    ! ...\n\n    ! ...\n    i_element = 0\n    do i_knot = i_b, i_e - p - 1 \n      ! we check if the element has zero measure\n      if ( knots(i_knot) /= knots(i_knot + 1) ) then\n        i_element = i_element + 1\n        \n        elements_spans(i_element) = i_knot\n      end if\n    end do\n    ! ...\n     \n  end subroutine spl_compute_spans \n"}, {"instruction": "Create a Fortran subroutine named spl_construct_grid_from_knots to construct a grid from the given knots for spline interpolation. The subroutine takes 4 input parameters of type integer, integer, integer, and real(kind=8) array, and 1 output parameter of type real(kind=8) array.", "input": "", "output": "  subroutine spl_construct_grid_from_knots(p, n, n_elements, knots, grid)\n    implicit none\n    integer, intent(in)  :: p\n    integer, intent(in)  :: n\n    integer, intent(in)  :: n_elements\n    real(kind=8), dimension(:), intent(in)  :: knots\n    real(kind=8), dimension(:), intent(out) :: grid\n    ! local\n    integer :: i\n    integer :: i_b\n    integer :: i_e\n\n    ! ...\n    i_b = lbound(knots, 1)\n    i_e = ubound(knots, 1)\n    ! ...\n\n    ! ...\n    grid = 0.0\n    do i = i_b, i_b+n_elements, 1\n      grid(i) = knots(i + p)\n    end do\n    ! ...\n\n  end subroutine spl_construct_grid_from_knots\n"}, {"instruction": "Create a Fortran subroutine named spl_construct_quadrature_grid to calculate the quadrature grid points and weights for a given set of parameters. The subroutine has 3 input parameters of type real(kind=8), dimension(:), and 2 output parameters of type real(kind=8), dimension(:,:).\n\nThe subroutine takes 3 input parameters of type real(kind=8), dimension(:) named u, w, and grid, and calculates the points and weights for the quadrature grid. The calculated points and weights are stored in the output parameters points and weights, both of type real(kind=8), dimension(:,:).\n\nThe subroutine uses imperative tone and reflects the features of Fortran subroutine.", "input": "", "output": "  subroutine spl_construct_quadrature_grid(u, w, grid, points, weights)\n    implicit none\n    real(kind=8), dimension(:), intent(in) :: u\n    real(kind=8), dimension(:), intent(in) :: w\n    real(kind=8), dimension(:), intent(in) :: grid \n    real(kind=8), dimension(:,:), intent(out) :: points\n    real(kind=8), dimension(:,:), intent(out) :: weights\n    ! local\n    integer :: i_b\n    integer :: i_e\n    integer :: k_b\n    integer :: k_e\n    integer :: i_element\n    integer :: i_point\n    real(kind=8) :: a\n    real(kind=8) :: b\n    real(kind=8) :: half\n\n    ! ...\n    i_b = lbound(grid, 1)\n    i_e = ubound(grid, 1)\n\n    k_b = lbound(u, 1)\n    k_e = ubound(u, 1)\n    ! ...\n\n    points  = 0.0\n    weights = 0.0\n\n    do i_element = i_b, -1 + i_e, 1\n      a = grid(i_element)\n      b = grid(i_element + 1)\n      half = 0.5d0*(-a + b)\n\n      do i_point = k_b, k_e, 1\n        points(i_point, i_element) = (u(i_point) + 1.0d0)*half + a\n        weights(i_point, i_element) = w(i_point)*half\n      end do\n    end do\n\n  end subroutine spl_construct_quadrature_grid\n"}, {"instruction": "Create a Fortran subroutine named \"getjminmax\" to determine the values of \"j_min\" and \"j_max\" based on the input parameters \"l\" and \"n\". The subroutine should have 2 input parameters of type integer, [\"l\", \"n\"], and 2 output parameters of type integer, [\"j_min\", \"j_max\"]. The purpose of the subroutine is to calculate the values of \"j_min\" and \"j_max\" according to specific conditions based on the values of \"l\" and \"n\".", "input": "", "output": "      subroutine getjminmax(l,n,j_min,j_max)\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      integer, intent(in) :: l, n\n      integer, intent(out):: j_min,j_max\n!-----------------------------------------------\n!\n      if(n==0 .or. 4*l+2-n==0) then\n         j_min = 0\n         j_max = 0\n      else if(n==1 .or. 4*l+2-n==1) then\n         j_min = iabs(2*l-1)\n         j_max = 2*l+1\n      else if(n==2 .or. 4*l+2-n==2) then\n         j_min = 0\n         j_max = 4*l\n      else if(l == 1) then\n         if(n==3) then\n            j_min = 1\n            j_max = 5\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else if(l==2) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==7) then\n            j_min = 1\n            j_max = 11\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==6) then\n            j_min = 0\n            j_max = 12\n         else if(n==5) then\n            j_min = 1\n            j_max = 13\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else if(l==3) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==11) then\n            j_min = 1\n            j_max = 17\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==10) then\n            j_min = 0\n            j_max = 20\n!gg!         else if(n==5) then\n         else if(n==5 .or. n==9) then\n            j_min = 1\n            j_max = 23\n!gg!         else if(n==6) then\n         else if(n==6 .or. n==8) then\n            j_min = 0\n            j_max = 24\n         else if(n==7) then\n            j_min = 1\n            j_max = 25\n         else\n            write(6,'(a)') 'error in getjminmax'\n            write(6,'(a6,2i5)') 'l,n = ',l,n\n            stop\n         end if\n      else\n         write(6,'(a)') 'error in getjminmax'\n         write(6,'(a6,2i5)') 'l,n = ',l,n\n         stop\n      end if\n      return\n      end subroutine getjminmax\n"}, {"instruction": "Create a Fortran subroutine named getjjjminmax that takes 2 input parameters of type integer and returns 2 output parameters of type integer. The subroutine evaluates the values of j_min and j_max based on the input parameters j and n, according to a set of conditional statements. If the conditions are met, the subroutine assigns specific values to j_min and j_max; otherwise, it outputs an error message and stops the program.", "input": "", "output": "      subroutine getjjjminmax(j,n,j_min,j_max)\n!-----------------------------------------------\n!   d u m m y   a r g u m e n t s\n!-----------------------------------------------\n      implicit none\n      integer, intent(in) :: j, n\n      integer, intent(out):: j_min,j_max\n!-----------------------------------------------\n!\n      if(n==0 .or. j+1-n==0) then\n         j_min = 0\n         j_max = 0\n      else if(n==1 .or. j+1-n==1) then\n         j_min = j\n         j_max = j\n      else if(n==2 .or. j+1-n==2) then\n         j_min = 0\n         j_max = 2*(j-1)\n      else if(j == 5) then\n         if(n==3) then\n!gg!!            j_min = 5\n            j_min = 3\n            j_max = 9\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else if(j==7) then\n         if(n==3 .or. n==5) then\n!gg!!            j_min = 7\n            j_min = 3\n            j_max = 15\n         else if(n==4) then\n            j_min = 0\n            j_max = 16\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else if(j==9) then\n!gg!         if(n==3) then\n         if(n==3 .or. n==7) then\n            j_min = 3\n            j_max = 21\n!gg!         else if(n==4) then\n         else if(n==4 .or. n==6) then\n            j_min = 0\n            j_max = 24\n         else if(n==5) then\n            j_min = 3\n            j_max = 25\n         else\n            write(6,'(a)') 'error in getjjjminmax'\n            write(6,'(a8,2i5)') '2*j,n = ',j,n\n            stop\n         end if\n      else\n         write(6,'(a)') 'error in getjjjminmax'\n         write(6,'(a8,2i5)') '2*j,n = ',j,n\n         stop\n      end if\n      return\n      end subroutine getjjjminmax\n"}, {"instruction": "Write a Fortran subroutine named diffq_spm to compute the differential equations for a specific physical system. The number of input arguments is 5 and the test_data type is ['real(kind=8), dimension(6)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)', 'real(kind=8)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(6)'].", "input": "", "output": "  subroutine diffq_spm(x, mass1, mass2, eps1, eps2, f)\n\n    implicit none\n    real(kind=8), dimension(6), intent(in) :: x\n    real(kind=8), intent(in) :: mass1, mass2\n    real(kind=8), intent(in) :: eps1, eps2\n    real(kind=8), dimension(6), intent(out):: f\n\n    real(kind=8) :: r21, r1, a1\n\n\n\n    r21=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)\n    r1=sqrt(r21)\n\n    a1 = -mass1 / (r21 + eps1) - mass2 / (r21 + eps2)\n\n    f(1) = x(4)\n    f(2) = x(5)\n    f(3) = x(6)\n    f(4) = a1 * x(1)/r1\n    f(5) = a1 * x(2)/r1\n    f(6) = a1 * x(3)/r1\n\n\n    return\n  end subroutine diffq_spm\n"}, {"instruction": "Create a Fortran subroutine named init to initialize an array with a specified value. The subroutine takes 2 input parameters: an integer n and a real number val, and has 1 output parameter: a real array x of size n. The input parameter types are ['integer', 'real(kind=4)'] and the output parameter type is ['real(kind=4), dimension(n)']. Use the imperative tone to define the subroutine.", "input": "", "output": "subroutine init (x, n, val)\n        integer, intent(in) :: n\n        real(kind=4), intent(out), dimension(n) :: x\n        real(kind=4), intent(in) :: val\n        do i=1,n\n                x(i)=val\n        end do\nend subroutine init\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorlogical that copies a logical vector lx to another vector ly. The subroutine takes 2 input parameters: lx of type logical, dimension(:) and an optional integer parameter n. It has 1 output parameter: ly of type logical, dimension(:).", "input": "", "output": "  subroutine lalg_copyvectorlogical (lx,ly,n)\n\n!<description>\n  ! copies a logical vector lx: ly = lx\n!</description>\n\n!<input>\n\n  ! source vector\n  logical, dimension(:), intent(in) :: lx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  logical, dimension(:), intent(out) :: ly\n\n!</output>\n\n  integer :: i\n\n    if (.not. present(n)) then\n\n#ifdef has_openmp40\n      !$omp parallel do simd if(size(lx) > lalg_perfconfig%nitemmin_omp)\n#endif\n      do i = 1, size(lx)\n        ly(i) = lx(i)\n      end do\n#ifdef has_openmp40\n      !$omp end parallel do simd\n#endif\n\n    else\n\n#ifdef has_openmp40\n      !$omp parallel do simd if(n > lalg_perfconfig%nitemmin_omp)\n#endif\n      do i = 1, n\n        ly(i) = lx(i)\n      end do\n#ifdef has_openmp40\n      !$omp end parallel do simd\n#endif\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorlogical2d to copy a 2D logical vector from source lx to destination ly. The subroutine takes 3 input parameters: lx of type logical, dimension(:,:), n of type integer (optional), and m of type integer (optional). It also has 1 output parameter ly of type logical, dimension(:,:).", "input": "", "output": "  subroutine lalg_copyvectorlogical2d (lx,ly,n,m)\n\n!<description>\n  ! copies a logical vector lx: ly = lx\n!</description>\n\n!<input>\n\n  ! source vector\n  logical, dimension(:,:), intent(in) :: lx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  logical, dimension(:,:), intent(out) :: ly\n\n!</output>\n\n\n  integer :: i,j\n\n    if (present(n) .and. present(m)) then\n\n      do j = 1, m\n        do i = 1, n\n          ly(i,j) = lx(i,j)\n        end do\n      end do\n\n    else\n\n      do j = 1, size(lx,2)\n        do i = 1, size(lx,1)\n          ly(i,j) = lx(i,j)\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorchar2d to copy a 2D character array from the source vector sx to the destination vector sy. The subroutine takes 3 input parameters: sx, an array of characters with dimensions (:,:), and two optional integers n and m. It has 1 output parameter: sy, an array of characters with dimensions (:,:). If n and m are provided, the subroutine copies the subarray of size (n,m) from sx to sy; otherwise, it copies the entire array from sx to sy.", "input": "", "output": "  subroutine lalg_copyvectorchar2d (sx,sy,n,m)\n\n!<description>\n  ! copies a character vector sx: sy = sx\n!</description>\n\n!<input>\n\n  ! source vector\n  character, dimension(:,:), intent(in) :: sx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  character, dimension(:,:), intent(out) :: sy\n\n!</output>\n\n\n  integer :: i,j\n\n    if (present(n) .and. present(m)) then\n\n      do j = 1, m\n        do i = 1, n\n          sy(i,j) = sx(i,j)\n        end do\n      end do\n\n    else\n\n      do j = 1, size(sx,2)\n        do i = 1, size(sx,1)\n          sy(i,j) = sx(i,j)\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_copyvectorchar3d to copy a 3-dimensional character vector from the source vector sx to the destination vector sy. The subroutine takes 4 input parameters: sx (character, dimension(:,:,:)), n (integer, optional), m (integer, optional), o (integer, optional), and 1 output parameter: sy (character, dimension(:,:,:)).\n", "input": "", "output": "  subroutine lalg_copyvectorchar3d (sx,sy,n,m,o)\n\n!<description>\n  ! copies a character vector sx: sy = sx\n!</description>\n\n!<input>\n\n  ! source vector\n  character, dimension(:,:,:), intent(in) :: sx\n\n  ! optional: size of the vector\n  integer, intent(in), optional :: n,m,o\n\n!</input>\n\n!<output>\n\n  ! destination vector\n  character, dimension(:,:,:), intent(out) :: sy\n\n!</output>\n\n\n  integer :: i,j,k\n\n    if (present(n) .and. present(m)) then\n\n      do k = 1, o\n        do j = 1, m\n          do i = 1, n\n            sy(i,j,k) = sx(i,j,k)\n          end do\n        end do\n      end do\n\n    else\n\n      do k = 1, size(sx,3)\n        do j = 1, size(sx,2)\n          do i = 1, size(sx,1)\n            sy(i,j,k) = sx(i,j,k)\n          end do\n        end do\n      end do\n\n    end if\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lalg_setvectorchar2d to set the elements of a two-dimensional character array to a specified character value. The subroutine takes 1 input parameter of type character and 1 output parameter of type character, dimension(:,:).", "input": "", "output": "  subroutine lalg_setvectorchar2d (sx,svalue)\n\n!<description>\n  ! sets the vector data to a defined value: sx = svalue\n!</description>\n\n!<input>\n  ! the value, the vector should be set to.\n  character, intent(in) :: svalue\n!</input>\n\n!<output>\n  ! destination vector to be set\n  character, dimension(:,:), intent(out) :: sx\n!</output>\n\n\n  ! local variables\n  integer :: i,j\n\n    do j = 1, size(sx,2)\n      do i = 1, size(sx,1)\n        sx(i,j) = svalue\n      end do\n    end do\n\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named `lalg_setvectorlogical3d` to set the elements of a 3D logical array to a specified logical value. The number of input arguments is 1, and the test_data type is ['logical']. The number of output arguments is 1, and the test_data type is ['logical, dimension(:,:,:)'].", "input": "", "output": "  subroutine lalg_setvectorlogical3d (lx,lvalue)\n\n!<description>\n  ! sets the vector data to a defined value: lx = lvalue\n!</description>\n\n!<input>\n  ! the value, the vector should be set to.\n  logical, intent(in) :: lvalue\n!</input>\n\n!<output>\n  ! destination vector to be set\n  logical, dimension(:,:,:), intent(out) :: lx\n!</output>\n\n\n  ! local variables\n  integer :: i,j,k\n\n    do k = 1, size(lx,3)\n      do j = 1, size(lx,2)\n        do i = 1, size(lx,1)\n          lx(i,j,k) = lvalue\n        end do\n      end do\n    end do\n\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rgbmono that converts RGB colors to a reasonable grayscale. The subroutine takes 3 input parameters of type real (rr, rg, rb) representing red, green, and blue intensities ranging from 0 to 100, and provides 2 output parameters of type real (ri) and integer (status). The status variable indicates the success or failure of the computation.", "input": "", "output": "subroutine rgbmono(rr,rg,rb,ri,status)\n\n! ident_7=\"@(#)m_color::rgbmono(3f): convert rgb colors to a reasonable grayscale\"\n\n! monochrome devices that support intensity can have intensity calculated from the specified red, green, blue\n! intensities as 0.30*r + 0.59*g + 0.11*b, as in us color television systems, ntsc encoding.\n! note that most devices do not have an infinite range of monochrome intensities available.\n\nreal,intent(in)      :: rr,rg,rb                ! red, green, blue, & intensity range from 0 to 100\nreal,intent(out)     :: ri\ninteger,intent(out)  :: status\n   status=0\n   if(rr .lt. 0.0 .or. rr .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   if(rg .lt. 0.0 .or. rg .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   if(rb .lt. 0.0 .or. rb .gt. 100.0 ) status = 1 !---- passive check for valid range of values.\n   ri = 0.30*rr + 0.59*rg + 0.11*rb\nend subroutine rgbmono\n"}, {"instruction": "Create a Fortran subroutine named \"sistl\" to solve a linear system of equations using the forward substitution method. The subroutine takes two input parameters of type real, dimension(:,:) and real, dimension(:), and one output parameter of type real, dimension(:).", "input": "", "output": "subroutine sistl(a, b, w)\n\nimplicit none\n\nreal, dimension(:,:), intent(in) :: a\nreal, dimension(:), intent(in) :: b\nreal, dimension(:), intent(out) :: w\n\ninteger :: n, i, j\n\nn = size(b)\n\nprint*, 'o termo independente b e: '\nprint*, b\nprint*,\n\nw(1) = b(1)/a(1,1)\n\ndo i = 2,n\n  w(i) = b(i)\n  do j = 1,i-1\n    w(i) = w(i) - a(i,j)*w(j)\n  enddo\n\n  w(i) = w(i)/a(i,i)\nenddo\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named sort_positions to reorder the positions of elements in an array based on their values. The subroutine takes 2 input parameters: an integer n and a real array a of dimension n. It also has 1 output parameter, an integer array ipiv of dimension n.", "input": "", "output": "subroutine sort_positions(n,a,ipiv)\n  implicit none\n  integer, intent(in) :: n\n  real(kind=8), dimension(n), intent(in) :: a\n  integer, dimension(n), intent(out) :: ipiv\n  !local variables\n  integer :: i,j,jmax,imax\n  real(kind=8) :: locmax\n\n  !neutral permutation\n  do i=1,n\n     ipiv(i)=i\n  end do\n  !find the order for all the arrays\n  do j=1,n\n  !search the maximum\n     locmax=-1.d300\n     do i=j,n\n        if (locmax < a(ipiv(i))) then\n           locmax=a(ipiv(i))\n           jmax=ipiv(i)\n           imax=i\n        end if\n     end do\n     !swap the position with j\n     ipiv(imax)=ipiv(j) !throw in the present element\n     ipiv(j)=jmax       !take out the present maximum\n  end do\n  !do i=1,n\n  !   print *,'a',i,a(i),ipiv(i),a(ipiv(i))\n  !end do\n  !stop\nend subroutine sort_positions\n"}, {"instruction": "Write a Fortran subroutine named sub to calculate the sum of two integer numbers. The subroutine takes 2 input parameters of integer type and provides 1 output parameter of integer type. The input parameters should be declared with the \"intent(in)\" attribute and the output parameter should be declared with the \"intent(out)\" attribute.", "input": "", "output": "elemental subroutine sub(a,b,c)\n  integer :: func, a, b, c\n  intent(in) :: b,c\n  intent(out) :: a\n  a = b +c\nend subroutine sub\n"}, {"instruction": "Write a Fortran subroutine named lagder to compute the derivative of a Lagrange interpolating polynomial. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine lagder(n,x,y,der)\n  implicit none\n  real*8, intent(in) :: x(n),y(n)\n  integer, intent(in):: n\n  real*8, intent(out):: der\n  ! locals\n  integer:: i, j, k\n  real*8 :: ade, anu, de, xu\n  xu=x(1)\n  de=0.d0\n  do k=2,n\n     de=de+1.d0/(xu-x(k))\n  enddo\n  de=de*y(1)\n  \n  do i=2,n\n     anu=1.d0\n     do j=2,n\n        if(j.eq.i) cycle\n        anu=anu*(xu-x(j))\n     enddo\n     ade=1.d0\n     do j=1,n\n        if(j.eq.i) cycle\n        ade=ade*(x(i)-x(j))\n     enddo\n     de=de+y(i)*anu/ade\n  enddo\n  der=de\n  return\nend subroutine lagder\n"}, {"instruction": "Create a Fortran subroutine named decompose to distribute a range of indices across multiple processes. The subroutine takes 2 input parameters of type integer: n and nprocs. It also has 2 output parameters of type integer arrays with dimensions (0:nprocs-1): jbeg and jend.", "input": "", "output": "subroutine decompose(n, nprocs, jbeg, jend)\n        implicit none\n\n        integer, intent(in) :: n, nprocs\n        integer, dimension(0:nprocs-1), intent(out) :: jbeg, jend\n        integer :: loc_size, i\n\n        loc_size = n/nprocs \n        do i = 0, nprocs-1\n\n                jbeg(i) = i*loc_size + 1\n                jend(i) = jbeg(i) + loc_size - 1\n\n\n        end do \n\n        if (mod(n, nprocs).ne.0) then \n                jend(nprocs-1) = jend(nprocs-1) + mod(n, nprocs)\n        end if\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"foo\" that takes an integer input parameter and returns an integer output parameter. The subroutine contains a nested subroutine \"bar\" which reads input using a namelist. The main subroutine assigns the value read by \"bar\" to the output parameter.", "input": "", "output": "subroutine foo (nnml, outv)\n  integer, intent(in) :: nnml\n  integer, intent(out) :: outv\n  integer :: grid\n  call bar\n  outv = grid\ncontains\n  subroutine bar\n    namelist /n/ grid\n    read (nnml, nml=n)\n  end subroutine bar\nend subroutine foo\n"}, {"instruction": "Write a Fortran subroutine named valid that takes an array of integers as input and assigns the value of the first element of the array to an output integer variable. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine valid (lhs,rhs)\n    integer, intent(out) ::  lhs\n    integer, intent(in) :: rhs(:)\n    lhs = rhs(1) \n  end subroutine valid\n"}, {"instruction": "Write a Fortran subroutine named valid2 that takes an array of integers as input and another 2D array of integers. The first element of the input array is assigned the values from the first column of the 2D array. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "  subroutine valid2 (lhs,rhs)\n    integer, intent(out) ::  lhs(:)\n    integer, intent(in) :: rhs(:,:)\n    lhs(:) = rhs(:,1) \n  end subroutine valid2\n"}, {"instruction": "Create a Fortran subroutine named \"invalid\" to assign the value of an integer input parameter to an output parameter. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer]. Ensure that the input parameter is declared with the \"intent(in)\" attribute, and the output parameter is declared with the \"intent(out)\" attribute.", "input": "", "output": "  subroutine invalid (lhs,rhs) ! { dg-error \"must not redefine an intrinsic type assignment\" }\n    integer, intent(out) ::  lhs\n    integer, intent(in) :: rhs\n    lhs = rhs\n  end subroutine invalid\n"}, {"instruction": "Create a Fortran subroutine named \"sca_deplcrv\" with two input parameters of type real and one output parameter of type real. The input parameters are \"snarea_curve\" (an array of 11 real numbers) and \"frac_swe\" (a real number). The output parameter is \"snowcov_area\" (a real number). The subroutine calculates the snow-covered area based on the depletion curve and the fractional snow water equivalent (SWE) provided. If the fractional SWE is greater than 1.0, the snow-covered area is set to the value at the 11th index of the depletion curve. Otherwise, it linearly interpolates the snow-covered area between the two closest points on the depletion curve based on the fractional SWE. Use intrinsic functions int and float for integer and floating-point conversions.", "input": "", "output": "      subroutine sca_deplcrv(snowcov_area, snarea_curve, frac_swe)\n      implicit none\n! functions\n      intrinsic :: int, float\n! arguments\n      real, intent(out) :: snowcov_area\n      real, intent(in) :: snarea_curve(11), frac_swe\n! local variables\n      integer :: idx, jdx\n      real :: af, dify, difx\n!***********************************************************************\n      if ( frac_swe>1.0 ) then\n        snowcov_area = snarea_curve(11)\n      else\n\n        ! get the indices (as integers) of the depletion curve that\n        ! bracket the given frac_swe (next highest and next lowest)\n        idx = int( 10.0*(frac_swe+0.2) ) ! [index]\n        jdx = idx - 1 ! [index]\n        if ( idx>11 ) idx = 11\n        ! calculate the fraction of the distance (from the next lowest)\n        ! the given frac_swe is between the next highest and lowest\n        ! curve values\n        af = float( jdx-1 )\n        dify = (frac_swe*10.0) - af ! [fraction]\n        ! calculate the difference in snow covered area represented\n        ! by next highest and lowest curve values\n        difx = snarea_curve(idx) - snarea_curve(jdx)\n        ! linearly interpolate a snow covered area between those\n        ! represented by the next highest and lowest curve values\n        snowcov_area = snarea_curve(jdx) + dify*difx\n      endif\n      end subroutine sca_deplcrv\n"}, {"instruction": "Create a Fortran subroutine named restart_index_to_vector_offset that takes an integer input argument and returns an integer output. The subroutine computes the offset value using the input index and the field size. The input parameter is of type integer, and the output parameter is also of type integer.", "input": "", "output": "  subroutine restart_index_to_vector_offset(var_index, var_offset)\n    integer, intent(in)  :: var_index\n    integer, intent(out) :: var_offset\n\n    var_offset = (var_index - 1) * field_size \n  end subroutine restart_index_to_vector_offset\n"}, {"instruction": "Create a Fortran subroutine named fornbergweights which calculates the weights for Fornberg interpolation. The subroutine has 3 input parameters of type real(dpk), real(dpk), and integer, and 1 output parameter of type real(dpk).", "input": "", "output": "\tsubroutine fornbergweights( x, ksi, m, c )\n\t\tinteger, parameter :: dpk = kind(1.d0)\n\t\t\n\t\treal(dpk), intent(in) :: x(0:)\n\t\treal(dpk), intent(in) :: ksi\n\t\tinteger, intent(in) :: m\n\t\treal(dpk), intent(out) :: c(0:,0:,0:)\n\t\t\t\n\t\treal (dpk) :: a, b, temp1, temp2, d\n\t\tinteger :: i, j, k\n\t\tinteger :: minim\n\t\t\n\t\tc(0,0,0) = 1.0_dpk\n\t\t\n\t\ta = 1.0_dpk\n\t\t\n\t\tdo i=1,ubound(x,1)\n\t\t\tminim = min(i,m)\n\t\t\tb = 1.0_dpk\n\t\t\t\t\n\t\t\ttemp1 = x(i) - ksi\n\t\t\t\t\n\t\t\tdo j=0,i-1\n\t\t\t\ttemp2 = x(i) - x(j)\n\t\t\t\t\n\t\t\t\tb = b * temp2\n\t\t\t\t\n\t\t\t\tif( i <= m ) c(i-1,j,i) = 0.0_dpk\n\t\t\t\t\t\n\t\t\t\tc(i,j,0) = temp1 * c(i-1,j,0) / temp2\n\t\t\t\t\t\n\t\t\t\tdo k = 1, minim\n\t\t\t\t\tc(i,j,k) = (temp1 * c(i-1,j,k) - k * c(i-1,j,k-1)) / temp2\n\t\t\t\tenddo\n\t\t\tenddo\n\t\t\n\t\t\td = a / b\n\t\t\ttemp1 = d * (ksi - x(i-1))\n\t\t\t\n\t\t\tc(i,i,0) = temp1 * c(i-1,i-1,0)\n\t\t\t\n\t\t\tdo k = 1, minim\n\t\t\t\tc(i,i,k) = d * k * c(i-1,i-1,k-1) + temp1 * c(i-1,i-1,k)\n\t\t\tenddo\n\t\t\t\n\t\t\ta = b\n\t\tenddo\n\t\t\n\tend subroutine fornbergweights\n"}, {"instruction": "Write a Fortran subroutine named trend_zfac to calculate the compressibility factor and its derivatives with respect to temperature, pressure, and composition. The number of input arguments is 3 and the test_data type is [real, real, real]. The number of output arguments is 4, with test_data types [real, real (optional), real (optional), real (optional)].", "input": "", "output": "  subroutine trend_zfac(t, rho, x, zfac, dzdt, dzdp, dzdx)\n    implicit none\n    ! input:\n    real,   intent(in)          :: t        !< temperature (k)\n    real,   intent(in)          :: rho      !< density (mol/m^3)\n    real,   intent(in)          :: x(:) !< composition (mol/mol)\n    ! output:\n    real,   intent(out)         :: zfac !< compressibility factor (-)\n    real, optional, intent(out) :: dzdt !< zfac diff. wrt. temperature\n    real, optional, intent(out) :: dzdp !< zfac diff. wrt. pressure\n    real, optional, intent(out) :: dzdx(:) !< zfac diff. wrt. composition\n    ! trend functions:\n    zfac = 0.0\n    if (present(dzdt)) then\n      dzdt = 0.0\n    endif\n    if (present(dzdp)) then\n      dzdp = 0.0\n    endif\n    if (present(dzdx)) then\n      dzdx = 0.0\n    endif\n  end subroutine trend_zfac\n"}, {"instruction": "Write a Fortran subroutine named trend_residualentropy_tp to calculate the specific residual entropy based on temperature, pressure, density, and composition as inputs. The number of input arguments is 4 with test data types ['real', 'real', 'real', 'real, dimension(:)']. The number of output arguments is 4 with test data types ['real', 'real, optional', 'real, optional', 'real, optional']. Use an imperative tone in your instructions.", "input": "", "output": "  subroutine trend_residualentropy_tp(t,p,rho,x,sr,dsrdt,dsrdp,dsrdx)\n    implicit none\n    ! input:\n    real, intent(in)                  :: t    !< temperature (k)\n    real, intent(in)                  :: p    !< pressure (pa)\n    real, intent(in)                  :: rho  !< density (mol/m3)\n    real, dimension(:), intent(in) :: x    !< composition (mol/mol)\n    ! output:\n    real, intent(out)                 :: sr   !< specific residual entropy\n                                              ! (j/(mol*k)\n    real, optional, intent(out)       :: dsrdt!< specific residual entropy diff.\n                                              ! wrpt. temperature (j/(mol*k^2)\n    real, optional, intent(out)       :: dsrdp!< specific residual entropy diff.\n                                              ! wrpt. pressure (j/(mol*k*pa)\n    real, optional, intent(out)       :: dsrdx(:) !< specific residual\n                                              !entropy diff. wrpt. mole numbers\n                                              ! (j/(mol^2*k)\n    sr = 0.0\n    if (present(dsrdt)) then\n      dsrdt = 0.0\n    endif\n    if (present(dsrdp)) then\n      dsrdp = 0.0\n    endif\n    if (present(dsrdx)) then\n      dsrdx = 0.0\n    endif\n\n  end subroutine trend_residualentropy_tp\n"}, {"instruction": "Write a Fortran subroutine named trend_thermotv to calculate thermodynamic properties based on temperature, volume, and number of moles. The subroutine takes 3 input parameters of type real: t, v, and n. It has 4 output parameters of type real, which are optional: lnfug, lnfugt, lnfugv, and lnfugn. If present, these output parameters are set to 0.0.", "input": "", "output": "  subroutine trend_thermotv(t,v,n,lnfug,lnfugt,lnfugv,lnfugn)\n    implicit none\n    real, intent(in) :: t,v,n(:)\n    ! output.\n    real, optional, intent(out) :: lnfug(:)\n    real, optional, intent(out) :: lnfugt(:),lnfugv(:),lnfugn(:,:)\n    ! locals\n    if (present(lnfug)) then\n      lnfug = 0.0\n    endif\n    if (present(lnfugt)) then\n      lnfugt = 0.0\n    endif\n    if (present(lnfugv)) then\n      lnfugv = 0.0\n    endif\n    if (present(lnfugn)) then\n    lnfugn = 0.0\n    endif\n  end subroutine trend_thermotv\n"}, {"instruction": "Create a Fortran subroutine named `trend_calcfid` that calculates various trend-related values. The subroutine should have 3 input parameters of type real and 10 optional output parameters of type real. The input parameters are `t`, `v`, and `n`, while the optional output parameters are `f`, `f_t`, `f_v`, `f_tt`, `f_tv`, `f_vv`, `f_n`, `f_tn`, `f_vn`, and `f_nn`.", "input": "", "output": "  subroutine trend_calcfid(t,v,n,f,f_t,f_v,f_tt,f_tv,f_vv,f_n,f_tn,f_vn,f_nn)\n    implicit none\n    real, intent(in) :: t,v,n(:)\n    ! output.\n    real, optional, intent(out) :: f,f_t,f_v,f_tt,f_tv,f_vv\n    real, optional, intent(out) :: f_n(:),f_tn(:),f_vn(:),f_nn(:,:)\n    ! locals\n\n    if (present(f)) f = 0.0\n    if (present(f_t)) f_t = 0.0\n    if (present(f_tt)) f_tt = 0.0\n    if (present(f_v)) f_v = 0.0\n    if (present(f_tv)) f_tv = 0.0\n    if (present(f_vv)) f_vv = 0.0\n\n    if (present(f_n)) then\n      f_n = 0.0\n    endif\n    if (present(f_tn)) then\n      f_tn = 0.0\n    endif\n    if (present(f_vn)) then\n      f_vn = 0.0\n    endif\n    if (present(f_nn)) then\n      f_nn = 0.0\n    endif\n  end subroutine trend_calcfid\n"}, {"instruction": "Create a Fortran subroutine named vol_int_part to compute the volume integral with partial bottom cells. The subroutine takes 10 input parameters of types integer, real, and real arrays, and outputs 1 real parameter. The subroutine calculates the integral using the provided input fields, areas, and depth arrays, considering partial bottom cells.", "input": "", "output": "subroutine vol_int_part(imin,jmin,kmin,imax,jmax,kmax,field,area,dz,dz_3d,integral)\n!\n!     calculates volume integral (*[m^3]) with partial bottom cells\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(km),         intent(in)  :: dz\nreal,    dimension(imt,jmt,km), intent(in)  :: dz_3d,field\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,                           intent(out) :: integral\n\nintegral = sum( area(imin:imax,jmin:jmax)                                      &\n                * sum( dz_3d(imin:imax,jmin:jmax,kmin:kmax)                    &\n                       * field(imin:imax,jmin:jmax,kmin:kmax),                 &\n               3,dz_3d(imin:imax,jmin:jmax,kmin:kmax).ne.0.0 ) )\n\nend subroutine vol_int_part\n"}, {"instruction": "Create a Fortran subroutine named \"vol_int_full\" to calculate the volume integral with full bottom cells. The subroutine takes 10 input parameters: imin, jmin, kmin, imax, jmax, kmax of type integer, arrays dz, dz_3d, field, and area of type real. The output parameter is \"integral\" of type real.", "input": "", "output": "subroutine vol_int_full(imin,jmin,kmin,imax,jmax,kmax,field,area,dz,dz_3d,integral)\n!\n!     calculates volume integral (*[m^3]) with full bottom cells\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(km),         intent(in)  :: dz\nreal,    dimension(imt,jmt,km), intent(in)  :: dz_3d,field\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,                           intent(out) :: integral\n\nintegral = 0.0\ndo k = kmin,kmax\n  integral = integral                                                          &\n           + sum( area(imin:imax,jmin:jmax)*field(imin:imax,jmin:jmax,k),      &\n                  dz_3d(imin:imax,jmin:jmax,k).ne.0.0 ) * dz(k)\nenddo !k\n\nend subroutine vol_int_full\n"}, {"instruction": "Create a Fortran subroutine named vol_int2 that calculates the volume integral of a 3D field using Kahan summation. The subroutine takes 9 input parameters of types integer and real arrays, and outputs a single real value. The input parameters include the dimensions of the field, the field itself (3D), the area, and the depth.", "input": "", "output": "subroutine vol_int2(imin,jmin,kmin,imax,jmax,kmax,field,tarea,dzt,integral)\n!\n!     calculates volume integral (*[m^3]) for ttt-field via kahan summation\n!\nimplicit none\n\n! input/output variables\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                        intent(in)  :: imin,jmin,kmin,imax,jmax,kmax\nreal,    dimension(imt,jmt,km), intent(in)  :: dzt,field\nreal,    dimension(imt,jmt),    intent(in)  :: tarea\nreal,                           intent(out) :: integral\nreal                                        :: c, y, t\n\nintegral = 0.0\nc = 0.0\ndo k = kmin,kmax\n  do j = jmin,jmax\n    do i = imin,imax\n      if ( dzt(i,j,k).ne.0.0 ) then\n        y = tarea(i,j) * dzt(i,j,k) * field(i,j,k) - c\n        t = integral + y\n        c = ( t - integral ) - y\n        integral = t\n      endif\n    enddo !i\n  enddo !j\nenddo !k\n\nintegral = integral\n\nend subroutine vol_int2\n"}, {"instruction": "Create a Fortran subroutine named surf_int_3d to calculate the surface integrals of a 3D field. The subroutine takes 7 input parameters: imin, jmin, imax, jmax of type integer, and field, tarea, dzt_k of type real, each with dimensions imt and jmt. It produces 1 output parameter of type real. The subroutine uses the imperative tone and computes the surface integrals by weighting the contribution using the cell-depth and averaging the depth.", "input": "", "output": "subroutine surf_int_3d(imin,jmin,imax,jmax,field,tarea,dzt_k,integral)\n!  calculates surface integrals *[m^2] weighting contribution by (pbc)cell-depth\nimplicit none\n\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\ninteger,                     intent(in)  :: imin,jmin,imax,jmax\nreal,    dimension(imt,jmt), intent(in)  :: field,tarea,dzt_k\nreal,                        intent(out) :: integral\nreal                                     :: avg_dz\n\navg_dz   = sum( tarea(imin:imax,jmin:jmax) * dzt_k(imin:imax,jmin:jmax),       &\n                dzt_k(imin:imax,jmin:jmax).ne.0.0  ) /    &\n           sum( tarea(imin:imax,jmin:jmax),  dzt_k(imin:imax,jmin:jmax).ne.0.0 )\nintegral = sum( tarea(imin:imax,jmin:jmax) * field(imin:imax,jmin:jmax)        &\n              * dzt_k(imin:imax,jmin:jmax),  dzt_k(imin:imax,jmin:jmax).ne.0.0)\nintegral = integral/avg_dz\n\nend subroutine surf_int_3d\n"}, {"instruction": "Create a Fortran subroutine named area_avg that calculates the unweighted area average of a field over different vertical levels.\nThe subroutine takes 4 input parameters of type real, with dimensions (imt, jmt, km), (imt, jmt, km), (imt, jmt), and (km) respectively. It also has 1 output parameter of type real with dimension (km).", "input": "", "output": "subroutine area_avg(field,dzt,area,area_k,avg)\n! creates unweighted area average\n\ninteger                                     :: i,j,k\ninteger, parameter                          :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt,km), intent(in)  :: field, dzt\nreal,    dimension(imt,jmt),    intent(in)  :: area\nreal,    dimension(km),         intent(in)  :: area_k\nreal,    dimension(km),         intent(out) :: avg\n\ndo k=1,km\n  avg(k) = sum(field(:,:,k)*area(:,:),dzt(:,:,k).ne.0.0)/area_k(k)\nenddo\n\nend subroutine area_avg\n"}, {"instruction": "Create a Fortran subroutine named masked_avg to calculate the weighted average of a field over a masked area. The subroutine takes 5 input parameters of type real, each with dimensions (imt, jmt), real, and integer with dimensions (imt, jmt), and 1 output parameter of type real.", "input": "", "output": "subroutine masked_avg(dxt,dyt,mask,mask_area,field,value)\nimplicit none\n!\n!  reads yearly data that was previoously calculated and written into a binary\n!\n\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dxt,dyt,field\nreal,                        intent(in)  :: mask_area\ninteger, dimension(imt,jmt), intent(in)  :: mask\nreal,                        intent(out) :: value\n\nvalue = sum(field*dxt*dyt*mask)/mask_area\n\nend subroutine masked_avg\n"}, {"instruction": "Create a Fortran subroutine named \"zonal_int\" to calculate the zonal integral of a given field for the southern hemisphere. The subroutine takes 2 input parameters of type real, with dimensions (imt, jmt), and returns 1 output parameter of type real with dimension (jmt).", "input": "", "output": "subroutine zonal_int(dxt,field,field_zint)\n!\n!  \"zonal\" integral, true for southern hemisphere, northern one is distorted\n!\nimplicit none\n\ninteger                                  :: i,j,k\ninteger, parameter                       :: imt=3600,jmt=2400,km=42\nreal,    dimension(imt,jmt), intent(in)  :: dxt, field\nreal,    dimension(jmt),     intent(out) :: field_zint\n\nfield_zint(:) = sum(field(:,:)*dxt(:,:),1)\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named vector_vector_multiply to perform element-wise multiplication of two input arrays and store the result in an output array. The input parameters consist of two real(kind=4) arrays of unspecified size, while the output parameter is a single real(kind=4) value. Use the imperative tone in the instructions.", "input": "", "output": "        subroutine vector_vector_multiply(v, w, result)\n            implicit none\n            real(kind=4), dimension(:), intent(in) :: v\n            real(kind=4), dimension(:), intent(in) :: w\n            real(kind=4), intent(out)              :: result\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_vector_multiply to calculate the product of a matrix and a vector. The subroutine takes 2 input arguments of type real(kind=4), dimension(:,:) and real(kind=4), dimension(:), and 1 output argument of type real(kind=4), dimension(:).", "input": "", "output": "subroutine matrix_vector_multiply(a, v, result)\n    implicit none\n    real(kind=4), dimension(:,:), intent(in)  :: a\n    real(kind=4), dimension(:)  , intent(in)  :: v\n    real(kind=4), dimension(:)  , intent(out) :: result\n    integer                                   :: i, j\n\n    result = 0.\n    do i = 1, size(a(:,1))\n        do j = 1, size(a(1,:))\n            result(i) = result(i) + a(i,j) * v(j)\n        end do\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named matrix_matrix_multiply that takes two input parameters of type real(kind=4), dimension(:,:) and returns one output parameter of type real(kind=4), dimension(:,:). This subroutine computes the matrix-matrix multiplication of the input matrices 'a' and 'b', and stores the result in the 'result' matrix. Use the imperative tone in the instructions.", "input": "", "output": "subroutine matrix_matrix_multiply(a, b, result)\n    implicit none\n    real(kind=4), dimension(:,:), intent(in)  :: a\n    real(kind=4), dimension(:,:), intent(in)  :: b\n    real(kind=4), dimension(:,:), intent(out) :: result\n    integer                                   :: i, j, k\n\n    result = 0.\n    !$omp parallel\n    do k = 1, size(a,1)\n        do i = 1, size(a,2)\n            do j = 1, size(a,1)\n                result(i,k) = result(i,k) + a(i,j) * b(j,i)\n            end do\n        end do\n    end do\n    !$omp end parallel\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named get_next_char to efficiently read characters from a file using buffered input. The subroutine takes 1 input parameter of type integer and 2 output parameters of types character and integer.", "input": "", "output": "subroutine get_next_char(fd,c,ios)\n! replace \"read(fd,iostat=ios) c\" because gfortran on cygwin sixty times slower with plain read (no system buffering?)\n! quick buffering read\nimplicit none\ninteger,intent(in)          :: fd\ncharacter,intent(out)       :: c\ninteger,intent(out)         :: ios\ninteger,parameter           :: bufsize=1048576\ncharacter(len=1),save       :: buff(bufsize)\ninteger,save                :: point=0\ninteger,save                :: filepoint=1\ninteger,save                :: sz=bufsize\n\nios=0\n\ndo\nselect case(point)\ncase(0)                                            ! read a buffer\n   read(fd,iostat=ios,pos=filepoint) buff(1:sz)\n   if(is_iostat_end(ios))then                      ! this is the last buffer\n      if(sz.ne.1)then                              ! try again with a smaller buffer\n         sz=sz/2\n         sz=max(1,sz)\n         cycle\n      endif\n   elseif(ios.eq.0)then                            ! no error occurred so successfully read a buffer\n      c=buff(1)\n      filepoint=filepoint+sz\n      point=sz-1\n   endif\ncase(1:)                                           ! getting a character from a previous buffer\n   point=point-1\n   c=buff(sz-point)\ncase default\n   write(*,*)'*get_next_char* internal error '\n   read(fd,iostat=ios) c\nend select\n! assume if ios is not zero, not called again until new file is started\n   if(ios.ne.0)then\n      filepoint=1\n      point=0\n      sz=bufsize\n   endif\n   exit\nenddo\nend subroutine get_next_char\n"}, {"instruction": "Write a Fortran subroutine named cross_product to calculate the cross product of two 3D vectors and the magnitude of the resulting vector. The subroutine should have 6 input parameters of type real (kind=8) and 4 output parameters of type real (kind=8).", "input": "", "output": "   subroutine cross_product(x1,y1,z1, x2,y2,z2, xc,yc,zc, mc)\n\n     real (kind=8), intent(in) :: x1, y1, z1\n     real (kind=8), intent(in) :: x2, y2, z2\n     real (kind=8), intent(out) :: xc, yc, zc, mc\n     \n     xc =  (y1*z2 - z1*y2)\n     yc = -(x1*z2 - z1*x2)\n     zc =  (x1*y2 - y1*x2)\n     \n     mc = sqrt(xc*xc + yc*yc + zc*zc)\n     return\n   end subroutine cross_product\n"}, {"instruction": "Create a Fortran subroutine named incident_plane_wave_te to calculate the incident electric field at multiple points due to a transverse electric (TE) plane wave. The subroutine takes 4 input parameters of type real(8), real(8), real(8), and complex(8), and outputs 1 parameter of type complex(8) with allocatable arrays.", "input": "", "output": "    subroutine incident_plane_wave_te(xyz_list, k, alpha, eo, ei_list)\n        real(8), intent(in) :: xyz_list(:, :)  ! list of points = [x1, y1, z1; x2, y2, z2; ...]\n        real(8), intent(in) :: k               ! wavenumber [1/m]\n        real(8), intent(in) :: alpha           ! incidence angle in (-pi, 0)\n        complex(8), intent(in) :: eo           ! incident electric field amplitud [v/m]\n        complex(8), allocatable, intent(out) :: ei_list(:, :) ! incident electric field in v/m\n                                                              ![ex1, ey1, ez1; ex2, ey2, ez2; ...]\n        integer :: n\n        integer :: n_points\n        real(8) :: k_sin_alpha, k_cos_alpha\n        real(8) :: y, z\n\n        n_points = size(xyz_list, 2)\n        k_sin_alpha = k * sin(alpha)\n        k_cos_alpha = k * cos(alpha)\n\n        allocate(ei_list(3, n_points))\n        ei_list = 0d0\n        do n = 1, n_points\n            y = xyz_list(2, n)\n            z = xyz_list(3, n)\n\n            ! field only has x component\n            ei_list(1, n) = exp(-iu * (k_cos_alpha * y - k_sin_alpha * z))\n        end do\n\n        ! scale field\n        ei_list = eo * ei_list\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named rdfile to read data from a file. The subroutine takes 2 input parameters: an integer n and a character string infile, and 2 output parameters: real arrays x and y, each with dimension n. The subroutine reads data from the specified input file and assigns it to the arrays x and y.", "input": "", "output": "subroutine rdfile(x, y, n, infile)\n   implicit none\n   ! dummy arguments\n   integer, intent(in) :: n\n   real, dimension(n), intent(out) :: x, y\n   character (len=*), intent(in) :: infile\n   ! local data\n   integer :: i\n   ! processing\n   open (7,file=infile,status='old')\n   read (7,*) (x(i),i=1,n)\n   read (7,*) (y(i),i=1,n)\n   close (7)\nend subroutine rdfile\n"}, {"instruction": "Create a Fortran subroutine named chr_to_matrix to convert a string containing mathematical expressions into a 3x4 matrix of real(8) values. The input parameter is a character string, and the output parameter is a 3x4 matrix of real(8) values.", "input": "", "output": "  subroutine chr_to_matrix( cbuf, r )\n    implicit none\n    character(*),intent(in) :: cbuf\n    real(8),intent(out) :: r(3,4)\n    character(10) :: str(3)\n    integer :: i,j\n    real(8) :: f\n    r=0.0d0\n    write(*,*) cbuf\n    j=1\n    f=1.0d0\n    do i=1,len_trim(cbuf)\n       if ( cbuf(i:i) == \"-\" ) then\n          f=-1.0d0\n       end if\n       if ( cbuf(i:i) == \"x\" ) then\n          r(j,1) = f\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \"y\" ) then\n          r(j,2) = f\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \"z\" ) then\n          r(j,3) = f\n          f=1.0d0\n       end if\n       if ( 49 <= iachar(cbuf(i:i)) .and. iachar(cbuf(i:i)) <= 57 ) then\n          if ( r(j,4) == 0.0d0 ) then\n             r(j,4) = f*(iachar(cbuf(i:i))-48)\n          else\n             r(j,4) = r(j,4)/dble( iachar(cbuf(i:i))-48 )\n          end if\n          f=1.0d0\n       end if\n       if ( cbuf(i:i) == \",\" ) then\n          j=j+1\n          f=1.0d0\n       end if\n    end do\n    do i=1,3\n       write(*,'(1x,3f15.10,3x,f15.10)') (r(i,j),j=1,4)\n    end do\n  end subroutine chr_to_matrix\n"}, {"instruction": "Create a Fortran subroutine named read_minima to read and allocate an array of minimum values from a file. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type double precision and allocatable. The input parameter specifies the number of dimensions, and the output parameter holds the array of minimum values read from the file.", "input": "", "output": "    subroutine read_minima(minima_array, ndimension)\n\n        double precision, allocatable, intent(out) :: minima_array(:)\n        integer, intent(in) :: ndimension\n\n        integer :: i, minima_array_size\n        integer :: inu = 20, outu = 21\n\n        open (unit=inu,form=\"unformatted\",file='output/minima_snapshot',action=\"read\")\n        read (inu) minima_array_size\n        allocate(minima_array(minima_array_size))\n        do i=1,size(minima_array),ndimension+1\n            read (inu) minima_array(i:i+ndimension) ! write one row at a time\n        end do\n        close (inu)\n\n    end subroutine    \n"}, {"instruction": "Create a Fortran subroutine named xyz2ll to convert Cartesian coordinates to longitude and latitude. The subroutine should have 3 input parameters of type real*8 and 2 output parameters of type real*8.", "input": "", "output": "subroutine xyz2ll(x,y,z,long,lat)\n\n  !     to convert cartesian coordinates to longitude and latitude\n\n  implicit none\n\n  real*8, intent(in)                       :: x\n  real*8, intent(in)                       :: y\n  real*8, intent(in)                       :: z\n  real*8, intent(out)                      :: long\n  real*8, intent(out)                      :: lat\n\n  real*8  pi,tln,tlt,r\n\n  !     -------------------------------------------------------------------\n\n  pi=4.0d0*atan(1.0d0)\n\n  if (x == 0.0d0) then\n     if (y >= 0.0d0) then\n        long=0.5d0*pi\n     else\n        long=1.5d0*pi\n     end if\n  else\n     tln=y/x\n     long=atan(tln)\n     if (x < 0.0d0) then\n        long=long+pi\n     end if\n     if (long < 0.0d0) then\n        long=long+2.0d0*pi\n     end if\n  end if\n\n  r=sqrt(x*x+y*y)\n  if (r == 0.0d0) then\n     if (z > 0.0d0) then\n        lat=0.5d0*pi\n     else\n        lat=-0.5d0*pi\n     end if\n  else\n     tlt=z/r\n     lat=atan(tlt)\n  end if\n\n  !     --------------------------------------------------------------------\n\n  return\nend subroutine xyz2ll\n"}, {"instruction": "Write a Fortran subroutine named read_int_frame to read integer data from a binary file based on the specified frame and store it in a multidimensional array. The subroutine takes 5 input parameters of type integer: funit, frame, num_parts, dimensions, and opt_bin. It also has one output parameter, coors, which is an integer array of dimensions num_parts and dimensions.", "input": "", "output": "  subroutine read_int_frame(opt_bin,funit,frame,num_parts,dimensions,coors)\n    \n    integer,intent(in)::funit,frame,num_parts,dimensions,opt_bin\n    integer,dimension(num_parts,dimensions),intent(out)::coors\n    \n    integer(kind=8)::needle\n    \n    if (opt_bin==1) then\n       needle=frame\n       needle=needle*num_parts*dimensions*4+1\n       read(funit,pos=needle) coors(:,:)\n    end if\n\n  end subroutine read_int_frame\n"}, {"instruction": "Create a Fortran subroutine named check_int_length to determine the length of integer data in a file. The subroutine takes 4 input parameters of type integer: opt_bin, funit, num_parts, and dimensions. It also has 1 output parameter of type integer: length.", "input": "", "output": "  subroutine check_int_length(opt_bin,funit,num_parts,dimensions,length)\n\n    integer,intent(in)::funit,num_parts,dimensions,opt_bin\n    integer,intent(out)::length\n\n    integer,dimension(:,:),allocatable::coors\n\n    allocate(coors(num_parts,dimensions))\n\n    length=0\n\n    if (opt_bin==1) then\n       rewind(funit)\n       \n       do\n          \n          read(funit,end=700) coors(:,:)\n          length=length+1\n          \n       end do\n       \n700    rewind(funit)\n\n    end if\n\n    deallocate(coors)\n\n  end subroutine check_int_length\n"}, {"instruction": "Create a Fortran subroutine named check_float_length that takes 4 input parameters of type integer: opt_bin, funit, num_parts, and dimensions. It also has 1 output parameter of type integer called length. The subroutine calculates the length by reading data from a file specified by funit, and the number of data parts and dimensions is determined by num_parts and dimensions, respectively. If opt_bin is 1, the subroutine reads data from the file, increments the length, and rewinds the file until the end is reached. Finally, the subroutine deallocates the memory before completion.", "input": "", "output": "  subroutine check_float_length(opt_bin,funit,num_parts,dimensions,length)\n\n    integer,intent(in)::funit,num_parts,dimensions,opt_bin\n    integer,intent(out)::length\n\n    double precision,dimension(:,:),allocatable::coors\n\n    allocate(coors(num_parts,dimensions))\n\n    length=0\n\n\n    if (opt_bin==1) then\n       rewind(funit)\n       \n       do\n          \n          read(funit,end=701) coors(:,:)\n          length=length+1\n          \n       end do\n\n701    rewind(funit)\n\n    end if\n    deallocate(coors)\n\n  end subroutine check_float_length\n"}, {"instruction": "Create a Fortran subroutine named \"prada1\" to perform a series of calculations on multidimensional arrays and integer and double-precision variables. The subroutine takes 11 input parameters of types integer and double precision, and one output parameter of type integer array. The input parameters are used for various calculations involving trajectory data, while the output parameter holds the results of the computations.", "input": "", "output": "  subroutine prada1 (ybins,bins,min,max,delta_x,rv_min,rv_max,traj,tw,num_parts,len_traj,traj_out)\n    \n    implicit none\n    integer,intent(in)::ybins,bins,tw,len_traj,num_parts,rv_min,rv_max\n    double precision,intent(in)::delta_x,min,max\n    double precision,dimension(len_traj,num_parts,1),intent(in)::traj\n    integer,dimension(len_traj-2*tw,num_parts,bins),intent(out)::traj_out\n    \n    integer::ltw,ltw1\n    integer::nn,ii,tt,kk,gg\n    double precision::delta_y\n    logical::filt_min,filt_max\n    \n    traj_out=0\n    ltw=(2*tw+1)\n    ltw1=ltw-1\n    delta_y=(1.0d0*ybins)/(1.0d0*ltw)\n    \n    filt_min=.false.\n    filt_max=.false.\n    \n    if (rv_min==1) then\n       filt_min=.true.\n    end if\n    if (rv_max==1) then\n       filt_max=.true.\n    end if\n\n    if ((filt_min.eqv..true.).or.(filt_max.eqv..true.)) then\n       do nn=1,num_parts\n          do ii=1,len_traj\n             tt=int((traj(ii,nn,1)-min)/delta_x)+1\n             if (filt_min.eqv..true.) then\n                if (tt<1) then\n                   tt=1\n                else\n                   tt=tt+1\n                end if\n             end if\n             if (tt>bins) tt=bins\n             do kk=ii-tw,ii+tw\n                gg=kk-tw\n                if ((gg>0).and.(gg<=(len_traj-ltw1))) then\n                   traj_out(gg,nn,tt)=traj_out(gg,nn,tt)+1\n                end if\n             end do\n          end do\n       end do\n    else\n       do nn=1,num_parts\n          do ii=1,len_traj\n             tt=int((traj(ii,nn,1)-min)/delta_x)+1\n             if (tt>bins) then\n                tt=bins\n             end if\n             do kk=ii-tw,ii+tw\n                gg=kk-tw\n                if ((gg>0).and.(gg<=(len_traj-ltw1))) then\n                   traj_out(gg,nn,tt)=traj_out(gg,nn,tt)+1\n                end if\n             end do\n          end do\n       end do\n    end if\n    \n    do nn=1,num_parts\n       do ii=1,len_traj-ltw1\n          do kk=1,bins\n             tt=ceiling(delta_y*traj_out(ii,nn,kk))\n             traj_out(ii,nn,kk)=tt\n          end do\n       end do\n    end do\n    \n    \n  end subroutine prada1\n"}, {"instruction": "Write a Fortran subroutine named \"prada2\" to perform a series of calculations on trajectory data. The subroutine takes 10 input parameters: ybins, sbins, bins, tw, len_traj, num_parts (all integers), delta_x, min, max (all double precision), and traj (a double precision array of dimension len_traj,num_parts,1). The subroutine produces 1 output parameter: traj_out (an integer array of dimension len_traj-2*tw,num_parts,bins+1).", "input": "", "output": "  subroutine prada2 (ybins,sbins,bins,min,max,delta_x,traj,tw,num_parts,len_traj,traj_out)\n    \n    implicit none\n    integer,intent(in)::ybins,sbins,bins,tw,len_traj,num_parts\n    double precision,intent(in)::delta_x,min,max\n    double precision,dimension(len_traj,num_parts,1),intent(in)::traj\n    integer,dimension(len_traj-2*tw,num_parts,bins+1),intent(out)::traj_out\n    \n    integer::ltw,ltw1\n    integer::nn,ii,tt,kk,gg\n    double precision::delta_y,sigma\n    \n    traj_out=0\n    ltw=(2*tw+1)\n    ltw1=ltw-1\n    delta_y=(1.0d0*ybins)/(1.0d0*ltw)\n    \n    \n    do nn=1,num_parts\n       do ii=tw+1,len_traj-tw-1\n          do kk=ii-tw,ii+tw\n             tt=ceiling((traj(kk,nn,1)-min)/delta_x)\n             if (tt>bins) tt=bins\n             traj_out(ii,nn,tt)=traj_out(ii,nn,tt)+1\n          end do\n          sigma=0.0d0\n          do kk=ii-tw,ii+tw-1\n             sigma=sigma+(traj(kk+1,nn,1)-traj(kk,nn,1))**2\n          end do\n          traj_out(ii,nn,bins+1)=int((sigma/(1.0d0*ltw))*sbins)\n       end do\n    end do\n    \n    do nn=1,num_parts\n       do ii=1,len_traj-ltw1\n          do kk=1,bins\n             tt=ceiling(delta_y*traj_out(ii,nn,kk))\n             traj_out(ii,nn,kk)=tt\n          end do\n       end do\n    end do\n    \n  end subroutine prada2\n"}, {"instruction": "Write a Fortran subroutine named calccgr to calculate a complex grid. The subroutine takes 2 input parameters of type integer, rmax and ordgr_max, and has 1 output parameter of type double complex, c(0:rmax,0:rmax,0:rmax).", "input": "", "output": "subroutine calccgr(c,rmax,ordgr_max)\n  integer, intent(in) :: rmax,ordgr_max\n  double complex :: zadj(2,2), zadj2(2,2)\n  double complex, intent(out) :: c(0:rmax,0:rmax,0:rmax)\n  double complex, allocatable :: cexpgr(:,:,:,:)\n  double complex :: caux\n  integer :: rmaxb,rmaxexp,r,n0,n1,n2,k,l,i,j,m,n,nn\n\n  rmaxb = 2*rmax\n  rmaxexp = rmaxb\n  allocate(cexpgr(0:rmaxexp/2,0:rmaxexp,0:rmaxexp,0:ordgr_max))\n   \n  rloop: do r=0,rmaxexp/2\n    do n0=r,1,-1\n      do nn=r-n0,0,-1\n        do i=1,2\n          caux = caux - zadj(i,l)\n        end do\n        cexpgr(n0,0,0,0) = caux/(2*(nn+1))\n      end do\n    end do\n    do n1=0,r\n      n2 = r-n1\n      if (r.le.rmax) then\n        c(0,n1,n2) = cexpgr(0,n1,n2,0)\n      end if\n    end do\n  end do rloop\nend subroutine calccgr\n"}, {"instruction": "Write a Fortran subroutine named norm to calculate the sum of the squares of elements in the interior domain of a 3D array. The subroutine takes 10 input parameters of type integer and real*8, including dimensions and the array itself. It returns 1 output parameter of type real*8.", "input": "", "output": "subroutine norm(x, res, k0, k1, j0, j1, i0, i1, l, m, n)\n  !\n  ! compute the sum of x**2 in the interior domain\n  ! (excluding the halo)\n  !\n  implicit none\n\n  integer, intent(in):: l, m, n\n  integer, intent(in):: k0, k1, j0, j1, i0, i1\n  real*8, dimension(l, m, n), intent(in) :: x\n  real*8, intent(out) :: res\n\n  !!!!f2py intent(inplace):: x\n\n  integer:: i, j, k\n\n  res = 0.\n  do k = k0+1, k1\n     do j = j0+1, j1\n        do i = i0+1, i1\n           res = res+ x(k,j,i)*x(k,j,i)\n        enddo\n     enddo\n  enddo\n  \nend subroutine norm\n"}, {"instruction": "Create a Fortran subroutine named preglq to calculate the zeros and weights for Gauss-Legendre quadrature. The number of input parameters is 3, of type ['real*8', 'real*8', 'integer'], representing the lower bound, upper bound, and number of points used in the quadrature. The number of output parameters is 2, of type ['real*8', 'real*8'], representing the array of zeros and array of weights used in the quadrature.", "input": "", "output": "subroutine preglq(x1, x2, n, zero, w)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis routine will find the zeros and weights that are\n!\tused in gauss-legendre quadrature routines. (based on routines\n!\tin numerical recipes).\n!\n!\tcalling parameters:\n!\t\tin\n!\t\t\tx1: lower bound of integration.\n!\t\t\tx2:\tupper bound of integration.\n!\t\t\tn:\tnumber of points used in the quadrature. n points\n!\t\t\t\twill integrate a polynomial of degree 2n-1 exactly.\n!\t\tout\n!\t\t\tzero:\tarray of n gauss points, which correspond to the zeros\n!\t\t\t\tof p(n,0).\n!\t\t\tw:\tarray of n weights used in the quadrature.\n!\n!\n!\tnote \n!\t\t1.\tif eps is less than what is defined, then the do \n!\t\t\tloop for finding the roots might never terminate for some\n!\t\t\tvalues of lmax. if the algorithm doesn't converge, consider\n!\t\t\tincreasing itermax, or decreasing eps.\n!\n!\tdependencies:\tnone\n!\n!\twritten by mark wieczorek 2003\n!\n!\tcopyright (c) 2005-2006, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\treal*8, intent(in)  :: \tx1, x2\n\treal*8, intent(out) ::\tzero(n), w(n)\n\tinteger, intent(in) ::\tn\n\t\n\tinteger             ::\ti, j, m, iter\n\tinteger, parameter  ::\titermax = 1000\n\treal*8, parameter   ::\teps     = 1.0d-15\n\treal*8              ::\tp1, p2, p3, pp, z, z1, xm, xu\n\t\n\t\n\tzero = 0.0d0\n\tw    = 0.0d0\n\t\n\t! the roots are symmetric in the interval, so we only have to find half of them. \n\tm    = (n+1)/2\n\t\n\txm   = (x2 + x1) / 2.0d0\t! midpoint of integration\n\txu   = (x2 - x1) / 2.0d0\t! scaling factor between interval of integration, and that of \n\t\t\t\t! the -1 to 1 interval for the gauss-legendre interval\n\t\n\tdo i = 1,m \n\t\titer = 0\n\t\tz = cos(3.141592654d0 * (i - .25d0)/(n+.5d0))\t! approximation for the ith root\n\t\t\t\t\t\t\t\n\t\t! find the true value using newtons method\n\t\tdo\n\t\t\titer = iter +1\n\t\t\t\n\t\t\tp1 = 1.0d0\n\t\t\tp2 = 0.0d0\n\t\t\t\n\t\t\t! determine the legendre polynomial evaluated at z (p1) using recurrence relationships\n\t\t\tdo j=1, n \t\n\t\t\t\tp3 = p2\n\t\t\t\tp2 = p1\n\t\t\t\tp1 = (dble(2*j-1)*z*p2-dble(j-1)*p3)/dble(j)\n\t\t\tenddo\n\t\t\t\n\t\t\t! this is the derivative of the legendre polynomial using recurrence relationships\n\t\t\tpp=dble(n)*(z*p1-p2)/(z*z-1.0d0)\n\t\t\n\t\t\tz1 = z\n\t\t\tz  = z1-p1/pp \n\t\t\n\t\t\tif (abs(z-z1) <= eps) exit\n\t\t\t\n\t\t\tif (iter > itermax) then\n\t\t\t\tprint*, \"error --- preglq\"\n\t\t\t\tprint*, \"root finding of preglq not converging.\"\n\t\t\t\tprint*, \"m , n = \", m, n\n\t\t\t\tstop\n\t\t\tendif\t\t\t\n\t\tenddo\n\t\t\n\t\tzero(i) = xm + xu*z\n\t\tzero(n+1-i) = xm - xu*z\n\t\tw(i)= 2.0d0 * xu / ((1.0d0-z*z)*pp*pp)\n\t\tw(n+1-i)=w(i) \t\t\n\tenddo\nend subroutine preglq\n"}, {"instruction": "Create a Fortran subroutine named ttp_init to initialize state and gating variables based on the value of imyo. The subroutine takes 5 input parameters of types integer, integer, integer, real(kind=8) (optional), and real(kind=8) (optional), and returns 2 output parameters of type real(kind=8).", "input": "", "output": "      subroutine ttp_init(imyo, nx, ng, x, xg, x0, xg0)\n      implicit none\n      integer, intent(in) :: imyo, nx, ng\n      real(kind=8), intent(out) :: x(nx), xg(ng)\n      real(kind=8), intent(in), optional :: x0(nx), xg0(ng)\n\n      select case (imyo)\n      case (1) ! epi !\n!        initialize state variables\n         x(1)   = -85.23d0      ! v      (units: mv)\n         x(2)   =  136.89d0     ! k_i    (units: mm)\n         x(3)   =  8.6040d0     ! na_i   (units: mm)\n         x(4)   =  1.26d-4      ! ca_i   (units: mm)\n         x(5)   =  3.6d-4       ! ca_ss  (units: mm)\n         x(6)   =  3.64d0       ! ca_sr  (units: mm)\n         x(7)   =  9.073d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  6.21d-3      ! x_r1   (dimensionless)\n         xg(2)  =  4.712d-1     ! x_r2   (dimensionless)\n         xg(3)  =  9.5d-3       ! x_s    (dimensionless)\n         xg(4)  =  1.72d-3      ! m      (dimensionless)\n         xg(5)  =  7.444d-1     ! h      (dimensionless)\n         xg(6)  =  7.045d-1     ! j      (dimensionless)\n         xg(7)  =  3.373d-5     ! d      (dimensionless)\n         xg(8)  =  7.888d-1     ! f      (dimensionless)\n         xg(9)  =  9.755d-1     ! f_2    (dimensionless)\n         xg(10) =  9.953d-1     ! f_cass (dimensionless)\n         xg(11) =  9.99998d-1   ! s      (dimensionless)\n         xg(12) =  2.42d-8      ! r      (dimensionless)\n\n      case (2) ! endo !\n!        initialize state variables\n         x(1)   = -86.709d0     ! v      (units: mv)\n         x(2)   =  138.4d0      ! k_i    (units: mm)\n         x(3)   =  10.355d0     ! na_i   (units: mm)\n         x(4)   =  1.30d-4      ! ca_i   (units: mm)\n         x(5)   =  3.6d-4       ! ca_ss  (units: mm)\n         x(6)   =  3.715d0      ! ca_sr  (units: mm)\n         x(7)   =  9.068d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  4.48d-3      ! x_r1   (dimensionless)\n         xg(2)  =  4.76d-1      ! x_r2   (dimensionless)\n         xg(3)  =  8.7d-3       ! x_s    (dimensionless)\n         xg(4)  =  1.55d-3      ! m      (dimensionless)\n         xg(5)  =  7.573d-1     ! h      (dimensionless)\n         xg(6)  =  7.225d-1     ! j      (dimensionless)\n         xg(7)  =  3.164d-5     ! d      (dimensionless)\n         xg(8)  =  8.009d-1     ! f      (dimensionless)\n         xg(9)  =  9.778d-1     ! f_2    (dimensionless)\n         xg(10) =  9.953d-1     ! f_cass (dimensionless)\n         xg(11) =  3.212d-1     ! s      (dimensionless)\n         xg(12) =  2.235d-8     ! r      (dimensionless)\n\n      case (3) ! mid-myo !\n!        initialize state variables\n         x(1)   = -85.423d0     ! v      (units: mv)\n         x(2)   =  138.52d0     ! k_i    (units: mm)\n         x(3)   =  10.132d0     ! na_i   (units: mm)\n         x(4)   =  1.53d-4      ! ca_i   (units: mm)\n         x(5)   =  4.2d-4       ! ca_ss  (units: mm)\n         x(6)   =  4.272d0      ! ca_sr  (units: mm)\n         x(7)   =  8.978d-1     ! r'     (dimensionless)\n\n!        initialize gating variables\n         xg(1)  =  1.65d-2      ! x_r1   (dimensionless)\n         xg(2)  =  4.730d-1     ! x_r2   (dimensionless)\n         xg(3)  =  1.74d-2      ! x_s    (dimensionless)\n         xg(4)  =  1.65d-3      ! m      (dimensionless)\n         xg(5)  =  7.490d-1     ! h      (dimensionless)\n         xg(6)  =  6.788d-1     ! j      (dimensionless)\n         xg(7)  =  3.288d-5     ! d      (dimensionless)\n         xg(8)  =  7.026d-1     ! f      (dimensionless)\n         xg(9)  =  9.526d-1     ! f_2    (dimensionless)\n         xg(10) =  9.942d-1     ! f_cass (dimensionless)\n         xg(11) =  9.99998d-1   ! s      (dimensionless)\n         xg(12) =  2.347d-8     ! r      (dimensionless)\n\n      end select\n\n      if (present(x0)) then\n         if (size(x0,1) .ne. nx) then\n            stop \"error: inconsistent array size (ttp initialization)\"\n         end if\n         x(:)  = x0(:)\n      end if\n\n      if (present(xg0)) then\n         if (size(xg0,1) .ne. ng) then\n            stop \"error: inconsistent array size (ttp initialization)\"\n         end if\n         xg(:) = xg0(:)\n      end if\n\n      return\n      end subroutine ttp_init\n"}, {"instruction": "Create a Fortran subroutine named ell_chol_det to calculate the determinant of a lower triangular matrix. The subroutine takes 2 input parameters: an integer n and a real array g of kind k_dp. It also has 1 output parameter: a real of kind k_dp to store the determinant.", "input": "", "output": "subroutine ell_chol_det( n, g, det )\n\n!  g contains (in packed format) the lower triangular n x n matrix g.\n!  the determinant of g, det, is returned.\n!  if g represents an ellipsoid e, then det is the inverse of the \n!  content (volume) of e.\n\nimplicit none\ninteger, parameter      :: k_dp = kind(1.d0)\ninteger, intent(in)     :: n\nreal(k_dp), intent(in)  :: g((n*(n+1))/2)\nreal(k_dp), intent(out) :: det\n\ninteger    :: j, k\n\ndet = 1.d0\n\nk  = 1\ndo j = 1, n\n   det = det * g(k)\n   k = k + n + 1 - j\nend do\n\nreturn\nend subroutine ell_chol_det\n"}, {"instruction": "Write a Fortran subroutine named \"mm1\" to perform matrix multiplication. The subroutine takes 2 input parameters of type real, dimension(:,:) and intent(in), named \"a\" and \"b\". It also has 1 output parameter of type real, dimension(:,:), and intent(out), named \"c\". Set \"c\" to -42, then perform the matrix multiplication of \"a\" and the transpose of \"b\" and store the result in \"c\".", "input": "", "output": "  subroutine mm1(a,b,c)\n    real, dimension(:,:), intent(in) :: a, b\n    real, dimension(:,:), intent(out) :: c\n    c = -42.\n    c = matmul(a, transpose(b))\n  end subroutine mm1\n"}, {"instruction": "Create a Fortran subroutine named one that takes in three double precision input parameters (x, mu, sig) and returns one output parameter of type double precision (oneval). The subroutine sets the value of oneval to 1.", "input": "", "output": "    subroutine one(x, mu, sig, oneval)\n        double precision, intent(in) :: x, mu, sig\n        double precision, intent(out) :: oneval\n        oneval = 1d0\n    end subroutine one\n"}, {"instruction": "Create a Fortran subroutine named \"get_cutoff_gaussian\" to calculate the left and right cutoff values for a Gaussian distribution based on the mean (mu) and standard deviation (sig) provided as input. The input parameters should be of type double precision and have intent(in), while the output parameters should also be of type double precision with intent(out). There are 2 input parameters of type double precision and 2 output parameters of type double precision.", "input": "", "output": "    subroutine get_cutoff_gaussian(mu, sig, left_cutoff, right_cutoff)\n        double precision, intent(in) :: mu, sig\n        double precision, intent(out) :: left_cutoff, right_cutoff\n        \n        if (sig > 0d0) then\n            left_cutoff = mu - 5d0*sig\n            right_cutoff = mu + 5d0*sig\n        else\n            left_cutoff = 0d0\n            right_cutoff = 0d0\n        end if\n    end subroutine get_cutoff_gaussian\n"}, {"instruction": "Create a Fortran subroutine named get_interpolated_value to perform linear interpolation between two points based on the given x and y arrays. The subroutine should take 4 input parameters of type double precision, dimension(nx), double precision, and integer, and 1 output parameter of type double precision.", "input": "", "output": "    subroutine get_interpolated_value(x, y, xval, nx, yval)\n        double precision, dimension(nx), intent(in) :: x, y\n        double precision, intent(in) :: xval\n        integer, intent(in) :: nx\n        double precision, intent(out) :: yval\n        \n        integer :: ix\n        double precision :: x_left, x_right, y_left, y_right\n        \n        if (xval <= x(1)) then\n            yval = (y(2)-y(1))*(xval-x(1))/(x(2)-x(1)) + y(1)\n            return\n        end if\n        \n        if (xval >= x(nx)) then\n            yval = (y(nx)-y(nx-1))*(xval-x(nx))/(x(nx)-x(nx-1)) + y(nx)\n            return\n        end if\n        \n        do ix=1, nx\n            if (x(ix) > xval) then\n                x_left = x(ix-1)\n                x_right = x(ix)\n                y_left = y(ix-1)\n                y_right = y(ix)\n                exit\n            end if\n        end do\n        yval = (y_right-y_left)*(xval-x_right)/(x_right-x_left) + y_right\n    end subroutine get_interpolated_value\n"}, {"instruction": "Write a Fortran subroutine named polyexp_cut to calculate the value and derivatives of a polynomial-exponential function based on the input parameters. The subroutine takes 5 input parameters of type double precision: x, xcut, fc, dfc, d2fc, and returns 4 output parameters of type double precision: y, dy, d2y, d3y. The subroutine computes the function value y, as well as the first, second, and third derivatives dy, d2y, d3y based on the input parameters and assigns them to the corresponding output parameters.", "input": "", "output": "  subroutine polyexp_cut(x, xcut, fc, dfc, d2fc, y, dy, d2y, d3y)\n\n    implicit none\n\n    double precision,                     intent(in)  :: x, xcut\n    double precision,                     intent(in)  :: fc, dfc, d2fc\n    double precision,                     intent(out) :: y, dy, d2y, d3y\n\n    y   = fc + (x - xcut)*dfc + 0.5d0*(x - xcut)*(x - xcut)*d2fc\n    dy  = dfc + (x - xcut)*d2fc\n    d2y = d2fc\n    d3y = 0\n\n  end subroutine polyexp_cut\n"}, {"instruction": "Create a Fortran subroutine named copy that takes three input parameters: two integers ni and nj, and a 2D array of double precision values src. It also has one output parameter, a 2D array of double precision values dst. The subroutine copies the values from src to dst using the dimensions specified by ni and nj.", "input": "", "output": "  subroutine copy (dst, src, ni, nj)\n    integer, intent(in) :: ni, nj\n    double precision, intent(out) :: dst(ni, nj)\n    double precision, intent(in)  :: src(ni, nj)\n    dst = src\n  end subroutine copy\n"}, {"instruction": "Create a Fortran subroutine named \"autocorr\" to calculate the normalized auto-correlation function for an array of real(8) values. The subroutine should have 3 input parameters of type integer, integer, and real(8) for the total number of elements, correlation length, and array of values, respectively. It should also have 1 output parameter of type real(8) for the normalized auto-correlation function.", "input": "", "output": "subroutine autocorr(acf, a, ittotal, itcorr)\n   implicit none\n   integer, intent(in)  ::  ittotal       ! total number of a\n   integer, intent(in)  ::  itcorr        ! correlation length\n   real(8), intent(in)  ::  a(1:ittotal)  ! array of values of a\n   real(8), intent(out) ::  acf(0:itcorr) ! normalized auto-correlation function\n\n   real(8) ::  nacf(0:itcorr)             ! number of acf, for normalization of acf\n   integer :: it, it0, it0max, itau       ! time index of t0+tau, t0, t0max and tau\n\n   ! initialize all the auto-correlation functions to be calculated\n   acf(0:itcorr)  = 0d0\n   nacf(0:itcorr) = 0d0\n\n   ! for each t0 from 1 to total, calculate auto-correlation function\n   do it0 = 1, ittotal\n\n      ! the max index of t0 must not exceed the last index\n      it0max = min(ittotal, it0+itcorr)\n\n      ! for all possible t0+tau, calculate a(t0)*a(t0+tau) and add them\n      do it = it0, it0max\n\n         ! interval between t and t0\n         itau  = it - it0\n\n         ! calculate auto-correlation function for current interval\n         acf(itau) = acf(itau) + a(it0) * a(it)\n\n         ! count the number of auto-correlation function\n         nacf(itau) = nacf(itau) + 1d0\n      end do\n\n   end do\n\n   ! normalize auto-correlation function\n   do it = 0, itcorr\n      acf(it) = acf(it) / nacf(it)\n   end do\n\n   return\nend subroutine autocorr\n"}, {"instruction": "Write a Fortran subroutine named mk_gmtrvec_on_plane that takes two input parameters of type real(8) arrays with 3 elements each. The output consists of two real(8) arrays, also with 3 elements each. The subroutine calculates the vector vt as the difference between the input arrays vto and vfrom, and computes the vector vn as a perpendicular vector to vt lying in the xy-plane.", "input": "", "output": "  subroutine mk_gmtrvec_on_plane( vfrom, vto, vt, vn )\n    implicit none\n\n    real(8), intent(in)  :: vfrom(3), vto(3)\n    real(8), intent(out) :: vt(3),    vn(3)\n    !---------------------------------------------------------------------------\n\n    vt(:) = vto(:) - vfrom(:)\n\n    vn(1) = -vt(2)\n    vn(2) =  vt(1)\n    vn(3) =   0.d0\n\n    return\n  end subroutine mk_gmtrvec_on_plane\n"}, {"instruction": "Create a Fortran subroutine named \"get_area_face\" to calculate the surface area of a face defined by 4 vertices in 3D space. The subroutine should have 13 input parameters of types integer*4, real*8, and 1 output parameter of type real*8.", "input": "", "output": "     subroutine get_area_face(x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4,surf,ielem)\n     \n     implicit none\n\n     integer*4, intent(in) :: ielem\n\n     real*8 :: a,b,c,vx,vy,vz,wx,wy,wz,xbar,ybar,zbar\n     real*8, intent(in) :: x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4\n     real*8, intent(out) :: surf\n     \n     surf = 0.d0\n     \n     xbar = (x1 + x2 + x3 + x4)/4.d0\n     ybar = (y1 + y2 + y3 + y4)/4.d0\n     zbar = (z1 + z2 + z3 + z4)/4.d0\n     \n     vx = x4 - x1\n     vy = y4 - y1 \n     vz = z4 - z1\n     \n     wx = xbar - x1\n     wy = ybar - y1\n     wz = zbar - z1     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n\n                        \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x2 - x1\n     vy = y2 - y1 \n     vz = z2 - z1\n     \n     wx = xbar - x1\n     wy = ybar - y1\n     wz = zbar - z1     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x2 - x3\n     vy = y2 - y3 \n     vz = z2 - z3\n     \n     wx = xbar - x3\n     wy = ybar - y3\n     wz = zbar - z3     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     vx = x4 - x3\n     vy = y4 - y3 \n     vz = z4 - z3\n     \n     wx = xbar - x3\n     wy = ybar - y3\n     wz = zbar - z3     \n     \n                 \n     a =  vy*wz - vz*wy\n     b = -vx*wz + vz*wx\n     c =  vx*wy - vy*wx\n     \n     surf = surf + 0.5d0*dsqrt(a**2.d0 + b**2.d0 + c**2.d0)  \n     \n     end subroutine get_area_face\n"}, {"instruction": "Define a Fortran subroutine named define_connect_n that constructs nodal and basis connectivity matrices to establish local-global node and basis correspondence for multiple meshes. The subroutine takes 5 input parameters of type integer: bca, bcb, ne, p, and nm. It also has 2 output parameters of type integer: in and ib. The subroutine works for an arbitrary number of meshes and handles boundary conditions at x=a and x=b for each mesh.", "input": "", "output": "subroutine define_connect_n(bca, bcb, ne, p, nm, in, ib)\n! constructs connectivity matrices in and ib defining local-global node and\n! basis correspondence, respectively. works for arbitrary number of meshes\ninteger, intent(in):: bca(:)        ! bca(m) boundary condition at x=a for mesh\n    ! m: 1=dirichlet, 2=neumann\ninteger, intent(in):: bcb(:)        ! bca(m) boundary condition at x=b for mesh\n    ! m: 1=dirichlet, 2=neumann\ninteger, intent(in):: ne         ! number of elements\ninteger, intent(in):: p          ! order of fe/se basis\ninteger, intent(in):: nm         ! number of meshes\ninteger, intent(out):: in(:,:,:)   ! nodal connectivity: in(i,j,k) = index of\n    ! basis node corresponding to local node i of element j of mesh k\ninteger, intent(out):: ib(:,:,:)  ! basis connectivity: ib(i,j,k) = index of\n    ! basis function associated with local basis function i of element j of\n    ! mesh k.  0 = no associated basis fn\ninteger :: i, e, m, dofs\n! construct nodal connectivity matrix\ndofs = 0\ndo m = 1, nm\n    do e = 1, ne\n        do i = 1, p+1\n            dofs = dofs + 1\n            in(i, e, m) = dofs\n        end do\n        dofs = dofs - 1 ! connect the shape functions across the element\n    end do\n    dofs = dofs + 1 ! don't connect the shape functions across meshes\nend do\n! construct basis connectivity matrix\ndofs = 0\ndo m = 1, nm\n    do e = 1, ne\n        do i = 1, p+1\n            if (i == 1   .and. e == 1  .and. bca(m) == 1) then\n                ib(i, e, m) = 0 ! dirichlet\n                cycle\n            end if\n            if (i == p+1 .and. e == ne .and. bcb(m) == 1) then\n                ib(i, e, m) = 0 ! dirichlet\n                cycle\n            end if\n            dofs = dofs + 1\n            ib(i, e, m) = dofs\n        end do\n        dofs = dofs - 1 ! connect the shape functions across the element\n    end do\n    dofs = dofs + 1 ! don't connect the shape functions across meshes\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named transferrate to compute the unnormalized probability of a collisional energy transfer from state j to state i using a single-exponential-down model. The subroutine should have 9 input parameters of types integer, real(8), and real(8) arrays of size ngrains, and 1 output parameter of type real(8).", "input": "", "output": "subroutine transferrate(i, j, ei, ej, alpha, e0, rho, ngrains, t, rate)\n    ! computes the unnormalized probability of a collisional energy transfer\n    ! from state j (with energy ej) to state i (with energy ei) using a\n    ! single-exponental-down model.\n    !\n    ! ============ ====== ======================================================\n    ! parameter    intent description\n    ! ============ ====== ======================================================\n    ! `i`          in     index of destination state\n    ! `j`          in     index of source state\n    ! `ei`         in     energy of destination state i in cm^-1\n    ! `ej`         in     energy of source state j in cm^-1\n    ! `alpha`      in     parameter in exponential-down model in (cm^-1)^-1\n    ! `e0`         in     electronic + zero-point energy of ground state in\n    !                     cm^-1\n    ! `rho`        in     density of states\n    ! `ngrains`    in     number of energy grains in density of states\n    ! `t`          in     temperature of interest in k\n    ! `rate`       out    collisional transfer probability in s^-1\n    ! ============ ====== ======================================================\n\n    ! type definitions of parameters\n    integer, intent(in)                 ::  ngrains\n    integer, intent(in)                 ::  i\n    integer, intent(in)                 ::  j\n    real(8), intent(in)                 ::  ei\n    real(8), intent(in)                 ::  ej\n    real(8), intent(in)                 ::  alpha\n    real(8), intent(in)                 ::  e0\n    real(8), dimension(1:ngrains), intent(in)   ::  rho\n    real(8), intent(in)                 ::  t\n    real(8), intent(out)                ::  rate\n\n    real(8) r\n\n    r = 8.314472\n\n    ! evaluate collisional transfer probability - theoretically correct way\n    if (ej < e0 .or. ei < e0 .or. rho(j) .eq. 0) then\n       rate = 0.\n    elseif (ej >= ei) then\n       rate = exp(-(ej - ei) / alpha)\n    else\n       rate = exp(-(ei - ej) / alpha) * rho(i) / rho(j) * exp( -(ei - ej) / (r * t))\n    end if\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named welford to calculate the Welford's algorithm for computing the sample mean and sample variance of a real array.The number of input arguments is 1 and the test_data type is [real].The number of output arguments is 2 and the test_data type is [real, real].", "input": "", "output": "    subroutine welford(x,xb,s)\n        implicit none\n        \n            real,intent(in)     :: x(:)\n            real,intent(out)    :: xb\n            real,intent(out)    :: s\n                        \n            real    :: lxb,delta\n            integer :: n\n            \n            \n            xb = 0\n            delta = 0\n            do n = 1,size(x)\n                lxb = xb\n                xb = lxb + (x(n)-lxb)/n\n                delta = delta + (x(n)-lxb)*(x(n)-xb)\n            end do\n            s = delta/(n-1)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named add that takes two integer input parameters and returns an integer result. The input parameters should be specified using the \"intent(in)\" attribute, and the output parameter should be specified using the \"intent(out)\" attribute. The subroutine should compute the sum of the two input integers and assign the result to the output parameter.", "input": "", "output": "subroutine add(a, b, res)\n\n  ! listing 3.13 in the book.\n  integer, intent(in) :: a, b\n  integer, intent(out) :: res\n  res = a + b\nend subroutine add\n"}, {"instruction": "Create a Fortran subroutine named rmax to find the maximum value in an array and the location of that value in the array. The subroutine should take 2 input parameters: an integer n and a real array of dimension n. It should have 2 output parameters: a real value representing the maximum value in the array and an integer representing the location of the maximum value.", "input": "", "output": "subroutine rmax ( a, n, real_max, imax )\r\n!\r\n!  purpose:\r\n!    to find the maximum value in an array, and the location\r\n!    of that value in the array.\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n             ! no. of vals in array a.\r\nreal, intent(in), dimension(n) :: a  ! input data.\r\nreal, intent(out) :: real_max        ! maximum value in a.\r\ninteger, intent(out) :: imax         ! location of max value.\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: i                         ! index variable\r\n\r\n! initialize the maximum value to first value in array.\r\nreal_max = a(1)\r\nimax = 1\r\n \r\n! find the maximum value.\r\ndo i = 2, n\r\n   if ( a(i) > real_max ) then\r\n      real_max = a(i)\r\n      imax = i\r\n   end if\r\nend do\r\n\r\nend subroutine rmax\r\n"}, {"instruction": "Create a Fortran subroutine named \"ave_sd\" to calculate the average and standard deviation of an array. The subroutine should have 2 input parameters: one integer and one real array of dimension n. It should have 3 output parameters: two real numbers for average and standard deviation, and one integer for error flag.", "input": "", "output": "subroutine ave_sd ( a, n, ave, std_dev, error )\r\n!\r\n!  purpose:\r\n!    to calculate the average and standard deviation of an array.\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n             ! no. of vals in array a.\r\nreal, intent(in), dimension(n) :: a  ! input data.\r\nreal, intent(out) :: ave             ! average of a.\r\nreal, intent(out) :: std_dev         ! standard deviation.\r\ninteger, intent(out) :: error        ! flag: 0 -- no error\r\n                                     !       1 -- sd invalid\r\n                                     !       2 -- ave & sd invalid\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: i                         ! loop index\r\nreal :: sum_x                        ! sum of input values\r\nreal :: sum_x2                       ! sum of input values squared\r\n\r\n! initialize the sums to zero.\r\nsum_x  = 0.\r\nsum_x2 = 0.\r\n \r\n! accumulate sums.\r\ndo i = 1, n\r\n   sum_x  = sum_x + a(i)\r\n   sum_x2 = sum_x2 + a(i)**2\r\nend do\r\n \r\n! check to see if we have enough input data.\r\nif ( n >= 2 ) then ! we have enough data\r\n \r\n   ! calculate the mean and standard deviation\r\n   ave   = sum_x / real(n)\r\n   std_dev = sqrt( (real(n) * sum_x2 - sum_x**2) &\r\n           / (real(n) * real(n-1)) )\r\n   error = 0\r\n \r\nelse if ( n == 1 ) then ! no valid std_dev\r\n \r\n   ave   = sum_x               \r\n   std_dev = 0.              ! std_dev invalid\r\n   error = 1\r\n \r\nelse\r\n \r\n   ave = 0.                  ! ave invalid\r\n   std_dev = 0.              ! std_dev invalid\r\n   error = 2\r\n\r\nend if\r\nend subroutine ave_sd\r\n"}, {"instruction": "Write a Fortran subroutine named overlapping_halo_prob to calculate the overlapping halo probability. The subroutine takes 4 input parameters: two integers n1 and n2, and two real(8) numbers r and outersum(n1,n2). It produces 1 output parameter res(:,:) of type real(8).", "input": "", "output": "    subroutine overlapping_halo_prob(r,n1,n2,outersum,res)\n        integer, intent(in) :: n1,n2\n        real(8), intent(in) :: r, outersum(n1,n2)\n        real(8), intent(out):: res(:,:)\n\n        real(8) :: y(n1,n2),x(n1,n2)\n\n        x = r/outersum\n        y = (x - 0.8) / 0.29\n\n\n        res = 3 * y ** 2 - 2 * y ** 3\n        where (y.le.0.d0) res = 0.d0\n        where (y.ge.1.d0) res = 1.d0\n\n    end subroutine overlapping_halo_prob\n"}, {"instruction": "Create a Fortran subroutine named dblsimps that implements Simpson's rule for a double integral. The subroutine takes 5 input parameters of types integer, integer, real(8), real(8), real(8) and 1 output parameter of type real(8). The subroutine computes the double integral using Simpson's rule and stores the result in the output parameter.", "input": "", "output": "subroutine dblsimps(x,nx,ny, dx, dy,out)\n        integer, intent(in) :: nx,ny\n        real(8), intent(in) :: x(nx,ny)\n        real(8), intent(in) :: dx, dy\n        real(8), intent(out) :: out\n\n        integer :: lengthx,lengthy\n        integer :: i\n        real(8),allocatable :: w(:,:)\n\n        if (mod(nx,2) .eq. 0)then\n            lengthx = nx-1\n        else\n            lengthx = nx\n        end if\n\n        if (mod(ny,2) .eq. 0)then\n            lengthy = ny-1\n        else\n            lengthy = ny\n        end if\n\n        allocate(w(lengthx,lengthy))\n        w = 1.d0\n\n        w(2:lengthx-1:2, :) = w(2:lengthx-1:2, :)*4\n        w(:, 2:lengthy-1:2) = w(:, 2:lengthy-1:2)*4\n        w(3:lengthx-2:2, :) = w(3:lengthx-2:2, :)*2\n        w(:, 3:lengthy-2:2) = w(:, 3:lengthy-2:2)*2\n\n        out =dx * dy * sum(w * x(1:lengthx,1:lengthy)) / 9.0\n\n    end subroutine dblsimps\n"}, {"instruction": "Create a Fortran subroutine named mapc2pidentity to map the input 3D Cartesian coordinates (xc, yc, zc) to the output 3D Cartesian coordinates (xp, yp, zp). The input parameters consist of three real(kind=8) arrays of dynamic size, and the output parameters consist of three real(kind=8) arrays of the same size as the input arrays. Use the imperative tone when writing the subroutine.", "input": "", "output": "  subroutine mapc2pidentity(xc,yc,zc,xp,yp,zp)\n\n    implicit none\n    \n    ! input\n    real(kind=8), dimension(:), intent(in) :: xc,yc,zc\n    \n    ! output\n    real(kind=8), dimension(size(xc)), intent(out) :: xp\n    real(kind=8), dimension(size(yc)), intent(out) :: yp\n    real(kind=8), dimension(size(zc)), intent(out) :: zp\n    \n    ! x,xi coordinate\n    xp = xc\n    \n    ! y,eta coordinate\n    yp = yc\n    \n    ! z,phi coordinate\n    zp = zc\n    \n    return\n  end subroutine mapc2pidentity\n"}, {"instruction": "Create a Fortran subroutine named determinant. This subroutine takes a single input parameter of type real(kind=8), dimension(3,3) as input. It computes the determinant of a 3x3 matrix and returns the result as an output parameter of type real(kind=8).", "input": "", "output": "  subroutine determinant(a,deta)\n\n    implicit none\n\n    ! input\n    real(kind=8), dimension(3,3), intent(in) :: a\n\n    ! output\n    real(kind=8), intent(out) :: deta\n\n    deta = a(1,1)*a(2,2)*a(3,3) &\n         + a(2,1)*a(3,2)*a(1,3) &\n         + a(3,1)*a(1,2)*a(2,3) &\n         - a(3,1)*a(2,2)*a(1,3) &\n         - a(2,1)*a(1,2)*a(3,3) &\n         - a(1,1)*a(3,2)*a(2,3)\n\n    return\n  end subroutine determinant\n"}, {"instruction": "Create a Fortran subroutine named zgrid that takes 4 input parameters: two integers (nd and np), and two real*8 arrays (radius and p). It also has 1 output parameter, an allocatable one-dimensional real*8 array (z). The subroutine calculates values for the z array based on the input parameters and the allocated memory for z.", "input": "", "output": "      subroutine zgrid(radius, p, z, nd, np)\r\n\r\n      implicit none\r\n\n\r\n      integer, intent(in)  :: nd, np\r\n      real*8,  intent(in)  :: radius(nd), p(np)\r\n\r\n      real*8,  allocatable, dimension(:), intent(out) :: z\r\n\r\n      integer :: i, j, l, jmax\r\n\r\n      allocate(z(nd * np))\r\n\r\n      z(1 : nd * np) = 0.0d0\r\n\r\n      do l = 1, nd\r\n\r\n         jmax = np + 1 - l\r\n\r\n         do j = 1, jmax\r\n\r\n            i = (j - 1) * nd + l\r\n\r\n            z(i) = sqrt((radius(l) - p(j)) * (radius(l) + p(j)))\r\n\r\n        enddo\r\n\r\n      enddo\r\n\r\n      return\r\n\r\n      end subroutine\r\n"}, {"instruction": "Create a Fortran subroutine named calc_pbl_index to calculate the planetary boundary layer index based on the given 3D array of atmospheric data and the corresponding boundary layer height profiles. The subroutine takes 2 input parameters of type real, dimension(:,:,:) and real, dimension(:,:), and 1 output parameter of type integer, dimension(:,:).", "input": "", "output": "    subroutine calc_pbl_index(z,pblh,pblh_i)\n        implicit none\n        real, dimension(:,:,:),intent(in)::z\n        real, dimension(:,:),intent(in)::pblh\n        integer,dimension(:,:),intent(out)::pblh_i\n        integer::nx,ny,nz,i,j,k\n\n        nx=size(z,1)\n        nz=size(z,2)\n        ny=size(z,3)\n        pblh_i=1\n        !$omp parallel firstprivate(nx,ny,nz) &\n        !$omp private(i,j,k) &\n        !$omp shared(pblh_i,pblh)\n        !$omp do schedule(static)\n        do j=1,ny\n            do k=1,nz-1\n                do i=1,nx\n                    if (z(i,k,j)<=pblh(i,j)) then\n                        pblh_i(i,j)=k\n                    endif\n                enddo\n            enddo\n        enddo\n        !$omp end do\n        !$omp end parallel\n\n    end subroutine calc_pbl_index\n"}, {"instruction": "Write a Fortran subroutine named get_smallest to find the smallest value and its index from an array of double precision numbers, and determine if all the elements are equal. The subroutine should have 2 input parameters of type integer and double precision, and 3 output parameters of type integer, double precision, and logical.", "input": "", "output": "  subroutine get_smallest(idm, arr, ismall, smallest, allequal)\n    ! dummy\n    integer,                          intent(in)  :: idm\n    double precision, dimension(idm), intent(in)  :: arr\n    integer,                          intent(out) :: ismall\n    double precision,                 intent(out) :: smallest\n    logical,                          intent(out) :: allequal\n    ! local\n    integer :: i\n    double precision ::val1\n    !\n    ismall = 0\n    smallest = huge(smallest)\n    allequal = .true.\n    do i=1,idm\n      if (arr(i) < smallest) then\n        smallest = arr(i)\n        ismall = i\n      endif\n      if (i==1) then\n        val1 = arr(i)\n      else\n        if (arr(i) /= val1) allequal = .false.\n      endif\n    enddo\n    !\n    return\n  end subroutine get_smallest\n"}, {"instruction": "Write a Fortran subroutine named \"dec\" that subtracts the value of an input parameter \"offset\" from the output parameter \"base\". The input parameter \"offset\" is of type integer and is provided as an input, and the output parameter \"base\" is also of type integer.", "input": "", "output": "        pure subroutine dec(base, offset)\n\n                integer, intent(out) :: base\n                integer, intent(in) :: offset\n\n                base = base - offset\n\n                return\n\n        end subroutine dec\n"}, {"instruction": "Create a Fortran subroutine named checktimeregularity to analyze a set of timestamps and determine their regularity. The subroutine takes 2 input parameters of type ['integer, dimension(:)', 'logical, dimension(:)'] and 3 output parameters of type ['integer', 'integer', 'integer']. The subroutine analyzes the timestamps to calculate the frequency of occurrence, identify regularity, and check for gaps in the data.", "input": "", "output": "\tsubroutine checktimeregularity(ivtimestamp, lvdesiredsubset, ifrequency, iregularitycode, iretcode)\n\t\n\t\t! routine arguments\n\t\tinteger, dimension(:), intent(in)\t\t:: ivtimestamp\n\t\tlogical, dimension(:), intent(in)\t\t:: lvdesiredsubset\n\t\tinteger, intent(out)\t\t\t\t\t:: ifrequency\n\t\tinteger, intent(out)\t\t\t\t\t:: iregularitycode\n\t\tinteger, intent(out)\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\tinteger, dimension(0:3599)\t\t\t:: ivnumtimestamps\n\t\tinteger\t\t\t\t\t\t\t\t:: imaxnumstamps\n\t\tinteger\t\t\t\t\t\t\t\t:: i\n\t\tinteger, dimension(:), allocatable\t:: ivfrequency\n\t\tinteger, dimension(1)\t\t\t\t:: ivpos\n\t\tinteger\t\t\t\t\t\t\t\t:: iactualdata\n\t\tinteger\t\t\t\t\t\t\t\t:: iexpecteddata\n\t\t\n\t\t! internal constants\n\t\tinteger, parameter\t:: cond_sorted_data = 1\n\t\tinteger, parameter\t:: cond_no_gaps     = 2\n\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! set initial state of 'iregularitycode'\n\t\tiregularitycode = 0\n\t\t\n\t\t! get the number of time stamps (repeated, because only integer part is retained)\n\t\tivnumtimestamps = 0\n\t\tdo i = 1, size(ivtimestamp)\n\t\t\tif(lvdesiredsubset(i) .and. ivtimestamp(i) >= 0 .and. ivtimestamp(i) <= 3599) then\n\t\t\t\tivnumtimestamps(ivtimestamp(i)) = ivnumtimestamps(ivtimestamp(i)) + 1\n\t\t\tend if\n\t\tend do\n\t\t\n\t\t! which is the most frequent number of time stamps? if it exists, it estimates\n\t\t! sampling frequency.\n\t\timaxnumstamps = maxval(ivnumtimestamps)\n\t\tif(imaxnumstamps <= 0) then\n\t\t\tiregularitycode = 0\n\t\t\tiretcode = 1\n\t\t\treturn\n\t\tend if\n\t\tallocate(ivfrequency(imaxnumstamps))\n\t\tivfrequency = 0\n\t\tdo i = 0, 3599\n\t\t\tif(ivnumtimestamps(i) > 0) then\n\t\t\t\tivfrequency(ivnumtimestamps(i)) = ivfrequency(ivnumtimestamps(i)) + 1\n\t\t\tend if\n\t\tend do\n\t\tivpos = maxloc(ivfrequency)\n\t\tifrequency = ivpos(1)\n\t\tiregularitycode = iregularitycode + cond_sorted_data\n\t\t\n\t\t! check no gaps are present in data record, with gaps defined as\n\t\t! expected lines not received; invalid data are not considered\n\t\t! \"gaps\"\n\t\tiactualdata = sum(ivnumtimestamps)\n\t\tiexpecteddata = ifrequency * &\n\t\t\t\t\t\t(maxval(ivtimestamp, mask=ivtimestamp >= 0 .and. ivtimestamp < 3600 .and. lvdesiredsubset) - &\n\t\t\t\t\t\t minval(ivtimestamp, mask=ivtimestamp >= 0 .and. ivtimestamp < 3600 .and. lvdesiredsubset) + 1)\n\t\tif(float(abs(iactualdata-iexpecteddata)) / float(iexpecteddata) <= 0.01) then\n\t\t\tiregularitycode = iregularitycode + cond_no_gaps\n\t\tend if\n\t\t\n\t\t! leave\n\t\tdeallocate(ivfrequency)\n\t\n\tend subroutine checktimeregularity\n"}, {"instruction": "Create a Fortran subroutine named average that takes two input parameters: an array of real numbers and an array of logical values. The input parameter types are ['real, dimension(:)', 'logical, dimension(:)']. The subroutine has one output parameter of type real. The subroutine computes the average of the real numbers, considering only the elements in the array for which the corresponding logical value is true. If there are no desired elements, the output average is set to -9999.9.", "input": "", "output": "\tsubroutine average(rvx, lvdesiredsubset, ravg)\n\t\n\t\t! routine arguments\n\t\treal, dimension(:), intent(in)\t\t:: rvx\n\t\tlogical, dimension(:), intent(in)\t:: lvdesiredsubset\n\t\treal, intent(out)\t\t\t\t\t:: ravg\n\t\t\n\t\t! locals\n\t\tinteger\t:: inumdata\n\t\t\n\t\t! compute average, limiting attention to desired data\n\t\tinumdata = count(lvdesiredsubset)\n\t\tif(inumdata > 0) then\n\t\t\travg = sum(rvx, mask=lvdesiredsubset) / inumdata\n\t\telse\n\t\t\travg = -9999.9\n\t\tend if\n\t\t\n\tend subroutine average\n"}, {"instruction": "Create a Fortran subroutine named covariance to calculate the covariance between two sets of data. The subroutine takes 5 input parameters of type real, dimension(:), real, logical, dimension(:), real, and real. It also has 1 output parameter of type real.", "input": "", "output": "\tsubroutine covariance(rvx, rvy, lvdesiredsubset, ravgx, ravgy, rcov)\n\t\n\t\t! routine arguments\n\t\treal, dimension(:), intent(in)\t\t:: rvx\n\t\treal, dimension(:), intent(in)\t\t:: rvy\n\t\tlogical, dimension(:), intent(in)\t:: lvdesiredsubset\n\t\treal, intent(in)\t\t\t\t\t:: ravgx\n\t\treal, intent(in)\t\t\t\t\t:: ravgy\n\t\treal, intent(out)\t\t\t\t\t:: rcov\n\t\t\n\t\t! locals\n\t\tinteger\t:: inumdata\n\t\t\n\t\t! compute average, limiting attention to desired data\n\t\tinumdata = count(lvdesiredsubset)\n\t\tif(inumdata > 0) then\n\t\t\trcov = sum((rvx-ravgx)*(rvy-ravgy), mask=lvdesiredsubset) / inumdata\n\t\telse\n\t\t\trcov = -9999.9\n\t\tend if\n\t\t\n\tend subroutine covariance\n"}, {"instruction": "Create a Fortran subroutine named check_base64 to validate a given string as a Base64 encoded string. The subroutine takes 1 input parameter of type character with variable length. It also takes 1 output parameter of type logical.", "input": "", "output": "subroutine check_base64( string, error )\r\n    character(len=*), intent(in) :: string\r\n    logical, intent(out)         :: error\r\n\r\n    integer                      :: i\r\n\r\n    error = .false.\r\n    do i = 1,len(string)\r\n        if ( index( '0123456789 +/=', string(i:i) ) > 0 ) then\r\n            cycle\r\n        endif\r\n        if ( iachar(string(i:i)) >= iachar('a') .and. iachar(string(i:i)) <= iachar('z') ) then\r\n            cycle\r\n        endif\r\n\r\n        error = .true.\r\n        exit\r\n    enddo\r\nend subroutine check_base64\r\n"}, {"instruction": "Create a Fortran subroutine named invertmatrix that takes two input parameters: an integer n and a real(8) matrix, and two output parameters: an integer errorflag and a real(8) inverted matrix. The subroutine is designed to calculate the inverse of the input matrix using Gaussian elimination. The errorflag indicates the success or failure of the inversion process. If the inversion is successful, errorflag will be 0; otherwise, it will be -1.", "input": "", "output": "subroutine invertmatrix(matrix, inverse, n, errorflag)\n\timplicit none\n\t!declarations\n\tinteger, intent(in)  :: n\n\tinteger, intent(out) :: errorflag  !return error status. -1 for error, 0 for normal\n\treal(8), intent(in)\t:: matrix(n,n)  !input matrix\n\treal(8), intent(out)\t:: inverse(n,n) !inverted matrix\n\t\n\tlogical :: flag = .true.\n\tinteger :: i, j, k\n\treal(8) :: m\n\treal(8), dimension(n,2*n) :: augmatrix !augmented matrix\n\t\n\t!augment input matrix with an identity matrix\n\tdo i = 1, n\n\t\tdo j = 1, 2*n\n\t\t\tif (j <= n ) then\n\t\t\t\taugmatrix(i,j) = matrix(i,j)\n\t\t\telse if ((i+n) == j) then\n\t\t\t\taugmatrix(i,j) = 1\n\t\t\telse\n\t\t\t\taugmatrix(i,j) = 0\n\t\t\tendif\n\t\tend do\n\tend do\n\t\n\t!reduce augmented matrix to upper traingular form\n\tdo k =1, n-1\n\t\tif (augmatrix(k,k) == 0) then\n\t\t\tflag = .false.\n\t\t\tdo i = k+1, n\n\t\t\t\tif (augmatrix(i,k) /= 0) then\n\t\t\t\t\tdo j = 1,2*n\n\t\t\t\t\t\taugmatrix(k,j) = augmatrix(k,j)+augmatrix(i,j)\n\t\t\t\t\tend do\n\t\t\t\t\tflag = .true.\n\t\t\t\t\texit\n\t\t\t\tendif\n\t\t\t\tif (flag .eqv. .false.) then\n\t\t\t\t\tprint*, \"matrix is non - invertible\"\n\t\t\t\t\tinverse = 0\n\t\t\t\t\terrorflag = -1\n\t\t\t\t\treturn\n\t\t\t\tendif\n\t\t\tend do\n\t\tendif\n\t\tdo j = k+1, n\t\t\t\n\t\t\tm = augmatrix(j,k)/augmatrix(k,k)\n\t\t\tdo i = k, 2*n\n\t\t\t\taugmatrix(j,i) = augmatrix(j,i) - m*augmatrix(k,i)\n\t\t\tend do\n\t\tend do\n\tend do\n\t\n\t!test for invertibility\n\tdo i = 1, n\n\t\tif (augmatrix(i,i) == 0) then\n\t\t\tprint*, \"matrix is non - invertible\"\n\t\t\tinverse = 0\n\t\t\terrorflag = -1\n\t\t\treturn\n\t\tendif\n\tend do\n\t\n\t!make diagonal elements as 1\n\tdo i = 1 , n\n\t\tm = augmatrix(i,i)\n\t\tdo j = i , (2 * n)\t\t\t\t\n\t\t\t   augmatrix(i,j) = (augmatrix(i,j) / m)\n\t\tend do\n\tend do\n\t\n\t!reduced right side half of augmented matrix to identity matrix\n\tdo k = n-1, 1, -1\n\t\tdo i =1, k\n\t\tm = augmatrix(i,k+1)\n\t\t\tdo j = k, (2*n)\n\t\t\t\taugmatrix(i,j) = augmatrix(i,j) -augmatrix(k+1,j) * m\n\t\t\tend do\n\t\tend do\n\tend do\t\t\t\t\n\t\n\t!store answer\n\tdo i =1, n\n\t\tdo j = 1, n\n\t\t\tinverse(i,j) = augmatrix(i,j+n)\n\t\tend do\n\tend do\n\terrorflag = 0\nend subroutine invertmatrix\n"}, {"instruction": "Create a Fortran subroutine named interp_sgl to perform linear interpolation. This subroutine takes 4 input parameters: an integer npts, an array of real(kind=kind) x, an array of real(kind=kind) y, and a single real(kind=kind) x0. It returns 2 output parameters: a real(kind=kind) y0 and an integer error.", "input": "", "output": "subroutine interp_sgl ( x, y, npts, x0, y0, error )\n!\n!  purpose:\n!    to linearly interpolate the value y0 at position x0, given a\n!    set of (x,y) measurements organized in increasing order of x.\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    03/17/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare local parameters\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: npts           ! dimension of arrays x and y\nreal(kind=kind),dimension(npts), intent(in) :: x\n                                      ! independent variable x.\nreal(kind=kind),dimension(npts), intent(in) :: y\n                                      ! dependent variable y.\nreal(kind=kind),intent(in) :: x0      ! point to interpolate.\nreal(kind=kind),intent(out) :: y0     ! interpolated value.\ninteger, intent(out) :: error         ! error flag: 0 -- no error\n                                      !            -1 -- x0 < x(1)\n                                      !             1 -- x0 > x(npts)\n\n! declare local variables:\ninteger :: i                     ! index variable\ninteger :: ibase                 ! index for interpolation.\nreal :: slope                    ! slope for interpolation.\n\n\n! assume that the input data set is in ascending order of x.\n! see if the measurement position x0 is smaller or larger\n! than any value in the data set.\nif ( x0 < x(1) ) then\n   error = -1\nelse if ( x0 > x(npts) ) then\n   error = 1\nelse\n\n   ! point is between x(1) and x(npts).  find the two points\n   ! that it is between.\n    do i = 1, npts-1\n       if ( (x0 >= x(i)) .and. (x0 <= x(i+1)) ) then\n            ibase = i        ! found the point\n            exit\n       end if\n    end do\n\n    ! now linearly interpolate point.\n    slope = ( y(ibase+1)-y(ibase) ) / ( x(ibase+1)-x(ibase) )\n    y0 = slope * ( x0 - x(ibase) ) + y(ibase)\n\n    ! set error flag to 0.\n    error = 0\nend if\n\nend subroutine interp_sgl\n"}, {"instruction": "Create a Fortran subroutine named \"lstmul\" to calculate the next power of 2 greater than or equal to a given value. The subroutine should have 2 input parameters of type integer and 2 output parameters of type integer. The input parameters should be \"value\" and \"base\", while the output parameters should be \"exp\" and \"mul\". Use the subroutine to calculate \"mul\" and the power \"exp\" required to obtain the next power of 2 from \"base\" that exceeds or equals \"value\".", "input": "", "output": "subroutine lstmul ( value, base, exp, mul )\n!\n!  purpose:\n\n!    value => mul ( = base**exp ).  this calculation is useful\n!    for sizing fft's, etc.\n!\nimplicit none\n\n! list of dummy arguments:\ninteger,intent(in) :: value ! value to compare.\ninteger,intent(in) :: base  ! base to which power exp is raised.\ninteger,intent(out) :: exp  ! the exponent.\ninteger,intent(out) :: mul  ! the next power of 2: mul = base**exp.\n\n! calculate \"mul\" and power of \"base\" required.\nexp = 0\nmul = base ** exp\n\n! find the power of base which exceeds or equals value.\ndo\n   exp = exp + 1\n   mul = base ** exp\n   if ( mul >= value ) exit\nend do\n\n! if the pwer exceeds value, back off by one power of base.\nif ( mul > value ) then\n   exp = exp - 1\n   mul = base ** exp\nend if\n\nend subroutine lstmul\n"}, {"instruction": "Create a Fortran subroutine named \"spline_fit_sgl\" to calculate the second derivatives for a set of cubic spline interpolation using the given input parameters. The number and type of input parameters are 5, with test_data type ['integer', 'real(kind=kind),dimension(n)', 'real(kind=kind),dimension(n)', 'real,optional', 'real,optional']. The number and type of output parameters are 2, with test_data type ['real(kind=kind),dimension(n)', 'integer'].", "input": "", "output": "subroutine spline_fit_sgl ( x, y, n, ypp, error, yp1, ypn )\n!\n!  purpose:\n\n!    ypp which define a set of cubic spline interpolation\n\n!    are supplied in monotonically increasing order of x.\n!    optional values yp1 and ypn are the first derivative of\n!    the function at positions 1 and n, respectively.  if a\n!    value is supplied at position 1 or n, then the\n!    second derivatives ypp are computed to satisfy that\n!    boundary.  if no value is supplied, then the \"natural\n!    cubic spline\", which has a value of ypp = 0 at the\n!    corresponding boundary, is computed.  this algorithm\n!    is adapted from the discussion in chapter 3 of\n!    \"numerical recipes in fortran\".\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    06/02/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare parameters:\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: n                        ! number of pts\nreal(kind=kind),dimension(n),intent(in) :: x    ! input x values\nreal(kind=kind),dimension(n),intent(in) :: y    ! input y values\nreal(kind=kind),dimension(n),intent(out) :: ypp ! 2nd derivatives\ninteger,intent(out) :: error                    ! error: 0 = none\n                                                ! 1=insuf. data\nreal,intent(in),optional :: yp1                 ! 1st der @ pt 1\nreal,intent(in),optional :: ypn                 ! 1st der @ pt n\n\n! declare local variables:\nreal(kind=kind) :: delta              !\ninteger :: i, k                       ! index variables\nreal(kind=kind),dimension(n) :: u     ! temp storage\nreal(kind=kind) :: p                  !\nreal(kind=kind) :: qn                 !\nreal(kind=kind) :: un                 ! temp storage\n\n! check for sufficient data\nenough_data: if ( n >= 2 ) then\n\n   ! set initial boundary condition\n   if ( present(yp1) ) then\n      ! set specified first derivative\n      ypp(1) = -0.5\n      u(1) = (3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)\n   else\n      ! set natural lower bound\n      ypp(1) = 0.\n      u(1) = 0.\n   end if\n\n   ! decomposition loop\n   do i = 2, n-1\n      delta = (x(i)-x(i-1)) / (x(i+1)-x(i-1))\n      p = delta * ypp(i-1) + 2.\n      ypp(i) = (delta - 1.) / p\n      u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1)) &\n           /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-delta*u(i-1))/p\n   end do\n\n   ! set final boundary condition\n   if ( present(ypn) ) then\n      ! set specified first derivative\n      qn = 0.5\n      un = (3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))\n   else\n      ! set natural lower bound\n      qn = 0.\n      un = 0.\n   end if\n\n   ! back substitution loop\n   ypp(n) = (un-qn*u(n-1)) / (qn*ypp(n-1)+1.)\n   do k = n-1,1,-1\n      ypp(k) = ypp(k)*ypp(k+1) + u(k)\n   end do\nelse\n   error = 1\nend if enough_data\n\nend subroutine spline_fit_sgl\n"}, {"instruction": "Create a Fortran subroutine named spline_int_sgl to perform cubic spline interpolation. The subroutine takes 5 input parameters: n (integer), x (real(kind=kind) array of dimension n), y (real(kind=kind) array of dimension n), ypp (real(kind=kind) array of dimension n), x0 (optional, real(kind=kind)). It also returns 2 output parameters: y0 (optional, real(kind=kind)) and error (integer). The purpose of this subroutine is to interpolate the value y0 at a given x0 using cubic spline interpolation based on the input knots and spline coefficients.", "input": "", "output": "subroutine spline_int_sgl(x, y, n, ypp, x0, y0, error)\n!\n!  purpose:\n\n!    given the set of knots and spline coefficients x,\n\n!    spline_fit.  this algorithm is adapted from the\n!    discussion in chapter 3 of \"numerical recipes in\n!    fortran\".\n!\n!  record of revisions:\n!      date       programmer          description of change\n!      ====       ==========          =====================\n!    06/02/96    s. j. chapman        original code\n!\nimplicit none\n\n! declare parameters:\ninteger, parameter :: kind = selected_real_kind(p=6) ! precision\n\n! declare calling arguments:\ninteger, intent(in) :: n                        ! number of pts\nreal(kind=kind),dimension(n),intent(in) :: x    ! input x values\nreal(kind=kind),dimension(n),intent(in) :: y    ! input y values\nreal(kind=kind),dimension(n),intent(in) :: ypp  ! 2nd derivatives\nreal(kind=kind),intent(in),optional :: x0       ! point to inter.\nreal(kind=kind),intent(out),optional :: y0      ! interpolated value\ninteger,intent(out) :: error                    ! error\n                                                !  0 - no error\n                                                !  1 - dx == 0\n\n! declare local variables:\nreal(kind=kind) :: a, b     ! temp storage\nreal(kind=kind) :: dx       ! delta x between points\ninteger :: k                ! index variables\ninteger :: klo              ! index of x just below x0\ninteger :: khi              ! index of x just above x0\n\n! find the interval containing x0 by bisection.  note that the\n! x values must be monotonically increasing, for this search may\n! fail.\nklo = 1\nkhi = n\ndo\n   if ( (khi-klo) == 1 ) exit     ! x(klo) < x <= x(khi)\n   k = ( khi + klo ) / 2\n   if ( x(k) < x0 ) then\n      klo = k\n   else\n      khi = k\n   end if\nend do\n\n! get dx\ndx = x(khi) - x(klo)\n\n! check for error\nif ( dx == 0. ) then\n   error = 1\nelse\n   ! interpolate cubic equation to get point\n   error = 0\n   a = ( x(khi) - x0 ) / dx\n   b = ( x0 - x(klo) ) / dx\n   y0 = a * y(klo) + b * y(khi) + &\n      ((a**3-a) * ypp(klo) + (b**3-b) * ypp(khi)) * (dx**2) / 6.\nend if\n\nend subroutine spline_int_sgl\n"}, {"instruction": "Create a Fortran subroutine named continuous_integrals_b2equal0 to calculate continuous integrals using the given input parameters. There are 5 input parameters of types integer, real(8) arrays of dimension (npt-1), and 1 output parameter of type real(8) array of dimension (npt-1). The subroutine uses the imperative tone and computes the integrals based on the given formula.", "input": "", "output": "subroutine continuous_integrals_b2equal0(npt, beta0, beta1, xlow, xhigh, integrals)\n    implicit none\n    integer,intent(in)                      :: npt\n    real(8),dimension(npt-1),intent(in)     :: beta0, beta1, xlow, xhigh\n    real(8),dimension(npt-1),intent(out)    :: integrals\n\n    integrals = exp(beta0) * (exp(beta1 * xhigh) - exp(beta1 * xlow) ) / beta1\nend subroutine continuous_integrals_b2equal0\n"}, {"instruction": "Write a Fortran subroutine named \"erfv\" to compute the error function values for a given array of real numbers. The subroutine takes 2 input parameters: an integer \"n\" and an array of real numbers \"x\" with dimension \"n\". It also has 1 output parameter, an array of real numbers \"res\" with dimension \"n\". Use the provided formula to calculate the error function values and assign the results to the \"res\" array.", "input": "", "output": "subroutine erfv(n,x,res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    real(8),dimension(n)                :: t\n\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * abs(x))\n    res = sign(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                        1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-x**2), x)\nend subroutine erfv\n"}, {"instruction": "Create a Fortran subroutine named erfs to compute the error function of a real(8) input. The subroutine takes 1 input parameter of type real(8) and returns 1 output parameter of type real(8).", "input": "", "output": "subroutine erfs(x,res)\n    implicit none\n    real(8),intent(in)     :: x\n    real(8),intent(out)    :: res\n    real(8)                :: t\n\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * abs(x))\n    res = sign(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                        1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-x**2), x)\nend subroutine erfs\n"}, {"instruction": "Create a Fortran subroutine named \"erfis\" to calculate the error function of a real(8) input parameter. The subroutine should have 1 input parameter of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine erfis(x, res)\n    implicit none\n    real(8),intent(in)     :: x\n    real(8),intent(out)    :: res\n    complex(8)             :: t, u\n\n    u   = cmplx(0.0d0,abs(x),kind=8)\n    t   = 1.0d0 / (1.0d0 + 0.327591100d0 * u )\n    res = sign(aimag(1.0d0 - (0.254829592d0 * t - 0.284496736d0 * t**2 + 1.421413741d0 * t**3 - &\n                   1.453152027d0 * t**4 + 1.061405429d0 * t**5) * exp(-u**2) ), x)\nend subroutine erfis\n"}, {"instruction": "Create a Fortran subroutine named inv_erfv to calculate the inverse error function values. The subroutine takes 2 input parameters: an integer n and an array of real(8) numbers of size n. The output is a real(8) array of size n.", "input": "", "output": "subroutine inv_erfv(n, x, res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    real(8),dimension(n)                :: t, q\n    real(8),parameter                   :: a = 0.145d0\n    real(8),parameter                   :: twopia = 2.0d0/(3.141592653589793d0*0.145d0)\n\n    t   = log(1.0d0 - x**2)\n    q   = twopia + 0.5d0 * t\n    res = sign( sqrt( sqrt(q**2 - t / a) - q ), x)\nend subroutine inv_erfv\n"}, {"instruction": "Create a Fortran subroutine named inv_erfiv to calculate the inverse error function value for each element of an input real array. The number of input arguments is 2 and the test_data type is ['integer', 'real(8),dimension(n)']. The number of output arguments is 1 and the test_data type is ['real(8),dimension(n)'].", "input": "", "output": "subroutine inv_erfiv(n, x, res)\n    implicit none\n    integer,intent(in)                  :: n\n    real(8),dimension(n),intent(in)     :: x\n    real(8),dimension(n),intent(out)    :: res\n    complex(8),dimension(n)             :: t, q, u\n    real(8), parameter                  :: a = 0.1382d0\n    real(8),parameter                   :: itwopia = 2.0d0/(3.141592653589793d0 * a)\n\n    u   = cmplx(0.0d0, abs(x),kind=8)\n    t   = log(1.0d0 - u**2)\n    q   = itwopia + 0.5d0 * t\n    res = sign(aimag(sqrt( sqrt(q**2 - t / a) - q )), x)\nend subroutine inv_erfiv\n"}, {"instruction": "Create a Fortran subroutine named histogram to generate a histogram of values, counting the occurrences within each specified bin range. The subroutine takes 4 input parameters of types ['integer', 'integer', 'real(dp)', 'real(dp)'] and 1 output parameter of type ['real(dp)']. The subroutine utilizes the imperative tone to declare the intent of the input and output parameters, and it updates the histogram counts based on the input data and bin edges.", "input": "", "output": "subroutine histogram(x, range, c, m, n)\n    ! generates a histogram of values, counting the number within each of a given set of bin ranges.\n    integer, parameter :: dp = kind(0.0d0)  ! double precision\n    ! sizes of the data to be binned, and the number of bins, respectively.\n    integer, intent(in) :: n, m\n    ! the input data to be binned, and values of bin edges, respectively.\n    real(dp), intent(in) :: x(n), range(m)\n    ! the histogram counts. note that range is left hand bins plus one right hand bin, and hence\n    ! c has length m-1.\n    real(dp), intent(out) :: c(m-1)\n    integer :: i, j  \n\n    c(:) = 0\n\n    do i = 1, n                       ! for each input score\n        do j = 1, m-1                    ! determine the bucket\n            if (x(i) < range(1) .or. x(i) > range(m)) then\n                exit\n            end if\n            if (x(i) < range(j+1) .and. x(i) >= range(j)) then\n                c(j) = c(j) + 1\n                exit\n            end if               \n        end do    \n        if (x(i) >= range(m)) then\n            c(m-1) = c(m-1) + 1\n        end if                    \n    end do\n\nend subroutine histogram\n"}, {"instruction": "Create a Fortran subroutine named plik_dust_template to generate a dust template array based on the specified range of wavelengths. It takes 2 input parameters of type integer, lmin and lmax, and has 1 output parameter of type real(8) array with dimensions ranging from lmin to an unspecified upper bound. Use an imperative tone in the instructions.", "input": "", "output": "   subroutine plik_dust_template(dust_template__l, lmin, lmax)\n\n    integer,                                intent(in)    :: lmin\n    integer,                                intent(in)    :: lmax\n    real(8),      dimension(lmin:),         intent(out)   :: dust_template__l\n\n    integer                                               :: i\n    real(8)                                               :: l_pivot\n    real(8)                                               :: gal_index\n    real(8),                                parameter     :: twopi = 6.283185307179586476925286766559005768394\n\n    l_pivot   = 500.0\n    gal_index = -2.6\n\n    do i = lmin,lmax\n       dust_template__l(i) = (dble(i)/l_pivot)**gal_index / twopi\n    enddo\n\n\n  end subroutine plik_dust_template\n"}, {"instruction": "Write a Fortran subroutine named sub2 that takes an integer as input and returns a character array of length specified by the input integer.", "input": "", "output": "  subroutine sub2(string,str_size)\n    integer,intent(in)    :: str_size\n    character,intent(out) :: string(str_size)\n    string(:) = 'a'\n  end subroutine sub2\n"}, {"instruction": "Create a Fortran subroutine named sfntri to calculate the shape functions, their derivatives, and Jacobian for a triangle element at specified global positions. The subroutine takes 4 input parameters of type real,dimension(3,2), real, real, and real, and returns 3 output parameters of type real, real,dimension(3), and real,dimension(2,3) respectively.", "input": "", "output": "subroutine sfntri(det,sf,gdsf,l1,l2,l3,elxy)\n  implicit none\n\n! and their derivatives at specified global positions\n  integer,parameter :: npe=3\n  integer :: i,j,k\n  real,dimension(3,2),intent(in) :: elxy\n  real,intent(in) :: l1,l2,l3\n  real,intent(out) :: det\n  real,dimension(3),intent(out) :: sf\n  real,dimension(2,3),intent(out) :: gdsf\n  real,dimension(3,3) :: dsf\n  real,dimension(2,2) :: gj,gjinv\n  real :: sum\n\n! initialize arrays\n  do i=1,npe  \n     dsf(1,i) = 0.0\n     dsf(2,i) = 0.0\n     dsf(3,i) = 0.0\n     sf(i)    = 0.0\n  end do\n  \n! set the shape functions for a triangle\n  sf(1) = l1\n  sf(2) = l2\n  sf(3) = l3\n  dsf(1,1) = 1.0\n  dsf(2,2) = 1.0\n  dsf(3,3) = 1.0\n\n! find the jacobian\n  do i=1,2\n     do j=1,2\n        sum = 0.0\n        do k=1,npe\n           sum = sum + (dsf(i,k) - dsf(3,k))*elxy(k,j)\n        end do\n        gj(i,j) = sum\n     end do\n  end do\n\n! find gj's inverse\n  det        =  gj(1,1)*gj(2,2) - gj(1,2)*gj(2,1)\n  gjinv(1,1) =  gj(2,2)/det\n  gjinv(2,2) =  gj(1,1)/det\n  gjinv(1,2) = -1.0*gj(1,2)/det\n  gjinv(2,1) = -1.0*gj(2,1)/det\n\n! obtain the derivative of the shape function with proper\n! transformation\n  do i=1,2\n     do j=1,npe\n        sum = 0.0\n        do k=1,2\n           sum = sum + gjinv(i,k)*(dsf(k,j) - dsf(3,j))\n        end do\n        gdsf(i,j) = sum\n     end do\n  end do\n\nend subroutine sfntri\n"}, {"instruction": "Create a Fortran subroutine named getthetasize to determine the size of the quadpoint array and check for custom points. The subroutine takes 1 input parameter of type real(kind=8) and returns 2 output parameters: one of type integer and one of type logical.", "input": "", "output": "subroutine getthetasize(quadpoint,irfcount,custompoints)\r\nimplicit none\r\ninteger,intent(out)::irfcount\r\nlogical,intent(out)::custompoints\r\nreal(kind=8),intent(in)::quadpoint(:,:)\r\n!\terror flag for input.\r\ninteger::io\r\n\r\nnamelist/irfspecs/irfcount,custompoints\r\nirfcount=size(quadpoint,2)\r\ncustompoints=.false.\r\nread(*,nml=irfspecs,iostat=io)\r\nif(io/=0) stop 'failure to read specifications for points for item response functions.'\r\nif(irfcount/=size(quadpoint,2)) custompoints=.true.\r\nend subroutine getthetasize\n"}, {"instruction": "Create a Fortran subroutine named smallest_prime to find the smallest prime factor of a given positive integer. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. The input parameter represents the integer for which the smallest prime factor needs to be determined, and the output parameter stores the value of the smallest prime factor. If the input number is less than or equal to 2, the output will be the input number itself. If the input number is greater than 2, the subroutine will iterate to find the smallest prime factor and store it in the output parameter. If the input number is negative, the subroutine will stop and display a message indicating that it is only designed for positive integers.", "input": "", "output": "  subroutine smallest_prime(a,sp)\n    integer, intent(in) :: a\n    integer, intent(out) :: sp\n\n    integer ::i\n\n    if (a<0) stop \"smallest_prime is only designed for positive integers.\"\n    if (a <= 2) then\n       sp = a\n    else\n       do i = 2, a\n          if (mod(a,i)==0) then\n             sp = i\n             exit\n          end if\n       end do\n    end if\n\n  end subroutine smallest_prime\n"}, {"instruction": "Create a Fortran subroutine named \"glob_to_axial\" that calculates the axial force for rod elements in 2D or 3D. The subroutine should have 2 input parameters of type real(iwp) and 1 output parameter of type real(iwp).", "input": "", "output": "subroutine glob_to_axial(axial,global,coord)\r\n!\r\n\n! into an axial force for rod elements (2- or 3-d).\r\n!\r\n implicit none\r\n integer,parameter::iwp=selected_real_kind(15)\r\n real(iwp),intent(in)::global(:),coord(:,:)\r\n real(iwp),intent(out)::axial\r\n real(iwp)::add,ell,zero=0.0_iwp\r\n integer::ndim,i\r\n ndim=ubound(coord,2)\r\n add=zero\r\n do i=1,ndim\r\n   add=add+(coord(2,i)-coord(1,i))**2\r\n end do\r\n ell=sqrt(add)\r\n axial=zero\r\n do i=1,ndim\r\n   axial=axial+(coord(2,i)-coord(1,i))/ell*global(ndim+i)\r\n end do\r\nreturn\r\nend subroutine glob_to_axial                       \r\n"}, {"instruction": "Create a Fortran subroutine named ppnd that implements an algorithm to produce a normal deviate corresponding to the lower tail area of a given probability, p. The subroutine takes 1 input parameter of type real and returns 2 output parameters of type integer and real.", "input": "", "output": "subroutine ppnd(p, ifault, fn_val)\r\n\r\n!  algorithm as 111  appl. statist. (1977), vol.26, no.1\r\n\r\n!  produces normal deviate corresponding to lower tail area of p\r\n!  real version for eps = 2 **(-31)\r\n!  the hash sums are the sums of the moduli of the coefficients\r\n!  they have no inherent meanings but are included for use in\r\n!  checking transcriptions\r\n!  standard functions abs, alog and sqrt are used\r\n\r\nimplicit none\r\nreal, intent(in)      :: p\r\ninteger, intent(out)  :: ifault\r\nreal, intent(out)     :: fn_val\r\n\r\nreal :: q, r\r\n\r\nreal, parameter  :: zero = 0.0e0, half = 0.5e0, one = 1.0e0\r\nreal, parameter  :: split = 0.42e0\r\nreal, parameter  :: a0 = 2.50662823884e0\r\nreal, parameter  :: a1 = -18.61500062529e0\r\nreal, parameter  :: a2 = 41.39119773534e0\r\nreal, parameter  :: a3 = -25.44106049637e0\r\nreal, parameter  :: b1 = -8.47351093090e0\r\nreal, parameter  :: b2 = 23.08336743743e0\r\nreal, parameter  :: b3 = -21.06224101826e0\r\nreal, parameter  :: b4 = 3.13082909833e0\r\nreal, parameter  :: c0 = -2.78718931138e0\r\nreal, parameter  :: c1 = -2.29796479134e0\r\nreal, parameter  :: c2 = 4.85014127135e0\r\nreal, parameter  :: c3 = 2.32121276858e0\r\nreal, parameter  :: d1 = 3.54388924762e0\r\nreal, parameter  :: d2 = 1.63706781897e0\r\n\r\nifault = 0\r\nq = p - half\r\nif (abs(q) > split) go to 1\r\nr = q*q\r\nfn_val = q * (((a3*r + a2)*r + a1) * r + a0) /  &\r\n    ((((b4*r + b3)*r + b2) * r + b1) * r + one)\r\nreturn\r\n\r\n1 r = p\r\nif (q > zero)r = one - p\r\nif (r <= zero) go to 2\r\nr = sqrt(-log(r))\r\nfn_val = (((c3 * r + c2) * r + c1) * r + c0)/ ((d2*r + d1) * r + one)\r\nif (q < zero) fn_val = -fn_val\r\nreturn\r\n\r\n2 ifault = 1\r\nfn_val = zero\r\nreturn\r\nend subroutine ppnd\r\n"}, {"instruction": "Write a Fortran subroutine named swa to calculate specific values and assign them to a 2x2 array based on input parameters. The subroutine takes 2 input arguments of type double precision and outputs a 2x2 array of type double precision. The input parameters are q1 and q2, both of type double precision. The output is a 2x2 array named 'a' of type double precision. The subroutine uses the values of q1 and q2 to perform calculations and assign specific values to the elements of the 2x2 array 'a'. The subroutine should be named swa.", "input": "", "output": "\tsubroutine swa(a,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: a\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c\n\t\n\tc = sqrt(g*q1)\n\t\n\ta(1,1) = q2/q1-c\n\ta(1,2) = 0d0\n\ta(2,1) = 0d0\n\ta(2,2) = q2/q1+c\n\t\n\t\n\tend subroutine swa\n"}, {"instruction": "Create a Fortran subroutine named swr to calculate the values of a 2x2 matrix based on the input parameters q1 and q2, both of type double precision. The output parameter r is also of type double precision and has a dimension of 2x2. Ensure that the subroutine includes the calculation of c as the square root of the product of g and q1.", "input": "", "output": "\tsubroutine swr(r,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: r\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c\n\t\n\tc = sqrt(g*q1)\n\t\n\tr(1,1) = 1d0\n\tr(1,2) = 1d0\n\tr(2,1) = q2/q1-c\n\tr(2,2) = q2/q1+c\n\t\n\tend subroutine swr\n"}, {"instruction": "Create a Fortran subroutine named \"swri\" to calculate the values of a 2x2 matrix based on given input parameters. The subroutine takes 2 input parameters of type 'double precision' and returns a 2x2 matrix of type 'double precision'. The input parameters are q1 and q2, while the output parameter is ri. The subroutine uses the given input parameters and a predefined constant 'g' to compute values for the 2x2 matrix 'ri'.", "input": "", "output": "\tsubroutine swri(ri,q1,q2)\n\t\n\tdouble precision, intent(in)\t\t\t\t\t:: q1, q2\n\tdouble precision, dimension(2,2), intent(out)\t:: ri\n\tdouble precision, parameter\t\t\t\t\t\t:: g = 1d0\n\tdouble precision\t\t\t\t\t\t\t\t:: c, twoc\n\t\n\tc = sqrt(g*q1)\n\ttwoc = 2d0*c\n\t\n\tri(1,1) = (q2/q1+c)/twoc\n\tri(1,2) = -1d0/twoc\n\tri(2,1) = (c-q2/q1)/twoc\n\tri(2,2) = 1d0/twoc\n\t\n\tend subroutine swri\n"}, {"instruction": "Create a Fortran subroutine named betalimits to calculate the minimum and maximum values based on the composition and k factors of a chemical system. The subroutine should have 3 input parameters of type integer, real*8 array of size n, and real*8 array of size n. It should also have 2 output parameters of type real*8.", "input": "", "output": "\tsubroutine betalimits (n,z,kfact,bmin,bmax)\r\n\r\n      implicit none\r\n\r\n        integer, intent(in) :: n  ! number of compounds in the system\r\n        real*8, dimension(n), intent(in) :: z, kfact  ! composition of the system and k factors\r\n        real*8, intent(out) :: bmin, bmax\r\n        real*8, dimension(n) :: vmin, vmax\r\n        integer :: i, in=0, ix=0\r\n\r\n        vmin=0.d0\r\n        vmax=1.d0\r\n        do i=1,n\r\n            if (kfact(i)*z(i)>1)then\r\n                in = in+1\r\n                vmin(in) = (kfact(i)*z(i)-1.d0)/(kfact(i)-1.d0)\r\n            else if (kfact(i)<z(i))then\r\n                ix = ix+1\r\n                vmax(ix) = (1.d0-z(i))/(1.d0-kfact(i))\r\n            end if\r\n        end do\r\n        bmin = maxval(vmin)\r\n        bmax = minval(vmax)\r\n\r\n    end subroutine betalimits\r\n"}, {"instruction": "Create a Fortran subroutine named sb_resample to resample an input array to a specified length. The subroutine takes 3 input parameters: two integers (in_n and out_n) passed by value, and an array of real numbers (in) with a dimension of in_n. It also has 1 output parameter, an array of real numbers (out) with a dimension of out_n. The subroutine resamples the input array to the specified length using linear interpolation and stores the result in the output array.", "input": "", "output": "subroutine sb_resample(in, in_n, out, out_n)\n  integer, intent(in), value :: in_n, out_n\n  real, dimension(in_n), intent(in) :: in\n  real, dimension(out_n), intent(out) :: out\n  out = (/ (in(1 + (i - 1) * in_n / out_n), i = 1, out_n) /)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named s_count_pdb_atoms to read a pdb_file and determine the number of atom or hetatm records declared in the file. The number of input parameters is 1 with the test_data type of ['character(len=*)'], and the number of output parameters is 1 with the test_data type of ['integer(c_int)'].", "input": "", "output": "subroutine s_count_pdb_atoms(pdb_file,num_atoms)\n!\n! reads the number of atom or hetatm records declared in pdb file.\n! single model hosted inside the pdb file is assumed.\n!\n! author : veselin kolev <vesso.kolev@gmail.com>\n! version: 2018121000\n! license: gplv2\n!\nuse iso_c_binding,only:c_int\n!\nimplicit none\n!\n! interface variables:\n!\ncharacter(len=*),intent(in) :: pdb_file\ninteger(c_int),intent(out)  :: num_atoms\n!\n! local variables:\n!\ninteger(c_int)              :: stat\ninteger(c_int),parameter    :: str_len=54\ncharacter(len=str_len)      :: buffer\n\nopen(666,file=pdb_file,iostat=stat)\n!\nnum_atoms=0\n!\ndo while(stat.eq.0)\n   !\n   read(666,'(a54)',iostat=stat) buffer\n   !\n   if (stat==0) then\n      !\n      if (buffer(1:6).eq.'atom  ') then\n         !\n         num_atoms=num_atoms+1\n         !\n      end if\n      !\n   end if\n   !\nend do\n!\nclose(666)\n\nend subroutine s_count_pdb_atoms\n"}, {"instruction": "Create a Fortran subroutine named get_opacities to calculate the opacities kp and kr based on the given input parameters. The subroutine takes 6 input parameters of types ['logical', 'logical', 'double precision', 'double precision', 'double precision', 'double precision'] and returns 2 output parameters of type ['double precision', 'double precision']. The subroutine uses the \"implicit none\" statement to enforce explicit declaration of all variables.", "input": "", "output": "  subroutine get_opacities(kp, kr, rho, temp, rhoye, nu, get_planck_mean, get_rosseland_mean)\n\n    implicit none\n\n    logical, intent(in) :: get_planck_mean, get_rosseland_mean\n    double precision, intent(in) :: rho, temp, rhoye, nu\n    double precision, intent(out) :: kp, kr\n\n    kp = 0.d0\n    kr = 0.d0\n\n  end subroutine get_opacities\n"}, {"instruction": "Write a Fortran subroutine named radiat to calculate the isothermal net radiation based on the van Ulden and Holtslag (1985) radiation scheme. The number of input arguments is 6, and the test_data type is [real, real, real, real, real, real]. The number of output arguments is 1, and the test_data type is [real].", "input": "", "output": "      subroutine radiat(sigma,sinphi,tm,rnn,rkin,ralb,qsti)  \n! ---------------------------------------------------------------------\n!         radiation scheme according to van ulden and holtslag \n!         (1985,jcam, 24, 1196-1207).\n!         \n!\n!         input:\n!             sigma  : stefan boltzmanns constant\n!             sinphi : sine of the solar elevation\n!             rnn    : cloud cover fraction (0-1)   \n!             rkin   : incoming short wave radiation (w/m2)\n!                      (missing : -9900. or 0.0)\n!             ralb   : surface albedo [0.0 - 1.0(total reflection)]   \n!\n!                      surface      albedo(%)   ralb\n!               1  :   dark soil       10       0.10\n!               2  :   forest          15       0.15\n!               3  :   grass,lush      20       0.20\n!               4  :   sand            25       0.25\n!               5  :   ice,old         30       0.30\n!               6  :   ice,new         35       0.35\n!               7  :   snow,old        40       0.40\n!               8  :   snow,normal     60       0.60\n!               9  :   snow,fresh      80       0.80\n!        \n!         output:\n!             qsti   : isothermal net radiation, q*_i. (w/m2)\n\n!    ------------------------------------------------------------------\n! ----------------------------------------------------------------------------------\n! based on:\n! version episode 5.5 (may29, 2012) prepared for bb-stand-alone\n! original source code of episode by sam-erik walker (nilu)\n!\n! sam-erik walker\n! norwegian institute for air research (nilu)\n! instituttveien 18 p.o. box 100\n! n-2027 kjeller, norway\n! tel: +47 63898000 fax: +47 63898050\n! e-mail: sam-erik.walker@nilu.no\n!\n! ----------------------------------------------------------------------------------\n! ----------------------------------------------------------------------------------\n! revision history\n!\n!    xx dat 201x  name: line  description of change\n!\n! ----------------------------------------------------------------------------------\n\n        implicit none\n\n! *** input variables:\n      real,intent(in)  :: sigma,sinphi,tm,rnn,rkin,ralb\n\n! *** output variables\n      real,intent(out) :: qsti\n\n! *** local variables:\n      real :: rkst,rlsti\n\t\n! *** the values of the constants below are identical with the ones\n! *** given in vu&h, 1985. \n      real,parameter :: a1    = 990.0 \n      real,parameter :: a2    = -30.0\n      real,parameter :: b1    =   0.75\n      real,parameter :: b2    =   3.4\n      real,parameter :: c1    =   9.35e-6\n      real,parameter :: c2    =  60.0\n      real,parameter :: sphi0 =   0.03\n\n!     selection of albedo (input parameter)\n\n      if(rkin >= 0.0) then\n! ***   if measured values of the incoming short wave rad. exists:\n          rkst = rkin*(1.0 - ralb)\n      else\n!       for phi < 1.7 degrees : no short wave radiation (vu&h, 1985). \n        if (sinphi .lt. sphi0) then\n           rkst = 0.0\n        else                                      \n! ***     the net shortwave radiation, see eq. (17) in vu&h, 1985:\n           rkst = (a1*sinphi + a2)*(1.0 - b1*rnn**b2)*(1.0 - ralb)    \n        endif\n      endif\n\n! *** isothermal longwave radiation, l*_i, see eq.(21) in vu&h,1985:\n      rlsti = -sigma*tm**4*(1.0 - c1*tm**2) + c2*rnn\n\n! *** isothermal net radiation, q*_i, see eq.(28) in vu&h,1985:\n      qsti = rkst + rlsti\n\n      return\n\n      end subroutine radiat\n"}, {"instruction": "Create a Fortran subroutine named get_index_of_csr_data to find the index of a specific element in a Compressed Sparse Row (CSR) matrix based on its row and column indices. The subroutine takes 6 input parameters of type integer: i, j, indptr, indices, n, and m. It also has 1 output parameter of type integer: k. The subroutine identifies the position (k) of the element in the data array of the CSR matrix based on the provided row and column indices and the CSR matrix arrays. Ensure that the subroutine considers the 0-based indexing used in numpy arrays.", "input": "", "output": "subroutine get_index_of_csr_data(i, j, indptr, indices, k, n, m)\n    ! i, j are the indices of the global array\n    ! indptr and indices are the arrays from the csr matrix\n    ! k is the python-index of the data array in the csr matrix\n    ! n is the dimension of the indptr-array\n    ! m is the dimension of the indices array\n\n    ! be careful, but the indexing is given in numpy arrays.\n    ! so the entries containing indices start at zero!\n\n    implicit none\n\n    integer, intent(in) :: n, m\n    integer, intent(in) :: i, j, indptr(n), indices(m)\n    integer, intent(out) :: k\n\n    k = indptr(i+1)\n    do while( j /= indices(k+1) )\n        k = k + 1\n\n        if (k > indptr(i+2)) then\n            k = 0\n            exit\n        end if\n\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named project_pt to perform a coordinate transformation. The subroutine takes 6 input parameters of types character(len=3), real(8), and real(8), and provides 3 output parameters of type real(8). The function converts coordinates between global and local frames based on the direction specified by the 'dir' parameter. Use the 'intent' attribute to specify the input and output parameters. Use the 'stop' statement to handle unknown direction flags. Use the 'implicit' statement to define the data types implicitly.", "input": "", "output": "      subroutine project_pt(dir,xi,yi,zi,origin0,frame0,xo,yo,zo)\n      implicit real*8(a-h,o-z)\n\n      character(len=3), intent(in) :: dir\n      real(8), intent(in) :: xi,yi,zi,origin0(3),frame0(3,3)\n      real(8), intent(out) :: xo,yo,zo\n\n      !local\n      real(8) :: wild(3)\n\n      if(dir.eq.'g2l') then\n        wild(1:3)=(xi-origin0(1))*frame0(1,1:3)+(yi-origin0(2))*frame0(2,1:3)+ &\n                 &(zi-origin0(3))*frame0(3,1:3)\n      else if(dir.eq.'l2g') then\n        wild(1:3)=origin0(1:3)+xi*frame0(1:3,1)+yi*frame0(1:3,2)+ &\n     &zi*frame0(1:3,3)\n      else\n        stop 'project_pt: unknown flag'\n      endif\n      xo=wild(1)\n      yo=wild(2)\n      zo=wild(3)\n\n      end subroutine project_pt\n"}, {"instruction": "Write a Fortran subroutine named loadc1nz_ that returns the non-zero values of 1e coupling constants. The subroutine takes 3 input parameters of types integer, integer, and real(8), and 5 output parameters of types integer, integer, integer, integer, and real(8).", "input": "", "output": "        subroutine loadc1nz_(inz,lnz,vnz,ic,jc,im,jm,a1)\n          ! return non-zero values of 1e coupling const.\n          implicit none\n          integer,intent(in)::inz,lnz(:,:)\n          real(8),intent(in)::vnz(:)\n          integer,intent(out)::ic,jc,im,jm\n          real(8),intent(out)::a1\n          ic=lnz(1,inz)\n          jc=lnz(2,inz)\n          im=lnz(3,inz)\n          jm=lnz(4,inz)\n          a1=vnz(inz)\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named loadc2nz_ to load the non-zero values of 2e coupling constants. The subroutine has 3 input parameters of type integer, integer, and real(8), and 7 output parameters of type integer, integer, integer, integer, integer, integer, and real(8).", "input": "", "output": "        subroutine loadc2nz_(inz,lc2,vc2,icr,jcr,im,jm,km,lm,val)\n          ! load the non-zero value of 2e coupling const.\n          implicit none\n          integer,intent(in)::inz,lc2(:,:)\n          real(8),intent(in)::vc2(:)\n          integer,intent(out)::icr,jcr,im,jm,km,lm\n          real(8),intent(out)::val\n          icr=lc2(1,inz)\n          jcr=lc2(2,inz)\n          im=lc2(3,inz)\n          jm=lc2(4,inz)\n          km=lc2(5,inz)\n          lm=lc2(6,inz)\n          val=vc2(inz)\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"getpasttimes\" to retrieve the indices of the previous time steps. It takes 2 input parameters of type integer and returns 3 output parameters of type integer.", "input": "", "output": "  subroutine getpasttimes (ntpc,n , n_1,n_2,n_3)\n    ! description :\n    ! recupere les indices des pas de temps precedents.\n    implicit none\n    ! inputs :\n    ! nombre de pas de temps par periode\n    integer, intent(in)                                     :: ntpc\n    ! indice du pas de temps courant\n    integer, intent(in)                                     :: n\n    ! outputs :\n    ! indices des pas de temps precedents\n    integer, intent(out)                                    :: n_1, n_2, n_3\n    \n    ! modulo ntpc\n    if ( n == 1 ) then\n      n_1 = ntpc\n      n_2 = ntpc-1\n      n_3 = ntpc-2\n      \n    else if ( n == 2 ) then\n      n_1 = 1\n      n_2 = ntpc\n      n_3 = ntpc-1\n      \n    else if ( n == 3 ) then\n      n_1 = 2\n      n_2 = 1\n      n_3 = ntpc\n      \n    else\n      n_1 = n-1\n      n_2 = n-2\n      n_3 = n-3\n      \n    end if\n    \n    return\n  end subroutine getpasttimes\n"}, {"instruction": "Create a Fortran subroutine named predictinitialsolution that implements second-order extrapolation to initialize a solution. This subroutine takes 4 input parameters of types integer, double precision arrays of size ndof, and one output parameter of type double precision array of size ndof.", "input": "", "output": "  subroutine predictinitialsolution (ndof,h_1,h_2,h_3 , h_n)\n    ! description :\n    ! extrapolation d'ordre 2 pour initialiser la solution.\n    implicit none\n    ! inputs :\n    ! discretisation\n    integer, intent(in)                                     :: ndof\n    ! champ aux pas precedents                              \n    double precision, dimension(ndof), intent(in)           :: h_1, h_2, h_3\n    ! outputs :                                           \n    ! prediction                                            \n    double precision, dimension(ndof), intent(out)          :: h_n\n    \n    ! prediction de la solution au pas n\n    h_n = 0.5d0*( 5.0d0*h_1 - 4.0d0*h_2 + h_3 )\n    \n    return\n  end subroutine predictinitialsolution\n"}, {"instruction": "Create a Fortran subroutine named calcullosses to calculate losses in a system. The subroutine takes 8 input parameters: ndof and ntpc of type integer, dx and dt of type double precision, rho of type double precision, and h_x_t, b_x_t, j_x_t of type double precision arrays of dimension (ndof+1,ntpc). It also has 2 output parameters: pj_x_t and ph_x_t, both of type double precision arrays of dimension (ndof+1,ntpc).", "input": "", "output": "  subroutine calcullosses (ndof,ntpc,dx,dt,rho,h_x_t,b_x_t,j_x_t , pj_x_t,ph_x_t)\n    implicit none\n    ! inputs :\n    ! discretisation\n    integer, intent(in)                                     :: ndof, ntpc\n    double precision, intent(in)                            :: dx, dt\n    ! resistivite\n    double precision, intent(in)                            :: rho\n    ! solution\n    double precision, dimension(ndof+1,ntpc), intent(in)    :: h_x_t, b_x_t, j_x_t\n    ! outputs :\n    ! pertes\n    double precision, dimension(ndof+1,ntpc), intent(out)   :: pj_x_t, ph_x_t\n    \n    ! variables :\n    integer                                                 :: n, nm1, np1\n    \n    ! initialisation\n    pj_x_t = 0.0d0\n    ph_x_t = 0.0d0\n    \n    ! calcul des pertes\n    do n = 1, ntpc\n      \n      ! index pas avant et apres\n      if ( n == 1 ) then\n        nm1 = ntpc\n        np1 = 2\n      else if ( n == ntpc ) then\n        nm1 = ntpc - 1\n        np1 = 1\n      else\n        nm1 = n - 1\n        np1 = n + 1\n      end if\n      \n      ! calcul des pertes joules en fonction du temps\n      pj_x_t(1:ndof+1,n) = rho*j_x_t(1:ndof+1,n)*j_x_t(1:ndof+1,n)\n      \n      ! calcul des pertes par hysteresis en fonction du temps\n      ph_x_t(1:ndof+1,n) = h_x_t(1:ndof+1,n)*0.5d0/dt*(b_x_t(1:ndof+1,np1)-b_x_t(1:ndof+1,nm1))\n      \n    end do\n    \n    return\n  end subroutine calcullosses\n"}, {"instruction": "Create a Fortran subroutine named apply_ptilde to calculate the weighted sum of pixel values and gains based on the given parameters. The subroutine takes 4 input parameters of type real(kind=8), dimension(:), real(kind=8), dimension(:), integer(kind=8), dimension(size(gains)), and integer(kind=8), dimension(:). It has 1 output parameter of type real(kind=8), dimension(size(pix_idx)).", "input": "", "output": "subroutine apply_ptilde(map_pixels, gains, samples_per_gainp, pix_idx, output)\n  real(kind=8), dimension(:), intent(in) :: map_pixels\n  real(kind=8), dimension(:), intent(in) :: gains\n  integer(kind=8), dimension(size(gains)), intent(in) :: samples_per_gainp\n  integer(kind=8), dimension(:), intent(in) :: pix_idx\n  real(kind=8), dimension(size(pix_idx)), intent(out) :: output\n\n  integer(kind=8) :: cur_gainp_idx, samples_in_gainp\n  integer(kind=8) :: i\n\n  output = 0\n  cur_gainp_idx = 1\n  samples_in_gainp = 0\n\n  do i = 1, size(pix_idx)\n     output(i) = output(i) + map_pixels(pix_idx(i) + 1) * gains(cur_gainp_idx)\n     samples_in_gainp = samples_in_gainp + 1\n\n     if (samples_in_gainp .ge. samples_per_gainp(cur_gainp_idx)) then\n        cur_gainp_idx = cur_gainp_idx + 1\n        samples_in_gainp = 0\n     endif\n  enddo\n\nend subroutine apply_ptilde\n"}, {"instruction": "Create a Fortran subroutine named padecof to calculate the Pad\u00e9 approximant coefficients. The subroutine takes 3 input parameters of type complex*16, complex*16, and integer, and 1 output parameter of type complex*16.", "input": "", "output": "subroutine padecof(pt,gn,zn,nn)\n!****************************\n  implicit none\n  complex*16, intent(out) :: pt(nn)\n  complex*16, intent(in)  :: gn(nn),zn(nn)\n  integer, intent(in)     :: nn\n  ! local\n  complex*16  :: p(nn,nn)\n  integer :: i, j\n  p=0.0\n  do j=1,nn\n     p(1,j) = gn(j)\n  enddo\n  do j=2,nn\n     do i=2,j\n        p(i,j)=(p(i-1,i-1)-p(i-1,j))/(zn(j)-zn(i-1))/p(i-1,j)\n     enddo\n  enddo\n  do j=1,nn\n     pt(j)=p(j,j)\n  enddo\n  return\nend subroutine padecof\n"}, {"instruction": "Create a Fortran subroutine named setup_num_levels to calculate the number of levels based on the given fine cell dimensions. The subroutine takes 2 input parameters of type integer (icv_fine, jcv_fine) and returns 1 output parameter of type integer (num_level).", "input": "", "output": "subroutine setup_num_levels(icv_fine, jcv_fine, num_level)\n\n! argument variables\ninteger, intent(in):: icv_fine, jcv_fine\ninteger, intent(out):: num_level\n\n! local variables\n\ninteger:: i, ncv\n\nncv = jcv_fine\ni = 1\n\ndo\n\n    if( mod(ncv,2) /= 0) exit\n    if( ncv/2 < 16 ) exit\n\n    ncv = ncv/2\n    i = i+1\n\nend do\n\nnum_level = i\n\nend subroutine setup_num_levels\n"}, {"instruction": "Create a Fortran subroutine named basis_orthg to calculate high-order orthogonal coefficients. The subroutine must take 5 input parameters: ndegr (integer), npoly (integer), nbsis (integer), b_taylor (real*8, array with dimension ndegr), cfbs (real*8, array with dimension 14). It should have 1 output parameter: b_out (real*8, array with dimension ndegr).", "input": "", "output": "subroutine basis_orthg(npoly,ndegr, nbsis, b_taylor, cfbs, b_out)\nimplicit none\ninteger, intent(in):: ndegr, npoly, nbsis\nreal*8, dimension(ndegr), intent(in)::b_taylor\nreal*8, dimension(14), intent(in)::cfbs\nreal*8, dimension(ndegr),intent(out)::b_out\n\n!...local\nreal*8::cfthg(6,6)\nreal*8, dimension(ndegr)::bph\n\n!...high-order orthogonal coefficients\nif(nbsis.eq.1)then\n!\nbph(1:3) = b_taylor(1:3)\n\nb_out(1:3) = bph(1:3)\n\nif(npoly.eq.2)then\nb_out(4) = 0.5d0*bph(2)*bph(2) - cfbs(1)\nb_out(5) = 0.5d0*bph(3)*bph(3) - cfbs(2)\nb_out(6) =       bph(2)*bph(3) - cfbs(3)\nendif\n\nelseif(nbsis.eq.2)then\ncfthg(3,1) = cfbs(1)\ncfthg(3,2) = cfbs(2)\n\nbph(1:3) = b_taylor(1:3)\n\nb_out(1) = 1.d0\nb_out(2) = bph(2)\nb_out(3) = cfthg(3, 1)*bph(2) + bph(3) + cfthg(3, 2)\n\nif(npoly.eq.2)then\ncfthg(4,1) = cfbs(3)\ncfthg(4,2) = cfbs(4)\ncfthg(4,3) = cfbs(5)\n\ncfthg(5,1) = cfbs(6)\ncfthg(5,2) = cfbs(7)\ncfthg(5,3) = cfbs(8)\ncfthg(5,4) = cfbs(9)\n\ncfthg(6,1) = cfbs(10)\ncfthg(6,2) = cfbs(11)\ncfthg(6,3) = cfbs(12)\ncfthg(6,4) = cfbs(13)\ncfthg(6,5) = cfbs(14)\n!\nbph(4) = bph(2)*bph(2)\nbph(5) = bph(3)*bph(3)\nbph(6) = bph(2)*bph(3)\n!\nb_out(4) =             bph(4) + cfthg(4, 1)*bph(2) + cfthg(4, 2)*bph(3) + cfthg(4, 3)\nb_out(5) = cfthg(5, 1)*bph(4) +             bph(6) + cfthg(5, 2)*bph(2) +&\ncfthg(5, 3)*bph(3) + cfthg(5, 4)\nb_out(6) = cfthg(6, 1)*bph(4) + cfthg(6, 2)*bph(6) +             bph(5) +&\ncfthg(6, 3)*bph(2) + cfthg(6, 4)*bph(3) + cfthg(6, 5)\n\nendif\n\nendif\nend subroutine basis_orthg\n"}, {"instruction": "Create a Fortran subroutine named p2r to convert polar coordinates to rectangular coordinates. The subroutine takes 2 input parameters of type real, representing velocity and angle in radians, and produces 2 output parameters of type real, representing x and y velocities.", "input": "", "output": "    subroutine p2r(v, theta, v_x, v_y)\n        !! convert polar to rectangular\n        implicit none\n        real, intent(in)    :: v, theta ! velocity, angle [rad]\n        real, intent(out)   :: v_x, v_y ! x, y velocity\n        v_x = v * cos(theta)\n        v_y = v * sin(theta)\n    end subroutine p2r\n"}, {"instruction": "Create a Fortran subroutine named r2p to convert rectangular coordinates to polar coordinates. The subroutine takes 2 input parameters of real type, v_x and v_y, and returns 2 output parameters of real type, v and theta, representing velocity and angle in radians, respectively.", "input": "", "output": "    subroutine r2p(v_x, v_y, v, theta)\n        !! convert rectangular to polar\n        implicit none\n        real, intent(in)    :: v_x, v_y ! x, y velocity\n        real, intent(out)   :: v, theta ! velocity, angle [rad]\n        v = sqrt(v_x ** 2 + v_y ** 2)\n        theta = atan2(v_y, v_x)\n    end subroutine r2p\n"}, {"instruction": "Create a Fortran subroutine named sqrt_array to compute the square root of each element in an input array. The subroutine should have 2 input parameters: an integer representing the length of the array and a real array of kind=8. It should also have 1 output parameter, a real array of kind=8.", "input": "", "output": "      subroutine sqrt_array(vect, vect_len, res)\n      \n        implicit none\n        \n        integer, intent(in)     :: vect_len\n        real(kind=8), intent(in)        :: vect(vect_len)\n        real(kind=8), intent(out)       :: res(vect_len)\n        \n        integer ::  i\n\n        do i=1,vect_len\n            res(i) = sqrt(vect(i))\n        enddo \n\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named set_flam_vert. This subroutine takes 4 input parameters of type real, integer, real, and real, respectively, and 3 output parameters of type integer, integer, and real. The subroutine calculates and sets values for k1, k2, and vmd based on the input parameters ztopmax, nkp, zzcon, and w_vmd.", "input": "", "output": "  subroutine set_flam_vert(ztopmax,k1,k2,nkp,zzcon,w_vmd,vmd)\n    real , intent(in) :: ztopmax(2)\n    integer , intent(out) :: k1\n    integer , intent(out) :: k2\n    integer , intent(in) :: nkp\n    real , intent(in) :: zzcon(nkp)\n    integer imm,k\n    integer, dimension(2) :: k_lim\n    real , intent(in) :: w_vmd(nkp,2)\n    real , intent(out) :: vmd(nkp,2)\n    real w_thresold,xxx\n    integer k_initial,k_final,ko,kk4,kl\n    do imm=1,2\n       do k=1,nkp-1\n          if(zzcon(k) > ztopmax(imm) ) exit\n       enddo\n       k_lim(imm) = k\n    enddo\n    k1=max(3,k_lim(1))\n    k2=max(3,k_lim(2))\n    if(k2 < k1) then\n       k2=k1\n    endif\n    w_thresold = 1.\n    do imm=1,2\n       vmd(1:nkp,imm)= 0.\n       xxx=0.\n       k_initial= 0\n       k_final = 0\n       do ko=nkp-10,2,-1\n        if(w_vmd(ko,imm) < w_thresold) cycle\n        if(k_final==0) k_final=ko\n        if(w_vmd(ko,imm)-1. > w_vmd(ko-1,imm)) then\n          k_initial=ko\n          exit\n        endif\n       enddo\n       if(k_final > 0 .and. k_initial > 0) then\n           k_initial=int((k_final+k_initial)*0.5)\n           kk4 = k_final-k_initial+2\n           do ko=1,kk4-1\n               kl=ko+k_initial-1\n               vmd(kl,imm) = 6.* float(ko)/float(kk4)**2 * (1. - float(ko)/float(kk4))\n           enddo\n    if(sum(vmd(1:nkp,imm)) .ne. 1.) then\n         xxx= ( 1.- sum(vmd(1:nkp,imm)) )/float(k_final-k_initial+1)\n         do ko=k_initial,k_final\n           vmd(ko,imm) = vmd(ko,imm)+ xxx\n         enddo\n           endif\n        endif\n    enddo\n  end subroutine set_flam_vert\n"}, {"instruction": "Write a Fortran subroutine named \"sub7\" with one input parameter and one output parameter. The input parameter should be an allocatable integer array, specified with the \"intent(in)\" attribute. The output parameter should also be an allocatable integer array, specified with the \"intent(out)\" attribute. The subroutine should copy the contents of the input array \"y\" to the output array \"x\".", "input": "", "output": "  subroutine sub7 (x, y)\n    integer, allocatable, intent(in) :: y(:)\n    integer, allocatable, intent(out) :: x(:)\n    x = y\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named linear_polynom_fit to perform a linear polynomial fit. The subroutine takes 3 input parameters of type integer and double precision, and 2 output parameters of type double precision. The input parameters are n, x(n), and y(n), while the output parameters are p1 and p2. The subroutine calculates the coefficients p1 and p2 of the linear polynomial that best fits the given data points.", "input": "", "output": "subroutine linear_polynom_fit(n,x,y,p1,p2)\n\nimplicit none\ninteger, intent(in)             :: n\ndouble precision, intent(in)    :: x(n), y(n)\ndouble precision, intent(out)   :: p1, p2\n!----------------------------------------------------\ndouble precision                :: sumx, sumy, sumx2, sumxy\n\nsumx = 0.0d0\nsumy = 0.0d0\nsumx2 = 0.0d0\nsumxy = 0.0d0\n\nsumx = sum(x)\nsumy = sum(y)\nsumx2 = sum(x**2)\nsumxy = sum(x*y)\n\np1 = (n*sumxy - sumx*sumy)/(n*sumx2 - sumx**2)\np2 = (sumy - p1*sumx)/n\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named rotation_matrix to calculate the 3x3 rotation matrix from the input quaternion. The number of input parameters is 1 of type double precision array with dimension (4). The number of output parameters is 1 of type double precision array with dimension (3,3).", "input": "", "output": "  subroutine rotation_matrix(q, u)\n  \n    double precision,dimension(4),intent(in)::q\n    double precision,dimension(3,3),intent(out)::u\n    double precision::q0,q1,q2,q3,b0,b1,b2,b3,q00,q01,q02,q03,q11,q12,q13,q22,q23,q33\n    \n    q0=q(1)\n    q1=q(2)\n    q2=q(3)\n    q3=q(4)\n    \n    b0=2.0d0*q0\n    b1=2.0d0*q1\n    b2=2.0d0*q2\n    b3=2.0d0*q3\n    \n    q00=b0*q0-1.0d0\n    q01=b0*q1\n    q02=b0*q2\n    q03=b0*q3\n    \n    q11=b1*q1\n    q12=b1*q2\n    q13=b1*q3  \n    \n    q22=b2*q2\n    q23=b2*q3\n    \n    q33=b3*q3 \n    \n    u(1,1)=q00+q11\n    u(1,2)=q12-q03\n    u(1,3)=q13+q02\n    \n    u(2,1)=q12+q03\n    u(2,2)=q00+q22\n    u(2,3)=q23-q01\n    \n    u(3,1)=q13-q02\n    u(3,2)=q23+q01\n    u(3,3)=q00+q33\n    \n  end subroutine rotation_matrix\n"}, {"instruction": "Create a Fortran subroutine named initial to initialize arrays representing the height and velocity of a fluid at different positions along a domain. The subroutine takes 4 input parameters of type integer, real(8), and real(8) and 2 output parameters of type real(8).", "input": "", "output": "subroutine initial(pi, nx, x, h, uh, x_length)\nimplicit none\n\n    integer, intent(in):: nx\n\treal(8), intent(in):: x(nx), pi, x_length\n\treal(8), intent(out):: h(nx), uh(nx)\n\treal(8)::a, b, c\n\n    ! sine wave initial condition\n\t!h(1:nx) = 2.0d0 + sin(2*pi* x(1:nx))\n\n\t! dam break initial condition\n\t!h = 1.0d0\n\t!h(1:nx/2) = 3.0d0\n\n    ! gaussian function\n    a=3.0d0\n    b=x_length/2.0d0\n    c=0.2d0\n    h(1:nx) = a*exp(-(x(1:nx)-b)**2 /(2*c**2))\n\n\tuh(1:nx) = 0.0d0\n\nreturn\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named detect_start to determine the start and finish indices based on the given seedling and harvesting days in an agricultural context. The subroutine takes 3 input parameters of type integer (seedling_day, harvesting_day, day) and 2 output parameters of type integer (start, finish).", "input": "", "output": " subroutine detect_start(start,finish,seedling_day,harvesting_day,day)\r\n\tinteger,intent(out)::start,finish\r\n\tinteger,intent(in)::seedling_day(:),harvesting_day(:),day(:,:)\r\n\tinteger i,j,n,yy,mm,dd,diff\r\n\t\r\n\tdo i=1,size(day,1)\r\n\t\tyy=day(i,1)\r\n\t\tmm=day(i,2)\r\n\t\tdd=day(i,3)\r\n\t\t\r\n\t\tdiff=abs( seedling_day(1)-yy )&\r\n\t\t\t+abs( seedling_day(2)-mm )&\r\n\t\t\t+abs( seedling_day(3)-dd )\r\n\t\t\r\n\t\tif(diff==0 )then\r\n\t\t\tstart=i\r\n\t\t\texit\r\n\t\tendif\r\n\t\t\r\n\tenddo\r\n\t\r\n\tdo i=1,size(day,1)\r\n\t\tyy=day(i,1)\r\n\t\tmm=day(i,2)\r\n\t\tdd=day(i,3)\r\n\t\t\r\n\t\tdiff=abs( harvesting_day(1)-yy )&\r\n\t\t\t+abs( harvesting_day(2)-mm )&\r\n\t\t\t+abs( harvesting_day(3)-dd )\r\n\t\t\r\n\t\tif(diff==0 )then\r\n\t\t\tfinish=i\r\n\t\t\texit\r\n\t\tendif\r\n\t\t\r\n\tenddo\r\n\t\r\n\t\r\n end subroutine detect_start\r\n"}, {"instruction": "Create a Fortran subroutine named count_br_per_node to calculate the number of branch connections per node. The subroutine takes 2 input parameters of type integer and an array, and returns 1 output parameter of type integer.", "input": "", "output": "  subroutine count_br_per_node(node_number,br_per_node,d_connect)\r\n\tinteger,intent(in)::node_number,d_connect(:,:)\r\n\tinteger,intent(out)::br_per_node\r\n\tinteger i\r\n\t\r\n\tbr_per_node=0\r\n\tdo i=1,size(d_connect,1)\r\n\t\tif(node_number==d_connect(i,1) )then\r\n\t\t\tbr_per_node=br_per_node+1\r\n\t\telse\r\n\t\t\tcycle\r\n\t\tendif\r\n\tenddo\r\n\tif(br_per_node>=3)stop\"debug\"\r\n\t\r\n end subroutine count_br_per_node\r\n"}, {"instruction": "Create a Fortran subroutine named detect_light_area to calculate the light area and total area based on leaf coordinates and node information. The subroutine takes 3 input parameters of type real(8), integer, and integer. It returns 2 output parameters of type real(8).", "input": "", "output": " subroutine detect_light_area(leaf_coord,light_area,total_area,node_id,leaf_id)\r\n\treal(8),intent(in)::leaf_coord(:,:,:,:)\r\n\treal(8),intent(out)::light_area,total_area\r\n\treal(8),allocatable::mid_x(:),shape_function(:),evaluate_point(:,:),eva_x(:),rvec(:)&\r\n\t\t,x1(:),x2(:),y1(:),y2(:)\r\n\treal(8) gzi_1,gzi_2,eva_r,mid_r,both_r,l1,l2,l3\r\n\tinteger,intent(in)::node_id,leaf_id\r\n\tinteger i,j,k,l,m,shade_or_not,count_shade\r\n\t\r\n\tallocate(mid_x(3),shape_function(4),evaluate_point(4,2),eva_x(3),rvec(2),x1(2),x2(2))\r\n\tallocate(y1(3),y2(3))\r\n\t\r\n\t!2d linear interpolation,4 points\r\n\tevaluate_point(1,1)=-0.50d0\r\n\tevaluate_point(1,2)=-0.50d0\r\n\tevaluate_point(2,1)=-0.50d0\r\n\tevaluate_point(2,2)=0.50d0\r\n\tevaluate_point(3,1)=0.50d0\r\n\tevaluate_point(3,2)=0.50d0\r\n\tevaluate_point(4,1)=0.50d0\r\n\tevaluate_point(4,2)=-0.50d0\r\n\t\r\n\ty1(1:3)=leaf_coord(node_id,leaf_id,1,1:3)-leaf_coord(node_id,leaf_id,3,1:3)\r\n\ty2(1:3)=leaf_coord(node_id,leaf_id,2,1:3)-leaf_coord(node_id,leaf_id,4,1:3)\r\n\tl1=dsqrt( dot_product(y1,y1) )\r\n\tl2=dsqrt( dot_product(y2,y2) )\r\n\ttotal_area=0.50d0*l1*l2/100.0d0/100.0d0\r\n\t\r\n\tcount_shade=0\r\n\tdo k=1,4 !evaluate points\r\n\t\tgzi_1=evaluate_point(k,1)\r\n\t\tgzi_2=evaluate_point(k,2)\r\n\t\tshape_function(1)=0.250d0*(1.0d0-gzi_1)*(1.0d0-gzi_1)\r\n\t\tshape_function(2)=0.250d0*(1.0d0-gzi_1)*(1.0d0+gzi_1)\r\n\t\tshape_function(3)=0.250d0*(1.0d0+gzi_1)*(1.0d0+gzi_1)\r\n\t\tshape_function(4)=0.250d0*(1.0d0+gzi_1)*(1.0d0-gzi_1)\r\n\t\t\r\n\t\teva_x(:)=0.0d0\r\n\t\tdo l=1,4 \r\n\t\t\teva_x(:)=eva_x(:)+leaf_coord(node_id,leaf_id,l,:)&\r\n\t\t\t\t*shape_function(l)\r\n\t\tenddo\r\n\t\trvec(:)=leaf_coord(node_id,leaf_id,k,1:2)\r\n\t\teva_r=dsqrt( dot_product(rvec-eva_x(1:2) ,rvec-eva_x(1:2)  ) )\r\n\t\t\r\n\t\tshade_or_not=0\r\n\t\t\r\n\t\tdo i=1,size(leaf_coord,1)\r\n\t\t\tdo j=1,size(leaf_coord,2)\r\n\t\t\t\tmid_x(:)=0.0d0\r\n\t\t\t\tdo l=1,4\r\n\t\t\t\t\tmid_x(:)=mid_x(:)+0.250d0*leaf_coord(i,j,l,:)\r\n\t\t\t\tenddo\r\n\t\t\t\t\r\n\t\t\t\t!if z coordinate of the midpoint of the leaf > evaluate point\r\n\t\t\t\t! => possible node\r\n\t\t\t\tif(mid_x(3) < eva_x(3) )then\r\n\t\t\t\t\tcycle\r\n\t\t\t\tendif\r\n\t\t\t\t\r\n\t\t\t\tx1(1:2)=leaf_coord(i,j,1,1:2)-leaf_coord(i,j,3,1:2)\r\n\t\t\t\tx2(1:2)=leaf_coord(i,j,2,1:2)-leaf_coord(i,j,4,1:2)\r\n\t\t\t\t\r\n\t\t\t\tmid_r=dsqrt( dot_product(x1,x1) )+dsqrt( dot_product(x2,x2) )\r\n\t\t\t\tmid_r=0.50d0*mid_r\r\n\t\t\t\t\r\n\t\t\t\tboth_r=dsqrt( dot_product(mid_x(1:2)-eva_x(1:2),mid_x(1:2)-eva_x(1:2)))\r\n\t\t\t\t\r\n\t\t\t\tif(both_r > eva_r+mid_r)then\r\n\t\t\t\t\tcycle\r\n\t\t\t\telse\r\n\t\t\t\t\tshade_or_not=1\r\n\t\t\t\t\texit\r\n\t\t\t\tendif\t\t\r\n\t\t\tenddo\r\n\t\t\t\r\n\t\t\tif(shade_or_not==1)then\r\n\t\t\t\texit\r\n\t\t\tendif\r\n\t\tenddo\r\n\t\t\r\n\t\tif(shade_or_not==1)then\r\n\t\t\tcycle\r\n\t\telse\r\n\t\t\tcount_shade=count_shade+1\r\n\t\tendif\t\r\n\tenddo\r\n\t\r\n\tlight_area=total_area/4.0d0*dble(count_shade)\r\n\t\r\n end subroutine detect_light_area\r\n"}, {"instruction": "Create a Fortran subroutine named get_descra that takes two input parameters of type character*11 and character, and two output parameters of type character and integer. The subroutine assigns a message based on the value of the descriptor and sets ierr to 0 if successful or -1 if there is an error.", "input": "", "output": "      subroutine get_descra(descra,descriptor,message,ierr)\n      implicit none\n      character*11, intent(in) :: descra\n      character, intent(in) :: descriptor\n      character, intent(out) :: message\n      integer, intent(out) :: ierr\n      ierr = -1\n      message = ''\n      select case(descriptor)\n      case('a') !lower,upper or both parts\n         message = descra(3:3)\n      case('b') !base\n         message = descra(5:5)\n      case('d') !unity diagonal stored or not\n         message = descra(1:1)\n      case('f') !internal block storage is row- or column-wise\n         message = descra(7:7)\n      case('r') !repeated indices\n         message = descra(2:2)\n      case('s') !structure of matrix\n         message = descra(4:4)\n      case('t') !matrix type\n         message = descra(6:6)\n      case default\n         return\n      end select      \n      ierr = 0\n      end subroutine get_descra\n"}, {"instruction": "Create a Fortran subroutine named estimate_coef. The subroutine takes 2 input parameters of type real, represented by arrays x and y, and 1 output parameter of type real represented by array b. This subroutine calculates the regression coefficients based on the input data and stores the result in the b array.", "input": "", "output": "subroutine estimate_coef(x, y, b)\n\n  real, intent(in) :: x(:), y(:)\n  real, intent(out) :: b(2)\n  real :: m_x, m_y\n  integer :: n\n\n  ! number of observations/points\n  n = size(x)\n\n  ! mean of x and y vector\n  m_x = sum(x)/n \n  m_y = sum(y)/n\n\n  ! calculating cross-deviation and deviation about x\n  ss_xy = sum(y*x) - n*m_y*m_x\n  ss_xx = sum(x*x) - n*m_x*m_x \n  \n  ! calculating regression coefficients \n  b(2) = ss_xy / ss_xx \n  b(1) = m_y - b(2)*m_x \n\n  return\n  \nend subroutine estimate_coef\n"}, {"instruction": "Write a Fortran subroutine named multiindices to generate multi-indices for a given set of degrees and stratify them.The number of input arguments is 6 and the test_data type is ['integer', 'integer', 'integer', 'integer', 'integer', 'integer']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "input": "", "output": "  subroutine multiindices(n, m, degs, n_deg, n_idx, n_idx_by_deg, idx_ptr, idx, stratifier)\n    implicit none\n\n    integer, intent(in) :: n, n_deg, n_idx, m(n), degs(n_deg), n_idx_by_deg(n_deg)\n    integer, intent(out) :: idx_ptr(:), idx(:), stratifier(:)\n    integer, allocatable :: var(:)\n    integer i, i1, i2, j, k\n\n    idx_ptr(1) = 0\n    i = 2\n    do j = 1, n_deg\n       do k = 1, n_idx_by_deg(j)\n          idx_ptr(i) = idx_ptr(i-1) + degs(j)\n          i = i + 1\n       end do\n    end do\n    ! print*, 'idx_ptr', idx_ptr\n\n    i = 1\n    do j = 1, n_deg\n       allocate(var(degs(j)))\n       ! var = (/ (i2, i=12, degs(j)) /)\n       do i2 = 1, degs(j)\n          var(i2) = i2\n       end do\n       idx(idx_ptr(i)+1:idx_ptr(i+1)) = var\n       i = i + 1\n       ! do k = 1, n_idx_by_deg(degs(j))-1\n       do k = 1, n_idx_by_deg(j)-1\n          i1 = degs(j)\n          var(i1) = var(i1) + 1\n          do while (var(i1) + degs(j) > i1 + n)\n             i1 = i1 - 1\n             var(i1) = var(i1) + 1\n          end do\n          ! var(i1+1:) = (/ (var(i2-1)+1, i2=i1+1, degs(j)) /)\n          do i2 = i1+1, degs(j)\n             var(i2) = var(i2-1)+1\n          end do\n          idx(idx_ptr(i)+1:idx_ptr(i+1)) = var\n          i = i + 1\n       end do\n       deallocate(var)\n    end do\n    ! print*, 'idx', idx\n\n    stratifier = 1\n    do i = 2, n_idx\n       do j = idx_ptr(i-1)+1, idx_ptr(i)\n          stratifier(i) = stratifier(i) * m(idx(j))\n       end do\n       stratifier(i) = stratifier(i) + stratifier(i-1)\n    end do\n    ! print*, 'stratifier', stratifier\n\n  end subroutine multiindices\n"}, {"instruction": "Create a Fortran subroutine named make_state_name to generate a state name based on the input integer value. The subroutine takes 1 input parameter of type integer and produces 1 output parameter of type character with varying length.", "input": "", "output": "      subroutine make_state_name(state_name, nstate)\n      implicit none\n      integer,          intent(in)  :: nstate\n      character(len=*), intent(out) :: state_name\n\n      state_name='/state_0000/'\n      write (state_name(8:11),'(i4.4)') nstate\n\n      return\n      end subroutine make_state_name\n"}, {"instruction": "Write a Fortran subroutine named copy_data_3d_real8 to copy 3D real(8) array data from the source array to the destination array. The subroutine takes one input parameter of type real(8) array and one output parameter of type real(8) array.", "input": "", "output": "  subroutine copy_data_3d_real8(src,dst)\n    implicit none\n    real(8), intent(in)  :: src(:,:,:)\n    real(8), intent(out) :: dst(:,:,:)\n    integer :: ix,iy,iz\n    integer :: nx,ny,nz\n\n    nz = size(src,3)\n    ny = size(src,2)\n    nx = size(src,1)\n\n!$omp parallel do collapse(2) default(none) &\n!$omp          private(ix,iy,iz) &\n!$omp          firstprivate(nx,ny,nz) &\n!$omp          shared(src,dst)\n    do iz=1,nz\n    do iy=1,ny\n    do ix=1,nx\n      dst(ix,iy,iz) = src(ix,iy,iz)\n    end do\n    end do\n    end do\n!$omp end parallel do\n  end subroutine\n"}, {"instruction": "Write a Fortran subroutine named return_gauge to extract values from arrays q and aux at a specific location xgauge. The subroutine takes 9 input parameters of types integer, integer, integer, integer, double precision, double precision, double precision, double precision, and double precision. The output is a single parameter of type double precision.", "input": "", "output": "      subroutine return_gauge(meqn,maux,mvars,mx,dx,xlower,xgauge,sol,q,aux)\n      !\n      ! return values sol(vars) at xlower\n      !=================================================================\n\n      !i/o\n      integer, intent(in) :: meqn,maux,mvars,mx\n      double precision, intent(in) :: dx,xlower,xgauge\n      double precision, intent(in) :: q(mx,meqn), aux(mx,maux)\n      double precision, intent(out) :: sol(mvars)\n\n      !locals\n      integer :: i,m\n\n      i = floor((xgauge - xlower)/dx) + 1\n\n      do m = 1, meqn\n         sol(m) = q(i,m)\n      enddo\n      do m = 1, maux\n         sol(m+meqn) = aux(i,m)\n      enddo\n\n      return\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lj_functions to calculate the magnitude of the Lennard-Jones force and potential between a pair of atoms at a given distance from each other. The subroutine takes 3 input parameters of type double precision: sigma, eps, and r, and provides 2 output parameters of type double precision: pot and force.", "input": "", "output": "         subroutine lj_functions(sigma, eps, r, pot, force)\n            ! calculates the magnitude of the lj force and potential between\n            ! a pair of atoms at a given distance from each other.\n            !\n            ! args:\n            !    sigma: the lj distance parameter.\n            !    eps: the lj energy parameter.\n            !    r: the separation of the atoms.\n            !    pot: the lj interaction potential.\n            !    force: the magnitude of the lj force.\n\n            double precision, intent(in) :: sigma\n            double precision, intent(in) :: eps\n            double precision, intent(in) :: r\n            double precision, intent(out) :: pot\n            double precision, intent(out) :: force\n\n            double precision sigma_by_r6\n\n            sigma_by_r6 = sigma/r\n            sigma_by_r6 = sigma_by_r6*sigma_by_r6*sigma_by_r6\n            sigma_by_r6 = sigma_by_r6*sigma_by_r6\n\n            pot = 4*eps*(sigma_by_r6*(sigma_by_r6 - 1))\n            force = 24*eps*(sigma_by_r6*(2*sigma_by_r6 - 1)/r)\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named lj_longrange to calculate the long-range correction to the total potential and virial pressure. The subroutine should have 5 input parameters of type double precision and 2 output parameters of type double precision. The input parameters are rc, sigma, eps, natoms, and volume, while the output parameters are pot_lr and vir_lr.", "input": "", "output": "         subroutine lj_longrange(rc, sigma, eps, natoms, volume, pot_lr, vir_lr)\n            ! calculates the long range correction to the total potential and\n            ! virial pressure.\n            !\n            ! uses the tail correction for a sharp cut-off, with no smoothing\n            ! function, as derived in martyna and hughes, journal of chemical\n            ! physics, 110, 3275, (1999).\n            !\n            ! args:\n            !    rc: the cut-off radius.\n            !    sigma: the lj distance parameter.\n            !    eps: the lj energy parameter.\n            !    natoms: the number of atoms in the system.\n            !    volume: the volume of the system box.\n            !    pot_lr: the tail correction to the lj interaction potential.\n            !    vir_lr: the tail correction to the lj virial pressure.\n\n            double precision, intent(in) :: rc\n            double precision, intent(in) :: sigma\n            double precision, intent(in) :: eps\n            integer, intent(in) :: natoms\n            double precision, intent(in) :: volume\n            double precision, intent(out) :: pot_lr\n            double precision, intent(out) :: vir_lr\n\n            double precision sbyr, s3byr3, s6byr3, s6byr6, prefactor\n\n            sbyr = sigma/rc\n            s3byr3 = sbyr*sbyr*sbyr\n            s6byr6 = s3byr3*s3byr3\n            prefactor = four_tau_by_3*natoms*natoms*eps/volume\n            prefactor = prefactor*s3byr3*sigma*sigma*sigma\n\n            pot_lr = prefactor*(s6byr6/3-1)\n            vir_lr = prefactor*(s6byr6-1) + pot_lr\n\n         end subroutine\n"}, {"instruction": "Create a Fortran subroutine named read_input_file_time_series to read a time series data from a file or use a default array if no file name is provided. The subroutine takes 3 input parameters of types character(60), double precision, and integer, and 1 output parameter of type double precision.", "input": "", "output": "  subroutine read_input_file_time_series(name, array, default, ntimesteps)\n    implicit none\n\n    character(60), intent(in) :: name\n    double precision, intent(out) :: array(ntimesteps)\n    double precision, intent(in) :: default\n    integer, intent(in) :: ntimesteps\n\n    if (name.ne.'') then\n      open(unit=10, form='unformatted', file=name)\n      read(10) array\n      close(10)\n    else\n      array = default\n    end if\n\n    return\n  end subroutine read_input_file_time_series\n"}, {"instruction": "Create a Fortran subroutine named set_acc_fact to calculate the accuracy factor based on certain conditions. The subroutine takes 3 input parameters of types logical, real*8, and real*8, and returns 1 output parameter of type real*8.", "input": "", "output": "      subroutine set_acc_fact(acccond, accfactcutoff, loe, accfact)\n\n      implicit none\n\n      logical, intent(in) :: acccond\n\n      real*8, intent(in) ::  accfactcutoff, loe\n\n      real*8, intent(out) :: accfact\n\n      accfact = 0.0d0\n\n      if (acccond) accfact = loe\n\n      if (accfact .gt. accfactcutoff) accfact = accfactcutoff\n\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named gaussmat to perform Gaussian elimination on a matrix. This subroutine takes 3 input parameters of type integer, real array, and real array, and 1 output parameter of type real array with allocatable memory.", "input": "", "output": "    subroutine gaussmat(jaa, bb, xx, nn)\n\n        integer, intent(in) :: nn\n        real, intent(in) :: jaa(:,:), bb(:)\n        real, allocatable, intent(out) :: xx(:)\n\n        real, allocatable, dimension(:,:) :: aa\n        integer :: ii, ij, ik\n        real :: xsum, xmult\n        !character(len=40) :: a3fmt\n\n        ! formation de la matrice a = [jaa | i]\n        allocate(aa(nn,nn+1), xx(nn))\n\n        xx=0.\n        aa=0.\n        do ii=1, nn\n            do ij=1, nn+1\n               aa(ii,ij) = jaa(ii,ij)\n            end do\n            aa(ii, nn+1) = bb(ii)\n        end do\n\n        ! elimination de gauss\n        do ik = 1, nn-1\n           do ii = ik+1, nn\n              xmult = aa(ii, ik) / aa(ik, ik)\n              aa(ii, ik) = 0.\n              do ij = ik+1, nn+1\n                 aa(ii, ij) = aa(ii, ij) - xmult * aa(ik, ij)\n              end do\n           end do\n        end do\n\n        xx(nn) = aa(nn, nn+1) / aa(nn, nn)\n        do ii = nn-1, 1, -1\n           xsum = 0.\n           do ij= ii+1, nn\n              xsum = xsum + aa(ii, ij) * xx(ij)\n           end do\n           xx(ii) = (aa(ii, nn+1) - xsum) / aa(ii, ii)\n        end do\n\n        deallocate(aa)\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_v to convert 3D Cartesian coordinates to 3D spherical coordinates. The subroutine takes 1 input parameter of type real(8) and 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_v(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n)\n      complex(8), intent(out) :: v(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      v(1)=(sqrt(2.0d0)/2.0d0)*cmplx(u(1),u(2),kind=8)\n      v(3)=-(sqrt(2.0d0)/2.0d0)*cmplx(u(1),-u(2),kind=8)\n      v(2)=-u(3)\n      \n   end subroutine cart2sph_v\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_v_modified that converts Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_v_modified(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      v(1)=(1.0d0/sqrt(2.0d0))*cmplx(-u(1,3),u(2,3),kind=8)\n      v(3)=(1.0d0/sqrt(2.0d0))*cmplx(-u(1,3),-u(2,3),kind=8)\n      v(2)=(1.0d0/sqrt(8.0d0))*cmplx(0.0d0,2.0d0*u(1,2)-2.0d0*u(2,1),kind=8)\n   end subroutine cart2sph_t_v_modified\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_v to convert Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_v(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m)\n      complex(8) a(m)\n      \n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      \n      ! call cart2sph_v(u,a)\n      ! v(3)=1.0d0/sqrt(2.0d0)*(a(3)*a(2)-a(2)*a(3))\n      ! v(1)=1.0d0/sqrt(2.0d0)*(a(2)*a(1)-a(1)*a(2))\n      ! v(2)=1.0d0/sqrt(2.0d0)*(a(3)*a(1)-a(1)*a(3))\n      \n      v(1)=(1.0d0/sqrt(4.0d0))*cmplx(u(3,1)-u(1,3),-u(3,2)+u(2,3),kind=8)\n      v(3)=(1.0d0/sqrt(4.0d0))*cmplx(u(3,1)-u(1,3),-u(2,3)+u(3,2),kind=8)\n      v(2)=(1.0d0/sqrt(8.0d0))*cmplx(0.0d0,2.0d0*u(1,2)-2.0d0*u(2,1),kind=8)\n   end subroutine cart2sph_t_v\n"}, {"instruction": "Create a Fortran subroutine named cart2sph_t_mix to convert Cartesian coordinates to spherical coordinates. The subroutine takes 1 input parameter of type real(8) and produces 1 output parameter of type complex(8).", "input": "", "output": "   subroutine cart2sph_t_mix(u,v)\n      integer(4) n,m,len_u,len_v\n      parameter(n=3,m=3)\n      real(8), intent(in) :: u(n,n)\n      complex(8), intent(out) :: v(m,m)\n      complex(8) iu\n      \n      iu=(0d0,1d0)\n      len_u = size(u,dim=1)\n      len_v = size(v,dim=1)\n      if(len_u/=n.or.len_v/=m)stop 'array dimensions do not match cartesian or spherical dimensions'\n      goto 51\n51       continue\n      !-1,-1\n      v(1,1)=0.5d0*(u(1,1)-iu*u(2,1)+iu*u(1,2)+u(2,2))\n      v(1,2)=1d0/sqrt(2d0)*(u(1,3)-iu*u(2,3))\n      v(1,3)=0.5d0*(-u(1,1)+u(2,2)+iu*u(2,1)+iu*u(1,2))\n      \n      v(2,1)=1d0/sqrt(2d0)*(u(3,1)+iu*u(3,2))\n      v(2,2)=u(3,3)\n      v(2,3)=1d0/sqrt(2d0)*(-u(3,1)+iu*u(3,2))\n      \n      \n      v(3,3)=0.5d0*(u(1,1)+iu*u(2,1)-iu*u(1,2)+u(2,2))\n      v(3,2)=-1d0/sqrt(2d0)*(u(1,3)+iu*u(2,3))\n      v(3,1)=0.5d0*(u(2,2)-iu*u(2,1)-u(1,1)-iu*u(1,2))\n      \n      !v(1,2)=1d0/sqrt(2d0)*(u(1,3)-iu*u(2,3))\n      \n      \n      return\n      !-1,-1\n      v(1,1)=0.5d0*cmplx(u(1,1)-u(2,2),-(u(1,2)+u(2,1)),kind=8)\n      !-1,0\n      v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      v(1,3)=0.5d0*cmplx(-u(1,1)-u(2,2),-(u(1,2)-u(2,1)),kind=8)\n      !0,-1\n      v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !1,-1\n      v(3,1)=0.5d0*cmplx(-u(1,1)-u(2,2),u(1,2)-u(2,1),kind=8)\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      !1,1\n      v(3,3)=0.5d0*cmplx(u(1,1)-u(2,2),u(1,2)+u(2,1),kind=8)\n      \n      return\n      !-1,-1\n      v(1,1)=0.5d0*((u(1,1)-iu*u(2,1))+iu*(u(1,2)-iu*u(2,2)))\n      !-1,0\n      v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      v(1,3)=-0.5d0*((u(1,1)-iu*u(2,1))-iu*(u(1,2)-iu*u(2,2)))\n      !0,-1\n      v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      !1,-1\n      v(3,1)=-0.5d0*((u(1,1)+iu*u(2,1))+iu*(u(1,2)+iu*u(2,2)))\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      !1,1\n      v(3,3)=0.5d0*((u(1,1)+iu*u(2,1))-iu*(u(1,2)+iu*u(2,2)))\n      \n      return\n      \n      !-1,-1\n      !v(1,1)=0.5d0*((u(1,1)-iu*u(2,1))+iu*(u(1,2)-iu*u(2,2)))\n      !-1,0\n      !v(1,2)=sqrt(0.5d0)*cmplx(u(1,3),-u(2,3),kind=8)\n      !-1,1\n      !v(1,3)=-0.5d0*((u(1,1)-iu*u(2,1))-iu*(u(1,2)-iu*u(2,2)))\n      !0,-1\n      !v(2,1)=sqrt(0.5d0)*cmplx(u(3,1),u(3,2),kind=8)\n      !0,0\n      v(2,2)=u(3,3)\n      !0,1\n      v(2,3)=-sqrt(0.5d0)*cmplx(u(3,1),-u(3,2),kind=8)\n      v(2,1)=-conjg(v(2,3))\n      !1,-1\n      v(3,1)=-0.5d0*((u(1,1)+iu*u(1,2))+iu*(u(2,1)+iu*u(2,2)))\n      v(1,3)=conjg(v(3,1))\n      !1,0\n      v(3,2)=-sqrt(0.5d0)*cmplx(u(1,3),u(2,3),kind=8)\n      v(1,2)=-conjg(v(3,2))\n      !1,1\n      v(3,3)=0.5d0*((u(1,1)-iu*u(1,2))+iu*(u(2,1)-iu*u(2,2)))\n      v(1,1)=conjg(v(3,3))\n   \n   end subroutine cart2sph_t_mix\n"}, {"instruction": "Write a Fortran subroutine named readflags_binary that takes 2 input parameters of type integer(4) and character(n), and 1 output parameter of type logical. The subroutine sets the elements of the logical array arr based on the characters in the input string str. If the character is '1', the corresponding array element is set to .true.; otherwise, it is set to .false. The subroutine stops processing if a space character is encountered in the input string.\n\nNote: The length of the character array str is specified by the integer parameter n.", "input": "", "output": "   subroutine readflags_binary(str,arr,n)\n      integer(4),intent(in) :: n\n      character(n),intent(in) :: str\n      logical,intent(out) :: arr(n)\n      integer(4) i\n\n      arr=.false.\n      do i = 1,n\n         if(str(i:i)=='1')then\n            arr(i)=.true.\n         else if(str(i:i)==' ')then\n            return\n         end if\n      end do\n   \n   end subroutine readflags_binary\n"}, {"instruction": "Write a Fortran subroutine named \"s\" that initializes a 2D array \"x\" with zeros and assigns the value of the first element of input array \"c\" to the first element of \"x\". The subroutine takes 3 input arguments of type integer, integer, and real(kind=8) and outputs a 2D array of real(kind=8) with dimensions specified by the input integers.", "input": "", "output": "subroutine s(n, m, c, x)\n\timplicit none\n  \tinteger, intent(in) :: n, m\n  \treal(kind=8), intent(out), dimension(n,m) :: x\n  \treal(kind=8), intent(in) :: c(:)\n\n\tx = 0.0d0\n\tx(1, 1) = c(1)\n\nend subroutine s\n"}, {"instruction": "Create a Fortran subroutine named create_rotmat to generate a 3x3 rotation matrix based on three random angles. The input parameter is a real(8) value for the step size, and the output parameter is a 3x3 real(8) matrix for the full rotation matrix.", "input": "", "output": "subroutine create_rotmat(fullrotmat, stepsize)\nreal(8), intent(in)  :: stepsize\nreal(8), intent(out) :: fullrotmat(3,3)\nreal(8)              :: rotmat_x(3,3), rotmat_y(3,3), rotmat_z(3,3)\nreal(8)              :: rand1, rand2, rand3\nreal(8), parameter   :: pi = 3.14159265358979323846 ! define pi\n\ncall random_number(rand1)                               ! random number for angle 1.    use the same angles for all coordinates -> rotation\ncall random_number(rand2)                               ! same for angle 2\ncall random_number(rand3)                               ! same for angle 3\n!\n! rotation based on the rotation around the cartesian axes. three random numbers for three random angles\n!\nrand1 = (2*rand1 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\nrand2 = (2*rand2 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\nrand3 = (2*rand3 - 1)*stepsize*pi  ! angle in radians. should be sufficiently small\n\nrotmat_x(1,1:3) = (/ real(1.0,8), real(0.0,8), real(0.0,8) /)\nrotmat_x(2,1:3) = (/ real(0.0,8), cos(rand1), -sin(rand1) /)\nrotmat_x(3,1:3) = (/ real(0.0,8), sin(rand1),  cos(rand1) /)\n\nrotmat_y(1,1:3) = (/ cos(rand2),  real(0.0,8), sin(rand2) /)\nrotmat_y(2,1:3) = (/ real(0.0,8), real(1.0,8), real(0.0,8) /)\nrotmat_y(3,1:3) = (/ -sin(rand2), real(0.0,8), cos(rand2) /)\n\nrotmat_z(1,1:3) = (/ cos(rand3), -sin(rand3),  real(0.0,8) /)\nrotmat_z(2,1:3) = (/ sin(rand3),  cos(rand3),  real(0.0,8) /)\nrotmat_z(3,1:3) = (/ real(0.0,8), real(0.0,8), real(1.0,8) /)\n\nfullrotmat = matmul(rotmat_z,matmul(rotmat_y,rotmat_x))\nreturn\nend subroutine create_rotmat\n"}, {"instruction": "Write a Fortran subroutine called create_rotmat_bond to generate a rotation matrix based on the input axis_vector and stepsize. The input parameters are two real(8) values for axis_vector and stepsize, and the output parameter is a real(8) array fullrotmat(3,3).", "input": "", "output": "subroutine create_rotmat_bond(fullrotmat,axis_vector,stepsize)\nreal(8), intent(in)  :: stepsize\nreal(8), intent(in)  :: axis_vector(3)\nreal(8), intent(out) :: fullrotmat(3,3)\nreal(8)              :: len_vector\nreal(8)              :: norm_vector(3)\nreal(8)              :: rand1\nreal(8), parameter   :: pi = 3.14159265358979323846 ! define pi\n\ncall random_number(rand1)          ! random number for angle\nrand1 = (2*rand1 - 1)*stepsize*10.0*pi  ! angle in radians. should be sufficiently small\n! normalize vector\nlen_vector = sqrt(sum(axis_vector(:)**2))\nnorm_vector(:) = axis_vector(:)/len_vector\n! generate rotation matrix\nfullrotmat(1,1) = cos(rand1) + norm_vector(1)**2*(1 - cos(rand1))\nfullrotmat(1,2) = norm_vector(1)*norm_vector(2)*(1 - cos(rand1)) - norm_vector(3)*sin(rand1)\nfullrotmat(1,3) = norm_vector(1)*norm_vector(3)*(1 - cos(rand1)) + norm_vector(2)*sin(rand1)\nfullrotmat(2,1) = norm_vector(2)*norm_vector(1)*(1 - cos(rand1)) + norm_vector(3)*sin(rand1)\nfullrotmat(2,2) = cos(rand1) + norm_vector(2)**2*(1 - cos(rand1))\nfullrotmat(2,3) = norm_vector(2)*norm_vector(3)*(1 - cos(rand1)) - norm_vector(1)*sin(rand1)\nfullrotmat(3,1) = norm_vector(3)*norm_vector(1)*(1 - cos(rand1)) - norm_vector(2)*sin(rand1)\nfullrotmat(3,2) = norm_vector(3)*norm_vector(2)*(1 - cos(rand1)) + norm_vector(1)*sin(rand1)\nfullrotmat(3,3) = cos(rand1) + norm_vector(3)**2*(1 - cos(rand1))\n\nreturn\nend subroutine create_rotmat_bond\n"}, {"instruction": "Create a Fortran subroutine named rotate_pos that takes 3 input parameters of type real(8) (fullrotmat, xyz1, center_xyz) and 1 output parameter of type real(8) (xyz2). The subroutine executes a rotation transformation on the coordinates xyz1 around the center_xyz using the rotation matrix fullrotmat. Use the do loop to perform the transformation on each coordinate and store the result in xyz2.", "input": "", "output": "subroutine rotate_pos(fullrotmat, xyz1, center_xyz, xyz2)\nreal(8), intent(in)  :: fullrotmat(3,3), xyz1(3), center_xyz(3)\nreal(8), intent(out) :: xyz2(3)\ninteger              :: a\n! rotation at origin. move to origin, rotate and move back to center\ndo a = 1,3\n  xyz2(a) = fullrotmat(a,1)*(xyz1(1) - center_xyz(1)) + &\n            fullrotmat(a,2)*(xyz1(2) - center_xyz(2)) + &\n            fullrotmat(a,3)*(xyz1(3) - center_xyz(3)) + &\n            center_xyz(a)\nend do\nreturn\nend subroutine rotate_pos\n"}, {"instruction": "Create a Fortran subroutine named temp_convert that takes a single input parameter of type real and returns three output parameters of type real. The input parameter represents the temperature in Kelvin, while the output parameters represent the temperature converted to Celsius, Fahrenheit, and Rankine, respectively.", "input": "", "output": "subroutine temp_convert(kelvin, celsius, fahrenheit, rankine)\n  real, intent(in)  :: kelvin\n  real, intent(out) :: celsius, fahrenheit, rankine\n\n  celsius = kelvin - 273.15\n  fahrenheit = kelvin * 1.8 - 459.67\n  rankine = kelvin * 1.8\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named mymodsub, which takes an integer input argument and returns an integer output argument. The subroutine doubles the value of the input argument and assigns it to the output argument.", "input": "", "output": "  subroutine mymodsub(arg1,arg2)\n    integer,intent(in) :: arg1\n    integer,intent(out) :: arg2\n\n    arg2=2*arg1\n  end subroutine mymodsub\n"}, {"instruction": "Create a Fortran subroutine named cal_sd to calculate the standard deviation of a given array of double precision numbers. The subroutine takes 2 input parameters of type integer and double precision in the form of an array, and provides 1 output parameter of type double precision.", "input": "", "output": "subroutine cal_sd(n,x,sd)\n  implicit none\n  integer,intent(in) :: n\n  double precision, intent(in) :: x(n)\n  double precision, intent(out) :: sd\n  integer :: i\n  double precision :: mean, mean2\n  mean = 0.d0\n  mean2 = 0.d0\n  do i = 1, n\n    mean = mean + x(i)\n    mean2 = mean2 + x(i)**2\n  end do\n  mean = mean/n\n  mean2 = mean2/n\n  sd = sqrt(mean2 - mean**2)\nend subroutine cal_sd\n"}, {"instruction": "Create a Fortran subroutine named set_initial to initialize a complex array with values computed based on the input parameters. The number of input parameters is 4, the test_data type is ['integer', 'integer', 'real(8)', 'real(8)'], and the number of output parameters is 1 of type complex(8). Use a combination of nested loops and mathematical operations to set the values of the complex array based on the input parameters.", "input": "", "output": " subroutine set_initial(nx, ny, dx, dy, u)\n    ! matlab: u = ones(m1,m2) + 2*repmat(cos(x'),[1,m2])+2*repmat(cos(y'),[1,m1])';\n    integer, intent(in) :: nx, ny\n    real(8), intent(in) :: dx, dy\n    complex(8), intent(out) :: u(nx, ny)\n\n    real(8) :: x, y\n    integer :: i, j\n\n    do i = 1, nx\n      do j = 1, ny\n        x = dx * (i - 1)\n        y = dy * (j - 1)\n        u(i, j) = 1d0 + 2d0 * cos(x) + 2d0 * cos(y)\n      end do\n    end do\n  end subroutine set_initial\n"}, {"instruction": "Create a Fortran subroutine named \"reshape_to_vector\" to convert a 2D complex array \"u\" into two real arrays \"p\" and \"q\" by separating the real and imaginary parts. The subroutine should take 3 input parameters of type integer, integer, and complex(8), and 2 output parameters of type real(8) and real(8).", "input": "", "output": "  subroutine reshape_to_vector(nx, ny, u, p, q)\n   integer, intent(in) :: nx, ny\n    complex(8), intent(in) :: u(nx, ny)\n    real(8), intent(out) :: p(nx, ny), q(nx, ny)\n\n    p = real(u)\n    q = aimag(u)\n  end subroutine reshape_to_vector\n"}, {"instruction": "Write a Fortran subroutine named set_jacobian that calculates the Jacobian matrix for a given set of input parameters. The subroutine takes 5 input parameters of type integer, real(8), real(8), real(8) and real(8), and returns 1 output parameter of type real(8).", "input": "", "output": "  subroutine set_jacobian(n, eps, p0, q0, a, jf)\n    ! matlab: jf = [2*eps*diag(p0.*q0), a + eps * diag(p0.^2+3*q0.^2);\n    !               -a - eps * diag(p0.^2+3*q0.^2), 2*eps*diag(p0.*q0)];\n    integer, intent(in) :: n\n    real(8), intent(in) :: eps, p0(n), q0(n), a(n, n)\n    real(8), intent(out) :: jf(n * 2, n * 2)\n\n    integer :: i\n    real(8) :: jfd1(n), jfd2(n)\n\n\n    jf(:, :) = 0d0\n    jf(1 : n, n + 1 : n * 2) = a(1 : n, 1 : n)\n    jf(n + 1 : n * 2, 1 : n) = -a(1 : n, 1 : n)\n\n    jfd1 = 2d0 * eps * (p0 * q0)\n    jfd2 = eps * ((p0**2) + 3d0 * (q0**2))\n    do i = 1, n\n      jf(i, i) = jfd1(i)\n      jf(n + i, n + i) = jfd1(i)\n      jf(i, n + i) = jf(i, n + i) + jfd2(i)\n      jf(n + i, i) = jf(n + i, i) - jfd2(i)\n    end do\n  end subroutine set_jacobian\n"}, {"instruction": "Create a Fortran subroutine named set_eye to initialize a square matrix with the identity matrix of a specified size. The number of input parameters is 1 of type integer, and the number of output parameters is 1 of type real(8).", "input": "", "output": "  subroutine set_eye(n, x)\n    ! set identity matrix with size n.\n    integer, intent(in) :: n\n    real(8), intent(out) :: x(n, n)\n\n    integer :: i\n\n    x(:, :) = 0d0\n    do i = 1, n\n      x(i, i) = 1d0\n    end do\n  end subroutine set_eye\n"}, {"instruction": "Write a Fortran subroutine named reshape_to_matrix that takes in four input parameters of type integer, integer, real(8), and real(8), and one output parameter of type complex(8). The subroutine reshapes the input real arrays p and q into a complex array u with dimensions nx and ny, where nx and ny are the input integers.", "input": "", "output": "  subroutine reshape_to_matrix(nx, ny, p, q, u)\n    ! matlab: u = reshape(p + sqrt(-1)*q,[nx,ny]);\n    integer, intent(in) :: nx, ny\n    real(8), intent(in) :: p(nx, ny), q(nx, ny)\n    complex(8), intent(out) :: u(nx, ny)\n\n    u = cmplx(p, q, 8)\n  end subroutine reshape_to_matrix\n"}, {"instruction": "Create a Fortran subroutine named krontmv to perform a Kronecker product transpose operation. The subroutine takes 3 input parameters of type integer, real(8) and real(8), and 1 output parameter of type real(8). The input parameters represent the size of the matrix, the 3x3 matrix T, and the vector X, while the output parameter represents the resulting vector Y. The subroutine uses the imperative do concurrent loop to calculate the elements of the resulting vector Y based on the Kronecker product transpose operation.", "input": "", "output": "  subroutine krontmv(n, t, x, y)\n    integer, intent(in) :: n\n    real(8), intent(in) :: t(3, 3), x(3*n)\n    real(8), intent(out) :: y(3*n)\n    integer :: i\n    do concurrent (i=1:n)\n      y(i    ) = t(1,1) * x(i) + t(1,2) * x(i+n) + t(1,3) * x(i+2*n)\n      y(i+n  ) = t(2,1) * x(i) + t(2,2) * x(i+n) + t(2,3) * x(i+2*n)\n      y(i+2*n) = t(3,1) * x(i) + t(3,2) * x(i+n) + t(3,3) * x(i+2*n)\n    end do\n  end subroutine\n"}, {"instruction": "Create a Fortran subroutine named number_of_lines to count the number of lines in a text file. The subroutine takes 1 input parameter of type character (len=30) and outputs 1 parameter of type integer.", "input": "", "output": "subroutine number_of_lines(input_file, n)\n    implicit none\n\t! dummy vars\n\tcharacter (len=30), intent(in) :: input_file\n\tinteger, intent(out) :: n\n\t\n\t! local vars\n    integer :: temp=0, iostatus=0, i=0\n\n    open(unit=10, file=input_file, status=\"old\", action=\"read\")\n    do\n        read(10,*,iostat=iostatus) temp\n        if (iostatus < 0) then\n            exit\n        else\n            i=i+1\n        endif\n    enddo\n\t    \n    close(10)\n    n = i\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named linspace that generates a linearly spaced array of real numbers between the given minimum and maximum values. The subroutine should take 3 input parameters of type real, real, and integer and 1 output parameter of type real array with dimension n.", "input": "", "output": "subroutine linspace(xmin, xmax, n, x)\n\timplicit none\n\t! dummy vars\n\treal, intent(in) :: xmin\n\treal, intent(in) :: xmax\n\tinteger, intent(in) :: n\n\treal, dimension(n), intent(out) :: x\n\t\n\t! local vars\n\tinteger :: i\n\treal :: dx\n\t\n\tdx = (xmax - xmin) / (n-1)\n\n\tdo i=1,n\n\t\tx(i) = xmin + dx * (i-1)\n\tenddo\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named spherical_to_cart to convert spherical coordinates to Cartesian coordinates. The subroutine takes 3 input parameters of type real (rad, phi, theta) and 3 output parameters of type real (x, y, z).", "input": "", "output": "subroutine spherical_to_cart( rad, phi, theta, x, y, z )\n    real, intent(in)  :: rad, phi, theta\n    real, intent(out) :: x, y, z\n\n    x = rad * cos(phi) * cos(theta)\n    y = rad * sin(phi) * cos(theta)\n    z = rad * sin(theta)\n\nend subroutine spherical_to_cart\n"}, {"instruction": "Write a Fortran subroutine named cart_to_spherical to convert Cartesian coordinates to spherical coordinates. The subroutine takes 3 input arguments of type real (x, y, z) and returns 3 output arguments of type real (rad, phi, theta).", "input": "", "output": "subroutine cart_to_spherical( x, y, z, rad, phi, theta )\n    real, intent(in)  :: x, y, z\n    real, intent(out) :: rad, phi, theta\n\n    rad    = sqrt( x ** 2 + y ** 2 + z ** 2 )\n    theta  = asin(z/rad)\n    if ( x /= 0.0 .or. y /= 0.0 ) then\n        phi = atan2(y,x)\n    else\n        phi = 0.0\n    endif\n\nend subroutine cart_to_spherical\n"}, {"instruction": "Write a Fortran subroutine named polar_to_cart to convert polar coordinates to Cartesian coordinates. The subroutine takes 2 input parameters of type real, representing the radius (rad) and angle (phi), and 2 output parameters of type real, representing the x and y coordinates.", "input": "", "output": "subroutine polar_to_cart( rad, phi, x, y )\n    real, intent(in)  :: rad, phi\n    real, intent(out) :: x, y\n\n\n    x = rad * cos(phi)\n    y = rad * sin(phi)\n\nend subroutine polar_to_cart\n"}, {"instruction": "Create a Fortran subroutine named model to calculate the model output based on the provided input parameters. The number of input parameters is 5, with test_data types ['double precision', 'double precision', 'double precision', 'double precision', 'double precision'], and there is 1 output parameter of test_data type 'double precision'.", "input": "", "output": "subroutine model(t, y, freqs, fitting_coeffs, params, y_model_array)\n    !computes model according to fitting coefficients, frequencies and params\n    double precision, intent(in) :: t(:), y(:), freqs(:), fitting_coeffs(:), params(:) \n    double precision, intent(out) :: y_model_array(size(t))\n    double precision :: y_model, t_p, t_ref\n    double precision :: pi=dacos(-1.0d0)\n    integer :: k, n_dim, delay\n    \n    t_ref = t(1)\n    n_dim = size(freqs)\n    n_data = size(t)\n    do j = 1, n_data\n        y_model = 0.0\n        t_p = t(j)\n        do k = 1,size(fitting_coeffs)\n            if (k.eq.1) then\n                y_model = y_model + fitting_coeffs(k)\n            else if ((k.gt.1).and.(k.le.(n_dim+1))) then\n                y_model = y_model + &\n                        fitting_coeffs(k)*cos(2.0*pi*(t_p-t_ref)*freqs(k-1))\n            else if ((k.gt.(n_dim+1)).and.(k.lt.(2*n_dim+2))) then\n                y_model = y_model + &\n                    fitting_coeffs(k)*sin(2.0*pi*(t_p-t_ref)*freqs((k-(n_dim+1))))\n            else if (k.ge.(2*n_dim+2)) then\n                    delay = k - (2*n_dim+1)\n                    if (j.gt.delay) then   \n                        y_model = y_model + fitting_coeffs(k)*exp((t(j-delay)-t(j))/params(1))*y(j-delay)\n                    endif\n            endif\n        enddo\n        y_model_array(j) = y_model\n    enddo\n\nend subroutine model\n"}, {"instruction": "Create a Fortran subroutine named computeintegrationnodesx2 that calculates the integration nodes for a given input value.The subroutine should take 1 input argument of type integer and provide 1 output argument of type array of integers.", "input": "", "output": "  subroutine computeintegrationnodesx2( inx1, nodesx2 )\n\n    integer, intent(in)  :: inx1\n    integer, intent(out) :: nodesx2(:)\n\n    if     ( nnodes .eq. 1 )then\n\n      nodesx2 = [ 1 ]\n\n    else if( nnodes .eq. 2 )then\n\n      if( inx1 .eq. 1 )then\n\n        nodesx2 = [ 1, 3 ]\n\n      else\n\n        nodesx2 = [ 2, 4 ]\n\n      end if\n\n    else if( nnodes .eq. 3 )then\n\n      if( inx1 .eq. 1 )then\n\n        nodesx2 = [ 1, 4, 7  ]\n\n      else if( inx1 .eq. 2 )then\n\n        nodesx2 = [ 2, 5, 9 ]\n\n      else\n\n        nodesx2 = [ 3, 6, 9 ]\n\n      end if\n\n    else\n\n      print*, 'not implemented for nnodes > 3. stopping...'\n      stop\n\n    end if\n\n  end subroutine computeintegrationnodesx2\n"}, {"instruction": "Create a Fortran subroutine named calc_factorials to calculate the factorial of numbers up to a specified maximum value. The subroutine takes 1 input parameter of type integer and returns 1 output parameter of type integer. The input parameter represents the maximum value for which to calculate the factorials, and the output parameter stores the computed factorials. Use the imperative tone to create the subroutine.", "input": "", "output": "  subroutine calc_factorials(nmax, fact)\n    implicit none\n    integer, intent(in) :: nmax\n    integer, intent(out) :: fact(nmax)\n    integer :: i\n\n    fact(0) = 1\n    do i=1,nmax\n       fact(i) = fact(i-1)*i\n    end do\n\n  end subroutine calc_factorials\n"}, {"instruction": "Write a Fortran subroutine named randominit that initializes the weight with a random real number. The number of input arguments is 1 and the test_data type is [real]. The number of output arguments is 1 and the test_data type is [real]. Use the imperative tone in the instructions.", "input": "", "output": "        subroutine randominit(weight, args)\n            real, intent(out) :: weight\n            real, intent(in) :: args(0:)\n            call random_number(weight)\n        end subroutine randominit\n"}, {"instruction": "Create a Fortran subroutine called test_g2cart to perform a specific calculation. The subroutine takes 4 input parameters: 3 integers (n1, n2, n3) and a 3x3 real array (gprimd). It also has 1 output parameter: a real array of size n1*n2*n3 (g2cart). The purpose of the subroutine is to compute certain values based on the input parameters and store the results in the g2cart array.", "input": "", "output": "subroutine test_g2cart(n1,n2,n3,gprimd,g2cart)\n   implicit none\n   integer, intent(in) :: n1,n2,n3\n   real(kind=8), dimension(3,3), intent(in) :: gprimd\n   real(kind=8), dimension(n1*n2*n3), intent(out) :: g2cart\n   !local variables\n   integer :: count, i1,i2,i3,id1,id2,id3,ifft,ig1,ig2,ig3,ii1\n   real(kind=8) :: b11,b12,b13,b21,b22,b23,b31,b32,b33\n   \n\n   id1=int(n1/2)+2\n   id2=int(n2/2)+2\n   id3=int(n3/2)+2\n   ifft=0\n   count=0\n   do i3=1,n3\n      ifft=(i3-1)*n1*n2\n      ig3=i3-int(i3/id3)*n3-1\n      do i2=1,n2\n         ig2=i2-int(i2/id2)*n2-1\n         ii1=1\n         do i1=ii1,n1\n            ig1=i1-int(i1/id1)*n1-1\n            ifft=ifft+1\n\n            b11=gprimd(1,1)*real(ig1,kind=8)\n            b21=gprimd(2,1)*real(ig1,kind=8)\n            b31=gprimd(3,1)*real(ig1,kind=8)\n            b12=gprimd(1,2)*real(ig2,kind=8)\n            b22=gprimd(2,2)*real(ig2,kind=8)\n            b32=gprimd(3,2)*real(ig2,kind=8)\n            b13=gprimd(1,3)*real(ig3,kind=8)\n            b23=gprimd(2,3)*real(ig3,kind=8)\n            b33=gprimd(3,3)*real(ig3,kind=8)\n\n            g2cart(ifft)=( &\n                 &     (b11+b12+b13)**2&\n                 &     +(b21+b22+b23)**2&\n                 &     +(b31+b32+b33)**2&\n                 &     )\n!!$     do ifunc=1,nfunc\n!!$!     compute the laplacien in fourrier space\n!!$!     that is * (i x 2pi x g)**2\n!!$      laplacerdfuncg(1,ifft,ifunc) = -rdfuncg(1,ifft,ifunc)*g2cart(ifft)*two_pi*two_pi\n!!$      laplacerdfuncg(2,ifft,ifunc) = -rdfuncg(2,ifft,ifunc)*g2cart(ifft)*two_pi*two_pi\n!!$     end do\n         end do\n      end do\n   end do\nend subroutine test_g2cart\n"}, {"instruction": "Create a Fortran subroutine named check_gap to find the largest gap in a given direction and transverse directions. The subroutine takes 3 input parameters of type integer, integer array, and integer array, and returns 2 output parameters of type integer.", "input": "", "output": "  subroutine check_gap(dir, n_blocks, n_atoms_block, gap_start, gap_end)\n    ! check gap in direction dir, transverse directions are b and c\n    ! find the largest gap\n\n    implicit none\n\n    ! passed parameters\n    integer,               intent(in)  :: dir\n    integer, dimension(:), intent(in)  :: n_blocks, n_atoms_block\n    integer,               intent(out) :: gap_start, gap_end\n\n    ! local variables\n    integer, dimension(2) :: tran_dir ! transverse directions\n    integer, dimension(3) :: cc_multiplier\n    integer :: ii, ia, ib, ic, icc\n    integer :: tmp_start, tmp_gap, gap\n    logical :: start_count, found_atom\n\n    ! work out transverse directions\n    do ii = 1, 2\n       tran_dir(ii) = mod(dir+ii-1, 3) + 1\n    end do\n    ! define cc index multipliers\n    cc_multiplier(1) = n_blocks(2) * n_blocks(3)\n    cc_multiplier(2) = n_blocks(3)\n    cc_multiplier(3) = 1\n    ! initialise values\n    gap = 0\n    start_count = .false.\n    gap_start = 0\n    gap_end = 0\n    ! find the maximum gap\n    loop_a: do ia = 1, n_blocks(dir)\n       found_atom = .false.\n       loop_b: do ib = 1, n_blocks(tran_dir(1))\n          loop_c: do ic = 1, n_blocks(tran_dir(2))\n             icc = (ia-1) * cc_multiplier(dir) + &\n                   (ib-1) * cc_multiplier(tran_dir(1)) + &\n                   (ic-1) * cc_multiplier(tran_dir(2)) + 1\n             if (n_atoms_block(icc) > 0)  then\n                found_atom = .true.\n                ! we have reached the end of the gap\n                if (start_count) then\n                   start_count = .false.\n                   tmp_gap = ia - tmp_start\n                   if (tmp_gap > gap) then\n                      gap = tmp_gap\n                      gap_start = tmp_start\n                      gap_end = ia - 1\n                   end if\n                end if\n                exit loop_b\n             end if\n          end do loop_c\n       end do loop_b\n       ! only start counting after found an empty slab\n       if ((.not. start_count) .and. (.not. found_atom)) then\n          tmp_start = ia\n          start_count = .true.\n       end if\n       ! if no atoms were found, but have reached the end of cell\n       if ((start_count) .and. (.not. found_atom) .and. &\n           (ia == n_blocks(dir))) then\n          ! remember the slab is still empty, so must be counted in\n          ! the gap, so need to add 1\n          tmp_gap = ia - tmp_start + 1\n          if (tmp_gap > gap) then\n             gap = tmp_gap\n             gap_start = tmp_start\n             gap_end = ia\n          end if\n       end if\n    end do loop_a\n\n    return\n  end subroutine check_gap\n"}, {"instruction": "Create a Fortran subroutine named rdsamo to read and store Hartree-Fock molecular orbital coefficients in atomic orbital (AO) basis from a dumpfile. The subroutine takes 4 input parameters of types integer, integer, integer, and double precision, and has 1 output parameter of type double precision.", "input": "", "output": "subroutine rdsamo( idmp, vmoao, norb, nbsf, rnel)\n  !************************************************************************\n  !\n  ! read hf-mos in ao basis from the dumpfile and store in vmoao\n  !\n  !************************************************************************\n  implicit none\n\n  integer, intent(in)           :: idmp, norb, nbsf\n  double precision, intent(in)  :: rnel\n  double precision, intent(out) :: vmoao(nbsf,nbsf)\n\n  integer          :: i, j, ncoeffs\n\n  write(6,'(/'' reading mo coefficients in ao basis'')')\n  read(idmp,*)\n  ncoeffs = 0\n\n  do i = 1, nbsf\n     do j = 1, nbsf\n\n        read(idmp,'(es24.16)',err=10) vmoao(j,i)\n        ncoeffs = ncoeffs + 1\n\n     enddo\n  enddo\n\n  write(6,'(''  ====> complete'')')\n  write(6,'(''  number of coefficients restored from file : '', &\n         & i12)') ncoeffs\n\n  return\n\n10 continue\n  write(6,'(/,'' error::: something went wrong reading mo coeffs'')')\n  write(6,'(''mo coeffs expected : '',i8,/,''mo coeff attempted to read : '',i8)') nbsf * nbsf, ncoeffs\n  stop\n  \nend subroutine rdsamo\n"}, {"instruction": "Write a Fortran subroutine named station2 that calculates the starting point for a journey based on the input arrays gas and distance. The input arguments are 2 arrays of type integer, and the output argument is a single integer.", "input": "", "output": "   subroutine station2(gas, distance, start)\n      integer, intent(in) :: gas(:), distance(size(gas))\n      integer, intent(out) :: start\n      integer i, tank\n\n      start = size(gas) + 1\n      i = 1\n      tank = 0\n      do while (i < start)\n         if (tank + gas(i) >= distance(i)) then\n            tank = tank + gas(i) - distance(i)\n            i = i + 1\n         else\n            start = start - 1\n            tank = tank + gas(start) - distance(start)\n         end if\n      end do\n      if (tank >= 0) then\n         start = modulo(start, size(gas))\n      else\n         start = 0\n      end if\n   end subroutine station2\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_integer2_1d to allocate memory for a one-dimensional array of 2-byte integers. The subroutine should have 1 input parameter of type integer(kind=8), dimension(1) and 2 output parameters of type integer(kind=2), dimension(:), allocatable and integer.", "input": "", "output": "    subroutine adios2_allocate_integer2_1d(array, shp, ierr)\n        integer(kind=2), dimension(:), allocatable, intent(out):: array\n        integer(kind=8), dimension(1), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_dp_3d to allocate a 3-dimensional array of double-precision real numbers. The subroutine takes 1 input parameter of type integer(kind=8), dimension(3), and returns 2 output parameters: a real(kind=8), 3-dimensional, allocatable array and an integer representing the error status. If the array is already allocated, deallocate it and then allocate a new array with dimensions specified by the input parameter.", "input": "", "output": "    subroutine adios2_allocate_dp_3d(array, shp, ierr)\n        real(kind=8), dimension(:, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(3), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named adios2_allocate_complex_5d to allocate a 5-dimensional array of complex numbers. The subroutine takes 1 input parameter of type integer(kind=8), dimension(5), and provides 2 output parameters of type complex, dimension(:, :, :, :, :), allocatable, and integer.", "input": "", "output": "    subroutine adios2_allocate_complex_5d(array, shp, ierr)\n        complex, dimension(:, :, :, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(5), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3), shp(4), shp(5)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named \"adios2_allocate_integer2_6d\" to dynamically allocate a 6-dimensional array of 2-byte integers based on the shape provided as input. The subroutine takes 1 input parameter of type integer(kind=8), dimension(6) and 2 output parameters of types integer(kind=2), dimension(:, :, :, :, :, :), allocatable and integer. Remember to deallocate the array if it is already allocated, then allocate it based on the provided shape.", "input": "", "output": "    subroutine adios2_allocate_integer2_6d(array, shp, ierr)\n        integer(kind=2), dimension(:, :, :, :, :, :), allocatable, intent(out):: array\n        integer(kind=8), dimension(6), intent(in):: shp\n        integer, intent(out):: ierr\n\n        if (allocated(array)) deallocate (array)\n        allocate (array(shp(1), shp(2), shp(3), shp(4), shp(5), shp(6)), stat=ierr)\n\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named cerf to calculate the complex error function erf(z) and its derivative erf'(z) for a given complex argument z. The subroutine takes 1 input parameter of type complex *16, and returns 2 output parameters, both of type complex *16.", "input": "", "output": "subroutine cerf(z,cer,cder)\n\n!     ==========================================================\n!     purpose: compute complex error function erf(z) & erf'(z)\n!     input:   z   --- complex argument of erf(z)\n!     x   --- real part of z\n!     y   --- imaginary part of z\n!     output:  cer --- erf(z)\n!     cder --- erf'(z)\n!     ==========================================================\n\nimplicit double precision (a-h,o-z)\ncomplex *16, intent(in)                  :: z\ncomplex *16, intent(out)                 :: cer\ncomplex *16, intent(out)                 :: cder\n\n\nw=0.0\nw1=0.0\nw2=0.0\neps=1.0d-12\npi=3.141592653589793d0\nx=real(z)\ny=dimag(z)\nx2=x*x\nif (x <= 3.5d0) then\n  er=1.0d0\n  r=1.0d0\n  do  k=1,100\n    r=r*x2/(k+0.5d0)\n    er=er+r\n    if (dabs(er-w) <= eps*dabs(er)) exit\n    w=er\n  end do\n  15    c0=2.0d0/dsqrt(pi)*x*dexp(-x2)\n  er0=c0*er\nelse\n  er=1.0d0\n  r=1.0d0\n  do  k=1,12\n    r=-r*(k-0.5d0)/x2\n    er=er+r\n  end do\n  c0=dexp(-x2)/(x*dsqrt(pi))\n  er0=1.0d0-c0*er\nend if\nif (y == 0.0d0) then\n  err=er0\n  eri=0.0d0\nelse\n  cs=dcos(2.0d0*x*y)\n  ss=dsin(2.0d0*x*y)\n  er1=dexp(-x2)*(1.0d0-cs)/(2.0d0*pi*x)\n  ei1=dexp(-x2)*ss/(2.0d0*pi*x)\n  er2=0.0d0\n  do  n=1,100\n    er2=er2+dexp(-.25d0*n*n)/(n*n+4.0d0*x2)*(2.0d0*x  &\n        -2.0d0*x*dcosh(n*y)*cs+n*dsinh(n*y)*ss)\n    if (dabs((er2-w1)/er2) < eps) exit\n    w1=er2\n  end do\n  30    c0=2.0d0*dexp(-x2)/pi\n  err=er0+er1+c0*er2\n  ei2=0.0d0\n  do  n=1,100\n    ei2=ei2+dexp(-.25d0*n*n)/(n*n+4.0d0*x2)*(2.0d0*x  &\n        *dcosh(n*y)*ss+n*dsinh(n*y)*cs)\n    if (dabs((ei2-w2)/ei2) < eps) exit\n    w2=ei2\n  end do\n  40    eri=ei1+c0*ei2\nend if\ncer=cmplx(err,eri)\ncder=2.0d0/dsqrt(pi)*cdexp(-z*z)\nreturn\nend subroutine cerf\n"}, {"instruction": "Write a Fortran subroutine named factorial to calculate the factorial of a given integer. The subroutine has 1 input parameter of type integer and 1 output parameter of type integer.", "input": "", "output": "recursive subroutine factorial ( n, result )\r\n!\r\n!  purpose:\r\n!    to calculate the factorial function\r\n!             | n(n-1)!    n >= 1 \r\n!       n ! = |\r\n!             | 1          n = 0\r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    12/07/06    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\ninteger, intent(in) :: n         ! value to calculate\r\ninteger, intent(out) :: result   ! result\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger :: temp                  ! temporary variable\r\n\r\nif ( n >= 1 ) then\r\n   call factorial ( n-1, temp )\r\n   result = n * temp\r\nelse\r\n   result = 1\r\nend if\r\n\r\nend subroutine factorial\r\n"}, {"instruction": "Write a Fortran subroutine named random_order to generate a random ordering of the integers 1 to n, where n is the input parameter of type integer and intent(in). The output is an array order of integers with length n, specified by the intent(out) attribute.", "input": "", "output": "subroutine random_order(order, n)\n\n!     generate a random ordering of the integers 1 ... n.\n\ninteger, intent(in)  :: n\ninteger, intent(out) :: order(n)\n\n!     local variables\n\ninteger :: i, j, k\nreal    :: wk\n\ndo i = 1, n\n  order(i) = i\nend do\n\n!     starting at the end, swap the current last indicator with one\n!     randomly chosen from those preceeding it.\n\ndo i = n, 2, -1\n  call random_number(wk)\n  j = 1 + i * wk\n  if (j < i) then\n    k = order(i)\n    order(i) = order(j)\n    order(j) = k\n  end if\nend do\n\nreturn\nend subroutine random_order\n"}, {"instruction": "Create a Fortran subroutine named aggiorno_ottimo to update the optimal solution with the given input values. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and 2 output parameters of type double precision. Upon execution, the subroutine updates the optimal solution and writes the updated values to a file named 'ottimocorrente.txt'.", "input": "", "output": "subroutine aggiorno_ottimo(n,xprop,fprop,xott,fott)\n\timplicit none\n\n\tinteger,\t  intent(in)\t\t:: n\n\tdouble precision, intent(in)\t\t:: xprop(n), fprop\n\tdouble precision, intent(out)\t\t:: xott(n),  fott\n\tinteger\t\t\t\t\t:: i\n\n\txott = xprop\n\tfott = fprop\n\n\treturn\n\n\topen(99,file='ottimocorrente.txt',status='replace')\n\tdo i = 1,n\n\t\twrite(99,1000) i, xott(i)\n\tenddo\n\twrite(99,1010) fott\n\tclose(99)\n\n1000 format(1x,'xott(',i3,') = ',es11.4)\n1010 format(1x,'fott      = ',es11.4)\n\n\treturn\n\nend subroutine aggiorno_ottimo\n"}, {"instruction": "Create a Fortran subroutine named coarsen3d to average the values of a 3D field over larger grid boxes. The subroutine takes 7 input parameters of type integer and real arrays, and 1 output parameter of type real array.", "input": "", "output": "subroutine coarsen3d(f,g,nlon1,nlat1,nlev1,nlon2,nlat2,nlev2)\n  !   averages the values of field f (grid size nlon1 x nlat1 x nlev1) over larger\n  !   grid boxes (grid size nlon2 x nlat2 x nlev2), to field g\n\n  !   to keep the algorithm\n  !   simple, only 0/1 weights are used -> works only well if\n  !   div(nlon1/nlon2)=div(nlat1/nlat2)=div(nlev1/nlev2)\n  !\n  integer,intent(in) :: nlon1,nlat1,nlon2,nlat2,nlev1,nlev2\n  real,dimension(nlon1,nlat1,nlev1),intent(in) :: f\n  real,dimension(nlon2,nlat2,nlev2),intent(out) :: g\n  integer :: i,i2,j,j2,k,k2,imin,imax,jmin,jmax,kmin,kmax\n  real :: fsum\n\n  do i2=1,nlon2\n     imin=nint((i2-1)*real(nlon1)/real(nlon2)+1)\n     imax=nint(i2*real(nlon1)/real(nlon2))\n     do j2=1,nlat2\n        jmin=nint((j2-1)*real(nlat1)/real(nlat2)+1)\n        jmax=nint(j2*real(nlat1)/real(nlat2))\n        do k2=1,nlev2\n           kmin=nint((k2-1)*real(nlev1)/real(nlev2)+1)\n           kmax=nint(k2*real(nlev1)/real(nlev2))\n           fsum=0.\n           do i=imin,imax\n              do j=jmin,jmax\n                 do k=kmin,kmax\n                    fsum=fsum+f(i,j,k)\n                 enddo\n              enddo\n           enddo\n           g(i2,j2,k2)=fsum/((imax-imin+1)*(jmax-jmin+1)*(kmax-kmin+1))\n        enddo\n     enddo\n  enddo\n\nend subroutine coarsen3d\n"}, {"instruction": "Create a Fortran subroutine named laplace2_cart that computes the laplacian and coefficient for a given field using a Cartesian grid. The subroutine takes 3 input parameters: a 3D array of real numbers representing the field (f), and two real numbers (dx and dy). It produces 2 output parameters: a 3D array of real numbers representing the laplacian (lapl2), and a 3D array of real numbers representing the coefficient (coeff).", "input": "", "output": "subroutine laplace2_cart(f,dx,dy,lapl2,coeff)\n  !\n  !      as laplace_cart but\n  !        - the contribution of the local value to the laplacian is left out\n  !        - coeff is the coefficient for the local value\n  !\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),intent(out) :: lapl2,coeff\n  real,intent(in) :: dx,dy\n  integer :: nlon,nlat,nlev,i,j,k,c\n  real :: inv_dx,inv_dy\n  nlon=size(f,1)\n  nlat=size(f,2)\n  nlev=size(f,3)\n  inv_dx = 1.0 / (dx * dx)\n  inv_dy = 1.0 / (dy * dy)\n  c=1\n  select case (c)\n  case(1)\n\n     ! x-direction\n     lapl2 ( 2 : nlon - 1, :, : ) = f( 1: nlon - 2, :, : ) &\n          + f ( 3: nlon, :, : )\n     lapl2 ( 1, :, : )    = f( nlon, :, : ) + f ( 2, :, : )\n     lapl2 ( nlon, :, : ) = f( nlon - 1, :, : ) + f ( 1, :, : )\n     lapl2 = lapl2 * inv_dx\n\n     ! y-direction\n     lapl2 ( :, 2 : nlat -1, : ) = lapl2 ( :, 2 : nlat -1, : ) &\n          + ( f ( :, 1 : nlat -2, : ) + f ( :, 3 : nlat, :) ) * inv_dy\n\n     coeff ( :, 2 : nlat -1, : ) = -2 * (inv_dx + inv_dy)\n     coeff ( :, 1, : ) = -2 * ( inv_dx )\n     coeff ( :, nlat, : ) = -2 * ( inv_dx )\n  case(2)\n     do j=1,nlat\n        do k=1,nlev\n           do i=1,nlon\n              ! x-direction\n              if(i==1)then\n                 lapl2(i,j,k)=(-(1./12.)*f(nlon-1,j,k)+(4./3.)*f(nlon,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k))/(dx*dx)\n              else if(i==2)then\n                 lapl2(i,j,k)=(-(1./12.)*f(nlon,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k))/(dx*dx)\n              else if(i==nlon-1)then\n                 lapl2(i,j,k)=(-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(1,j,k))/(dx*dx)\n              else if(i==nlon)then\n                 lapl2(i,j,k)=(-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(1,j,k)-(1./12.)*f(2,j,k))/(dx*dx)\n              else\n                 lapl2(i,j,k)=-(1./12.)*f(i-2,j,k)+(4./3.)*f(i-1,j,k) &\n                      +(4./3.)*f(i+1,j,k)-(1./12.)*f(i+2,j,k)\n                 lapl2(i,j,k)=lapl2(i,j,k)/(dx*dx)\n              end if\n           enddo\n        enddo\n     enddo\n\n     do i=1,nlon\n        do k=1,nlev\n           do j=2,nlat-1\n              ! y-direction\n              if(j==2)then\n                 lapl2(i,j,k)=lapl2(i,j,k)+(f(i,j-1,k)+f(i,j+1,k))/(dy*dy)\n              else if(j==nlat-1)then\n                 lapl2(i,j,k)=lapl2(i,j,k)+(f(i,j-1,k)+f(i,j+1,k))/(dy*dy)\n              else\n                 lapl2(i,j,k)=lapl2(i,j,k)+(-(1./12.)*f(i,j-2,k)+(4./3.) &\n                      *f(i,j-1,k) + (4./3.)*f(i,j+1,k)-(1./12.)*f(i,j+2,k)) &\n                      /(dy*dy)\n              end if\n           enddo\n        enddo\n     enddo\n     coeff(:,3:nlat-2,:)=-(5./2.)/(dx*dx)-(5./2.)/(dy*dy)\n     coeff(:,2,:)=-(5./2.)/(dx*dx)-2./(dy*dy)\n     coeff(:,nlat-1,:)=-(5./2.)/(dx*dx)-2./(dy*dy)\n     coeff(:,1,:)=-(5./2.)/(dx*dx)\n     coeff(:,nlat,:)=-(5./2.)/(dx*dx)\n  end select\n\nend subroutine laplace2_cart\n"}, {"instruction": "Write a Fortran subroutine named p2der2 that calculates the second derivative of a three-dimensional array f with respect to a parameter dp. The subroutine has 2 input parameters of type real,dimension(:,:,:) and real, and 2 output parameters of type real,dimension(:,:,:) and real,dimension(:,:,:), respectively.", "input": "", "output": "subroutine p2der2(f,dp,df2dp22,coeff)\n  !  as p2der, but\n  !     - the contribution of the local value is left out\n  !     - the coefficient 'coeff' of the local value is also calculated\n\n  real,dimension(:,:,:),intent(in) :: f\n  real,dimension(:,:,:),intent(out) :: df2dp22,coeff\n  real,intent(in) :: dp\n  integer :: nlev,c,k\n\n  c=1\n  nlev=size(f,3)\n\n  select case (c)\n  case(1)\n     df2dp22(:,:,2:nlev-1)=(f(:,:,3:nlev)+f(:,:,1:nlev-2)) &\n          /(dp*dp)\n     coeff(:,:,2:nlev-1)=-2./(dp*dp)\n     df2dp22(:,:,1)=0.\n     df2dp22(:,:,nlev)=0.\n     coeff(:,:,1)=0.\n     coeff(:,:,nlev)=0.\n  case(2)\n     do k=3,nlev-2\n        df2dp22(:,:,k)=(-1./12.)*f(:,:,k-2)+(4./3.)*f(:,:,k-1) &\n             +(4./3.)*f(:,:,k+1)-(1./12.)*f(:,:,k+2)\n        df2dp22(:,:,k)=df2dp22(:,:,k)/(dp*dp)\n     enddo\n     coeff(:,:,3:nlev-2)=(-5./2.)/(dp*dp)\n     df2dp22(:,:,2)=(f(:,:,3)+f(:,:,1))/(dp*dp)\n     df2dp22(:,:,nlev-1)=(f(:,:,nlev)+f(:,:,nlev-2))/(dp*dp)\n     coeff(:,:,2)=-2./(dp*dp)\n     coeff(:,:,nlev-1)=-2./(dp*dp)\n     coeff(:,:,1)=0\n     coeff(:,:,nlev)=0\n     df2dp22(:,:,1)=0.\n     df2dp22(:,:,nlev)=0.\n  end select\n\nend subroutine p2der2\n"}, {"instruction": "Create a Fortran subroutine named boxnum to categorize two energy values into bins based on predefined energy and interval arrays. The subroutine takes 5 input parameters of type real, real, real, real, and integer, representing energies e1, e2, del, ener, and nbins respectively. It also has 4 output parameters of type real, real, integer, and integer, representing r1, r2, m1, and m2 respectively. The subroutine categorizes the input energies e1 and e2 into the appropriate bins based on the energy intervals and assigns the corresponding bin numbers and edges to the output parameters.", "input": "", "output": "subroutine boxnum (e1, e2, m1, m2, r1, r2, nbins, del, ener)\n\n! energies e1 and e2, and calls them m1 and m2.\n! r1 is the upper edge of the lower box, r2 is the lower edge of the\n! upper box.\n\n  implicit none\n\n  real,intent(in) :: e1,e2\n  real,intent(in) :: del(nbins), ener(nbins)\n  integer,intent(in) :: nbins\n  real,intent(out) :: r1,r2\n  integer,intent(out) :: m1,m2\n  integer :: i,j\n\n  do i=1,nbins\n    if (e1 < ener(i)+del(i)/2.) then\n      m1 = i\n      r1 = ener(i) + del(i)/2.\n      do j=1,nbins\n        if (e2 < ener(j)+del(j)/2.) then\n          m2 = j\n          r2 = ener(j) - del(j)/2.\n          return \n        endif\n      enddo\n      m2 = nbins\n      r2 = e2 - del(nbins)\n      return\n    endif\n  enddo\n  m1 = nbins+1\n  return\n\nend subroutine boxnum\n"}, {"instruction": "Write a Fortran subroutine named comp_coef to compute coefficients a1, b1, c1, d1, a2, b2, c2, and d2 using the input parameter phi of type real. The subroutine should have 1 input parameter of type real and 8 output parameters of type real.", "input": "", "output": "  subroutine comp_coef(phi, a1,b1,c1,d1,a2,b2,c2,d2)\n\n    ! compute coefficients a,b,c,d\n\n    real, intent(in) :: phi\n    real, intent(out):: a1,b1,c1,d1, a2,b2,c2,d2\n    \n    real :: phi2, s,c,sc,s2, delta,q, d, e1,e2\n    \n\n    phi2 = phi**2\n    \n    s = sin(phi)\n    c = cos(phi)\n    sc = s*c\n    s2 = s**2\n        \n    delta = phi - pi\n    !##q = miu2  ! ambiguous (not sure if should be the inverse)\n    q = miu1/miu2  ! mu_a/mu_b, a is where the contact measured from\n    \n    d = (sc-phi)*(delta**2-s2) + q*(delta-sc)*(phi2-s2)\n\n    e1 = s2-delta*phi+q*(phi2-s2)\n    c1 = s2*e1/d\n    d1 = sc*(e1-pi*tan(phi))/d\n    a1 = -1.-pi*c1-d1\n    b1 = -pi*d1\n\n    e2 = s2-delta**2+q*(delta*phi-s2)\n    c2 = s2*e2/d\n    d2 = sc*(e2-q*pi*tan(phi))/d\n    a2 = -1.-d2\n    b2 = 0.\n   \n\n    return\n  end subroutine comp_coef\n"}, {"instruction": "Create a Fortran subroutine named get_vgrid, which reads and processes input data from the file vgrid.in or its parent directory. The subroutine takes 3 input parameters of type character(len=*), integer, and integer, and produces 10 output parameters of type integer, integer, integer, real, real, real, real, real, real, and real.", "input": "", "output": "      subroutine get_vgrid(vgrid,np,nvrt1,ivcor,kz,h_s,h_c,theta_b,theta_f,ztot,sigma,sigma_lcl,kbp)\n!     (single-precision) routine to read in vgrid.in (either in the current dir or ../) \n!     not all outputs have meaningful values, depending on ivcor.\n!      implicit real*8(a-h,o-z)\n      character(len=*), intent(in) :: vgrid\n      integer, intent(in) :: np,nvrt1\n      integer, intent(out) :: ivcor,kz,kbp(np)\n      real, intent(out) :: h_s,h_c,theta_b,theta_f,ztot(nvrt1),sigma(nvrt1),sigma_lcl(nvrt1,np)\n\n      !local\n      logical :: lexist\n      \n      inquire(file=vgrid,exist=lexist)\n      if(lexist) then\n        open(19,file=vgrid,status='old')\n      else\n        inquire(file='../'//vgrid,exist=lexist)\n        if(lexist) then\n          open(19,file='../'//vgrid,status='old')\n        else\n          write(*,*)'unable to find vgrid.in'\n          stop\n        endif\n      endif\n\n      read(19,*)ivcor\n      select case(ivcor)\n        case(2) !sz\n          read(19,*) nvrt,kz,h_s !kz>=1\n          if(nvrt<2) stop 'nvrt<2'\n          if(kz<1) then !.or.kz>nvrt-2) then\n            write(*,*)'wrong kz:',kz\n            stop\n          endif\n          if(h_s<6) then\n            write(*,*)'h_s needs to be larger:',h_s\n            stop\n          endif\n\n          ! # of z-levels excluding \"bottom\" at h_s\n          read(19,*) !for adding comment \"z levels\"\n          do k=1,kz-1\n            read(19,*)j,ztot(k)\n            if(ztot(k)>=-h_s) then\n              print*, 'illegal z level:',k\n              stop\n            endif\n            if(k>1) then; if(ztot(k)<=ztot(k-1)) then\n              print*, 'z-level inverted:',k\n              stop\n            endif; endif\n          enddo !k\n          read(19,*) !level kz       \n          ! in case kz=1, there is only 1 ztot(1)=-h_s\n          ztot(kz)=-h_s\n\n          nsig=nvrt-kz+1 !# of s levels (including \"bottom\" & f.s.)\n          read(19,*) !for adding comment \"s levels\"\n          read(19,*)h_c,theta_b,theta_f\n          if(h_c<5.or.h_c>=h_s) then !large h_c to avoid 2nd type abnormality\n            print*, 'h_c needs to be larger avoid 2nd type abnormality; &\n     &do u want to continue? enter 1 to continue, or ctrl-c to abort:'\n            read*, itmp\n          endif\n          if(theta_b<0.or.theta_b>1) then\n            write(*,*)'wrong theta_b:',theta_b\n            stop\n          endif\n          if(theta_f<=0) then\n            write(*,*)'wrong theta_f:',theta_f\n            stop\n          endif\n\n          sigma(1)=-1 !bottom\n          sigma(nsig)=0 !surface\n          read(19,*) !level kz\n          do k=kz+1,nvrt-1\n            kin=k-kz+1\n            read(19,*) j,sigma(kin)\n            if(sigma(kin)<=sigma(kin-1).or.sigma(kin)>=0) then\n              write(*,*)'check sigma levels at:',k,sigma(kin),sigma(kin-1)\n              stop\n            endif\n          enddo !k\n          read(19,*) !level nvrt\n\n        case(1) !localized sigma\n          read(19,*)nvrt\n          do i=1,np\n            read(19,*)j,kbp(i),sigma_lcl(kbp(i):nvrt,i)\n          enddo !i\n        case default\n          write(*,*)'unknown ivcor:',ivcor\n          stop\n      end select\n      close(19)      \n\n      end subroutine get_vgrid\n"}, {"instruction": "Create a Fortran subroutine named cmp_pw_olap to calculate the overlap between plane waves. It should take 10 input parameters of types integer and complex*16 and 1 output parameter of type complex*16. The subroutine should use the imperative tone and reflect Fortran features.", "input": "", "output": "subroutine cmp_pw_olap(olap, indgq, ipwint, gindex, i_g0, ngq, ng, maxngq_barc, n1, n2, n3)\n  ! calculates overlap between plane waves from indgq\n  implicit none\n  complex*16, intent(out):: olap(ngq,ngq)\n  integer,   intent(in)  :: indgq(maxngq_barc)  !\n  integer,   intent(in)  :: gindex(ng,3)       ! all g-points\n  complex*16, intent(in) :: ipwint(ng)\n  integer, intent(in)    :: i_g0(2*n1+1,2*n2+1,2*n3+1)\n  integer,    intent(in) :: ngq, ng, maxngq_barc, n1, n2, n3\n  !\n  integer :: ipw, jpw, ig(3), idg\n  do ipw=1,ngq\n     olap(ipw,ipw) = ipwint(1)\n     do jpw=ipw+1,ngq\n        ig  = gindex(indgq(ipw)+1,:) - gindex(indgq(jpw)+1,:)\n        idg = i_g0(ig(1)+n1+1,ig(2)+n2+1,ig(3)+n3+1)\n        olap(ipw,jpw) = ipwint(idg+1)\n        olap(jpw,ipw) = conjg(ipwint(idg+1))\n     enddo\n  enddo\nend subroutine cmp_pw_olap\n"}, {"instruction": "Write a Fortran subroutine named cmp_pw_olap2 to calculate the overlap between plane waves from the given input parameters. The subroutine takes 11 input parameters of type integer and complex*16 and outputs a single complex*16 value. The subroutine should be designed to calculate the overlap matrix between plane waves based on the provided input parameters.", "input": "", "output": "subroutine cmp_pw_olap2(olap, indgq, ipwint, gindex, i_g0, ngq, ngq_barc, ng, maxngq_barc, n1, n2, n3)\n  ! calculates overlap between plane waves from indgq\n  implicit none\n  complex*16,intent(out) :: olap(ngq,ngq_barc)\n  integer,   intent(in)  :: indgq(maxngq_barc)  !\n  integer,   intent(in)  :: gindex(ng,3)       ! all g-points\n  complex*16, intent(in) :: ipwint(ng)\n  integer, intent(in)    :: i_g0(2*n1+1,2*n2+1,2*n3+1)\n  integer,    intent(in) :: ngq, ngq_barc, ng, maxngq_barc, n1, n2, n3\n  !\n  integer :: ipw, jpw, igv(3), idg\n  olap = 0.d0\n  do ipw=1,ngq_barc\n     do jpw=1,ngq\n        igv  = gindex(indgq(ipw)+1,:) - gindex(indgq(jpw)+1,:)   ! g_{ipw}-g_{jpw}\n        if ( abs(igv(1))<=n1 .and. abs(igv(2))<=n2 .and. abs(igv(3))<=n3 ) idg = i_g0(igv(1)+n1+1,igv(2)+n2+1,igv(3)+n3+1)+1\n        if (idg>0) olap(jpw,ipw) = ipwint(idg)  ! olap[jpw,ipw]=integrate[ (e^{i(g[ipw]-g[jpw])r},{r in interstitials}]/v_cell = <g_{jpw}|g_{ipw}>_{interstitials}\n     enddo\n  enddo\nend subroutine cmp_pw_olap2\n"}, {"instruction": "Write a Fortran subroutine named pw_get_short_length to find the number of unique lengths present. The subroutine takes 2 input parameters of type real(8) and integer, and 2 output parameters of type integer. The number of input arguments is 2 and the test_data type is ['real(8)', 'integer'], and the number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "subroutine pw_get_short_length(ngs, gind4, glen, nk)\n  ! this function find how many unique lengths are present\n  implicit none\n  integer, intent(out)    :: ngs, gind4(nk)\n  real(8), intent(in)     :: glen(nk)\n  integer, intent(in)     :: nk\n  !\n  integer    :: ipw, igl\n  real(8)    :: glprev\n  !\n  glprev=0.d0 ! notice that we remove g=0 by setting glprev to zero. make it negative if we want to inlcude g=0\n  igl=0\n  do ipw=1,nk\n     if ( abs(glen(ipw)-glprev) > 1e-10 ) then\n        igl=igl+1          ! how many different lengths\n        glprev = glen(ipw)\n     endif\n     gind4(ipw) = igl      ! gind4(ipw_long) = index_to_unique\n  enddo\n  ngs=igl\nend subroutine pw_get_short_length\n"}, {"instruction": "Create a Fortran subroutine named pw_get_short_and_phase to calculate the integral of the plane wave in the interstitials. The subroutine takes 9 input parameters of types integer, integer, real(8), integer, real(8), integer, integer, integer, integer and returns 2 output parameters of types real(8) and complex*16.", "input": "", "output": "subroutine pw_get_short_and_phase(glen0, phase, ngs, gind4, gind, glen, pos, mult, nk, nat, ndf)\n  ! this function calculated integral of the plane wave in the interstitials\n  ! for all vectors in gind array with length glen:\n  !  integrate[ exp(i g\\vr), {\\vr in interstitials}]\n  ! \n  ! we could use  function int1ipw from for_vxcnn.f90, which does the same thing, but for\n  ! a single vector\n  implicit none\n  real(8), intent(out)    :: glen0(ngs)\n  complex*16, intent(out) :: phase(ndf,ndf,ngs)\n  integer, intent(in)     :: gind(nk,3), gind4(nk)\n  real(8), intent(in)     :: glen(nk)\n  integer, intent(in)     :: mult(nat)\n  real(8), intent(in)     :: pos(3,ndf)\n  integer, intent(in)     :: ngs        ! length of the short arrays\n  integer, intent(in)     :: nk, nat, ndf\n  !\n  real(8),    parameter  :: pi = 3.14159265358979d0\n  !\n  integer    :: ipw, igl, jgl, iat, ieq, jat, jeq, idf, jdf\n  real(8)    :: dpos(3)\n  complex*16 :: expg, two_pi_i\n  !\n  glen0=0.d0    ! glen0 stores only different lengths  (much smaller than number of all g-points)\n  jgl=0\n  do ipw=1,nk\n     !print *, 'ipw=', ipw, 'jgl=', jgl\n     if (gind4(ipw) .ne. jgl) then\n        jgl = gind4(ipw)\n        glen0(jgl) = glen(ipw) ! fancy way of setting smaller mesh of glen0 with inequivalent lengths only\n        !write(6,'(a,i3,a,f10.6)') 'glen0[',jgl,']=',glen0(jgl)\n     endif\n  enddo\n  if (jgl.ne.ngs) then\n     write(6,'(a,i4,a,i4)') 'error in pw_get_short_and_phase for_coulomb.f90 ngs=', ngs, 'while jgl=', jgl\n  endif\n  !\n  two_pi_i = 2.0d0*pi*cmplx(0.d0,1.d0,8)\n  phase(:,:,:) = cmplx(0.d0,0.d0,8)\n  idf=0\n  do iat = 1, nat\n     do ieq = 1, mult(iat)\n        idf=idf+1\n        jdf=0    \n        do jat=1,nat\n           do jeq=1,mult(jat)\n              jdf=jdf+1\n              if (idf .eq. jdf) then\n                 do ipw = 2, nk                 ! over all g's, excepy g=0\n                    igl = gind4(ipw)            ! igl is index in the shorter array\n                    phase(idf,jdf,igl) = phase(idf,jdf,igl) + 1.d0 ! phase for the entire set of g vectors which have equal length!\n                 enddo ! ipw\n              else\n                 dpos(1:3) = pos(1:3,idf)-pos(1:3,jdf)\n                 do ipw = 2, nk                 ! over all g's, excepy g=0\n                    expg = exp( -dot_product( gind(ipw,:), dpos) * two_pi_i )  ! exp(-(g*(r_i-r_j)*2*pi*1j)\n                    igl = gind4(ipw)            ! igl is index in the shorter array\n                    phase(idf,jdf,igl) = phase(idf,jdf,igl) + expg      ! phase for the entire set of g vectors which have equal length!\n                 enddo ! ipw\n              endif\n              !do igl=1,ngs\n              !   write(6,'(3i5,2x,2f12.4)') idf, jdf, igl, phase(idf,jdf,igl)\n              !end do\n           enddo ! jeq\n        enddo ! jat\n     enddo ! ieq\n  enddo ! iat\nend subroutine pw_get_short_and_phase\n"}, {"instruction": "Create a Fortran subroutine named make_date that takes two input parameters of type integer, representing an 8-digit date (yyyymmdd) and a 6-digit time (hhmmss). The subroutine should produce one output parameter of type character with a length of 24, representing the date and time in the format \"yyyy-mm-dd_hh:mm:ss.ffff\".", "input": "", "output": "subroutine make_date ( date , time , date_time_char )\n\n!  this routine takes an 8-digit date (yyyymmdd) and a\n!  6-digit time (hhmmss) and converts it to a 24-digit\n!  string (yyyy-mm-dd_hh:mm:ss.ffff).\n\n   integer , intent(in) :: date , &\n                           time\n\n   character (len=24) , intent(out) :: date_time_char\n\n\n   !  local data.\n\n   integer :: year , month , day , hour , minute , second , fraction\n\n   year = date / 10000\n   month = ( date - year*10000 ) / 100\n   day   =  date - year*10000 - month*100\n\n\n   hour = time / 10000\n   minute = ( time - hour*10000 ) / 100\n   second = time - hour*10000 - minute*100\n\n   fraction = 0\n\n   write ( date_time_char , &\n   fmt = '(i4.4,\"-\",i2.2,\"-\",i2.2,\"_\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i4.4) ') &\n           year , month ,    day ,    hour  , minute , second , fraction\n\nend subroutine make_date\n"}, {"instruction": "Write a Fortran subroutine named strtoarr, which takes an integer and a character array as input and returns an integer array as output. The subroutine converts the characters in the input array to their ASCII values and stores them in the output integer array. The input parameters consist of an integer and an array of characters with a specified length, and the output is an array of integers. ", "input": "", "output": "subroutine strtoarr(strin, chararr, n_str)\n  integer, intent(in) :: n_str\n  character(len=n_str), intent(in) :: strin\n  integer, intent(out) ::  chararr(n_str+1)\n  chararr = 32 ! space\n  do j=1,n_str\n     chararr(j) = ichar(strin(j:j))\n  enddo\n  chararr(n_str+1) = 124 ! '|'\nend subroutine strtoarr\n"}, {"instruction": "Create a Fortran subroutine named \"get_chmcycles\" to calculate the number of cycles per nops based on the input parameters nrchem and nropsm. The number of input parameters is 2, with test_data type ['integer', 'integer'], and the number of output parameters is 1, with test_data type ['integer'].", "input": "", "output": "  subroutine get_chmcycles(chmcycles, nrchem, nropsm)\n    !// --------------------------------------------------------------------\n    !// internal uio loop for chemistry/boundary layer mixing\n    !// number of cycles per nops when nropsm==3.\n    !//\n    !// ole amund sovde, november 2009\n    !// --------------------------------------------------------------------\n    implicit none\n    !// --------------------------------------------------------------------\n    !// input\n    integer, intent(in) :: nrchem, nropsm\n    !// output\n    integer, intent(out) :: chmcycles\n    !// --------------------------------------------------------------------\n    character(len=*), parameter :: subr = 'get_chmcycles'\n    !// --------------------------------------------------------------------\n\n    if (nrchem .eq. 1) then\n       chmcycles = 4\n       !// simple test to take nropsm into account,\n       if (nropsm .ge. 6 .and. nropsm .lt. 12) chmcycles = 2\n       if (nropsm .ge. 12) chmcycles = 1\n    else if (nrchem .eq. 2) then\n       chmcycles = 2\n       !// simple test to take nropsm into account\n       if (nropsm .ge. 6) chmcycles = 1\n    else\n       chmcycles = 1\n    end if\n\n    !// --------------------------------------------------------------------\n  end subroutine get_chmcycles\n"}, {"instruction": "Create a Fortran subroutine named stringupcase to convert a given input string to uppercase letters (English alphabet). The subroutine takes 1 input parameter of type character(len=*) and outputs 1 parameter of type character(len=*).", "input": "", "output": "  subroutine stringupcase(ucstr,instr)\n    !// --------------------------------------------------------------------\n    !// put a string into upper case letters (english alphabet).\n    !//\n    !// ole amund sovde, august 2009\n    !// --------------------------------------------------------------------\n    implicit none\n    !// --------------------------------------------------------------------\n    !// input\n    character(len=*),intent(in) :: instr\n    !// output\n    character(len=*),intent(out) :: ucstr\n\n    !// locals\n    character(len=*),parameter :: lc='abcdefghijklmnopqrstuvwxyz'\n    character(len=*),parameter :: uc='abcdefghijklmnopqrstuvwxyz'\n    integer :: i, n,strlen\n    !// --------------------------------------------------------------------\n\n    ucstr = instr\n    strlen = min(len(instr),len(ucstr))\n\n    do i = 1, strlen\n       !// find location of letter in lower case constant string\n       n = index( lc, instr(i:i))\n       !// if current substring is a lower case letter, make it upper case,\n       !// otherwise keep the input letter.\n       if ( n .ne. 0 ) then\n          ucstr(i:i) = uc(n:n)\n       else\n          ucstr(i:i) = instr(i:i)\n       end if\n    end do\n\n    !// --------------------------------------------------------------------\n  end subroutine stringupcase\n"}, {"instruction": "Create a Fortran subroutine named skewsymmetric to generate a skew-symmetric matrix from a given 3D vector. The input parameter is a real*8 array of size 3, and the output parameter is a real*8 array of size (3,3).", "input": "", "output": "    pure subroutine skewsymmetric(vector, s)\n      real*8, intent(in) :: vector(3)\n      real*8, intent(out) :: s(3,3)\n\n      s(1,:) = (/        0d0, -vector(3),  vector(2) /)\n      s(2,:) = (/  vector(3),        0d0, -vector(1) /)\n      s(3,:) = (/ -vector(2),  vector(1),        0d0 /)\n\n    end subroutine skewsymmetric\n"}, {"instruction": "Create a Fortran subroutine named \"photgrid\" to calculate the grid spacing and altitude grid for a photochemical model. The subroutine takes 3 input parameters of type integer, real(8), and real(8), and 2 output parameters of type real(8).", "input": "", "output": "subroutine photgrid(top_atmos, bottom_atmos, nz, z, dz)\n  implicit none\n\n  ! local variables\n  integer, intent(in) :: nz\n  real(8), intent(in) :: top_atmos, bottom_atmos \n  real(8), intent(out) :: z(nz), dz(nz)\n  \n  \n  real*8 :: dzgrid\n  integer :: i\n\n  dzgrid = (top_atmos - bottom_atmos)/nz\n  dz = dzgrid\n\n  z(1) = bottom_atmos + 0.5d0*dzgrid\n  do i=2,nz\n   z(i) = z(i-1) + dzgrid\n  enddo\n\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"vecadd\" to perform element-wise addition of two integer arrays and store the result in a third integer array. The subroutine takes 3 input parameters of type integer arrays and 1 output parameter of type integer array. The input arrays \"a\" and \"b\" are of length \"n\", and the output array \"c\" is also of length \"n\".", "input": "", "output": "   subroutine vecadd(a, b, c, n)\n      integer, intent(in) :: n\n      integer, intent(in) :: a(n), b(n)\n      integer, intent(out) :: c(n)\n      integer :: i\n      !dir$ omp offload target(mic)\n      !$omp parallel do\n      do i=1,n\n         c(i) = a(i) + b(i)\n      end do\n   end subroutine\n"}, {"instruction": "Write a Fortran subroutine named evolution_step to perform an evolution step for a given system. The subroutine takes 6 input parameters: n_nodes (integer), ktot (integer), t_ind (array of integers), t_tau (array of double precision), t_start (array of integers), and vect_in (array of double precision). It produces 1 output parameter named vect_out (array of double precision).", "input": "", "output": "subroutine evolution_step(t_start,t_ind,t_tau,vect_in,n_nodes,ktot,vect_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  \n  double precision,dimension(n_nodes),intent(in)::vect_in\n  double precision,dimension(n_nodes),intent(out)::vect_out\n  double precision,dimension(n_nodes)::pe\n\n  integer::i,j,jj\n  \n  pe=0\n  vect_out=0.0d0\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        pe(i)=pe(i)+t_tau(j)\n     end do\n  end do\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        jj=t_ind(j)\n        vect_out(jj)=vect_out(jj)+(t_tau(j)/pe(i))*vect_in(i)\n     end do\n  end do\n\nend subroutine evolution_step\n"}, {"instruction": "Write a Fortran subroutine named criterio_distancia to calculate the shortest path distances between nodes in a graph based on the input adjacency matrix. The subroutine takes 2 input parameters: an integer representing the number of nodes and a 2D array of double precision numbers representing the adjacency matrix. It returns 1 output parameter: a 2D array of double precision numbers representing the shortest path distances between nodes.", "input": "", "output": "subroutine criterio_distancia(mat_in,n_nodes,mat_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes\n  double precision,dimension(n_nodes,n_nodes),intent(in)::mat_in\n  double precision,dimension(n_nodes,n_nodes),intent(out)::mat_out\n\n  double precision::aa,azero\n  integer::ii,jj,kk,ll\n  logical,dimension(:),allocatable::filtro\n  double precision,dimension(:),allocatable::vect_aux\n\n  allocate(filtro(n_nodes))\n  allocate(vect_aux(n_nodes))\n  azero=0.0d0\n\n  do ii=1,n_nodes\n     vect_aux(:)=1.0d0/azero\n     filtro=.true.\n     vect_aux(ii)=0.0d0\n  \n     do while (count(filtro)>0)\n        ll=minloc(vect_aux(:),dim=1,mask=filtro)\n        do jj=1,n_nodes\n           if (filtro(jj).eqv..true.) then\n              if (vect_aux(jj)>(vect_aux(ll)+mat_in(jj,ll))) then\n                 vect_aux(jj)=vect_aux(ll)+mat_in(jj,ll)\n              end if\n           end if\n        end do\n        filtro(ll)=.false.\n     end do\n     mat_out(:,ii)=vect_aux(:)\n  end do\n\n\nend subroutine criterio_distancia\n"}, {"instruction": "Write a Fortran subroutine named matrix_fpt to perform a matrix computation. The subroutine takes 5 input parameters of types: integer, integer, integer array of size ktot, double precision array of size ktot, and integer array of size n_nodes+1. It also has 1 output parameter of type double precision array of size n_nodes x n_nodes.", "input": "", "output": "subroutine matrix_fpt (t_start,t_ind,t_tau,n_nodes,ktot,mat_out)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,dimension(n_nodes,n_nodes),intent(out)::mat_out\n\n  double precision,dimension(n_nodes)::pe\n  integer::ii,jj,gg,times,a\n\n  double precision,dimension(:),allocatable::pf,pf2,antes\n  logical::interr\n\n  mat_out  = 0.0d0\n\n  pe=0\n  do ii=1,n_nodes\n     do jj=t_start(ii)+1,t_start(ii+1)\n        pe(ii)=pe(ii)+t_tau(jj)\n     end do\n  end do\n\n  allocate(pf(n_nodes),pf2(n_nodes),antes(n_nodes))\n\n  do a=1,n_nodes\n\n     print*,a\n\n     pf=0.0d0\n\n     pf2=100000.0d0\n     pf2(a)=0.0d0\n\n     do times=1,1000000\n        \n        pf2(a)=0.0d0\n        pf=pf2\n        antes=pf2\n        pf2=0.0d0\n        \n        do ii=1,n_nodes\n           do jj=t_start(ii)+1,t_start(ii+1)\n              gg=t_ind(jj)\n              pf2(ii)=pf2(ii)+(t_tau(jj)*pf(gg))/pe(ii)\n           end do\n        end do\n        \n        antes=antes-pf2\n        interr=.false.\n        do ii=1,n_nodes\n           if (abs(antes(ii))>0.0010d0) then\n              interr=.true.\n              exit\n           end if\n        end do\n        \n        if (interr.eqv..false.) exit\n        \n        pf2=pf2+1.0d0\n     end do\n\n     pf2(a)=0.0d0\n\n     pf=pf2\n     \n     mat_out(:,a)=pf(:)\n\n     do ii=1,n_nodes\n        write(789,*) a, ii, pf(ii)\n     end do\n\n  end do\n\nend subroutine matrix_fpt\n"}, {"instruction": "Write a Fortran subroutine named detailed_balance_distance to calculate the detailed balance distance based on the provided inputs. The subroutine takes 6 input parameters of types integer, integer, integer array of size ktot, double precision array of size ktot, integer array of size n_nodes+1, and double precision. It also has 1 output parameter of type double precision.", "input": "", "output": "subroutine detailed_balance_distance(db_dist,p,t_start,t_ind,t_tau,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,intent(in)::p\n  double precision,intent(out)::db_dist\n\n\n  integer::i,j,ii,jj\n  double precision::overp\n  double precision::we_total,i_trans,j_trans\n\n  overp=1.0d0/p\n  db_dist=0.0d0\n\n  we_total=0\n\n  do i=1,n_nodes\n     do j=t_start(i)+1,t_start(i+1)\n        we_total=we_total+t_tau(j)\n     end do\n  end do\n\n  do i=1,n_nodes\n     do ii=t_start(i)+1,t_start(i+1)\n        j=t_ind(ii)\n        i_trans=t_tau(ii)\n        j_trans=0\n        do jj=t_start(j)+1,t_start(j+1)\n           if (i==t_ind(jj)) then\n              j_trans=t_tau(jj)\n              exit\n           end if\n        end do\n        db_dist=db_dist+(abs((i_trans-j_trans))/(we_total))**p\n     end do\n  end do\n\n  db_dist=(0.50d0*db_dist)**overp\n\n\nend subroutine detailed_balance_distance\n"}, {"instruction": "Create a Fortran subroutine named \"weight_core_new_k_total\" to calculate the new values of \"newktot\" and \"newnnodes\" based on the input parameters \"newktot\", \"newnnodes\", \"threshold\", \"t_ind\", \"t_tau\", \"t_start\", \"n_nodes\", and \"ktot\". The input parameter types are ['integer', 'integer', 'double precision', 'integer,dimension(ktot)', 'double precision,dimension(ktot)', 'integer,dimension(n_nodes+1)'], and the output parameter types are ['integer', 'integer'].", "input": "", "output": "subroutine weight_core_new_k_total(newktot,newnnodes,threshold,t_ind,t_tau,t_start,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot\n  double precision,intent(in)::threshold\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n\n  integer,intent(out)::newktot,newnnodes\n\n  integer::i,j\n  logical,dimension(:),allocatable::filtro\n  double precision::pe\n\n  allocate(filtro(n_nodes))\n\n  filtro=.true.\n\n  do i=1,n_nodes\n     pe=0.0d0\n     do j=t_start(i)+1,t_start(i+1)\n        pe=pe+t_tau(j)\n     end do\n     if (pe<=threshold) filtro(i)=.false.\n  end do\n\n  newktot=0\n  do i=1,n_nodes\n     if (filtro(i).eqv..true.) then\n        do j=t_start(i)+1,t_start(i+1)\n           if (filtro(t_ind(j)).eqv..true.) then\n              newktot=newktot+1\n           end if\n        end do\n     end if\n  end do\n\n  newnnodes=count(filtro,dim=1)\n\n  deallocate(filtro)\n\nend subroutine weight_core_new_k_total\n"}, {"instruction": "Create a Fortran subroutine named extract_net_new_k_total to calculate the total number of new connections based on the input parameters. The subroutine takes 6 input parameters of type integer and array, and 1 output parameter of type integer. The input parameter types are ['integer', 'integer', 'integer', 'integer,dimension(ktot)', 'integer,dimension(n_nodes+1)', 'integer,dimension(newnnodes)'].", "input": "", "output": "subroutine extract_net_new_k_total(newktot,list_nodes,t_ind,t_start,newnnodes,n_nodes,ktot)\n\n  implicit none\n\n  integer,intent(in)::n_nodes,ktot,newnnodes\n  integer,dimension(ktot),intent(in)::t_ind\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  integer,dimension(newnnodes),intent(in)::list_nodes\n\n  integer,intent(out)::newktot\n\n  integer::i,j,tt\n  logical,dimension(:),allocatable::filtro\n\n  allocate(filtro(n_nodes))\n\n  filtro=.false.\n\n  do i=1,newnnodes\n     filtro(list_nodes(i)+1)=.true.\n  end do\n\n  newktot=0\n  do i=1,newnnodes\n     tt=list_nodes(i)+1\n     do j=t_start(tt)+1,t_start(tt+1)\n        if (filtro(t_ind(j)).eqv..true.) then\n           newktot=newktot+1\n        end if\n     end do\n  end do\n\n  deallocate(filtro)\n\nend subroutine extract_net_new_k_total\n"}, {"instruction": "Create a Fortran subroutine named dijkstra to implement Dijkstra's algorithm for finding the shortest path in a graph. The subroutine takes 8 input parameters of types integer, integer, integer, integer, integer, integer dimension(ktot), double precision dimension(ktot), and integer dimension(n_nodes+1). It also has 1 output parameter of type double precision dimension(n_nodes,dim_out).", "input": "", "output": "subroutine dijkstra (distancia,node,dim_out,directed,t_start,t_ind,t_tau,n_nodes,ktot)\n \n  implicit none\n  \n  integer,intent(in)::n_nodes,ktot,node,directed,dim_out\n  integer,dimension(ktot),intent(in)::t_ind\n  double precision,dimension(ktot),intent(in)::t_tau\n  integer,dimension(n_nodes+1),intent(in)::t_start\n  double precision,dimension(n_nodes,dim_out),intent(out)::distancia\n  \n  double precision,dimension(:),allocatable::vect_aux\n  logical,dimension(:),allocatable::filtro,filtro2\n  \n  double precision::azero\n  integer::i,j,g,h\n  \n  allocate(filtro(n_nodes),vect_aux(n_nodes))\n  \n  distancia=0.0d0\n  azero=0.0d0\n\n  if (node>0) then\n     \n     vect_aux=1.0d0/azero\n     filtro=.true.\n     vect_aux(node)=0.0d0\n     \n     do while (count(filtro)>0)\n        i=minloc(vect_aux(:),dim=1,mask=filtro)\n        do j=t_start(i)+1,t_start(i+1)\n           g=t_ind(j)\n           if (filtro(g).eqv..true.) then\n              if (vect_aux(g)>(vect_aux(i)+t_tau(j))) then\n                 vect_aux(g)=vect_aux(i)+t_tau(j)\n              end if\n           end if\n        end do\n        filtro(i)=.false.\n     end do\n     distancia(:,1)=vect_aux(:)\n\n  else\n\n     allocate(filtro2(n_nodes))\n     do h=1,n_nodes\n        vect_aux=1.0d0/azero\n        filtro=.true.\n        filtro2=.true.\n        vect_aux(h)=0.0d0\n        if (directed==0) then\n           do i=1,h-1\n              vect_aux(i)=distancia(h,i)\n              filtro2(i)=.false.\n           end do\n        end if\n        do while (count(filtro)>0)\n           i=minloc(vect_aux(:),dim=1,mask=filtro)\n           do j=t_start(i)+1,t_start(i+1)\n              g=t_ind(j)\n              if (filtro2(g).eqv..true.) then\n                 if (vect_aux(g)>(vect_aux(i)+t_tau(j))) then\n                    vect_aux(g)=vect_aux(i)+t_tau(j)\n                 end if\n              end if\n           end do\n\n           filtro(i)=.false.\n           filtro2(i)=.false.\n        end do\n        distancia(:,h)=vect_aux(:)\n     end do\n     deallocate(filtro2)\n\n  end if\n\n  deallocate(filtro,vect_aux)\n\nend subroutine dijkstra\n"}, {"instruction": "Create a Fortran subroutine named reshape_to_2_by_99_x_99 to reshape a 3D integer array into a 2D array. The input parameter is a 3D integer array, and the output parameter is a 2D integer array.", "input": "", "output": "    subroutine reshape_to_2_by_99_x_99(arr_in, arr_out)\n        integer, intent(in) :: arr_in(:, :, :)\n        integer, intent(out) :: arr_out(:, :)\n\n        arr_out = reshape(arr_in, [2, 99*99])\n    end subroutine reshape_to_2_by_99_x_99\n"}, {"instruction": "Write a Fortran subroutine named mpi_read_control_p to read integer and real values from a file specified by the input file path. The subroutine takes 2 input parameters of type integer and character*17, and 2 output parameters of type integer and real(8).", "input": "", "output": "subroutine mpi_read_control_p(infile_control,my_rank,itr_max,tol)\n\t\n\tinteger,intent(in)::my_rank\n\tinteger,intent(out)::itr_max\n\treal(8),intent(out)::tol\n\tcharacter*17,intent(in):: infile_control\n\t\n\topen(10,file=infile_control)\n\tread(10,*)itr_max,tol\n\tclose(10)\n\nend subroutine mpi_read_control_p\n"}, {"instruction": "Write a Fortran subroutine named interpltn to calculate the interpolating coefficients for a general interpolation. The subroutine takes 4 input parameters of type integer, integer, real array, and real array, and 1 output parameter of type real array. The subroutine performs calculations based on the input parameters to determine the interpolating coefficients.", "input": "", "output": "subroutine interpltn(nd,ng,co,ac,oc)\n!*************************************************\n! calculate the interpolating coefficent (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n! 2     , 3     , 5     , 9\n! 2**0+1, 2**1+1, 2**2+1, 2**3+1\n  implicit none\n! --------------------\n  integer  :: i,j\n  integer , intent(in)  :: nd,ng\n  real    , intent(in)  :: ac(nd,ng),oc(nd)\n  real    , intent(out) :: co(ng)\n  real                  :: dd(nd,ng),dc(nd)\n! --------------------\n! declare:\n!        'nd' is the number of dimensions of the field\n!        'ng' is the number of gridpoints neighbor to the position, which is to be interpolated, ng is equal to 2**nd\n!        'co' is the interpolating coefficients.\n!        'oc' is the position where to be interpolated \n!        'ac' is the index of the gridpoints, which is neighbor to the positioin\n! --------------------\n  do i=1,nd\n    if((oc(i)-ac(i,1))*(oc(i)-ac(i,2**(i-1)+1)).gt.0.0) then\n      print*,'interpltn: oc is not in the domain ',i,oc(i),ac(i,1),ac(i,2**(i-1)+1)\n      stop\n    endif\n  enddo\n  do i=1,nd\n    do j=1,ng\n      dd(i,j)=ac(i,j)-oc(i)\n    enddo\n    dc(i)=abs(ac(i,2**(i-1)+1)-ac(i,1))\n!    if(dc(i).le.0.0)stop 'grid arrange wrong!!!'            ! omitted by zhongjie he\n  enddo\n  do i=1,nd\n    if(dc(i).ne.0) then \n      do j=1,ng\n        dd(i,j)=dd(i,j)/dc(i)\n        if(dd(i,j).gt.0.0)then\n          dd(i,j)=dd(i,j)-1.0\n        else\n          dd(i,j)=dd(i,j)+1.0\n        endif\n        dd(i,j)=abs(dd(i,j))\n      enddo\n    else                                     !     added by zhongjie he \n      do j=1,ng\n        dd(i,j)=1.\n      enddo\n    endif\n  enddo\n  do j=1,ng\n    co(j)=1.0\n    do i=1,nd\n      co(j)=co(j)*dd(i,j)\n    enddo\n  enddo\n  return\nend subroutine interpltn\n"}, {"instruction": "Create a Fortran subroutine named \"interpltn_xie\" to calculate the interpolating coefficients for a general interpolation. The subroutine takes 7 input parameters of type [integer, integer, integer, integer, real, real, real] and 1 output parameter of type [real].", "input": "", "output": "subroutine interpltn_xie(nd,ng,co,ac,oc,ip,np,pv)\n!*************************************************\n! calculate the interpolating coefficent (general)\n! history: august 2007, coded by wei li.\n!\n!          march 31, 2009 by yuanfu xie for log(p)\n!          interpolation.\n!*************************************************\n! 2     , 3     , 5     , 9\n! 2**0+1, 2**1+1, 2**2+1, 2**3+1\n  implicit none\n! --------------------\n  integer  :: i,j,k,k1\n  integer , intent(in)  :: nd,ng,ip,np\n  real    , intent(in)  :: ac(nd,ng),oc(nd),pv(np)\n  real    , intent(out) :: co(ng)\n  real                  :: dd(nd,ng),dc(nd),p\n! --------------------\n! declare:\n!        'nd' is the number of dimensions of the field\n!        'ng' is the number of gridpoints neighbor to the position, which is to be interpolated, ng is equal to 2**nd\n!        'co' is the interpolating coefficients.\n!        'oc' is the position where to be interpolated \n!        'ac' is the index of the gridpoints, which is neighbor to the positioin\n! --------------------\n  do i=1,nd\n    if((oc(i)-ac(i,1))*(oc(i)-ac(i,2**(i-1)+1)).gt.0.0) then\n      print*,'interpltn: oc is not in the domain ',i,oc(i),ac(i,1),ac(i,2**(i-1)+1)\n      stop\n    endif\n  enddo\n  do i=1,nd\n    do j=1,ng\n      dd(i,j)=ac(i,j)-oc(i)\n    enddo\n    dc(i)=abs(ac(i,2**(i-1)+1)-ac(i,1))\n  enddo\n  do i=1,nd\n    if(dc(i).ne.0) then \n      do j=1,ng\n        dd(i,j)=dd(i,j)/dc(i)\n        if(dd(i,j).gt.0.0)then\n          ! log(p):\n          if (i .eq. ip) then\n            k1 = ac(i,j)\n            if (k1 .le. 1) then\n              dd(i,j) = 0.0\n            else\n              k = k1-1\n              p = pv(k)*dd(i,j)+(1.0-dd(i,j))*pv(k+1)\n              dd(i,j) = (log(p)-log(pv(k)))/(log(pv(k1))-log(pv(k)))\n            endif\n          else\n            dd(i,j)=dd(i,j)-1.0\n          endif\n        else\n          if (i .eq. ip) then\n            k = ac(i,j)\n            if (k .ge. np) then\n              dd(i,j) = 1.0\n            else\n              k1 = k+1\n              p = (1.0+dd(i,j))*pv(k)-dd(i,j)*pv(k1)\n              dd(i,j) = (log(pv(k1))-log(p))/(log(pv(k1))-log(pv(k)))\n            endif\n          else\n            dd(i,j)=dd(i,j)+1.0\n          endif\n        endif\n        dd(i,j)=abs(dd(i,j))\n      enddo\n    else                                     !     added by zhongjie he \n      do j=1,ng\n        dd(i,j)=1.\n      enddo\n    endif\n  enddo\n\n  do j=1,ng\n    co(j)=1.0\n    do i=1,nd\n      co(j)=co(j)*dd(i,j)\n    enddo\n  enddo\n  return\nend subroutine interpltn_xie\n"}, {"instruction": "Write a Fortran subroutine named gderiveit to calculate the general derivative of interior (general). The subroutine takes 3 input parameters of type real and returns 3 output parameters of type real. The input parameters are z1, z2, and z3, and the output parameters are a, b, and c.", "input": "", "output": "subroutine gderiveit(z1,z2,z3,a,b,c)\n!*************************************************\n! general derivative of interior (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  real  :: x,y\n  real , intent(in)  :: z1,z2,z3\n  real , intent(out) :: a,b,c\n! --------------------\n  x=z2-z1\n  y=z3-z2\n  a=-y/(x*x+x*y)\n  b=(-x+y)/(x*y)\n  c=x/(x*y+y*y)\n  return\nend subroutine gderiveit\n"}, {"instruction": "Write a Fortran subroutine named gderivelb to calculate the general derivative of the left boundary. The subroutine takes 3 input parameters of type real: z1, z2, and z3. It returns 3 output parameters of type real: a, b, and c.", "input": "", "output": "subroutine gderivelb(z1,z2,z3,a,b,c)\n!*************************************************\n! general derivative of left boundary (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  real  :: x,y\n  real , intent(in)  :: z1,z2,z3\n  real , intent(out) :: a,b,c\n! --------------------\n  x=z2-z1\n  y=z3-z2\n  a=(-2.0*x-y)/(x*x+x*y)\n  b=(x+y)/(x*y)\n  c=-x/(x*y+y*y)\n  return\nend subroutine gderivelb\n"}, {"instruction": "Write a Fortran subroutine named \"pstn2numb\" that transforms the position to a number (general), coded by Wei Li in August 2007. The subroutine takes 3 input parameters of type integer: nn, np(nn), nm(nn), and outputs one integer parameter nc. The subroutine computes the index of the gridpoint in a 1-dimensional field given the dimensions and gridpoint indices.", "input": "", "output": "subroutine pstn2numb(nn,np,nm,nc)\n!*************************************************\n! transform position to number (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer               :: pt,m,n\n  integer , intent(in)  :: nn\n  integer , intent(in)  :: np(nn),nm(nn)\n  integer , intent(out) :: nc\n! --------------------\n! declare:\n!        'nn' is the number of dimensions of the field\n!        'np' is the index of the gridpoint at each dimension\n!        'nm' is the total grid number of each dimensioin \n!        'nc' is the index of the gridpoint, when the field is translated to a 1 dimensional filed\n! --------------------\n  nc=np(1)\n  if(nn.eq.1)return\n  do n=2,nn\n    pt=np(n)-1\n    do m=1,n-1\n      pt=pt*nm(m)\n    enddo\n    nc=nc+pt\n  enddo\n  return\nend subroutine pstn2numb\n"}, {"instruction": "Create a Fortran subroutine named \"vrtclpstn8\" to determine the vertical position based on the provided parameters. The subroutine takes 4 input parameters of type integer, real, real, and real, and returns 2 output parameters of type real and integer. The subroutine is used to calculate the index of a given position in the vertical coordinate based on the pressure levels and limitations.", "input": "", "output": "subroutine vrtclpstn8(km,lm,pp,p,ps,is)\n!*************************************************\n! get vertical position (general)\n! history: september 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer  :: k\n  integer ,intent(in)  :: km\n  real ,   intent(in)  :: pp(km)\n  real ,   intent(in)  :: p,lm\n  real ,   intent(out) :: ps\n  integer ,intent(out) :: is\n! --------------------\n! declare:\n!        'km' is the number of levels of the field\n!        'pp' is the presure of each level\n!        'p'  is the presure of the position, which we want to get its index in the vertical coordinate\n!        'ps' is the index of the point in the vertical coordinate\n\n!        'lm' is a limitation to decide whether the observation is available (just used for the case: km=1)\n! --------------------\n  is=0\n  if(km.ge.2) then\n    do k=1,km-1\n      if((p-pp(k))*(p-pp(k+1)).gt.0.0)cycle\n      ps=k+abs(p-pp(k))/abs(pp(k+1)-pp(k))\n      is=1\n    enddo\n  elseif(km.eq.1) then\n    if(abs(p-pp(1)).le.lm) then\n      ps=1\n      is=1\n    endif\n  endif\n  return\nend subroutine vrtclpstn8\n"}, {"instruction": "Create a Fortran subroutine named zpconvert to calculate the pressure from a given height. The subroutine takes 4 input parameters of types integer, real, real, and real, and 2 output parameters of types real and integer. The input parameters are km, zz, pp, and z, while the output parameters are p and is. Ensure that the subroutine is coded properly to perform the required pressure calculation based on the given height and level data.", "input": "", "output": "subroutine zpconvert(km,zz,pp,z,p,is)\n!*************************************************\n! find pressure from height (general)\n! history: september 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer              :: k\n  integer ,intent(in)  :: km\n  real ,   intent(in)  :: zz(km),z\n  real ,   intent(in)  :: pp(km)\n  real ,   intent(out) :: p\n  integer ,intent(out) :: is\n! --------------------\n! declare:\n!        'km' is the number of levels of the field\n!        'zz' is the height of each level\n!        'pp' is the presure of each level\n!        'z'  is the height of point, which we want to get its presure\n!        'p'  is the presure calculated from the zz, pp, and z\n\n! --------------------\n  is=0\n  do k=1,km-1\n    if((z-zz(k))*(z-zz(k+1)).gt.0.0)cycle\n    p=pp(k)*abs(zz(k+1)-z)/abs(zz(k+1)-zz(k))+pp(k+1)*abs(z-zz(k))/abs(zz(k+1)-zz(k))\n    is=1\n  enddo\n  return\nend subroutine zpconvert\n"}, {"instruction": "Create a Fortran subroutine named checkpstn, which calculates the position of a given value within an array. The subroutine takes 3 input parameters of type integer, real, and real, and 1 output parameter of type integer.", "input": "", "output": "subroutine checkpstn(km,zz,z,kz)\n!*************************************************\n! find the position (general)\n! history: august 2007, coded by wei li.\n!*************************************************\n  implicit none\n! --------------------\n  integer  :: k\n  integer , intent(in)  :: km\n  real    , intent(in)  :: zz(km),z\n  integer , intent(out) :: kz\n! --------------------\n  kz=0\n  if(km.eq.1.and.zz(1).eq.z)then\n    kz=1\n    return\n  endif\n  do k=1,km-1\n    if((z-zz(k))*(z-zz(k+1)).gt.0.0)cycle\n    kz=k\n    exit\n  enddo\n  return\nend subroutine checkpstn\n"}, {"instruction": "Create a Fortran subroutine named obstogrid to calculate the position of an observation at the model grid. The subroutine takes 6 input parameters of type integer and real, and 3 output parameters of type real and integer.", "input": "", "output": "subroutine obstogrid(y0,x0,y00,x00,im,jm,x,y,is)\n!*************************************************\n! calculate the position of observation at the model grid.\n! history: feburary 2008, coded by zhongjie he.\n!*************************************************\n  implicit none\n  integer  :: i,j\n  integer , intent(in)  :: im,jm\n  real    , intent(in)  :: x0,y0\n  real    , intent(in)  :: x00(im,jm),y00(im,jm)\n  real    , intent(out) :: x,y\n  integer , intent(out) :: is\n!--------------------\n  is=0\n  x=0\n  y=0\n\n  if(x0.le.x00(1,1)) then\n    if(abs(x00(1,1)-x00(2,1)).le.1e-10) return \n    x=1-(x0-x00(1,1))/(x00(1,1)-x00(2,1))\n  endif\n  if(x0.ge.x00(im,jm)) then\n    if(abs(x00(im,jm)-x00(im-1,jm)).le.1e-10) return\n    x=im+(x0-x00(im,jm))/(x00(im,jm)-x00(im-1,jm))\n  endif\n  do i=2,im\n    if(x0.ge.x00(i-1,1) .and. x0.lt.x00(i,1)) then\n      if(abs(x00(i-1,1)-x00(i,1)).le.1e-10) return\n      x=i-1+(x0-x00(i-1,1))/(x00(i,1)-x00(i-1,1))\n    endif\n  enddo  \n\n  if(y0.le.y00(1,1)) then\n    if(abs(y00(1,1)-y00(1,2)).le.1e-10) return\n    y=1-(y0-y00(1,1))/(y00(1,1)-y00(1,2))\n  endif\n  if(y0.ge.y00(im,jm)) then\n    if(abs(y00(im,jm)-y00(im,jm-1)).le.1e-10) return\n    y=jm+(y0-y00(im,jm))/(y00(im,jm)-y00(im,jm-1))\n  endif\n  do j=2,jm\n    if(y0.ge.y00(1,j-1) .and. y0.lt.y00(1,j)) then\n      if(abs(y00(1,j-1)-y00(1,j)).le.1e-10) return\n      y=j-1+(y0-y00(1,j-1))/(y00(1,j)-y00(1,j-1))\n    endif\n  enddo\n  \n  if(x.ge.1 .and. x.le.im .and. y.ge.1 .and. y.le.jm) is=1\n\n  return\nend subroutine obstogrid\n"}, {"instruction": "Create a Fortran subroutine named \"scsmethod_help\" that takes 5 input parameters of type real(8) and 2 output parameters of type real(8). The inputs are rain, smi, smax, fc, and tn, while the outputs are roff and filtrn. This subroutine computes runoff and infiltration based on the modified scs method. Ensure that the imperative tone is used while providing the instructions.", "input": "", "output": "  subroutine scsmethod_help(rain,smi,smax,fc,tn,roff,filtrn)\n    real(8),intent(in) ::rain ,smi ,smax ,fc ,tn\n    real(8),intent(out)::roff ,filtrn\n\n    !local variables\n    real(8)::s ,si ,sp, smi_work \n\n    !initialize variables\n    roff   = 0.0\n    filtrn = rain\n\n    !compute runoff and infiltration based on modified scs method\n    if (rain.gt.0.0) then\n      if (smi.gt.fc/2.0) then\n        smi_work = min(smi,tn)\n        s        = smax*(1.0-(smi_work-fc/2.0)/(tn-fc/2.0))\n      else\n        s = smax\n      end if\n      si = 0.2*s\n      sp = 0.8*s\n      if (rain.gt.si) then\n        roff   = rain-si\n        roff   = min(roff*roff/(rain+sp) , rain)\n        filtrn = rain-roff\n      end if\n    end if\n\n  end subroutine scsmethod_help\n"}, {"instruction": "Write a Fortran subroutine named sumation to compute the element-wise sum of two arrays of integers. The subroutine takes 2 input arrays of integers and produces 1 output array of integers. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine sumation(a,b,d)\nimplicit none\ninteger,intent(in) :: a(:)\ninteger,intent(in) :: b(:)\ninteger,intent(out):: d(:)\ninteger :: i,n\n\nn = size(a)\ndo i = 1, n\nd(i) = a(i)+b(i)\nend do\nend subroutine sumation      \n"}, {"instruction": "Create a Fortran subroutine named quad_eq to solve a quadratic equation of the form ax^2 + bx + c = 0. The subroutine takes 3 input arguments of type real(16) (a, b, c) and returns 2 output arguments of type real(16) (result1, result2) representing the solutions to the quadratic equation. If the discriminant (b^2 - 4ac) is negative, the subroutine will print a message indicating that the result will be imaginary and return without computing the solutions.", "input": "", "output": "subroutine quad_eq(a, b, c, result1, result2) \n    !-b(+-)sqrt(b^2-4ac)\n    !------------------\n    !      2a\n    implicit none\n    real(16), intent(in) :: a, b, c\n    real(16), intent(out) :: result1, result2\n    real(16) :: inside_sqrt\n    \n    if ((b**2 - (4 * a * c)) < 0) then\n        print *, \"the result will be imaginary\"\n        return\n    end if\n    \n    inside_sqrt = b**2 - 4 * a * c\n    \n    result1 = (-b + sqrt(inside_sqrt))/2 * a\n    result2 = (-b - sqrt(inside_sqrt))/2 * a\n    \nend subroutine quad_eq\n"}, {"instruction": "Write a Fortran subroutine named chebyshev to compute the value of a Chebyshev polynomial of the first kind. The subroutine takes 2 input parameters of type integer and real(8), and 1 output parameter of type real(8). The input parameters are n and x, and the output parameter is phi.", "input": "", "output": "    subroutine chebyshev(n, x, phi)\n\n        integer, intent(in) :: n\n        real(8), intent(in) :: x\n        real(8), intent(out) :: phi\n\n        phi = cos(n * acos(x));\n\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named byte2bin to convert an input byte into an array of 8 binary digits. The number of input parameters is 1, with the test data type being 'integer'. The number of output parameters is 1, with the test data type being 'integer, dimension(8)'.", "input": "", "output": "subroutine byte2bin(inbyte,bin)\r\ninteger, intent(in) :: inbyte\r\ninteger, intent(out), dimension(8) :: bin\r\n\r\ninteger :: byte\r\n!----------------------------------------------------------------------!\r\n\r\nbyte = inbyte\r\n\r\nbin(1)=byte/128\r\nbyte=byte-bin(1)*128\r\nbin(2)=byte/64\r\nbyte=byte-bin(2)*64\r\nbin(3)=byte/32\r\nbyte=byte-bin(3)*32\r\nbin(4)=byte/16\r\nbyte=byte-bin(4)*16\r\nbin(5)=byte/8\r\nbyte=byte-bin(5)*8\r\nbin(6)=byte/4\r\nbyte=byte-bin(6)*4\r\nbin(7)=byte/2\r\nbyte=byte-bin(7)*2\r\nbin(8)=byte\r\n\r\nend subroutine byte2bin\r\n"}, {"instruction": "Create a Fortran subroutine named safe_open_old that takes two input arguments of type character(len=*) and returns two output arguments of type integer. This subroutine opens a file located in a specified directory with a given filename and assigns a logical unit number to it. If the file cannot be opened, the subroutine sets the error code and prints an error message.", "input": "", "output": "  subroutine safe_open_old( lun, dir, fname, ierr )\n    implicit none\n\n    ! input variables\n    character(len=*), intent(in) :: dir, fname\n\n    ! output variables\n    integer, intent(out) :: lun, ierr\n\n    ! local variables\n    character(len=130) :: tmp_fname\n\n    tmp_fname = trim(adjustl(dir))//'/'//trim(adjustl(fname))\n    open( newunit=lun, file=trim(tmp_fname), status='old', iostat=ierr )\n    if ( ierr /= 0 ) write(*,'(a,i3,2a)') 'error(',ierr,'): cannot open ',tmp_fname\n\n    return\n  end subroutine safe_open_old\n"}, {"instruction": "Write a Fortran subroutine named \"sub\" that extracts the first 5 characters from a given input string and assigns it to an output string. The input parameter is a string of type character(len=*), and the output parameter is also a string of type character(len=*).", "input": "", "output": "  subroutine sub(a,b)\n    character(len=*), intent(in) :: a\n    character(len=*), intent(out) :: b\n    b = ''\n    b = a(1:5)\n  end subroutine sub\n"}, {"instruction": "Create a Fortran subroutine named get_inti to calculate interstitial integrals for the difference between two wave vectors. The subroutine takes 4 input parameters: jipw (integer array), istpw (complex*16 array), nvk (integer), npw2apw (integer). It returns 1 output parameter inti (complex*16 array).", "input": "", "output": "subroutine get_inti(inti, jipw, istpw, nvk, npw2apw)\n  ! now we calculate interstitail integral for the difference g1-g2 (with g1 and g2 from hamiltonian basis)\n  !       inti[1,2] = integrate[ (ik - i(g1-g2))\\vr, {\\vr in interstitial}]  = <g1|e^{ik\\vr}|g2>\n  implicit none\n  complex*16, intent(out) :: inti(nvk,nvk)        ! output\n  integer,    intent(in)  :: jipw(nvk,nvk)        ! jipw is index for difference between two g points from vector file\n  complex*16, intent(in)  :: istpw(npw2apw)       ! interstitial integral integrate[ (ik - ig)\\vr, {\\vr in interstitial}] where k is averaged over all members of the star\n  integer,    intent(in)  :: nvk, npw2apw\n  !\n  integer :: iv1, iv2\n  !\n  inti = 0.d0\n  do iv1=1,nvk\n     do iv2=1,nvk\n        if ( jipw(iv1,iv2) >= 0 ) then\n           inti(iv1,iv2) = istpw(jipw(iv1,iv2)+1)\n        end if\n     end do\n  end do\nend subroutine get_inti\n"}, {"instruction": "Create a Fortran subroutine named loginterp that performs logarithmic interpolation in log-pressure space. It takes 2 input parameters of type real, dimension(:) and 2 output parameters of type real, dimension(:).", "input": "", "output": "  subroutine loginterp(presi, zi, z, pres)\n    ! interpolation function taken from pressz.f90\n    ! interpolates in log-pressure space\n    real, intent(in), dimension(:) :: presi, zi\n    real, intent(out), dimension(:) :: pres, z\n    integer k\n\n    do k=1, size(pres)\n       pres(k) = exp(log(presi(k))+log(presi(k+1)/presi(k))* &\n            (z(k)-zi(k))/(zi(k+1)-zi(k)))\n    end do\n  end subroutine loginterp\n"}, {"instruction": "Create a Fortran subroutine named convective_radius to calculate the convective radius based on the given mean background reflectivity value and area relation. The subroutine takes 2 input parameters of types real(kind=8) and character(len=16), and returns 1 output parameter of type real(kind=8).", "input": "", "output": "subroutine convective_radius(ze_bkg, area_relation, conv_rad)\n\n   implicit none\n\n   real(kind=8), intent(in)      :: ze_bkg\n   character(len=16), intent(in) :: area_relation\n   real(kind=8), intent(out)     :: conv_rad\n\n\n!  f2py directives ===========================================================\n\n   !f2py character(len=16), intent(in) :: area_relation\n   !f2py real(kind=8), intent(in)      :: ze_bkg\n   !f2py real(kind=8), intent(out)     :: conv_rad\n\n!  ===========================================================================\n\n\n!  given a mean background reflectivity value, we determine via a step\n!  function what the corresponding convective radius would be\n!\n!  higher background reflectivitives are expected to have larger convective\n!  influence on surrounding areas, so a larger convective radius would be\n!  prescribed\n\n   if (area_relation == 'small') then\n\n      if (ze_bkg < 30.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 35.d0 .and. ze_bkg < 40.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 40.d0 .and. ze_bkg < 45.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n\n   elseif (area_relation == 'medium') then\n\n      if (ze_bkg < 25.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 25.d0 .and. ze_bkg < 30.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 35.d0 .and. ze_bkg < 40.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n   elseif (area_relation == 'large') then\n\n      if (ze_bkg < 20.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 20.d0 .and. ze_bkg < 25.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 25.d0 .and. ze_bkg < 30.d0) then\n         conv_rad = 3000.d0\n      elseif (ze_bkg >= 30.d0 .and. ze_bkg < 35.d0) then\n         conv_rad = 4000.d0\n      else\n         conv_rad = 5000.d0\n      endif\n      \n   elseif (area_relation == 'sgp') then\n\n      if (ze_bkg < 40.d0) then\n         conv_rad = 0.d0\n      elseif (ze_bkg >= 40.d0 .and. ze_bkg < 45.d0) then\n         conv_rad = 1000.d0\n      elseif (ze_bkg >= 45.d0 .and. ze_bkg < 50.d0) then\n         conv_rad = 2000.d0\n      elseif (ze_bkg >= 50.d0 .and. ze_bkg < 55.d0) then\n         conv_rad = 6000.d0\n      else\n         conv_rad = 8000.d0\n      endif\n      \n   else\n\n      stop\n\n   endif\n\n   return\n\n end subroutine convective_radius\n"}, {"instruction": "Create a Fortran subroutine named peakedness that takes 2 input parameters of type real(kind=8) and character(len=16), and 1 output parameter of type real(kind=8). The subroutine calculates the necessary peakedness value based on the background reflectivity and a specified peak relation. Use the imperative tone to define the subroutine.", "input": "", "output": " subroutine peakedness(ze_bkg, peak_relation, peak)\n\n   implicit none\n\n   real(kind=8), intent(in)      :: ze_bkg\n   character(len=16), intent(in) :: peak_relation\n   real(kind=8), intent(out)     :: peak\n\n\n!  f2py directives ===========================================================\n\n   !f2py character(len=16), intent(in) :: peak_relation\n   !f2py real(kind=8), intent(in)     :: ze_bkg\n   !f2py real(kind=8), intent(out)    :: peak\n\n!  ===========================================================================\n\n\n!  given a background reflectivity value, we determine what the necessary\n!  peakedness (or difference) has to be between a grid point's reflectivity\n!  and the background reflectivity in order for that grid point to be labeled\n!  convective\n\n   if (peak_relation == 'default') then\n\n      if (ze_bkg < 0.d0) then\n         peak = 10.d0\n      elseif (ze_bkg >= 0.d0 .and. ze_bkg < 42.43d0) then\n         peak = 10.d0 - ze_bkg**2 / 180.d0\n      else\n         peak = 0.d0\n      endif\n      \n   elseif (peak_relation == 'sgp') then\n\n      if (ze_bkg < 0.d0) then\n         peak = 14.d0\n      elseif (ze_bkg >= 0.d0 .and. ze_bkg < 42.43d0) then\n         peak = 14.d0 - ze_bkg**2 / 180.d0\n      else\n         peak = 4.d0\n      endif\n      \n   else\n\n      stop\n\n   endif\n\n   return\n\nend subroutine peakedness\n"}, {"instruction": "Write a Fortran subroutine named c_get_global_int to retrieve a global integer value using the C binding. The subroutine should take 1 input parameter of type character(kind=c_char) and 1 output parameter of type integer(kind=c_int64_t).", "input": "", "output": "        subroutine c_get_global_int(name, val) bind(c)\n            use iso_c_binding\n            implicit none\n            character(kind=c_char), intent(in)::name(*)\n            integer(kind=c_int64_t), intent(out)::val\n        end subroutine c_get_global_int\n"}, {"instruction": "Write a Fortran subroutine named dist to calculate the Euclidean distance between two n-dimensional points. The subroutine takes 2 input parameters of type real*8, dimension(:) and 1 output parameter of type real*8.", "input": "", "output": "subroutine dist(x, y, d)\n\n   implicit none\n\n   real*8, dimension(:), intent(in) :: x\n   real*8, dimension(:), intent(in) :: y\n   real*8, intent(out) :: d\n   \n   d = sqrt(sum((x - y)**2))\n\nend subroutine dist\n"}, {"instruction": "Write a Fortran subroutine named readval_l that checks whether a specific substring, specified by the 'name' parameter, exists within the input string 'string'. The subroutine takes 2 input parameters of type character(len=*) and 1 output parameter of type logical. The number and type of input parameters is ['character(len=*)', 'character(len=*)'], and the number and type of output parameters is ['logical'].", "input": "", "output": "  subroutine readval_l(string, name, value)\n\n    implicit none\n\n    character(len=*), intent(in)  :: string, name\n    logical,          intent(out) :: value\n\n    integer :: i\n\n    i = index(string, trim(name))\n    if (i == 0) then\n       value = .false.\n    else\n       value = .true.\n    end if\n\n  end subroutine readval_l\n"}, {"instruction": "Create a Fortran subroutine named foobar. The subroutine takes 2 optional integer input parameters and 1 integer output parameter. The purpose of the subroutine is to assign the value of 1 to the output parameter.", "input": "", "output": "  elemental subroutine foobar (b1,b2,b3)\n    integer, intent(out)           :: b1\n    integer, optional, intent(in)  :: b2, b3\n    b1 = 1\n  end subroutine foobar\n"}, {"instruction": "Create a Fortran subroutine named fitparabola to calculate the coefficients (a, b, c) and the chi-squared value of a parabola that best fits the given data points. The subroutine takes 3 input parameters of type real*8, real*8, and integer, representing the x-coordinates, y-coordinates, and the number of data points respectively. It also has 4 output parameters of type real*8, real*8, real*8, and real*8, representing the coefficients a, b, c, and the chi-squared value respectively.", "input": "", "output": "subroutine fitparabola(a, b, c, chi2, xw, fw, n)\n  implicit none\n  real*8, intent(out) :: a, b, c, chi2\n  real*8, intent(in)  :: xw(n), fw(n)\n  integer, intent(in) :: n\n  ! locals\n  real*8 :: s, sx, sxx, sxxx, sxxxx, sy, sxy, sxxy, x, y, den\n  integer :: i\n  do i=1,n\n     x = xw(i)\n     y = fw(i)\n     s     = s    + 1\n     sx    = sx   + x\n     sxx   = sxx  + x*x\n     sxxx  = sxxx + x*x*x\n     sxxxx = sxxxx+ x*x*x*x\n     sy    = sy   + y\n     sxy   = sxy  + x*y\n     sxxy  = sxxy + x*x*y\n  enddo\n  den = sxx**3 + s*sxxx**2 + sx**2*sxxxx - sxx*(2*sx*sxxx + s*sxxxx)\n  a = (sxx**2*sxxy - sx*sxxx*sxxy + sx*sxxxx*sxy + sxxx**2*sy -  sxx*(sxxx*sxy + sxxxx*sy))/den\n  b = (-sx*sxx*sxxy + s*sxxx*sxxy + sxx**2*sxy - s*sxxxx*sxy - sxx*sxxx*sy +  sx*sxxxx*sy)/den\n  c = (sx**2*sxxy - s*sxx*sxxy + s*sxxx*sxy + sxx**2*sy -  sx*(sxx*sxy + sxxx*sy))/den\n  \n  chi2=0\n  do i=1,n\n     chi2 = chi2 + (a+b*xw(i)+c*xw(i)*xw(i) - fw(i))**2\n  enddo\n  chi2 = chi2/n\nend subroutine fitparabola\n"}, {"instruction": "Write a Fortran subroutine named cardano to solve a cubic equation using Cardano's formula. The number of input parameters is 3, the test_data type is ['complex(8)', 'complex(8)', 'complex(8)']. The number of output parameters is 1, the test_data type is ['complex(8)'].", "input": "", "output": "  subroutine cardano(a,b,c,x)\n    !3\u6b21\u65b9\u7a0b\u5f0f\u3092\u30ab\u30eb\u30c0\u30ce\u306e\u516c\u5f0f\u306b\u3088\u308a\u89e3\u304f\n    !x**3 + a*x**2 + b*x + c = 0\n    implicit none\n    integer :: i\n    complex(8),intent(in) :: a,b,c\n    complex(8),parameter :: omega = (-1d0 + sqrt(cmplx(-3d0)))/2d0\n    complex(8) :: u,v,p,q,d\n    complex(8),intent(out) :: x(:)\n\n    p = b/3d0 - a**2/9d0\n    q = c/2d0 + a**3/27d0 -a*b/6d0\n    d = q**2+p**3\n    u = (-cmplx(q) + sqrt(cmplx(d)))**(1d0/3d0)\n\n    if(abs(u) /= 0.0d0) then\n      !uv = -p\n      v = -cmplx(p)/u\n\n      x(1) = u + v -cmplx(a)/3.0d0\n      x(2) = u*omega + v*omega**2 -cmplx(a)/3.0d0\n      x(3) = u*omega**2 + v*omega -cmplx(a)/3.0d0\n    else\n      v = (-cmplx(2*q))**(1.0d0/3.0d0)\n\n      x(1) = v -cmplx(a)/3.0d0\n      x(2) = v*omega -cmplx(a)/3.0d0\n      x(3) = v*omega**2 -cmplx(a)/3.0d0\n    endif\n  end subroutine cardano\n"}, {"instruction": "Create a Fortran subroutine named prep_netcdf_ocn_w to prepare ocean data for netCDF format. The subroutine takes 6 input parameters of types (integer, integer, integer, real, integer, real) and 1 output parameter of type real. The subroutine processes the input data to generate ocean data suitable for netCDF format and assigns the result to the output parameter.", "input": "", "output": "  subroutine prep_netcdf_ocn_w(maxi, maxj, maxk, data_i, data_o, iland, scale)\n    implicit none\n    integer, intent(in) ::maxi, maxj, maxk\n    real, intent(in) :: data_i(3,0:maxi,0:maxj,1:maxk)\n    real, intent(out) :: data_o(maxi, maxj, maxk+1)\n    integer, intent(in) :: iland(0:maxi+1,0:maxj+1)\n    real, intent(in) :: scale\n\n    integer :: i, j, k\n\n    do k = 1, maxk\n       do j = 1, maxj\n          do i = 1, maxi\n             if (iland(i,j) >= 90 .or. iland(i,j) > (maxk+1-k)) then\n                data_o(i,j,k) = -99999.0\n             else\n                data_o(i,j,k) = real(scale * data_i(3,i,j,maxk+1-k))\n             end if\n          end do\n       end do\n    end do\n    data_o(1:maxi,1:maxj,maxk+1) = -99999.0\n  end subroutine prep_netcdf_ocn_w\n"}, {"instruction": "Create a Fortran subroutine named twodee_tracer2 to process two-dimensional temperature data and land mask values. The subroutine takes 5 input parameters of types real, integer, integer, integer, and real, and has 1 output parameter of type real. This subroutine uses a where construct to assign values to the output parameter based on the land mask values.", "input": "", "output": "  subroutine twodee_tracer2(temper, temp1, maxi, maxj, iland, scale)\n    implicit none\n    real, intent(in) :: temper(maxi, maxj)\n    real, intent(out) :: temp1(maxi,maxj)\n    integer, intent(in) :: maxi, maxj\n    integer, intent(in) :: iland(0:maxi+1,0:maxj+1)\n    real, intent(in) :: scale\n\n    where (iland(1:maxi,1:maxj) >= 90)\n       temp1 = -99999.0\n    elsewhere\n       temp1 = real(scale * temper)\n    end where\n  end subroutine twodee_tracer2\n"}, {"instruction": "Create a Fortran subroutine named is_equal_arr to compare two real arrays for equality. The subroutine takes 3 input parameters of types integer, real(8) array, and real(8) array, and 1 output parameter of type logical. The subroutine checks if the elements of the two arrays are equal within a tolerance of 1e-4 and sets the output parameter accordingly.", "input": "", "output": "subroutine is_equal_arr(a, b, n, ans)\n    integer, intent(in) :: n\n    real(8), intent(in) ::a(n), b(n)\n    logical, intent(out) :: ans\n    integer :: i\n    real(8) :: tol = 1e-4\n    ans = .true.\n    \n    do i=1, n\n        if (abs(a(i)- b(i)) .ge. tol ) then\n            ans = .false.\n            return\n        end if\n    enddo\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"randos\" to generate an array of random numbers using the Marsaglia shift sequence algorithm. The subroutine takes 2 input parameters of type integer and produces 1 output parameter of type integer array. The input parameters are the seed and the number of random numbers to generate, and the output parameter is the array of generated random numbers.", "input": "", "output": "subroutine randos(seed,n,ys)\n    !grows a single seed into an array of seeds\n    implicit none\n    integer, intent(in) :: seed\n    integer, intent(in) :: n\n    integer, intent(out) :: ys(1:n)\n    integer :: i,y\n\n    !initialize\n    y = ieor(777755555,abs(seed))\n    !fill the array ys using marsaglia shift sequence with period 2**32 \u2212 1.\n    do i = 1,n\n        y = ieor( y , ishft(y,13) ) \n        y = ieor( y , ishft(y,-17) )\n        y = ieor( y , ishft(y,5) )\n        ys(i) = y\n    end do\nend subroutine randos\n"}, {"instruction": "Write a Fortran subroutine named get_xgwg that computes the Gauss-Legendre ordinates and weights on an interval. The number of input parameters is 3: an integer n, and two double precision numbers x1 and x2. The output parameters are two double precision arrays x and w, both of dimension n.", "input": "", "output": "subroutine get_xgwg(x1, x2, x, w, n)\n    ! gauleg.f90     p145 numerical recipes in fortran\n    ! compute x(i) and w(i)  i=1,n  gauss-legendre ordinates and weights\n    ! on interval -1.0 to 1.0 (length is 2.0)\n    ! use ordinates and weights for gauss legendre integration\n    ! after f2py implicit argument wrapping: x, w = get_xgwg(x1, x2, n)\n  implicit none\n  integer, intent(in) :: n\n  double precision, intent(in) :: x1, x2\n  double precision, dimension(n), intent(out) :: x, w\n  integer :: i, j, m\n  double precision :: p1, p2, p3, pp, xl, xm, z, z1\n  double precision, parameter :: eps=1.d-15\n\n  m = (n+1)/2\n  xm = 0.5d0*(x2+x1)\n  xl = 0.5d0*(x2-x1)\n  do i=1,m\n    z = cos(3.141592654d0*(i-0.25d0)/(n+0.5d0))\n    z1 = 0.d0\n    do while(abs(z-z1) > eps)\n      p1 = 1.0d0\n      p2 = 0.0d0\n      do j=1,n\n        p3 = p2\n        p2 = p1\n        p1 = ((2.0d0*j-1.0d0)*z*p2-(j-1.0d0)*p3)/j\n      end do\n      pp = n*(z*p1-p2)/(z*z-1.0d0)\n      z1 = z\n      z = z1 - p1/pp\n    end do\n    x(i) = xm - xl*z\n    x(n+1-i) = xm + xl*z\n    w(i) = (2.0d0*xl)/((1.0d0-z*z)*pp*pp)\n    w(n+1-i) = w(i)\n  end do\nend subroutine get_xgwg\n"}, {"instruction": "Create a Fortran subroutine named \"dhdt_vert_diff\" to calculate the vertical diffusive mass fluxes. The subroutine takes 9 input parameters of type ['double precision', 'double precision', 'integer', 'integer', 'integer', 'integer', 'integer', 'integer', 'logical'] and returns 1 output parameter of type ['double precision']. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes to specify the direction of data flow for each parameter.", "input": "", "output": "  subroutine dhdt_vert_diff(dhdt_kv, h, kv, xlow, xhigh, ylow, yhigh, layers, ol, redgrav)\n    implicit none\n\n    ! dhdt is evaluated at the centre of the grid box\n    double precision, intent(out) :: dhdt_kv(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: h(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: kv\n    integer, intent(in) :: xlow, xhigh, ylow, yhigh, layers, ol\n    logical, intent(in) :: redgrav\n\n    integer i, j, k\n\n    dhdt_kv = 0d0\n\n    ! calculate vertical diffusive mass fluxes\n    ! only evaluate vertical mass diff flux if more than 1 layer, or reduced gravity\n    if (layers .eq. 1) then\n      if (redgrav) then\n        do j = ylow, yhigh\n          do i = xlow, xhigh\n            dhdt_kv(i,j,1) = kv/h(i,j,1)\n          end do\n        end do\n      end if\n    else if (layers .gt. 1) then\n      ! if more than one layer, need to have multiple fluxes\n      do k = 1, layers\n        do j = ylow, yhigh\n          do i = xlow, xhigh\n            if (k .eq. 1) then ! in top layer\n              dhdt_kv(i,j,k) = kv/h(i,j,k) - kv/h(i,j,k+1)\n            else if (k .eq. layers) then ! bottom layer\n              dhdt_kv(i,j,k) = kv/h(i,j,k) - kv/h(i,j,k-1)\n            else ! mid layer/s\n              dhdt_kv(i,j,k) = 2d0*kv/h(i,j,k) -  &\n                  kv/h(i,j,k-1) - kv/h(i,j,k+1)\n            end if\n          end do\n        end do\n      end do\n    end if\n\n    return\n  end subroutine dhdt_vert_diff\n"}, {"instruction": "Write a Fortran subroutine named \"epade\" to calculate the value of the Pad\u00e9 approximant at given complex points. The subroutine takes 2 input parameters of type complex(kind=16) for points in the complex plane and Pad\u00e9 coefficients, and 1 output parameter of type complex(kind=16) for the values of the Pad\u00e9 approximant at the given points.", "input": "", "output": "subroutine epade(z,x,f)\n    ! returns the value of the pad\u00e9 approximant at the points z.\n    implicit none\n    complex(kind=16),intent(in) :: z(:)  ! points in the complex plane\n    complex(kind=16),intent(in) :: x(:)  ! pade coefficients\n    complex(kind=16),intent(out) :: f(:) ! values of the pade approximant at the points z.\n    integer :: i,r\n    complex(kind=16),allocatable :: num(:),denum(:)\n    r = size(x)/2\n    allocate(num(size(z)),denum(size(z)))\n    num = 0q0\n    denum = 0q0\n    do i=1,r\n        num = num + x(i)*z**(i-1)\n        denum = denum + x(r+i)*z**(i-1)\n    enddo  \n    denum = denum + z**r\n    f = num/denum\n    deallocate(num,denum)\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named exist_netcdf_file to check the existence of a specified file. The subroutine should take 1 input parameter with test_data type ['character(*)'] to represent the file name, and 1 output parameter with test_data type ['logical'] to indicate the existence of the file. Use the imperative tone in your instructions.", "input": "", "output": "        subroutine exist_netcdf_file(ncfname, l_exist)\n            character(*), intent(in)  :: ncfname\n            logical,      intent(out) :: l_exist\n\n            ! check whether file exists\n            inquire(file=ncfname, exist=l_exist)\n        end subroutine exist_netcdf_file\n"}, {"instruction": "Write a Fortran subroutine named readvelocityk to read and process optics matrix elements. The subroutine takes 2 input arguments of type integer and 3 output arguments of type complex*16, integer, and integer.", "input": "", "output": "subroutine readvelocityk(vel, ne, fh_m, nb_min, nb_max)!, nemin, nbands)\n  implicit none\n  complex*16, intent(out) :: vel(ne,ne,3)\n  integer, intent(out) :: nb_min, nb_max\n  integer, intent(in) :: fh_m, ne!, nemin, nbands\n  ! locals\n  integer      :: iikp, i1, i2, ib1, ib2, ixyz\n  real*8       :: wemin, wemax, de\n  character*10 :: kname\n  complex*16   :: o(3)\n  \n  vel = 0\n!!! reading optics matrix elements\n  read(fh_m,9010) iikp,nb_min,nb_max,wemin,wemax,kname\n  do i1=nb_min,nb_max\n     do i2=i1,nb_max\n        read(fh_m, 9040) ib1,ib2, o(1), o(2), o(3), de\n        if (i1.ne.ib1 .or. i2.ne.ib2) then\n           print *, 'error', i1, ib1, i2, ib2\n        endif\n        !if (i1.ge.nemin .and. i1.lt.nemin+nbands .and. i2.ge.nemin .and. i2.lt.nemin+nbands) then\n        if (i1.le.ne .and. i2.le.ne) then\n           do ixyz=1,3\n              vel(i1,i2,ixyz) = o(ixyz)\n              if (i2.ne.i1) then\n                 vel(i2,i1,ixyz) = conjg(o(ixyz))\n              endif\n           enddo\n        endif\n     enddo\n  enddo\n  if (nb_max.gt.ne) nb_max = ne\n!9010 format(/,2x,' kp:',i6,' nemin nemax : ',2i5, ' de:',2f5.2,' k:',a10 /)\n9010 format(/,2x,4x,i6,15x,2i5,4x,2f5.2,3x,a10 /)\n9040 format(3x,2i4,6e13.6,f13.8)\nend subroutine readvelocityk\n"}, {"instruction": "Write a Fortran subroutine named functionphieval to calculate the value of a function based on the input parameters. The number of input arguments is 4 and the test_data type is [real, real, real, real]. The number of output arguments is 1 and the test_data type is [real]. The subroutine computes the value of the functionphi using the formula functionphi = ( x + v2*sin(2*(x-psi)) - phi0 ). Use the \"intent(in)\" and \"intent(out)\" attributes to specify the input and output parameters.", "input": "", "output": "      subroutine functionphieval(x, v2, psi, phi0, functionphi)\n        implicit none\n        real, intent(in)  :: x, v2, psi, phi0\n        real, intent(out) :: functionphi\n\n        functionphi = ( x + v2*sin(2*(x-psi)) - phi0 ) \n\n      end subroutine functionphieval\n"}, {"instruction": "Create a Fortran subroutine named tensor_inner_product_3x3 to compute the inner product of two 3x3 tensors. The subroutine should take 2 input parameters of type real(8), dimension(3,3) and an output parameter of type real(8).", "input": "", "output": "        subroutine tensor_inner_product_3x3(a,b,t)\n            \n            implicit none\n            real(8), dimension(3,3), intent(in) :: a, b\n            real(8), intent(out) :: t!, tx\n\n            !tx = sum(sum(a*b,2))\n            \n            t = a(1,1)*b(1,1) + a(1,2)*b(1,2) + a(1,3)*b(1,3) \n            t = t + a(2,1)*b(2,1) + a(2,2)*b(2,2) + a(2,3)*b(2,3)\n            t = t + a(3,1)*b(3,1) + a(3,2)*b(3,2) + a(3,3)*b(3,3)                \n\n        end subroutine\n"}, {"instruction": "Write a Fortran subroutine named \"hencky_1d\" to calculate the first Piola-Kirchhoff stress, the second Piola-Kirchhoff stress, and the strain energy. The subroutine has 3 input parameters of type real(8), and 3 output parameters of type real(8). Ensure the input and output parameters are appropriately labeled and assigned within the subroutine.", "input": "", "output": "        subroutine hencky_1d(mu, etr, ei, dwtr, d2wtr, energye)\n\n            implicit none\n            real(8), intent(in) :: mu, etr(3,1), ei(3,3,3)\n            real(8) :: g, eps(3), vdwtr(3)\n            real(8), intent(out) :: dwtr(3,3), d2wtr(3,3), energye\n\n            eps(:) = 0.d0\n\n            g = mu\n\n            eps=[etr(1,1), etr(2,1), etr(3,1)]\n\n            vdwtr(:) = 2*g*eps(:)\n\n            dwtr(1, 1:3) = [vdwtr(1),    0.0d0,    0.0d0]\n            dwtr(2, 1:3) = [   0.0d0, vdwtr(2),    0.0d0]\n            dwtr(3, 1:3) = [   0.0d0,    0.0d0, vdwtr(3)]\n\n            d2wtr(1, 1:3) = [2*g,    0.0d0,    0.0d0]\n            d2wtr(2, 1:3) = [   0.0d0, 2*g,    0.0d0]\n            d2wtr(3, 1:3) = [   0.0d0,    0.0d0, 2*g]\n\n            energye = g*(eps(1)**2 + eps(2)**2 + eps(3)**2)\n\n        end subroutine\n"}, {"instruction": "Create a Fortran subroutine named entropy_fd to calculate the entropy based on given occupancy data and temperature factor. The subroutine takes 2 input parameters of type real(8) and 1 output parameter of type real(8). The number of input arguments is 2, and the test_data type is [real(8), real(8)]. The number of output arguments is 1, and the test_data type is [real(8)].", "input": "", "output": "  subroutine entropy_fd( eentropy, ekbt, occ )\n    implicit none\n    real(8), intent(out) :: eentropy\n    real(8), intent(in)  :: ekbt\n    real(8), intent(in)  :: occ(:,:,:)\n    real(8) :: factor1,factor2,sf,f,g\n    integer :: n,k,s,nb,nk,ns\n    nb=size(occ,1)\n    nk=size(occ,2)\n    ns=size(occ,3)\n    factor1=ns/2.0d0  ! ns=1: factor1=0.5,  ns=2: factor1=1.0\n    factor2=2.0d0/ns  ! ns=1: factor2=2.0,  ns=2: factor2=1.0\n    eentropy=0.0d0\n    do s=1,ns\n    do k=1,nk\n    do n=1,nb\n       sf=0.0d0\n       f=occ(n,k,s)*factor1\n       if ( f > 0.0d0 ) sf=sf-f*log(f)\n       g=1.0d0-f\n       if ( g > 0.0d0 ) sf=sf-g*log(g)\n       eentropy=eentropy+factor2*ekbt*sf\n    end do\n    end do\n    end do\n  end subroutine entropy_fd\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_n2t\" to stagger a 3D array of non-staggered data to the mass grid of an Arakawa C stagger. The subroutine should have 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real.", "input": "", "output": "  subroutine arakawa_c_n2t(datain, nx, ny, nz, dataout)\n    \n    ! staggers a 3d array of data from the non-staggered points\n    ! to the mass grid of an arakawa c stagger.\n\n    implicit none\n    integer, intent(in)                :: nx\n    integer, intent(in)                :: ny\n    integer, intent(in)                :: nz\n    real, intent(in)                   :: datain(nx,ny,nz)\n    real, intent(out)                  :: dataout(nx,ny,nz)\n   \n    integer                            :: i,j,k\n    print *, 'staggering to t grid (arakawa c)'\n    do k = 1, nz\n      do j = 1, ny-1\n        do i = 1, nx-1\n          dataout(i,j,k) = 0.25 * ( datain(i,j,k)    + &\n                                    datain(i+1,j,k)  + &\n                                    datain(i+1,j+1,k)+ &\n                                    datain(i,j+1,k) )\n        enddo\n        ! fill unused rightmost column\n        dataout(nx,j,k) = dataout(nx-1,j,k)\n      enddo\n      ! fill unused uppermost row\n      dataout(:,ny,k) = dataout(:,ny-1,k)\n    enddo\n    return\n  end subroutine arakawa_c_n2t\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_t2n\" that destaggers a WRF Arakawa C grid from staggered thermodynamic points to non-staggered points. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The input parameters represent the dimensions of the staggered thermodynamic points and the input array, while the output parameter represents the destaggered array. The subroutine returns an array that is one element larger in each direction than the input array.", "input": "", "output": "  subroutine arakawa_c_t2n(datain,nx_t,ny_t,nz,dataout)\n\n    ! destaggers a wrf arakawa c from the staggered thermodynamic\n    ! points to the non-staggered points.   note that this routine\n    ! returns an array that is one element larger in each direction\n    ! than the input array.\n    !\n    !  example:  input 3x3 \"t\" points, return 4x4 \"n\" points\n    !\n    !           n   n   n   n\n    !             t   t   t\n    !           n   n   n   n \n    !             t   t   t\n    !           n   n   n   n\n    !             t   t   t \n    !           n   n   n   n\n\n    implicit none\n\n    integer, intent(in)       :: nx_t\n    integer, intent(in)       :: ny_t    \n    integer, intent(in)       :: nz\n    real, intent(in)          :: datain(nx_t,ny_t,nz)       \n    real, intent(out)         :: dataout(nx_t+1,ny_t+1,nz)   \n\n    integer                   :: i,j,k\n\n    vertical_loop:  do k=1,nz\n\n      ! first, compute all of the interior points\n\n      do j = 2, ny_t\n        do i = 1, nx_t\n\n           dataout(i,j,k) = 0.25*( datain(i-1,j-1,k) + datain(i-1,j,k) + &\n                                  datain(i,j,k) + datain(i,j-1,k) )\n\n        enddo\n      enddo\n\n      ! now, extrapolate upper and lower rows, except corner points\n\n      do i = 2, nx_t\n \n        dataout(i,1,k) = 2.0* dataout(i,2,k)-dataout(i,3,k)\n        dataout(i,ny_t+1,k) = 2.0*dataout(i,ny_t,k)-dataout(i,ny_t-1,k)\n\n      enddo\n\n      ! extrapolate left and right columns, except corner points\n\n      do j = 2, ny_t\n    \n        dataout(1,j,k) = 2.0*dataout(2,j,k)-dataout(3,j,k)\n        dataout(nx_t+1,j,k) = 2.0*dataout(nx_t,j,k)-dataout(nx_t-1,j,k)\n\n      enddo\n\n      ! compute corner point values by solving for 4 point average\n\n      dataout(1,1,k) = 4.0 * datain(1,1,k) - &\n                             dataout(1,2,k) - &\n                             dataout(2,2,k) - &\n                             dataout(2,1,k)\n      dataout(1,ny_t+1,k) = 4.0 * datain(1,ny_t,k) - &\n                                  dataout(1,ny_t,k) - &\n                                  dataout(2,ny_t+1,k) - &\n                                  dataout(2,ny_t,k)\n      dataout(nx_t+1,ny_t+1,k) = 4.0 * datain(nx_t,ny_t,k) - &\n                                       dataout(nx_t,ny_t,k) - &\n                                       dataout(nx_t,ny_t+1,k) - &\n                                       dataout(nx_t+1,ny_t,k)\n      dataout(nx_t+1,1,k) = 4.0 * datain(nx_t,1,k) - &\n                                dataout(nx_t,1,k) - &\n                                dataout(nx_t,2,k) - &\n                                dataout(nx_t+1,2,k)\n\n    enddo vertical_loop       \n    return\n  end subroutine arakawa_c_t2n\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_u2n\" to destagger data from the \"u\" grid to the non-staggered grid. The subroutine takes 4 input parameters of types integer, integer, integer, and real, and returns 1 output parameter of type real. The input parameters represent the dimensions and data of the \"u\" grid, and the output parameter represents the destaggered data on the non-staggered grid.", "input": "", "output": "  subroutine arakawa_c_u2n(datain,nx_u,ny_u,nz,dataout)\n\n    ! destaggers from the wrf \"u\" grid to the non-staggered grid.  the\n    ! return array will be 1 element larger in the y direction than\n    ! the input array.  example:\n    !\n    !   input 4x3 \"u\" grid, return 4x4 \"n\" grid:\n    !\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n    !            u   u   u   u\n    !            n   n   n   n\n\n    implicit none\n\n    integer,  intent(in)   :: nx_u\n    integer,  intent(in)   :: ny_u\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_u,ny_u,nz)\n    real,     intent(out)  :: dataout(nx_u,ny_u+1,nz)\n\n    integer                :: i,k\n    integer                :: nx,ny\n\n    nx = nx_u\n    ny = ny_u+1\n\n    do k = 1, nz\n   \n      ! linear interpolation along each column, except top/bottom rows\n      do i = 1, nx\n   \n        ! average of points above and below to fill interior rows \n        dataout(i,2:ny_u,k) = 0.5*(datain(i,1:ny_u-1,k)+datain(i,2:ny_u,k))\n \n        ! fill bottom row\n        dataout(i,1,k) = 2.0 * dataout(i,2,k) - dataout(i,3,k)\n\n        ! fill top row\n        dataout(i,ny,k) = 2.0 * dataout(i,ny-1,k) - dataout(i,ny-2,k)\n\n      enddo\n    enddo \n    return\n  end subroutine arakawa_c_u2n\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_v2n\" that destaggers the input \"v\" grid data to a non-staggered grid. The subroutine takes 4 input parameters of type ['integer', 'integer', 'integer', 'real'] representing nx_v, ny_v, nz, and datain, and returns 1 output parameter of type ['real'] representing dataout. The subroutine performs linear interpolation and boundary filling to generate the non-staggered grid data.", "input": "", "output": " subroutine arakawa_c_v2n(datain,nx_v,ny_v,nz,dataout)\n\n    ! destaggers from the wrf \"v\" grid to the non-staggered grid.  the\n    ! return array will be 1 element larger in the x direction than\n    ! the input array.  example:\n    !\n    !   input 3x4 \"v\" grid, return 4x4 \"n\" grid:\n    !\n    !            n v n v n v n\n    !           \n    !            n v n v n v n\n    !       \n    !            n v n v n v n\n    !        \n    !            n v n v n v n\n\n    implicit none\n    integer,  intent(in)   :: nx_v\n    integer,  intent(in)   :: ny_v\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_v,ny_v,nz)\n    real,     intent(out)  :: dataout(nx_v+1,ny_v,nz)\n\n    integer                :: j,k\n    integer                :: nx,ny\n\n    nx = nx_v + 1\n    ny = ny_v\n\n    do k = 1, nz\n\n      ! linear interpolation along each row, except left/right columns\n      do j = 1, ny\n\n        ! average of points above and below to fill interior rows \n        dataout(2:nx_v,j,k) = 0.5*(datain(1:nx_v-1,j,k)+datain(2:nx_v,j,k))\n\n        ! fill left column\n        dataout(1,j,k) = 2.0 * dataout(2,j,k) - dataout(3,j,k)\n\n        ! fill top row\n        dataout(nx,j,k) = 2.0 * dataout(nx-1,j,k) - dataout(nx-2,j,k)\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_v2n\n"}, {"instruction": "Create a Fortran subroutine named arakawa_c_v2t to destagger data from the \"v\" grid to the mass grid. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real.", "input": "", "output": " subroutine arakawa_c_v2t(datain,nx_v,ny_v,nz,dataout)\n\n    ! destaggers from the wrf \"v\" grid to the mass grid.  the\n    ! return array will be 1 element smaller in the y direction than\n    ! the input array.  example:\n    !\n    !   input 3x4 \"v\" grid, return 3x3 \"t\" grid:\n    !\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n    !              t   t   t\n    !              v   v   v  \n\n    implicit none\n    integer,  intent(in)   :: nx_v\n    integer,  intent(in)   :: ny_v\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_v,ny_v,nz)\n    real,     intent(out)  :: dataout(nx_v,ny_v-1,nz)\n\n    integer                :: j,k\n    integer                :: nx,ny\n\n    nx = nx_v \n    ny = ny_v - 1\n\n    do k = 1, nz\n\n      ! linear interpolation along each column\n      do j = 1, ny\n\n        dataout(:,j,k) = 0.5*(datain(:,j,k) + datain(:,j+1,k))\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_v2t\n"}, {"instruction": "Create a Fortran subroutine named \"arakawa_c_u2t\" that performs destaggering from the \"u\" grid to the mass grid. The subroutine takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The purpose of the subroutine is to interpolate the input data and store the results in the output array, where the x-dimension of the output array is one element smaller than the input array. The subroutine uses linear interpolation along each row to achieve this.", "input": "", "output": " subroutine arakawa_c_u2t(datain,nx_u,ny_u,nz,dataout)\n\n    ! destaggers from the wrf \"u\" grid to the mass grid.  the\n    ! return array will be 1 element smaller in the x direction than\n    ! the input array.  example:\n    !\n    !   input 4x3 \"u\" grid, return 3x3 \"t\" grid:\n    !\n    !                           \n    !            u t u t u t u\n    !                             \n    !            u t u t u t u\n    !                             \n    !            u t u t u t u\n    !                           \n    implicit none\n    integer,  intent(in)   :: nx_u\n    integer,  intent(in)   :: ny_u\n    integer,  intent(in)   :: nz\n    real,     intent(in)   :: datain(nx_u,ny_u,nz)\n    real,     intent(out)  :: dataout(nx_u-1,ny_u,nz)\n\n    integer                :: i,k\n    integer                :: nx,ny\n\n    nx = nx_u - 1\n    ny = ny_u\n\n    do k = 1, nz\n\n      ! linear interpolation along each row     \n      do i = 1, nx\n\n        dataout(i,:,k) = 0.5*(datain(i,:,k) + datain(i+1,:,k))\n\n      enddo\n    enddo\n    return\n  end subroutine arakawa_c_u2t\n"}, {"instruction": "Write a Fortran subroutine named wlevs2hlevs that vertically destaggers an array from the full w levels to the half levels. The subroutine takes 4 input parameters of types integer, integer, integer, and real. The output parameter is of type real.", "input": "", "output": "  subroutine wlevs2hlevs(datain,nx,ny,nz_in,dataout)\n\n    ! vertically destaggers an array from the full w levels to\n    ! the half levels.  output array is one less in the z dimension\n    ! than the input array\n\n    implicit none\n    integer, intent(in)   :: nx,ny,nz_in\n    real, intent(in)      :: datain(nx,ny,nz_in)\n    real, intent(out)     :: dataout(nx,ny,nz_in-1)\n\n    integer :: k\n\n    do k = 1,nz_in-1\n\n      dataout(:,:,k) = 0.5*(datain(:,:,k)+datain(:,:,k+1))\n  \n    enddo\n    return\n  end subroutine wlevs2hlevs\n"}, {"instruction": "Write a Fortran subroutine named reverse_point_order that takes in four sets of three real numbers representing points p1, p2, p3, p4, and outputs the points p1r, p2r, p3r, p4r in reverse order. The input parameters should be of type real and intent(in), while the output parameters should also be of type real and intent(out).", "input": "", "output": "    subroutine reverse_point_order(p1,p2,p3,p4,p1r,p2r,p3r,p4r)\n\n        ! reverse_points() : reverses the ordering of four points given by p1,p2,p3,p4\n\n        real, intent(in) :: p1(3), p2(3), p3(3), p4(3)\n        real, intent(out) :: p1r(3), p2r(3), p3r(3), p4r(3)\n        real :: temp1(3), temp2(3)\n\n        temp1 = p1\n        temp2 = p2\n\n        p1r = p4\n        p2r = p3\n        p3r = temp2\n        p4r = temp1\n\n    end subroutine reverse_point_order\n"}, {"instruction": "Create a Fortran subroutine named stern to generate the start of a reciprocal vector. The subroutine takes 5 input parameters: g (array of 3 integers), iz (3D array of integers), tau (2D array of real*8), iord (integer), qcomplex (logical). It provides 3 output parameters: nst (integer), stg (2D array of integers), taup (1D array of complex*16).", "input": "", "output": "subroutine stern(g,nst,stg,taup, iz, tau, iord, qcomplex)\n  ! generates the start of reciprocal vector g\n  ! input:\n  !     g(3)           -- reciprocal vector\n  !     iz(3,3,iord)   -- 3x3 matrices for group operations (rotations, reflections...)\n  !     tau(3,iord)    -- vector shifts for non-simmorphic symmetries\n  !     qcomplex       -- calculation is real when inversion is present and there is no spin-orbit. otherwise we work with complex phase factors.\n  ! output:\n  !     nst            -- number of star members\n  !     stg            -- the first star member, i.e., iz*g\n  !     taup           -- sum of phase factors for non-simmorphic symmetries : sum_{star_members=j} e^{2*pi*i*g*tau_j}, otherwise just degeneracy of star member\n  !\n  implicit none\n  !\n  integer, intent(out)      :: nst,stg(3,iord)  \n  complex*16, intent(out)   :: taup(iord)\n  integer, intent(in)       :: g(3)             \n  integer, intent(in)       :: iord\n  integer, intent(in)       :: iz(3,3,iord)\n  real*8, intent(in)        :: tau(3,iord)\n  logical, intent(in)       :: qcomplex\n  ! locals\n  integer :: i, m\n  real*8  :: tk, pi, greal(3)\n  integer :: ind(iord)\n  logical :: foundstarmember\n  !---------------------------------------------------------------------  \n  !\n  pi=acos(-1.d0)\n  nst=0\n  greal(:) = g(:)\n  do i=1,iord\n     tk = dot_product(greal(:),tau(:,i))*2.0d0*pi\n     stg(:,i) = matmul(iz(:,:,i),g(:))\n     foundstarmember=.false.\n     do m=1,nst\n        if( stg(1,m).ne.stg(1,i) .or. stg(2,m).ne.stg(2,i) .or. stg(3,m).ne.stg(3,i) ) cycle\n        ! if we come here, previous stg(:,m) is exactly equal to current stg(:,i). hence stg(:,i) is part of the same star.\n        ind(m)=ind(m)+1\n        if (qcomplex) then\n           taup(m) = taup(m) + dcmplx(cos(tk),sin(tk))\n        else\n           taup(m) = taup(m) + cos(tk)\n        endif\n        foundstarmember=.true.\n     enddo\n\n     if (.not.foundstarmember) then\n        ! we come here only when we start a new star member\n        nst=nst+1            ! next start member started\n        stg(:,nst)=stg(:,i)  ! symmetry related g\n        ind(nst)=1           ! how many members of the star we have\n        if (qcomplex) then\n           taup(nst) = dcmplx(cos(tk),sin(tk))\n        else\n           taup(nst) = cos(tk)\n        endif\n     endif\n  enddo\n\n  taup(1:nst)=taup(1:nst)/ind(1:nst)                                            \n  return                                                            \nend subroutine stern\n"}, {"instruction": "Write a Fortran subroutine named sinedvr to perform calculations related to the discrete variable representation of the sine function. The subroutine takes 2 input parameters of type integer and real*8 and 3 output parameters of type real*8. The subroutine calculates the ketot, fdtot, and points based on the gridpoints and spacing provided. Use the imperative tone in your instructions.", "input": "", "output": "subroutine sinedvr(ketot,fdtot, points,gridpoints,spacing)\n  implicit none\n  integer,intent(in) :: gridpoints\n  real*8,intent(in) :: spacing\n  real*8,intent(out) :: ketot(1-gridpoints:gridpoints-1),points(gridpoints),&\n       fdtot(1-gridpoints:gridpoints-1)\n  integer :: i\n  real*8 ::  mypi\n\n  mypi   = 4d0*atan(1d0)\n\n  do i=1,gridpoints\n     points(i) = i*spacing\n  enddo\n\n  points(:)=points(:)-(points(1)+points(gridpoints))/2d0\n\n  do i=1-gridpoints,gridpoints-1\n     if (i==0) then\n        ketot(i) = mypi**2/3.d0\n        fdtot(i) = 0d0\n     else\n        ketot(i) = 2.d0/real(i,8)**2 * (-1)**(i)\n        fdtot(i) = 1d0/real(i,8) * (-1)**(i)\n     endif\n  enddo\n\n  ketot=ketot/2.d0/spacing**2 \n  fdtot=fdtot/spacing\n\nend subroutine sinedvr\n"}, {"instruction": "Create a Fortran subroutine named quintic_extrap to perform quintic extrapolation on an input array of double precision with dimension (6), and output the result as an array of double precision with dimension (2).", "input": "", "output": "subroutine quintic_extrap(source, dest)\n    implicit none\n    double precision, dimension(6), intent(in) :: source\n    double precision, dimension(2), intent(out) :: dest\n    dest(1) = 21.d0 * source(1) - 70.d0 * source(2) + 105.d0 * source(3)  &\n        - 84.d0 * source(4) + 35.d0 * source(5) - 6.d0 * source(6)\n    dest(2) = 6.d0 * source(1) - 15.d0 * source(2) + 20.d0 * source(3)  &\n        - 15.d0 * source(4) + 6.d0 * source(5) - source(6)\nend subroutine quintic_extrap\n"}, {"instruction": "Create a Fortran subroutine named cosine to calculate the value of c using the input parameters a, b, thetai, and thetaf, which are all real numbers. The output parameter c is also a real number.", "input": "", "output": "subroutine cosine(a,b,thetai,thetaf,c)\n    implicit none\n\n    real, intent(in) :: a,b,thetai,thetaf\n    real, intent(out):: c\n    real:: pi,d2r,dtheta\n\n    !convert to radians\n    pi=4.*atan(1.)\n    dtheta=abs(thetai-thetaf)\n    d2r=(2.*pi)/360.\n    c=sqrt(a*a + b*b - 2.*a*b*cos(dtheta*d2r))\n\nend subroutine cosine\n"}, {"instruction": "Create a Fortran subroutine named fac2mit to calculate the flimit based on the given smcmax value. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter is specified with the intent(in) attribute, and the output parameter is specified with the intent(out) attribute. The flimit value is calculated based on the conditions specified in the subroutine.", "input": "", "output": "  subroutine fac2mit(smcmax,flimit)\n    implicit none\n    real, intent(in) :: smcmax\n    real, intent(out) :: flimit\n    flimit = 0.90\n    if ( smcmax == 0.395 ) then\n       flimit = 0.59\n    else if ( ( smcmax == 0.434 ) .or. ( smcmax == 0.404 ) ) then\n       flimit = 0.85\n    else if ( ( smcmax == 0.465 ) .or. ( smcmax == 0.406 ) ) then\n       flimit = 0.86\n    else if ( ( smcmax == 0.476 ) .or. ( smcmax == 0.439 ) ) then\n       flimit = 0.74\n    else if ( ( smcmax == 0.200 ) .or. ( smcmax == 0.464 ) ) then\n       flimit = 0.80\n    endif\n  end subroutine fac2mit\n"}, {"instruction": "Create a Fortran subroutine named frh2o to calculate the free water content based on input parameters. The subroutine takes 6 input parameters of type real: bexp, psis, sh2o, smc, smcmax, and tkelv. It returns 1 output parameter of type real: free.", "input": "", "output": "      subroutine frh2o (free,tkelv,smc,sh2o,smcmax,bexp,psis)\n      implicit none\n      real, intent(in) :: bexp,psis,sh2o,smc,smcmax,tkelv\n      real, intent(out) :: free\n      real :: bx,denom,df,dswl,fk,swl,swlk\n      integer :: nlog,kcount\n      real, parameter :: ck = 8.0, blim = 5.5, error = 0.005, &\n                              hlice = 3.335e5, gs = 9.81,dice = 920.0, &\n                              dh2o = 1000.0, t0 = 273.15\n      bx = bexp\n      if (bexp > blim) bx = blim\n      nlog = 0\n      kcount = 0\n      if (tkelv > (t0- 1.e-3)) then\n          free = smc\n      else\n         if (ck /= 0.0) then\n            swl = smc - sh2o\n            if (swl > (smc -0.02)) swl = smc -0.02\n            if (swl < 0.) swl = 0.\n 1001 continue\n              if (.not.( (nlog < 10) .and. (kcount == 0))) goto 1002\n              nlog = nlog +1\n              df = alog ( ( psis * gs / hlice ) * ( ( 1. + ck * swl )**2.) * &\n                   ( smcmax / (smc - swl) )** bx) - alog ( - ( &\n                   tkelv - t0)/ tkelv)\n              denom = 2. * ck / ( 1. + ck * swl ) + bx / ( smc - swl )\n              swlk = swl - df / denom\n              if (swlk > (smc -0.02)) swlk = smc - 0.02\n              if (swlk < 0.) swlk = 0.\n              dswl = abs (swlk - swl)\n              swl = swlk\n              if ( dswl <= error ) then\n                    kcount = kcount +1\n              end if\n           goto 1001\n 1002 continue\n           free = smc - swl\n         end if\n         if (kcount == 0) then\n             print *,'flerchinger used in new version. iterations=',nlog\n                  fk = ( ( (hlice / (gs * ( - psis)))* &\n                       ( (tkelv - t0)/ tkelv))** ( -1/ bx))* smcmax\n             if (fk < 0.02) fk = 0.02\n             free = min (fk, smc)\n         end if\n      end if\n  end subroutine frh2o\n"}, {"instruction": "Create a Fortran subroutine named snowz0 to calculate the roughness length for momentum and scalar transfer over snow-covered and non-snow-covered surfaces.\nThe subroutine takes 7 input parameters of type real, real, real, logical, real, real, real and returns 1 output parameter of type real.", "input": "", "output": "      subroutine snowz0 (sncovr,z0, z0brd, snowh,fbur,fgsn,shdmax,ua_phys)\n      implicit none\n      real, intent(in) :: sncovr, z0brd\n      real, intent(out) :: z0\n      real, parameter :: z0s=0.001\n      real, intent(in) :: snowh\n      real :: burial\n      real :: z0eff\n      logical, intent(in) :: ua_phys\n      real, intent(in) :: fbur\n      real, intent(in) :: fgsn\n      real, intent(in) :: shdmax\n      real, parameter :: z0g=0.01\n      real :: fv,a1,a2\n      if(ua_phys) then\n          fv = shdmax * (1.-fbur)\n          a1 = (1.-fv)**2*((1.-fgsn**2)*log(z0g) + (fgsn**2)*log(z0s))\n          a2 = (1.-(1.-fv)**2)*log(z0brd)\n          z0 = exp(a1+a2)\n      else\n          burial = 7.0*z0brd - snowh\n          if(burial.le.0.0007) then\n              z0eff = z0s\n          else\n              z0eff = burial/7.0\n          endif\n          z0 = (1.- sncovr)* z0brd + sncovr * z0eff\n      endif\n  end subroutine snowz0\n"}, {"instruction": "Create a Fortran subroutine named tdfcnd to calculate the value of df based on the input parameters qz, smc, smcmax, and sh2o, which are all real numbers. The subroutine takes 4 input parameters (real, real, real, real) and returns 1 output parameter (real).", "input": "", "output": "      subroutine tdfcnd ( df, smc, qz, smcmax, sh2o)\n      implicit none\n      real, intent(in) :: qz, smc, smcmax, sh2o\n      real, intent(out) :: df\n      real :: ake, gammd, thkdry, thkice, thko, &\n                                   thkqtz,thksat,thks,thkw,satratio,xu, &\n                                   xunfroz\n      satratio = smc / smcmax\n      thkice = 2.2\n      thkw = 0.57\n      thko = 2.0\n      thkqtz = 7.7\n      thks = (thkqtz ** qz)* (thko ** (1. - qz))\n      xunfroz = sh2o / smc\n      xu = xunfroz * smcmax\n      thksat = thks ** (1. - smcmax)* thkice ** (smcmax - xu)* thkw ** &\n         (xu)\n      gammd = (1. - smcmax)*2700.\n      thkdry = (0.135* gammd+ 64.7)/ (2700. - 0.947* gammd)\n      if ( (sh2o + 0.0005) < smc ) then\n         ake = satratio\n      else\n         if ( satratio > 0.1 ) then\n            ake = log10 (satratio) + 1.0\n         else\n            ake = 0.0\n         end if\n      end if\n      df = ake * (thksat - thkdry) + thkdry\n  end subroutine tdfcnd\n"}, {"instruction": "Write a Fortran subroutine named bmat_nonaxi to handle axisymmetric solids under non-axisymmetric loading. The subroutine takes 5 input parameters of type real(iwp), real(iwp), real(iwp), integer, and integer, and 2 output parameters of type real(iwp).", "input": "", "output": "subroutine bmat_nonaxi(bee,radius,coord,deriv,fun,iflag,lth)\n!\n\n! axisymmetric solids subjected to non-axisymmetric loading.\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::deriv(:,:),fun(:),coord(:,:)\n real(iwp),intent(out)::bee(:,:),radius\n integer,intent(in)::iflag,lth\n integer::nod,k,l,m,n\n nod=ubound(deriv,2) \n bee=0.0_iwp\n radius=sum(fun*coord(:,1))\n do m=1,nod\n   n=3*m      \n   k=n-1      \n   l=k-1\n   bee(1,l)=deriv(1,m)\n   bee(2,k)=deriv(2,m)\n   bee(3,l)=fun(m)/radius\n   bee(3,n)=iflag*lth*bee(3,l) \n   bee(4,l)=deriv(2,m)\n   bee(4,k)=deriv(1,m)\n   bee(5,k)=-iflag*lth*fun(m)/radius \n   bee(5,n)=deriv(2,m)\n   bee(6,l)=bee(5,k) \n   bee(6,n)=deriv(1,m)-fun(m)/radius\n end do\nreturn\nend subroutine bmat_nonaxi\n"}, {"instruction": "Create a Fortran subroutine named qadd that takes two input arrays of real(kind=8) type, with dimensions of [:, :] and [size(a, 1), size(a, 2)], and one output array of real(kind=8) type with dimensions [size(a, 1), size(a, 2)]. The subroutine computes the sum of the two input arrays element-wise and stores the result in the output array.", "input": "", "output": "subroutine qadd(a, b, output)\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(out) :: output\n\n  output = a + b\nend subroutine qadd\n"}, {"instruction": "Write a Fortran subroutine named qnorm to calculate the normalized vectors from an input array of vectors. The number of input arguments is 1 and the test_data type is ['real(kind=8), dimension(:, :)']. The number of output arguments is 1 and the test_data type is ['real(kind=8), dimension(size(q, 1), size(q, 2))'].", "input": "", "output": "subroutine qnorm(q, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), size(q, 2)), intent(out) :: output\n  real(kind=8) :: curnorm\n  integer :: i\n\n  do i = 1, size(q, 1)\n     curnorm = sqrt(dot_product(q(i, 1:4), q(i, 1:4)))\n     if (curnorm .gt. 0.0) then\n        output(i, :) = q(i, :) / curnorm\n     else\n        output(i, :) = 0.0\n     endif\n  enddo\nend subroutine qnorm\n"}, {"instruction": "Create a Fortran subroutine named qmul that takes two input parameters and one output parameter. The input parameters are of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(a, 1), size(a, 2)), while the output parameter is of type real(kind=8), dimension(size(a, 1), size(a, 2)). The subroutine performs quaternion multiplication for each row of the input matrices a and b and stores the results in the output matrix.", "input": "", "output": "subroutine qmul(a, b, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(out) :: output\n  integer :: i\n\n  do i = 1, size(a, 1)\n     output(i, 1) = a(i, 1) * b(i, 4) + a(i, 4) * b(i, 1) + a(i, 2) * b(i, 3) - a(i, 3) * b(i, 2)\n     output(i, 2) = a(i, 2) * b(i, 4) + a(i, 4) * b(i, 2) + a(i, 3) * b(i, 1) - a(i, 1) * b(i, 3)\n     output(i, 3) = a(i, 3) * b(i, 4) + a(i, 4) * b(i, 3) + a(i, 1) * b(i, 2) - a(i, 2) * b(i, 1)\n     output(i, 4) = a(i, 4) * b(i, 4) - a(i, 1) * b(i, 1) - a(i, 2) * b(i, 2) - a(i, 3) * b(i, 3)\n  enddo\n\nend subroutine qmul\n"}, {"instruction": "Create a Fortran subroutine named qfromaxisangle to calculate the quaternion from the axis-angle representation. The subroutine takes 2 input parameters of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(axes, 1)), and 1 output parameter of type real(kind=8), dimension(size(axes, 1), 4).", "input": "", "output": "subroutine qfromaxisangle(axes, angles, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: axes\n  real(kind=8), dimension(size(axes, 1)), intent(in) :: angles\n  real(kind=8), dimension(size(axes, 1), 4), intent(out) :: output\n\n  integer :: i\n  real(kind=8) :: sinangle\n  real(kind=8) :: cosangle\n\n  do i = 1, size(axes, 1)\n     sinangle = sin(angles(i) / 2)\n     cosangle = cos(angles(i) / 2)\n     output(i, 1:3) = sinangle * axes(i, :)\n     output(i, 4) = cosangle\n  enddo\nend subroutine qfromaxisangle\n"}, {"instruction": "Create a Fortran subroutine called \"qtoaxisangle\" that takes an input array of real numbers with kind=8 and dimensions(:, :) and returns two output arrays of real numbers with kind=8 and dimensions(size(q, 1), 3) and dimensions(size(q, 1)). The subroutine computes the axes and angles from the input quaternion array and assigns the results to the output arrays. Use an imperative tone to create the subroutine.", "input": "", "output": "subroutine qtoaxisangle(q, axes, angles)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), 3), intent(out) :: axes\n  real(kind=8), dimension(size(q, 1)), intent(out) :: angles\n\n  integer :: idx\n\n  do idx = 1, size(q, 1)\n     angles(idx) = 2 * acos(q(idx, 4))\n     if (angles(idx) == 0.0) then\n        axes(idx, :) = 0.0\n     else\n        axes(idx, :) = q(idx, 1:3) / sin(angles(idx) / 2.0)\n     endif\n  end do\n\nend subroutine qtoaxisangle\n"}, {"instruction": "Create a Fortran subroutine named qinvrot to calculate the inverse rotation of a quaternion matrix. The subroutine takes 1 input parameter of type real(kind=8), dimension(:, :). The output is 1 parameter of type real(kind=8), dimension(size(q, 1), size(q, 2)). Use the imperative tone.", "input": "", "output": "subroutine qinvrot(q, output)\n  implicit none\n  \n  real(kind=8), dimension(:, :), intent(in) :: q\n  real(kind=8), dimension(size(q, 1), size(q, 2)), intent(out) :: output\n\n  integer :: idx\n\n  do idx = 1, size(q, 1)\n    output(idx, 1:3) = -q(idx, 1:3)\n    output(idx, 4) = q(idx, 4)\n  enddo\nend subroutine qinvrot\n"}, {"instruction": "Write a Fortran subroutine named qrotate to perform quaternion rotation on a vector. The subroutine takes 2 input parameters of type real(kind=8), dimension(:, :) and real(kind=8), dimension(size(vec, 1), 4), and 1 output parameter of type real(kind=8), dimension(size(vec, 1), size(vec, 2)). The subroutine compute the expression output = inv(quat) * (vec * quat) and uses the imperative tone.", "input": "", "output": "subroutine qrotate(vec, quat, output)\n  implicit none\n\n  real(kind=8), dimension(:, :), intent(in) :: vec\n  real(kind=8), dimension(size(vec, 1), 4), intent(in) :: quat\n  real(kind=8), dimension(size(vec, 1), size(vec, 2)), intent(out) :: output\n\n  ! the computation is the following (in symbols):\n  !     output = inv(quat) * (vec * quat)\n  ! we use \"tmpq\" to store the value of \"vec * quat\"\n  real(kind=8), dimension(4) :: tmpq\n  real(kind=8), dimension(4) :: invq\n  integer :: i\n\n  do i = 1, size(vec, 1)\n     invq(1:3) = -quat(i, 1:3)\n     invq(4) = quat(i, 4)\n\n     ! this code is like \"qmul\", but it assumes that \"vec\" is an array of\n     ! 3-element vector instead of an array of 4-element quaternions: so a few\n     ! terms can be safely dropped (vec(i, 4) is always zero!)\n     tmpq(1) =  vec(i, 1) * invq(4) + vec(i, 2) * invq(3) - vec(i, 3) * invq(2)\n     tmpq(2) =  vec(i, 2) * invq(4) + vec(i, 3) * invq(1) - vec(i, 1) * invq(3)\n     tmpq(3) =  vec(i, 3) * invq(4) + vec(i, 1) * invq(2) - vec(i, 2) * invq(1)\n     tmpq(4) = -vec(i, 1) * invq(1) - vec(i, 2) * invq(2) - vec(i, 3) * invq(3)\n\n     ! this code is again like \"qmul\", but we drop the last term, as we are\n     ! only interested in the \"vector\" part of the computation (i.e., the first\n     ! three elements of the \"output(i, :)\" quaternion)\n     output(i, 1) = quat(i, 1) * tmpq(4) + quat(i, 4) * tmpq(1) &\n         + quat(i, 2) * tmpq(3) - quat(i, 3) * tmpq(2)\n     output(i, 2) = quat(i, 2) * tmpq(4) + quat(i, 4) * tmpq(2) &\n         + quat(i, 3) * tmpq(1) - quat(i, 1) * tmpq(3)\n     output(i, 3) = quat(i, 3) * tmpq(4) + quat(i, 4) * tmpq(3) &\n         + quat(i, 1) * tmpq(2) - quat(i, 2) * tmpq(1)\n  enddo\nend subroutine qrotate\n"}, {"instruction": "Create a Fortran subroutine named lint1u that performs linear interpolation. The subroutine takes 7 input parameters of types ['integer', 'real (kind=8)', 'integer', 'integer', 'real (kind=8)', 'integer', 'integer'], and 1 output parameter of type ['real (kind=8)']. The subroutine uses the imperative tone to linearly interpolate and assign values to the output parameter q based on the input parameters p, ix, dx, inmx, and isubx.", "input": "", "output": "    subroutine lint1u(nx,p,mx,q,ix,dx,inmx,isubx)\n\n    implicit none\n    integer, intent(in)                      :: nx\n    real (kind=8), intent(in)                :: p(nx)\n    integer, intent(in)                      :: mx\n    real (kind=8), intent(out)               :: q(mx)\n    integer, intent(in)                      :: ix(mx)\n    real (kind=8), intent(in)                :: dx(mx)\n    integer, intent(in)                      :: inmx\n    integer, intent(in)                      :: isubx\n    integer :: i,ii\n\n\n    if (isubx == 1) then\n      \n    !     mx grid is subset of nx grid so q can be set directly\n      \n      do ii=1,mx\n        i = inmx*(ii-1)+1\n        q(ii) = p(i)\n      end do\n      return\n    else\n      \n    !     linearly interpolate\n      \n      do ii=1,mx\n        i = ix(ii)\n        q(ii) = p(i)+dx(ii)*(p(i+1)-p(i))\n      end do\n      return\n    end if\n    end subroutine lint1u\n"}, {"instruction": "Create a Fortran subroutine named linmxu to set linear interpolation terms. It takes 2 input parameters of type integer and returns 2 output parameters, one of type integer and the other of type real (kind=8).", "input": "", "output": "    subroutine linmxu(nx,mx,ix,dx)\n\n    !     set linear interpolation terms\n\n\n    implicit none\n    integer, intent(in)                      :: nx\n    integer, intent(in)                      :: mx\n    integer, intent(out)                     :: ix(mx)\n    real (kind=8), intent(out)               :: dx(mx)\n    integer :: i,ii\n    real (kind=8) :: dnx,dmx,x,xx\n\n    !     set \"virtual\" uniform increments\n\n    dnx = 1.0/(nx-1)\n    dmx = 1.0/(mx-1)\n\n    !     set ix(ii) = i  s.t. i,i+1 can interpolate for ii\n\n    do ii=1,mx\n      xx = (ii-1)*dmx\n      ix(ii) = min0(int(xx/dnx)+1,nx-1)\n      \n    !     set scale term for linear\n      \n      i = ix(ii)\n      x = (i-1)*dnx\n      dx(ii) = (xx-x)/dnx\n    end do\n    return\n    end subroutine linmxu\n"}, {"instruction": "Write a Fortran subroutine named cubnmxu to calculate cubic interpolation terms. The subroutine takes 2 input parameters of type integer, nx and mx. It returns 5 output parameters of type integer (ix) and real (kind=8) (dxm, dx, dxp, dxpp).", "input": "", "output": "    subroutine cubnmxu(nx,mx,ix,dxm,dx,dxp,dxpp)\n\n    !     set cubic interpolation terms\n\n\n    implicit none\n    integer, intent(in)                      :: nx\n    integer, intent(in)                      :: mx\n    integer, intent(out)                     :: ix(mx)\n    real (kind=8), intent(out)               :: dxm(mx)\n    real (kind=8), intent(out)               :: dx(mx)\n    real (kind=8), intent(out)               :: dxp(mx)\n    real (kind=8), intent(out)               :: dxpp(mx)\n    integer :: i,ii\n    real (kind=8) :: dnx,dmx,odnx3\n    real (kind=8) :: xx,xim,xi,xip,xipp\n\n    !     set \"virtual\" uniform increments\n\n    dnx = 1.0/(nx-1)\n    dmx = 1.0/(mx-1)\n    odnx3 = 1.0/(6.*dnx*dnx*dnx)\n\n    !     set i=ix(ii) in [2,nx-2] such that\n    !     i-1,i,i+1,i+2 can be used to interpolate at ii\n\n    do ii=1,mx\n      xx = (ii-1)*dmx\n      ix(ii) = min0(max0(int(xx/dnx)+1,2),nx-2)\n      i = ix(ii)\n      \n    !     set scale terms for cubic\n      \n      xi = (i-1)*dnx\n      xim = xi-dnx\n      xip = xi+dnx\n      xipp = xip+dnx\n      dxm(ii) = -(xx-xi)*(xx-xip)*(xx-xipp)*odnx3\n      dx(ii) = 3.*(xx-xim)*(xx-xip)*(xx-xipp)*odnx3\n      dxp(ii) = -3.*(xx-xim)*(xx-xi)*(xx-xipp)*odnx3\n      dxpp(ii) = (xx-xim)*(xx-xi)*(xx-xip)*odnx3\n    end do\n    return\n    end subroutine cubnmxu\n"}, {"instruction": "Write a Fortran subroutine named polint to perform polynomial interpolation. The subroutine takes 4 input parameters of types integer, real(8) array, real(8) array, and real(8), and 2 output parameters of types real(8) and real(8).", "input": "", "output": "  subroutine polint( xa,ya,n,x,y,dy )\n\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: xa(n),ya(n),x\n    real(8),intent(out) :: y,dy\n    integer :: i,m\n    real(8) :: a,b,f0nm,f0nm_0\n    real(8),allocatable :: f0(:)\n\n    allocate( f0(n) )\n    f0(:) = ya(:)\n\n    f0nm = ya(1)\n\n    do m=1,n-1\n       do i=1,n-m\n          a = x-xa(i)\n          b = x-xa(i+m)\n          f0(i) = ( b*f0(i) - a*f0(i+1) )/( b - a )\n       end do\n       f0nm_0 = f0nm\n       f0nm   = sum( f0(1:n-m) )/(n-m)\n    end do\n    y  = f0(1)\n    dy = f0nm - f0nm_0\n\n    deallocate( f0 )\n\n    return\n  end subroutine polint\n"}, {"instruction": "Create a Fortran subroutine named dpolint to perform polynomial interpolation. The number of input arguments is 4 with test_data type ['integer', 'real(8)', 'real(8)', 'real(8)']. The number of output arguments is 2 with test_data type ['real(8)', 'real(8)'].", "input": "", "output": "  subroutine dpolint( xa,ya,n,x,y,dy )\n\n    implicit none\n    integer,intent(in)  :: n\n    real(8),intent(in)  :: xa(n),ya(n),x\n    real(8),intent(out) :: y,dy\n    integer :: i,m\n    real(8) :: a,b,f1nm,f1nm_0\n    real(8),allocatable :: f0(:),f1(:)\n\n    allocate( f0(n),f1(n) )\n    f0(:) = ya(:)\n    f1(:) = 0.0d0\n\n    f1nm = ( ya(2)-ya(1) )/( xa(2)-xa(1) )\n\n    do m=1,n-1\n       do i=1,n-m\n          a = x-xa(i)\n          b = x-xa(i+m)\n          f1(i) = ( f0(i) - f0(i+1) + b*f1(i) -a*f1(i+1) )/( b - a )\n          f0(i) = ( b*f0(i) - a*f0(i+1) )/( b - a )\n       end do\n       f1nm_0 = f1nm\n       f1nm   = sum( f1(1:n-m) )/(n-m)\n    end do\n\n    y  = f1(1)\n    dy = f1nm - f1nm_0\n\n    deallocate( f0,f1 )\n\n    return\n  end subroutine dpolint\n"}, {"instruction": "Write a Fortran subroutine named get_nloat that reads linearization energy data for lapw and computes the total number of entries based on the maximum angular momentum (lomax) and the number of atoms (nat) provided as input. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "subroutine get_nloat(lomax,nat,nloat)\n  implicit none\n  integer, intent(in) :: lomax, nat\n  integer, intent(out):: nloat\n  ! locals\n  integer ::   i,ios, ii\n  real*8, allocatable :: elo(:,:)\n  nloat=1000\n  allocate (elo(0:lomax,1:nloat))\n  ii=1\n  nloat=0\n  do i=1,nat\n     read(9)  ! linearization energy for lapw\n     do\n        read(9,iostat=ios) elo(0:lomax,1:ii)\n        if (ios.ne.0) exit ! no more entries\n        ii=ii+1\n        backspace(9)\n     enddo\n     nloat=ii\n  enddo\n  deallocate(elo)\n  rewind(9)\nend subroutine get_nloat\n"}, {"instruction": "Create a Fortran subroutine named evaluatecubicandderivs to evaluate a cubic polynomial and its 1st, 2nd, and 3rd derivatives at a specified point. The subroutine takes 7 input parameters of type real: a, fa, fpa, b, fb, fpb, and u. It also has 4 optional output parameters of type real: f, fp, fpp, and fppp.", "input": "", "output": "pure subroutine evaluatecubicandderivs(a,fa,fpa, b,fb,fpb, u, f,fp,fpp,fppp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - evaluate a cubic polynomial and its 1st, 2nd, and 3rd\r\n!   derivatives at a specified point. the cubic is defined by the function\r\n!   and the 1st derivative at two points. the cubic is mapped onto [0,1]\r\n!   for some savings in computation. if no derivatives are wanted, it is\r\n!   probably preferable to use functions evaluatecubic above.\r\n\r\n  real,intent(in):: a,fa,fpa   ! a, f(a), f'(a)  at first point\r\n  real,intent(in):: b,fb,fpb   ! b, f(b), f'(b)  at second point\r\n  real,intent(in):: u   ! point where function is to be evaluated\r\n\r\n  real,intent(out),optional:: f,fp,fpp,fppp   ! f(u),f'(u),f''(u),f'''(u)\r\n  \r\n  real,parameter:: one=1.0, two=2.0, three=3.0, six=6.0\r\n! the \"magic\" matrix. this is how you declare a constant 4x4 matrix\r\n  real,parameter,dimension(4,4):: magic = reshape(                      &\r\n     & (/2.0, -3.0,  0.0,  1.0, -2.0,  3.0,  0.0,  0.0,                 &\r\n     &   1.0, -2.0,  1.0,  0.0,  1.0, -1.0,  0.0,  0.0/), (/4,4/) )\r\n  real,dimension(4)::coef,rhs\r\n  real:: h,t\r\n! ------------------------------------------------------------------------------\r\n  rhs(1)=fa\r\n  rhs(2)=fb\r\n  rhs(3)=fpa*(b-a)\r\n  rhs(4)=fpb*(b-a)\r\n  coef=matmul(magic,rhs)\r\n\r\n! caution - these are not the coefficients of the cubic in the original \r\n! coordinates. this is the cubic on [0,1] from the mapping t=(x-a)/(b-a). \r\n! that is why the h terms appear in the derivatives.       \r\n\r\n  h=one/(b-a)\r\n  t=(u-a)*h\r\n  if (present(f)) then\r\n    f=             coef(4) +     t*(coef(3) + t*(coef(2)   + t*coef(1)))\r\n  end if\r\n  if (present(fp)) then\r\n    fp=         h*(coef(3) + t*(two*coef(2) + t*three*coef(1)))\r\n  end if\r\n  if (present(fpp)) then\r\n    fpp=  h*h*(two*coef(2) +  t*six*coef(1))\r\n  end if\r\n  if (present(fppp)) then\r\n    fppp=h*h*h*six*coef(1)\r\n  end if\r\n  return\r\nend subroutine evaluatecubicandderivs   ! -------------------------------------\r\n"}, {"instruction": "Create a Fortran subroutine named f1max that calculates approximations to the 1%, 5%, and 10% points of the distribution of the maximum of nf values of an f-ratio. The subroutine takes 2 input parameters of type integer and 4 output parameters of type real and integer.", "input": "", "output": "subroutine f1max(ndf, nf, f1, f5, f10, ier)\r\n! calculates approximations to the 1%, 5% & 10% points of the distribution\r\n! of the maximum of nf values of an f-ratio with 1 d.f. for the numerator\r\n! and ndf d.f. for the denominator.\r\n! an approximation is used to the values given in table 2 of:\r\n!     gilmour, s.g. (1996) `the interpretation of mallows's cp-statistic',\r\n!     the statistician, vol.45, pp.49-56\r\n\r\nimplicit none\r\ninteger, intent(in)  :: ndf, nf\r\nreal, intent(out)    :: f1, f5, f10\r\ninteger, intent(out) :: ier\r\n\r\n! local variables\r\nreal :: a1(6) = (/ 1.67649, 6.94330,  1.22627, 0.25319,  0.06136, -2.41097 /)\r\nreal :: a5(6) = (/ 1.28152, 4.93268, -0.29583, 0.28518, -0.23566, -1.60581 /)\r\nreal :: a10(6) = (/1.06642, 3.96276, -0.62483, 0.30228, -0.52843, -1.04499 /)\r\n\r\nreal :: log_nf, one = 1.0\r\n\r\nif (ndf < 4 .or. nf < 1) then\r\n  ier = 1\r\n  return\r\nend if\r\nier = 0\r\n\r\nlog_nf = log(dble(nf))\r\n\r\nf1 = one + exp(a1(1) + (a1(3)/ndf + a1(2))/ndf + a1(4)*log_nf          &\r\n               + (a1(6)/ndf + a1(5))/nf)\r\n\r\nf5 = one + exp(a5(1) + (a5(3)/ndf + a5(2))/ndf + a5(4)*log_nf          &\r\n               + (a5(6)/ndf + a5(5))/nf)\r\n\r\nf10 = one + exp(a10(1) + (a10(3)/ndf + a10(2))/ndf + a10(4)*log_nf     &\r\n                + (a10(6)/ndf + a10(5))/nf)\r\n\r\nreturn\r\nend subroutine f1max\r\n"}, {"instruction": "Create a Fortran subroutine named polar_to_cartesian to convert polar coordinates to cartesian coordinates. The subroutine takes 2 input parameters of type real: radius and inclination. It also outputs 2 parameters of type real: x and y. If the radius is zero, the x and y coordinates are set to 0.0; otherwise, x is calculated as radius times cosine of inclination, and y is calculated as radius times sine of inclination.", "input": "", "output": "   subroutine polar_to_cartesian(radius,inclination,x,y)\n      implicit none\n      character(len=*),parameter::ident_21=\"@(#)m_units::polar_to_cartesian(3f): convert polar coordinates to cartesian coordinates\"\n      real,intent(in) :: radius,inclination\n      real,intent(out)  :: x,y\n      if(radius.eq.0)then\n         x=0.0\n         y=0.0\n      else\n         x=radius*cos(inclination)\n         y=radius*sin(inclination)\n      endif\n   end subroutine polar_to_cartesian\n"}, {"instruction": "Write a Fortran subroutine named readscalar_i to read a single integer value from a file specified by the input file_name. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 1 and the test_data type is ['integer'].", "input": "", "output": "    subroutine readscalar_i(x,file_name)\r\n    \r\n    implicit none\r\n    \r\n    character(len=*), intent(in) :: file_name\r\n    integer, intent(out) :: x\r\n    integer :: unitno,i, ierr\r\n    \r\n    open(newunit=unitno, file=file_name, status='old', iostat=ierr)\r\n    if (ierr/=0) then\r\n        write(*,*) \"error in readscalar: cannot open file\"\r\n\t\tpause\r\n\t\tstop \r\n    endif\r\n    \r\n    read(unitno,*) x\r\n    \r\n    close(unitno)\r\n    \r\n    end subroutine readscalar_i\r\n"}, {"instruction": "Create a Fortran subroutine named read1dim_i to read integer data from a file and store it in an array. The subroutine has 1 input parameter of type character(len=*) to specify the file name, and 1 output parameter of type integer array to store the read data.", "input": "", "output": "    subroutine read1dim_i(x,file_name)\r\n    \r\n    implicit none\r\n    \r\n    character(len=*), intent(in) :: file_name\r\n    integer, intent(out) :: x(:)\r\n    integer :: unitno,i, ierr\r\n    \r\n    open(newunit=unitno, file=file_name, status='old', iostat=ierr)\r\n    if (ierr/=0) then\r\n        write(*,*) \"error in read1dim: cannot open file\"\r\n\t\tpause\r\n\t\tstop \r\n    endif\r\n    \r\n    do i = 1,size(x)\r\n        read(unitno,*) x(i)\r\n    enddo\r\n    close(unitno)\r\n    \r\n    end subroutine read1dim_i\r\n"}, {"instruction": "Create a Fortran subroutine named \"flncoshd\" that takes a single input parameter of type real*8 and returns a single output parameter of type real*8. The subroutine should calculate the natural logarithm of the hyperbolic cosine of the input parameter and store the result in the output parameter. Ensure to use the \"intent(in)\" and \"intent(out)\" attributes to specify the purpose of each parameter.", "input": "", "output": "subroutine flncoshd(x,y)\n    implicit none\n    real*8,parameter :: log2_=log(2d0)\n    real*8,intent(in) :: x\n    real*8,intent(out) :: y\n    real*8 :: absx\n    !f2py intent(in) :: x\n    !f2py intent(out) :: y\n    absx=abs(x)\n    if(x>12) then\n        y=x-log2_\n    else\n        y=log(cosh(x))\n    endif\nend subroutine flncoshd\n"}, {"instruction": "Create a Fortran subroutine named \"c_uparser_get_bool\" that takes 1 input parameter of type character(kind=c_char) and 1 output parameter of type logical(kind=c_bool). The subroutine is intended to retrieve a boolean value associated with the specified key. Use the imperative tone to define this subroutine.", "input": "", "output": "        subroutine c_uparser_get_bool(key, val) &\n            bind(c, name = \"uparser_get_bool\")\n            use, intrinsic :: iso_c_binding, only: c_char, c_bool\n            implicit none\n            character(kind=c_char), intent(in) :: key\n            logical(kind=c_bool),  intent(out) :: val\n        end subroutine c_uparser_get_bool\n"}, {"instruction": "Create a Fortran subroutine named c_uparser_get_char to retrieve a character value associated with a given key. The subroutine takes 1 input parameter of type character(kind=c_char) and provides 1 output parameter of type character(kind=c_char).", "input": "", "output": "        subroutine c_uparser_get_char(key, val) &\n            bind(c, name='uparser_get_char')\n            use, intrinsic :: iso_c_binding, only: c_char\n            character(kind=c_char),  intent(in) :: key\n            character(kind=c_char), intent(out) :: val\n        end subroutine c_uparser_get_char\n"}, {"instruction": "Create a Fortran subroutine named splint to perform spline interpolation. The subroutine takes 7 input parameters of types integer and real, and 1 output parameter of type real. The input parameters are n, nrow, ncol (integers), x (2D real array), xa, ya, y2a (1D real arrays). The output parameter is y (2D real array). Ensure to use the provided code for the subroutine.", "input": "", "output": "subroutine splint(xa,ya,y2a,n,x,nrow,ncol,y)\ninteger, intent(in) :: n, nrow, ncol\nreal, intent(in) :: x(nrow,ncol)\nreal, intent(in) :: xa(n,1), ya(n,1), y2a(n,1)\nreal, intent(out) :: y(nrow,ncol)\ninteger :: k, khi, klo, indr, indc\nreal :: a, b, h\nklo = 1\nkhi = n\n!print *, 'the fifth argument in splint.f90 is', x\ndo indr=1,nrow\n  do indc=1,ncol\n       klo = 1\n       khi = n\n       do while (khi-klo>1)\n          k=(khi+klo)/2\n          if (xa(k,1)>x(indr,indc)) then\n            khi=k\n          else\n            klo=k\n          end if\n       end do\n    h = xa(khi,1)-xa(klo,1)\n    a = (xa(khi,1)-x(indr,indc))/h\n    b = (x(indr,indc)-xa(klo,1))/h\n    y(indr,indc) = a*ya(klo,1)+b*ya(khi,1)+((a**3-a)*y2a(klo,1)+(b**3-b)*y2a(khi,1))*(h**2)/6.0\n  end do\nend do\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named f2ksubstr to locate the start and end positions of the first sub-string in the supplied character string. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters of type integer. The start position of the delimited string is returned as zero if the string is blank, and the end position of the delimited string is also returned as zero if the string is blank. Use this subroutine to efficiently find and extract sub-strings within a larger string.", "input": "", "output": "      subroutine f2ksubstr(string,istart,iend)\r\n!\r\n! locate start and end of first sub-string in supplied string\r\n!\r\n! string = character string to search\r\n! istart = start position of delimited string\r\n!          returned as zero if string is blank\r\n! iend   = end position of delimited string\r\n!          returned as zero if string is blank\r\n!\r\n      implicit none\r\n!\r\n      character(len=*), intent(in)  :: string\r\n      integer         , intent(out) :: istart,iend\r\n!\r\n      integer :: ipos,ipos2\r\n!\r\n! find start of sub-string\r\n!\r\n      do ipos = 1,len(string)\r\n        if (string(ipos:ipos) /= ' ') then\r\n            istart = ipos\r\n!\r\n! find the end of the sub-string\r\n!\r\n            ipos2 = index(string(ipos:),' ')\r\n            if (ipos2 == 0) then\r\n                iend = len(string)\r\n            else\r\n                iend = ipos2 + ipos - 2\r\n            end if\r\n            return\r\n        end if\r\n      end do\r\n!\r\n! string was blank\r\n!\r\n      istart = 0\r\n      iend   = 0\r\n      return\r\n      end subroutine f2ksubstr\r\n"}, {"instruction": "Create a Fortran subroutine named get_ref_date. It takes 1 input parameter of type character(len=*) and 1 output parameter of type integer. The subroutine reads the time units label and extracts the reference date if the label contains the word \"since\". If \"since\" is found, the subroutine extracts the date and assigns it to the output parameter.", "input": "", "output": " subroutine get_ref_date (units, date)\n\n  character(len=*), intent(in)  :: units\n  integer         , intent(out) :: date(6)\n\n  integer :: is, ie\n\n!---- returns the reference date from time units label ----\n!---- note: this version requires a specific format ----\n\n  date = 0\n\n  is = index(units, 'since')\n\n  if ( is > 0 ) then\n       ie = is + 24\n       read (units(is:ie),10) date(1:6)\n 10    format (6x,i4,5(1x,i2))      \n  endif\n\n end subroutine get_ref_date\n"}, {"instruction": "Create a Fortran subroutine named looktmdf to analyze a given character string and determine the presence of certain terms. The subroutine takes 1 input parameter of type character(len=2) and provides 2 output parameters of type integer.", "input": "", "output": "        subroutine looktmdf(sl, ip, nsl)\n!======================================================================\n!\n!     terms for the configuration d(1) f(1)\n!\n!----------------------------------------------------------------------\n           implicit none\n           integer, intent(out) :: ip\n           integer, intent(out) :: nsl\n           character(len=2), intent(in) :: sl\n           integer :: i1, j2, i\n           character(len=2), dimension(10) :: terms\n\n!             .. d1 f1 terms\n           data terms/'1p', '1d', '1f', '1g', '1h', '3p', '3d', '3f', '3g', '3h'/\n!\n           ip = 0\n           nsl = 0\n           i = 1\n           i1 = i\n           j2 = max(10, i1)\n           do i = i1, j2\n              if (sl /= terms(i)) cycle\n              nsl = nsl + 1\n              ip = i\n           end do\n           return\n        end subroutine looktmdf\n"}, {"instruction": "Create a Fortran subroutine named reorderpdg that takes an array of integers as input and rearranges the elements in ascending order. The number of input parameters is 1, with the test_data type being ['integer']. The number of output parameters is 1, with the test_data type also being ['integer'].", "input": "", "output": " subroutine reorderpdg(array_in,array_out)\n !********************************************************\n  implicit none\n  integer,intent(in) :: array_in(:)\n  integer,allocatable :: array_in_temp(:)\n  integer,intent(out) :: array_out(:)\n  integer,parameter :: veryhighnumber=1000000000 !should be higher than all the pdg numbers\n  integer :: i, minl\n\n  allocate(array_in_temp(lbound(array_in,dim=1):ubound(array_in,dim=1)))\n\n  array_in_temp=array_in\n  array_out=0\n\n  do i=lbound(array_in_temp,dim=1),ubound(array_in_temp,dim=1)\n    minl=minloc(array_in_temp,dim=1)\n    array_out(i)=array_in_temp(minl)\n    array_in_temp(minl)=veryhighnumber\n  enddo\n   \n  deallocate(array_in_temp)\n\n end subroutine reorderpdg\n"}, {"instruction": "Create a Fortran subroutine named bcucof that takes 6 input parameters of type double precision and dimension 4, and 2 input parameters of type double precision. The input parameters are y, y1, y2, y12, d1, and d2. The output parameter is c of type double precision and dimension 4x4. This subroutine computes a 4x4 table used for bicubic interpolation based on the given function, gradients, and cross derivative at four grid points of a rectangular grid cell, along with the lengths of the grid cell in the 1- and 2-directions.", "input": "", "output": "  subroutine bcucof(y,y1,y2,y12,d1,d2,c)\n    !\n    implicit none\n    !\n    double precision, intent(in) :: d1,d2\n    double precision, dimension(4), intent(in) :: y,y1,y2,y12\n    double precision, dimension(4,4), intent(out) :: c\n      !given arrays y, y1, y2, and y12, each of length 4, containing the function, gradients, and\n      !cross derivative at the four grid points of a rectangular grid cell (numbered counterclockwise\n      !from the lower left), and given d1 and d2, the length of the grid cell in the 1- and 2-\n      !directions, this routine returns the 4\u00d74 table c that is used by routine bcuint for bicubic\n      !interpolation.\n    double precision, dimension(16) :: x,c1\n    double precision :: xx\n!     double precision, dimension(4,4) :: c1\n    double precision, dimension(16,16) :: wt\n    integer :: i,j,k,l\n    data wt /1., 0.,-3., 2., 0., 0., 0., 0.,-3., 0., 9.,-6., 2., 0.,-6., 4., &\n\t     0., 0., 0., 0., 0., 0., 0., 0., 3., 0.,-9., 6.,-2., 0., 6.,-4., &\n\t     0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 9.,-6., 0., 0.,-6., 4., &\n             0., 0., 3.,-2., 0., 0., 0., 0., 0., 0.,-9., 6., 0., 0., 6.,-4., &\n             0., 0., 0., 0., 1., 0.,-3., 2.,-2., 0., 6.,-4., 1., 0.,-3., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0.,-1., 0., 3.,-2., 1., 0.,-3., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,-3., 2., 0., 0., 3.,-2., &\n             0., 0., 0., 0., 0., 0., 3.,-2., 0., 0.,-6., 4., 0., 0., 3.,-2., &\n             0., 1.,-2., 1., 0., 0., 0., 0., 0.,-3., 6.,-3., 0., 2.,-4., 2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 3.,-6., 3., 0.,-2., 4.,-2., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,-3., 3., 0., 0., 2.,-2., &\n             0., 0.,-1., 1., 0., 0., 0., 0., 0., 0., 3.,-3., 0., 0.,-2., 2., &\n             0., 0., 0., 0., 0., 1.,-2., 1., 0.,-2., 4.,-2., 0., 1.,-2., 1., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0.,-1., 2.,-1., 0., 1.,-2., 1., &\n             0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,-1., 0., 0.,-1., 1., &\n             0., 0., 0., 0., 0., 0.,-1., 1., 0., 0., 2.,-2., 0., 0.,-1., 1./\n\n    x(1:4)=y !pack a temporary vector x.\n    x(5:8)=y1*d1\n    x(9:12)=y2*d2\n    x(13:16)=y12*d1*d2\n    x=matmul(wt,x) !matrix multiply by the stored table.\n    c=reshape(x,(/4,4/),order=(/2,1/)) !unpack the result into the output table.\n\n  end subroutine bcucof\n"}, {"instruction": "Create a Fortran subroutine named c1 that takes an array of double precision values as input and outputs another array of double precision values. The input array is marked as intent(in) and the output array is marked as intent(out). The subroutine calculates the first element of the output array based on the values of the input array.", "input": "", "output": "    subroutine c1(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = x(1) + x(2) - 1\n    end subroutine c1\n"}, {"instruction": "Create a Fortran subroutine named dc1 that takes an array of double precision values as input and returns a 2x2 array of double precision values as output. The subroutine sets the elements of the output array dcx to specific values.", "input": "", "output": "    subroutine dc1(dcx, x)\n        double precision, intent(out) :: dcx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        dcx(1, 1) = 1\n        dcx(1, 2) = 1\n    end subroutine dc1\n"}, {"instruction": "Create a Fortran subroutine named testh2 that takes an input array of double precision values and outputs a 2D array of double precision values. The input parameter consists of a single array of double precision values, while the output parameter is a 2D array of double precision values. The subroutine initializes the output array to zeros and then sets the diagonal elements to 2.", "input": "", "output": "    subroutine testh2(hx, x)\n        double precision, intent(out) :: hx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        integer :: i, n\n        n = size(x)\n\n        hx(:, :) = 0.d0\n        do i = 1, n\n            hx(i, i) = 2\n        end do\n    end subroutine testh2\n"}, {"instruction": "Create a Fortran subroutine named dc2 that takes an array of double precision as input and computes the derivative of a specific mathematical function. The input parameter is of type double precision, intent(in) and the output parameter is of type double precision, intent(out).", "input": "", "output": "    subroutine dc2(dcx, x)\n        double precision, intent(out) :: dcx(:, :)\n        double precision, intent(in)  :: x(:)\n\n        dcx(1, 1) = 3*(x(1) + x(2) - 1)**2\n        dcx(1, 2) = 3*(x(1) + x(2) - 1)**2\n    end subroutine dc2\n"}, {"instruction": "Create a Fortran subroutine named d2c2 to compute the elements of a three-dimensional array d2cx based on the computation involving a one-dimensional array x. The input parameter is a three-dimensional array d2cx of type double precision, and the output parameter is a one-dimensional array x of type double precision.", "input": "", "output": "    subroutine d2c2(d2cx, x)\n        double precision, intent(out) :: d2cx(:, :, :)\n        double precision, intent(in)  :: x(:)\n\n        d2cx(1, 1, 1) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 1, 2) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 2, 1) = 6*(x(1) + x(2) - 1)\n        d2cx(1, 2, 2) = 6*(x(1) + x(2) - 1)\n    end subroutine d2c2\n"}, {"instruction": "Create a Fortran subroutine named c3 that takes an array of double precision numbers as input and returns another array of double precision numbers as output. The input is specified using the \"intent(in)\" attribute, and the output is specified using the \"intent(out)\" attribute. The subroutine computes the output array by modifying the input array based on specific operations.", "input": "", "output": "    subroutine c3(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = x(1) - 1\n        cx(2) = x(2)\n    end subroutine c3\n"}, {"instruction": "Create a Fortran subroutine named testg4 to perform an element-wise multiplication of an input array x of type double precision. The output array gx, also of type double precision, will store the result of multiplying each element of x by 2. The subroutine has 1 input parameter of type double precision and 1 output parameter of type double precision.", "input": "", "output": "    subroutine testg4(gx, x)\n        double precision, intent(out) :: gx(:)\n        double precision, intent(in)  :: x(:)\n\n        gx(:) = 2*x(:)\n    end subroutine testg4\n"}, {"instruction": "Write a Fortran subroutine named c4 that takes an array of double precision values as input and outputs an array of double precision values. The input array is marked as intent(in) and the output array is marked as intent(out). The subroutine calculates two equations and assigns the results to the elements of the output array. The number of input arguments is 1 and the test_data type is ['double precision'].The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "    subroutine c4(cx, x)\n        double precision, intent(out) :: cx(:)\n        double precision, intent(in)  :: x(:)\n\n        cx(1) = (x(1) - 1)**2 + (x(2) - 1)**2 - 1\n        cx(2) = (x(1) - 1)**2 + (x(2) + 1)**2 - 1\n    end subroutine c4\n"}, {"instruction": "Write a Fortran subroutine named tdma to solve a tridiagonal matrix equation. The subroutine takes 5 input parameters of type integer*4, real*8, real*8, real*8, and real*8, and 1 output parameter of type real*8. The subroutine uses the Thomas algorithm to solve the tridiagonal matrix equation.", "input": "", "output": "subroutine tdma(n, a, b, c, d, x)\n\n    implicit none\n\n    integer*4, intent(in)  :: n\n    real*8,    intent(in)  :: a(n)\n    real*8,    intent(in)  :: b(n)\n    real*8,    intent(in)  :: c(n)\n    real*8,    intent(in)  :: d(n)\n    real*8,    intent(out) :: x(n)\n\n    real*8    :: p(n) \n    real*8    :: q(n) \n    real*8    :: r(n) \n    integer*4 :: i\n\n    p(1) = -c(1)/b(1)\n    q(1) =  d(1)/b(1)\n    do i = 2, n\n        r(i) =  a(i)*p(i-1) + b(i)\n        p(i) = -c(i)/r(i)\n        q(i) = (d(i) - a(i)*q(i-1))/r(i)\n    end do\n\n    x(n) = q(n)\n    do i = n - 1, 1, -1\n        x(i) = p(i)*x(i+1) + q(i)\n    end do\n\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named eapskill to perform a transformation on the input arrays covtheta, lintran, and meantheta. The subroutine takes 3 input parameters of type real(kind=8) and returns 2 output parameters of the same type. The covnewtheta and meannewtheta arrays are populated by performing matrix operations involving covtheta, lintran, and meantheta. Use this subroutine to transform covariance and mean arrays according to the specified calculations.", "input": "", "output": "subroutine eapskill(covtheta,lintran,meantheta,covnewtheta,meannewtheta)\r\nimplicit none\r\nreal(kind=8),intent(in)::covtheta(:,:,:),lintran(:,:),meantheta(:,:)\r\nreal(kind=8),intent(out)::covnewtheta(:,:,:),meannewtheta(:,:)\r\n!\tobs is observation number.\r\ninteger::obs\r\n!\tset up parameter arrays for simplified processing.\r\ndo obs=1,size(meantheta,2)\r\n\tcovnewtheta(:,:,obs)=matmul(lintran,matmul(covtheta(:,:,obs),transpose(lintran)))\r\n\tmeannewtheta(:,obs)=matmul(lintran,meantheta(:,obs))\r\n\t\r\nend do\r\n\r\nreturn\r\nend subroutine eapskill\r\n"}, {"instruction": "Create a Fortran subroutine named dp_format to format double precision numbers. The subroutine takes three input parameters: an integer n, an array of double precision numbers x, and an optional integer decimals. The subroutine also has two output parameters: an integer w and an integer d. \n\nThe dp_format subroutine first determines the number of decimal places required based on the optional decimals argument, or uses a default value if the argument is not present. It then calculates the minimum width required to accommodate the formatted numbers by finding the maximum absolute value of the elements in the x array and adding the number of decimal places and additional space.\n\nTo calculate the minimum width required, the subroutine finds the ceiling of the logarithm base 10 of the maximum absolute value of the elements in the x array. It then adds the number of decimal places and three additional spaces.\n\nThe subroutine assigns the calculated minimum width to the output parameter w and the number of decimal places to the output parameter d.", "input": "", "output": "  subroutine dp_format (n, x, w, d, decimals)\n    integer , intent(in) :: n\n    double precision , intent(in) :: x(n)\n    integer , intent(out) :: w, d\n    integer , optional , intent(in) :: decimals\n    ! ! alternative method variables\n    ! character(len=100) :: temp, fmt_temp, str_d\n    ! integer :: l\n    ! integer :: ii\n\n    ! determine decimal places, either from optional argument or predefined\n    ! global parameter\n    if (present(decimals)) then\n      d = decimals\n    else\n      d = dp_max\n    end if\n\n    ! determine minimum width required\n    w = max(ceiling(log10(maxval(abs(x(:))))), 1) + d + 3\n\n    ! ! alternative method\n    ! write (str_d, \"(i)\") d\n    ! write (fmt_temp, \"(i)\") \"(f0.\", trim(adjustl(str_d)), \")\"\n    ! l = 0\n    ! do ii = 1, n\n    !   write (temp, fmt_temp) x(ii)\n    !   l = max(l, len(trim(adjustl(temp))))\n    ! end do\n    ! w = l\n\n  end subroutine dp_format\n"}, {"instruction": "Write a Fortran subroutine named dp_format_string that takes two integer input arguments, w and d, and one output argument, str. The purpose of this subroutine is to generate a formatted string that represents a floating-point number with a specified width and decimal precision. The input parameters w and d specify the desired width and decimal precision, respectively. The output parameter str is an allocatable character array that will store the generated format string.\n\nThe subroutine begins by declaring some local variables and character arrays to store intermediate results. It then converts the integer values w and d into strings using the write function. Next, it constructs the format string by concatenating the necessary components using the write function and storing it in the str_temp character array.\n\nThe length of the non-empty part of the format string is determined by calculating the length of the trimmed and adjusted str_temp. Finally, the subroutine allocates the required memory for the output parameter str and writes the trimmed and adjusted str_temp into it using the write function.\n\nTo use this subroutine, you need to pass two input integers for w and d, and provide an allocatable character array for the output parameter str. The subroutine will generate a formatted string based on the input values of w and d and store it in the str array.", "input": "", "output": "  subroutine dp_format_string (w, d, str)\n    integer , intent(in) :: w, d\n    character(len=:) , allocatable , intent(out) :: str\n    character(len=100) :: str_w, str_d, str_temp\n    integer :: l\n\n    ! write width, decimal precision to string\n    write (str_w, *) w\n    write (str_d, *) d\n\n    ! write format string\n    write (str_temp, \"(a,a,a,a,a)\") &\n        \"(f\", trim(adjustl(str_w)), \".\", trim(adjustl(str_d)), \")\"\n\n    ! determine length of (non-empty part of) string\n    l = len(trim(adjustl(str_temp)))\n\n    ! write compacted format string (uses minimal space)\n    allocate(character(len=l) :: str)\n\n    write (str, \"(a)\") trim(adjustl(str_temp))\n\n  end subroutine dp_format_string\n"}, {"instruction": "Write a Fortran subroutine named dp_zero_string that creates a string of whitespaces with a specified width and inserts a dot at a specific position. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [character(len=:) , allocatable].", "input": "", "output": "  subroutine dp_zero_string (w, d, str)\n    integer , intent(in) :: w, d\n    character(len=:) , allocatable , intent(out) :: str\n\n    ! allocate\n    allocate(character(len=w) :: str)\n\n    ! write zero string\n    str = repeat(' ', w)\n    str(w-d:w-d) = '.'\n\n  end subroutine dp_zero_string\n"}, {"instruction": "Write a Fortran subroutine named \"cncalcelemaveragefromnodes\" that calculates the average value of elements based on the values of connected nodes. The subroutine takes four input parameters: \"elemcount\" and \"nodecount\" of type integer, \"elemconnect\" of type integer array with dimensions (elemcount,4), and \"rnodesin\" of type real*8 array with dimension (nodecount). The subroutine also has one output parameter: \"relemout\" of type real*8 array with dimension (elemcount).", "input": "", "output": "        subroutine cncalcelemaveragefromnodes (elemcount, nodecount,elemconnect,rnodesin,relemout) \n            implicit none\n            integer,   intent(in) :: elemcount, nodecount\n            integer,    intent(in) :: elemconnect(elemcount,4)\n            real*8,    intent(in) :: rnodesin(nodecount)\n            real*8,    intent(out):: relemout(elemcount)\n            real*8 ::valn1,valn2,valn3,valn4\n            integer i\n            \n            \n            do i=1,elemcount\n                valn1=rnodesin(elemconnect(i,1))\n                valn2=rnodesin(elemconnect(i,2))\n                valn3=rnodesin(elemconnect(i,3))\n                valn4=rnodesin(elemconnect(i,4))\n                relemout(i)=0.25*(valn1+valn2+valn3+valn4)\n            enddo\n            \n        end subroutine cncalcelemaveragefromnodes\n"}, {"instruction": "Provide a Fortran subroutine named paircount to perform a specific calculation. The purpose of this subroutine is to compute pairwise counts based on given input parameters. \n\nThe subroutine takes 13 input parameters:\n- Four integers: n1, n2, m, auto\n- Four real arrays of size n1: theta1, phi1, delta1, fpix1\n- Four real arrays of size n2: theta2, phi2, delta2, fpix2\n- One real array of size m+1: bins\n\nIt has one output parameter:\n- A real array of size 2 by m: c\n\nThe computation in the subroutine involves multiple loops and conditions. It first calculates the trigonometric functions for the input angles. Then, depending on the value of the auto parameter, it performs different calculations. \n\nIf auto is 0, it iterates over the elements of theta1 and theta2 arrays and calculates a value 's'. It then determines the bin id based on the 's' value and updates the elements of the c array accordingly.\n\nIf auto is 1 and n1 is equal to n2, it performs a similar calculation as above but with an additional condition that ensures the loop only runs for unique pairs of indices.\n\nThe subroutine returns after completing the calculations.\n\nPlease note that the subroutine uses Fortran-specific features such as array dimensions and array element access.", "input": "", "output": "subroutine paircount(theta1, phi1, theta2, phi2, delta1, delta2, fpix1, fpix2, bins, auto, c, n1,n2, m)\ninteger,intent(in) :: n1, n2, m, auto\nreal(8),dimension(n1),intent(in)   :: theta1, phi1, delta1, fpix1\nreal(8),dimension(n2),intent(in)   :: theta2, phi2, delta2, fpix2\nreal(8),dimension(m+1),intent(in)  :: bins\nreal(8),dimension(2,m),intent(out) :: c\n\n\nreal(8) :: s, be\ninteger :: i,j,binid\nreal(8), dimension(n1) :: cost1,sint1,cosp1,sinp1\nreal(8), dimension(n2) :: cost2,sint2,cosp2,sinp2\n\n\n!\ncost1 = dcos(theta1)\nsint1 = dsin(theta1)\ncosp1 = dcos(phi1)\nsinp1 = dsin(phi1)\n!\ncost2 = dcos(theta2)\nsint2 = dsin(theta2)\ncosp2 = dcos(phi2)\nsinp2 = dsin(phi2)\n\nc    = 0.0\ns    = 0.0\n\nif (auto .eq. 0) then\n    do i = 1, n1\n        do j = 1, n2\n           s = sint1(i)*sint2(j)*(cosp1(i)*cosp2(j) + sinp1(i)*sinp2(j))+cost1(i)*cost2(j)\n           be = bins(1) ! starts from the max sep angle\n           binid = 0\n           do while (s > be)\n                binid = binid + 1\n                be    = bins(binid+1)\n           end do\n           if ((binid .ge. 1) .and. (binid .le. m)) then\n               c(1,binid) = c(1,binid) + delta1(i)*delta2(j)*fpix1(i)*fpix2(j)\n               c(2,binid) = c(2,binid) + fpix1(i)*fpix2(j)\n           end if\n           s = 0\n        end do\n    end do\nelse if ((auto .eq. 1) .and. (n1 .eq. n2)) then\n    do i = 1, n1\n        do j = i+1, n1\n           !print*, i, j\n           s = sint1(i)*sint2(j)*(cosp1(i)*cosp2(j) + sinp1(i)*sinp2(j))+cost1(i)*cost2(j)\n           be = bins(1) ! starts from the max sep angle\n           binid = 0\n           do while (s > be)\n                binid = binid + 1\n                be    = bins(binid+1)\n           end do\n           if ((binid .ge. 1) .and. (binid .le. m)) then\n               c(1,binid) = c(1,binid) + delta1(i)*delta2(j)*fpix1(i)*fpix2(j)\n               c(2,binid) = c(2,binid) + fpix1(i)*fpix2(j)\n           end if\n           s = 0\n        end do\n    end do\nend if\nreturn\nend subroutine paircount\n"}, {"instruction": "Provide a Fortran subroutine named abc0 to calculate the coefficients a, b, and c for local orbitals (lo). The subroutine takes 14 input parameters of various types: logical, real*8, and integer. The output parameters consist of three real*8 variables. The purpose of this subroutine is to construct the lo orbitals based on different conditions. If the logical parameter \"lapw\" is true, the subroutine calculates the coefficients using specific formulas. Otherwise, different formulas are used based on the value of the integer parameter \"jlo\". The subroutine returns the coefficients a, b, and c as output parameters.", "input": "", "output": "subroutine abc0(alo,blo,clo,lapw,p,dp,pe,dpe,pei,plo,dplo,pi12lo,pe12lo,rmt_,l,jlo,qprint_)\n  implicit none\n  real*8, intent(out) :: alo, blo, clo\n  logical, intent(in) :: lapw\n  real*8,  intent(in) :: p, dp, pe, dpe, pei, plo, dplo, pi12lo, pe12lo, rmt_\n  integer, intent(in) :: l, jlo\n  logical, intent(in) :: qprint_\n  !..................................................................\n  !   abc calculates the cofficients a,b,c of the local orbitals (lo)\n  !..................................................................\n  !        local parameters\n  double precision   cutoff\n  parameter          (cutoff = 200.0d+0)\n  !        local scalars\n  double precision   xac, xbc, alonorm\n  !        intrinsic functions\n  \n  if(lapw) then\n     ! dpe are indexed from 0 to lmax2 in lapw2 usw\n     ! dpe are indexed from 1 to lmax2+1 in lapw1 usw\n     !   p(l)   = ul_rmt(1,l,jatom)\n     !   pe(l)  = ul_rmt(2,l,jatom)\n     !   dp(l)  = dul_rmt(1,l,jatom)\n     !   dpe(l) = dul_rmt(2,l,jatom)\n     !   plo(l) = ul_rmt(2+jlo,l,jatom)\n     !   dplo(l)= dul_rmt(2+jlo,l,jatom)\n     !   ri_mat(2,2,l,jatom)=pei(l) ! <udot|udot>\n     !   ri_mat(1,2+jlo,l,jatom) = pi12lo(jlo,l)  ! <u | u_lo>\n     !   ri_mat(2+jlo,1,l,jatom) = pi12lo(jlo,l)  ! <u_lo | u>\n     !   ri_mat(2,2+jlo,l,jatom) = pe12lo(jlo,l)  ! <udot | u_lo>\n     !   ri_mat(2+jlo,2,l,jatom) = pe12lo(jlo,l)  ! <u_lo | udot>\n     !   ri_mat(2+jlo,2+jlop,l,jatom) = pr12lo(jlo,jlop,l)  ! <u_lo | u_lo >\n     !\n     !  we construct the lo orbtial as   u_new = alo*u + blo*dotu + clo*u_lo\n     !    and require       u_new(r) = 0\n     !                  du_new/dr(r) = 0\n     !         and     <u_new|u_new> = 1\n     !  which leads to:\n     ! xac =  (u_lo*ddotu-du_lo*dotu)*r^2\n     ! xbc = -(u_lo*du - du_lo*u)*r^2\n     ! clo =   1/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     ! alo = xac/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     ! blo = xbc/sqrt( 1 + xac*(xac + 2*<u_lo|u>)+xbc*(xbc*<dotu|dotu>+2*<dotu|u_lo> )\n     xac = (plo*dpe - dplo*pe)*rmt_**2\n     xbc = -(plo*dp - dplo*p)*rmt_**2\n     clo = 1.0d0/sqrt(1.d0 + xac*(xac + 2.0d0*pi12lo) + xbc*(xbc*pei + 2.0d0*pe12lo))\n     clo = min(clo,cutoff)\n     alo = clo*xac\n     blo = clo*xbc\n  else\n     !.....apw definitions\n     if(jlo.eq.1) then  ! apw+lo, hence ony u and dotu are used\n        ! we construct the lo orbtial as   u_new = alo*u + blo*dotu\n        !   and require       u_new(r) = 0\n        !        and     <u_new|u_new> = 1\n        ! which leads to:\n        ! alo = 1/sqrt(1 + (u/dotu)**2 * <dotu|dotu>)\n        ! blo = -u/dotu/sqrt(1 + (u/dotu)**2 * <dotu|dotu>)\n        ! clo = 0.d0\n        alonorm=sqrt(1.d0+(p/pe)**2*pei)\n        alo = 1.d0 /alonorm \n        blo = -p/pe/alonorm\n        clo = 0.d0\n     else ! apw+lo\n        ! we construct the lo orbital as u_new = alo*u + clo*u_lo\n        !   and require       u_new(r) = 0\n        !       and      <u_new|u_new> = 1\n        ! which leads to:\n        ! xac = sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        ! alo = 1/sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        ! clo = -u/u_lo /sqrt(1 + (u/u_lo)**2 - 2*(u/u_lo)*<u|u_lo>)\n        xbc=-p/plo\n        xac=sqrt(1+xbc**2+2*xbc*pi12lo)\n        alo = 1.d0/xac\n        blo = 0.d0\n        clo = xbc/xac\n     endif\n  endif\n  if (qprint_) write(6,6000) l,alo,blo,clo\n  !\n  return\n  !\n6000 format ('lo coefficient: l,a,b,c  ',i2,5x,3f12.5)\nend subroutine abc0\n"}, {"instruction": "Write a Fortran subroutine named compute_stream_function to compute the stream function values for a given grid size and domain. The subroutine takes 9 input parameters: nx (integer), ny (integer), hx (real), hy (real), xmin (real), xmax (real), ymin (real), ymax (real), and b (real). It also has one output parameter s (real 2D array). \n\nThe subroutine uses a nested loop to iterate over the grid points and calculates the stream function value at each point based on the given formula. The calculated values are stored in the s array.\n\nPlease note that the subroutine uses the concurrent loop construct to parallelize the computation.\n\nNow, write the Fortran subroutine code.", "input": "", "output": "  subroutine compute_stream_function(nx, ny, hx, hy, xmin, xmax, ymin, ymax, b, s)\n    implicit none\n    ! arguments\n    integer, intent(in) :: nx, ny\n    real, intent(in) :: hx, hy\n    real, intent(in) :: xmin, xmax, ymin, ymax\n    real, intent(in) :: b\n    real, intent(out) :: s(:, :)\n    ! local variables\n    real, parameter :: pi = 3.141592653589793238462643383279502884\n    real :: x = 0.0, y = 0.0\n    integer :: i = 0, j = 0\n\n    do concurrent (i=1:nx, j=1:ny)\n      x = xmin + (i-1) * hx\n      y = ymin + (j-1) * hy\n      s(i, j) = b * sin((pi * x) / xmax) * sin((pi * y) / ymax)\n    end do\n\n  end subroutine compute_stream_function\n"}, {"instruction": "Create a Fortran subroutine named compute_velocity to calculate the velocity components at interior points of a grid using centered finite differences. The subroutine takes 3 input arguments of type real (hx, hy, s) and provides 2 output arguments of type real (vx, vy).", "input": "", "output": "  subroutine compute_velocity(s, hx, hy, vx, vy)\n    implicit none\n    ! arguments\n    real, intent(in) :: hx, hy\n    real, intent(in) :: s(:, :)\n    real, intent(out) :: vx(:, :)\n    real, intent(out) :: vy(:, :)\n    ! local variables\n    integer :: nx, ny\n    nx = size(s, 1)\n    ny = size(s, 2)\n\n    ! initialize vx and vy\n    vx = 0.0\n    vy = 0.0\n\n    ! compute velocity at each interior point using centered finite differences\n    vx(2:nx-1, 2:ny-1) =  (s(2:nx-1, 3:ny) - s(2:nx-1, 1:ny-2)) / (2 * hy)\n    vy(2:nx-1, 2:ny-1) = -(s(3:nx, 2:ny-1) - s(1:nx-2, 2:ny-1)) / (2 * hx)\n\n  end subroutine compute_velocity\n"}, {"instruction": "Create a Fortran subroutine named lay2vel1 that takes 4 input parameters of type integer, integer, real, and real and 1 output parameter of type real. The subroutine should use the input parameters to calculate and output the velocity values based on the layer thicknesses and velocities provided.", "input": "", "output": "  subroutine lay2vel1(vel, lay, nlay, dz, nz)\n    integer, intent(in) :: nlay, nz\n    real, intent(in) :: lay(nlay,2), dz\n    real, intent(out) :: vel(nz)\n    integer :: i, ztop, zbot\n\n    ztop = 1\n    do i = 1, nlay\n      zbot = min( nint( lay(i,2) / dz ), nz )\n      vel(ztop:zbot) = lay(i,1)\n      if ( zbot .ge. nz ) then\n        exit\n      else\n        ztop = zbot + 1\n      end if\n    end do\n    vel(zbot+1:nz) = lay(nlay,1)\n    return\n  end subroutine lay2vel1\n"}, {"instruction": "Write a Fortran subroutine named sphericaltocart to convert spherical coordinates (r, theta, phi) to Cartesian coordinates (x, y, z). The subroutine takes 3 input arguments of type real (r, theta, phi) and provides 3 output arguments of type real (x, y, z).", "input": "", "output": "    subroutine sphericaltocart(r, theta, phi, x, y, z)\n       implicit none\n\n       real, intent(in)  :: r, theta, phi\n       real, intent(out) :: x, y, z\n\n       x=r*sin(theta)*cos(phi)\n       y=r*sin(theta)*sin(phi)\n       z=r*cos(theta)\n    end subroutine sphericaltocart\n"}, {"instruction": "Write a Fortran subroutine named stpnt that initializes the elements of the array par and the array u according to specific values. The subroutine takes 2 input parameters of type integer and double precision and returns 2 output parameters of type double precision and double precision.", "input": "", "output": " subroutine stpnt(ndim,u,par,t)\n!---------- -----\n\n   implicit none\n   integer, intent(in) :: ndim\n   double precision, intent(in) :: t\n   double precision, intent(out) :: u(ndim), par(*)\n\n   par(1)=5.0         ! a_1\n   par(2)=3.0         ! b_1\n   par(3)=1.10830e+00 ! d_1\n   par(4)=0.1         ! a_2\n   par(5)=2.0         ! b_2\n   par(6)=0.01        ! d_2\n\n   u(1:3)=(/log(0.66163d0),log(0.20199d0),0.0d0/)\n\n end subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named random_number_int to generate an array of random integers within a specified range. The subroutine takes 2 input parameters of type integer and optional integer, and 1 output parameter of type integer. The first input parameter specifies the maximum value for the random numbers, and the optional second input parameter specifies the minimum value (defaulted to 0 if not provided).", "input": "", "output": "    subroutine random_number_int(array, max, min)\n        !arguments\n        integer, intent(out) :: array(:)\n        integer, intent(in) :: max\n        integer, optional, intent(in) :: min\n        !variables\n        integer :: i, min_number\n        real :: rand\n\n        if(present(min)) then\n            min_number = min\n        else\n            min_number = 0\n        endif\n\n        do i=1,size(array)\n            call random_number(rand)\n            array(i) = int((max-min_number+1)*rand) + min_number\n        end do\n    end subroutine random_number_int\n"}, {"instruction": "Write a Fortran subroutine named covariance_matrix that computes the covariance matrix of input data. The number of input arguments is 1, and the test_data type is ['real'] representing the input data matrix. The number of output arguments is 1, and the test_data type is ['real'] representing the covariance matrix.", "input": "", "output": "    subroutine covariance_matrix(x, cov)\n        !arguments\n        real, intent(in) :: x(:,:)\n        real, intent(out) :: cov(:,:)\n        !variables\n        integer :: i, j, n_samples, n_data\n        real :: mean_i, mean_j\n\n        n_samples = size(x, dim=1)\n        n_data = size(x, dim=2)\n\n        do i=1,n_data\n            mean_i = sum(x(:,i))/n_samples\n            do j=1,i\n                mean_j = sum(x(:,j))/n_samples\n                cov(i,j) = sum((x(:,i)-mean_i)*(x(:,j)-mean_j))/(n_samples-1)\n                cov(j,i) = cov(i,j)\n            end do\n        end do\n    end subroutine covariance_matrix\n"}, {"instruction": "Create a Fortran subroutine named get_ggg_kinetic to calculate the kinetic energy geometric tensor. The subroutine takes 2 input parameters of type real(8) and 3x3 arrays, and 1 output parameter of type real(8) array. The input parameters are aa and bb, and the output parameter is ggg.", "input": "", "output": "  subroutine get_ggg_kinetic(aa,bb,ggg)\n    implicit none\n    real(8),intent(in)  :: aa(3,3),bb(3,3)\n    real(8),intent(out) :: ggg(6)\n    real(8) :: const,a1,a2,a3\n    const=1.d0/(4.d0*acos(-1.d0)**2)\n    a1 = sqrt( sum( aa(:,1)**2 ) )\n    a2 = sqrt( sum( aa(:,2)**2 ) )\n    a3 = sqrt( sum( aa(:,3)**2 ) )\n    ggg(1) = a1*a1*sum(bb(:,1)*bb(:,1))*const\n    ggg(2) = a2*a2*sum(bb(:,2)*bb(:,2))*const\n    ggg(3) = a3*a3*sum(bb(:,3)*bb(:,3))*const\n    ggg(4) = a1*a2*sum(bb(:,1)*bb(:,2))*const\n    ggg(5) = a2*a3*sum(bb(:,2)*bb(:,3))*const\n    ggg(6) = a3*a1*sum(bb(:,3)*bb(:,1))*const\n  end subroutine get_ggg_kinetic\n"}, {"instruction": "Create a Fortran subroutine named fun with two input parameters, one of real type (x) and the other of real, dimension(:) type (param). The subroutine also has two output parameters, one of real type (f) and an optional one of real type (df).", "input": "", "output": "       subroutine fun(x, param, f, df)\n         implicit none\n         real, intent(in)  :: x                     !< function argument x\n         real, dimension(:), intent(in) :: param    !< additional parameters\n         real, intent(out) :: f                     !< function value f(x)\n         real, intent(out), optional :: df          !< derivative value df(x)/dx\n       end subroutine fun\n"}, {"instruction": "Create a Fortran subroutine named getnuniquerandomnumbers. This subroutine generates a specified number of unique random integers within a specified range and stores them in an array. The number of input parameters is 2, with test_data type ['integer', 'integer'], representing the number of random numbers and the range of values. The number of output parameters is 1, with test_data type ['integer'], representing the array of unique random numbers.", "input": "", "output": "subroutine getnuniquerandomnumbers(rvals, rvn, nw)\n  ! stores rvn integer random numbers into array rvals(1:rvn), which can take values -nw,-nw+1,...,nw,nw+1\n  implicit none\n  integer, intent(in)  :: rvn, nw\n  integer, intent(out) :: rvals(rvn)\n  ! locals\n  integer :: i, j, ix\n  real*8  :: x\n  logical :: duplicate\n  do i=1,rvn\n     do\n        call random_number(x)\n        ix = int(x*(2*nw+1))-nw\n        duplicate=.false.\n        do j=1,i-1\n           if (ix.eq.rvals(j)) then\n              duplicate=.true.\n              !print *, 'found duplicate', i, j, ix\n              exit\n           endif\n        enddo\n        if (.not.duplicate) exit\n     enddo\n     rvals(i) = ix\n     !print *, i, ix\n  enddo\nend subroutine getnuniquerandomnumbers\n"}, {"instruction": "Create a Fortran subroutine named identity that takes a single input argument of type character and returns a single output argument of type character. The subroutine copies the input character to the output character.", "input": "", "output": "    subroutine identity(x, y)\n        character, intent(in) :: x\n        character, intent(out) :: y\n        y = x\n    end subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_aainv to calculate the inverse of a 3x3 matrix. The subroutine takes one input parameter of type real(8) and intent(in), and one output parameter of type real(8) and intent(out).", "input": "", "output": "  subroutine calc_aainv( aa, bb )\n    implicit none\n    real(8),intent(in)  :: aa(3,3)\n    real(8),intent(out) :: bb(3,3)\n    real(8) :: va\n    va = aa(1,1)*aa(2,2)*aa(3,3)+aa(1,2)*aa(2,3)*aa(3,1) &\n        +aa(1,3)*aa(2,1)*aa(3,2)-aa(1,3)*aa(2,2)*aa(3,1) &\n        -aa(1,2)*aa(2,1)*aa(3,3)-aa(1,1)*aa(2,3)*aa(3,2)\n    bb(1,1) = aa(2,2)*aa(3,3) - aa(3,2)*aa(2,3)\n    bb(2,1) = aa(3,2)*aa(1,3) - aa(1,2)*aa(3,3)\n    bb(3,1) = aa(1,2)*aa(2,3) - aa(2,2)*aa(1,3)\n    bb(1,2) = aa(2,3)*aa(3,1) - aa(3,3)*aa(2,1)\n    bb(2,2) = aa(3,3)*aa(1,1) - aa(1,3)*aa(3,1)\n    bb(3,2) = aa(1,3)*aa(2,1) - aa(2,3)*aa(1,1)\n    bb(1,3) = aa(2,1)*aa(3,2) - aa(3,1)*aa(2,2)\n    bb(2,3) = aa(3,1)*aa(1,2) - aa(1,1)*aa(3,2)\n    bb(3,3) = aa(1,1)*aa(2,2) - aa(2,1)*aa(1,2)\n    bb(:,:) = bb(:,:)/va\n    bb(:,:) = transpose( bb )\n  end subroutine calc_aainv\n"}, {"instruction": "Create a Fortran subroutine named check_open to handle file opening and management. The subroutine takes 1 input parameter of type character(*) for the file name. It returns 2 output parameters of type integer.", "input": "", "output": "      subroutine check_open( file_name, file_num, err )\n\n         ! unit number or to open a file named file_name (create the file if it doesn't exist)\n         implicit none\n         character(*), intent(in) :: file_name\n         integer, intent(out)     :: file_num, err\n         logical                  :: isopen, isthere\n\n         err=0\n         inquire( file=file_name, opened=isopen, exist=isthere, number=file_num )\n         if ( isopen ) goto 10\n\n         file_num = 1\n         do\n            inquire( unit=file_num, opened=isopen )\n            if ( .not. isopen ) exit\n            file_num = file_num + 1\n         enddo\n\n         if ( isthere ) then\n            open( unit=file_num, file=file_name, action='write', status='old', iostat=err )\n         else\n            open( unit=file_num, file=file_name, action='write', status='new', iostat=err )\n         endif\n\n         10 return\n\n      end subroutine check_open\n"}, {"instruction": "Write a Fortran subroutine named \"s\" that takes 4 input integer arguments and returns 1 output integer argument. The input argument types are ['integer', 'integer', 'integer', 'integer'], and the output argument type is ['integer']. The subroutine should compute the output by concatenating the input integers as per the given formula.", "input": "", "output": "    subroutine s(a, b, c, d, f)\n    integer, intent(in) :: a, b, c, d\n    integer, intent(out) :: f\n    f = a*1000 + b*100 + c*10 + d\n    end subroutine\n"}, {"instruction": "Write a Fortran subroutine named rotylm to compute the rotation matrix given the gradient matrices in complex numbers. The subroutine takes 3 input parameters of type complex and intent(in), and 1 output parameter of type complex and intent(out). The input parameters are gradmtx, gradmty, and gradmtz, while the output parameter is rotmt.", "input": "", "output": "   subroutine rotylm(gradmtx, gradmty, gradmtz, rotmt)\n      complex, intent(in) :: gradmtx(:,:,:,:), gradmty(:,:,:,:), gradmtz(:,:,:,:) !r,lm,n,x\n      complex, intent(out) :: rotmt(:,:,:,:)\n\n      rotmt(:,:,:,1)=gradmtz(:,:,:,2)-gradmty(:,:,:,3)\n      rotmt(:,:,:,2)=gradmtx(:,:,:,3)-gradmtz(:,:,:,1)\n      rotmt(:,:,:,3)=gradmty(:,:,:,1)-gradmtx(:,:,:,2)\n\n   end subroutine rotylm\n"}, {"instruction": "Create a Fortran subroutine named getbasename to extract the indices of the base name from a given filename. The subroutine takes 1 input parameter of type character(*) and 1 output parameter of type integer array with size 2.", "input": "", "output": "      subroutine getbasename(filename, indices)\n            implicit none\n            character(*), intent(in) :: filename\n            integer, intent(out) :: indices(2)\n            integer :: n, temp, slashtemp, extindex, slashindex\n\n            n = len(filename)\n            temp = index(filename, '/')\n            slashtemp = 0\n            slashindex = 0\n            do while (temp.ne.0 .and. slashtemp.ne.n)\n                slashtemp = slashtemp + temp\n                slashindex = slashtemp\n                temp = index(filename(slashtemp+1:), '/')\n            end do\n\n            extindex = index(filename(slashindex+1:), '.')\n            if (extindex.eq.0) then\n                extindex = n + 1\n            else\n                extindex = slashindex + extindex\n            end if\n\n            indices(1) = slashindex + 1\n            indices(2) = extindex - 1\n      end subroutine\n"}, {"instruction": "Create a Fortran subroutine named int2bool that takes an input parameter of type integer and an output parameter of type logical. The subroutine converts the input integer to a boolean value by assigning true if the integer is non-zero, and false if the integer is zero.", "input": "", "output": "subroutine int2bool (lhs, rhs)\n   implicit none\n   logical, intent(out) :: lhs\n   integer, intent(in) :: rhs\n\n   lhs = rhs .ne. 0\nend subroutine\n"}, {"instruction": "Create a Fortran subroutine named calc_baro_u to calculate the barotropic velocity field based on the provided input parameters. The subroutine takes 10 input parameters of type double precision, integer and calculates 1 output parameter of type double precision.", "input": "", "output": "  subroutine calc_baro_u(ub, u, h, eta, freesurffac, xlow, xhigh, ylow, yhigh, layers, ol)\n    implicit none\n\n    double precision, intent(out) :: ub(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    double precision, intent(in)  :: u(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: h(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n    double precision, intent(in)  :: eta(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol)\n    double precision, intent(in)  :: freesurffac\n    integer, intent(in) :: xlow, xhigh, ylow, yhigh, layers, ol\n\n    integer i, j, k\n    double precision h_temp(xlow-ol:xhigh+ol, ylow-ol:yhigh+ol, layers)\n\n    ub = 0d0\n\n    h_temp = h\n    ! add free surface elevation to the upper layer\n    h_temp(:, :, 1) = h(:, :, 1) + eta*freesurffac\n\n    do k = 1, layers\n      do j = ylow-ol+1, yhigh+ol-1\n        do i = xlow-ol+1, xhigh+ol\n          ub(i,j) = ub(i,j) + u(i,j,k)*(h_temp(i,j,k)+h_temp(i-1,j,k))/2d0\n        end do\n      end do\n    end do\n\n    return\n  end subroutine calc_baro_u\n"}, {"instruction": "Create a Fortran subroutine named calc_metric to compute the metric of a 3x3 tensor 'a' and store the result in 'm'. The input parameter is a 3x3 real(8) array, and the output parameter is a 3x3 real(8) array.", "input": "", "output": "  subroutine calc_metric(a, m)\n    !! compute the metric of a box of tensor `a` to `m`.\n    real(8), intent(in) :: a(3,3)\n    real(8), intent(out) :: m(3,3)\n\n    integer :: i,j,k\n    do i=1,3\n      do j=1,3\n        m(i,j) = 0.d0\n        do k=1,3\n          m(i,j) = m(i,j) + a(k,i)*a(k,j)\n        end do\n      end do\n    end do\n\n  end subroutine calc_metric\n"}, {"instruction": "Create a Fortran subroutine named create_box_from_3l3a to compute a box tensor from box lengths and box angles. The subroutine takes 6 input parameters of type real(8) representing the box lengths (la, lb, lc) and box angles (alpha, beta, gamma), and outputs a 3x3 array of real(8) representing the box tensor. The subroutine should be written in the imperative tone.", "input": "", "output": "  subroutine create_box_from_3l3a(boxtens,la,lb,lc,alpha,beta,gamma)\n    !! computes a box tensor from box lengths and box angles.\n    implicit none\n    real(8),intent(in) :: la,lb,lc,alpha,beta,gamma\n    real(8),intent(out) :: boxtens(3,3)\n\n    real(8) :: a(3),b(3),c(3)\n\n    a(1)=la ; a(2)=0.d0 ; a(3)=0.d0\n    b(1)=lb*cos(gamma) ; b(2) = lb*sin(gamma) ; b(3)=0.d0\n    c(1)=lc*cos(beta) \n    c(2)=lc/(lb*sin(gamma))*(lb*cos(alpha)-la*cos(beta)*cos(gamma))\n    c(3) = sqrt(lc**2-c(2)**2-c(1)**2)\n\n    boxtens(1,:) = a\n    boxtens(2,:) = b\n    boxtens(3,:) = c\n\n  end subroutine create_box_from_3l3a\n"}, {"instruction": "Create a Fortran subroutine named calc_eij_morse to calculate the interaction energy eij based on the Morse potential function. The subroutine takes 2 input parameters of type real*8, dimension(3) and real*8, and 1 output parameter of type real*8.", "input": "", "output": "subroutine calc_eij_morse(rij, param, eij)\n\n    implicit none\n    real*8, dimension(3), intent(in) :: param\n    real*8, intent(in) :: rij\n    real*8, intent(out) :: eij\n    real*8 :: t\n    t = exp(-param(2)*(rij-param(3)))\n    eij = param(1) * (t*t - 2*t)\nend subroutine\n"}, {"instruction": "Write a Fortran subroutine named stpnt to initialize the array parameters par and the array solution u. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 2, and their test_data types are [double precision, double precision].", "input": "", "output": "subroutine stpnt(ndim,u,par)\n!--------- -----\n  \n  implicit none\n  integer, intent(in) :: ndim\n  double precision, intent(out) :: u(ndim), par(*)\n\n  par(1:3) = (/ 1.0d0, 2.0d0, 0.0d0 /)\n\n  u(1) = 1.0 \n   \nend subroutine stpnt\n"}, {"instruction": "Create a Fortran subroutine named build_square to generate a square mesh of triangles. The subroutine takes 4 input parameters of type integer and real(8), and returns 4 output parameters of type real(8), integer, integer, and integer. The inputs are the number of points per side, the number of elements, the number of nodes, and the width of one side of the square. The outputs are the xyz points, the element map, the boundary conditions, and the hex number.", "input": "", "output": "      subroutine build_square(jjmax, nelem, nnode, width, xi, gg, ibc, ihex)\n      implicit none\n      integer, intent(in)  :: jjmax    ! number of points per side\n      integer, intent(in)  :: nelem    ! number of elements\n      integer, intent(in)  :: nnode    ! number of nodes\n      real(8), intent(in)  :: width    ! width of one side of square\n      real(8), intent(out) :: xi(3,nnode)   ! xyz points\n      integer, intent(out) :: gg(3,nelem)   ! element map\n      integer, intent(out) :: ibc(nnode)    ! boundary conditions\n      integer, intent(out) :: ihex(nelem)   ! hex number\n\n      integer :: i, j\n      integer :: ne      ! element counter\n      integer :: nn      ! node counter\n      real(8) :: delx\n      real(8) :: x, y\n\n      write (*,*)\n      write (*,*) 'building square mesh of triangles'\n      write (*,*) 'number of points along edge ', jjmax\n\n      ibc(:)=0\n\n      delx=width/dble(jjmax)  ! mesh width\n\n      nn=0\n      ne=0\n\n      y=0.0d0\n      do j=0, jjmax\n        x=0.0d0\n        do i=0,jjmax\n\n           nn=nn+1\n           xi(1,nn)=x\n           xi(2,nn)=y\n           xi(3,nn)=0.0d0\n           x=x+delx\n\n           if (i.eq.0) ibc(nn)=3\n           if (j.eq.0) ibc(nn)=3\n           if (i.eq.jjmax) ibc(nn)=3\n           if (j.eq.jjmax) ibc(nn)=3\n\n           if (i.ne.0 .and. y.ne.0) then    ! first nn is 11\n             ne=ne+1\n             gg(1,ne)=nn-jjmax-2\n             gg(2,ne)=nn-jjmax-1\n             gg(3,ne)=nn-1\n\n             ihex(ne)=(i-1)*jjmax+j\n\n             ne=ne+1\n             gg(1,ne)=nn-1\n             gg(2,ne)=nn-jjmax-1\n             gg(3,ne)=nn\n\n             ihex(ne)=ihex(ne-1)\n           endif\n        enddo\n\n        y=y+delx\n      enddo\n\n      if (nn.ne.nnode) stop 'nnode error in square_build'\n      if (ne.ne.nelem) stop 'nelem error in square_build'\n\n      return\n      end subroutine build_square\n"}, {"instruction": "Write a Fortran subroutine named l2g to calculate the global array index based on the local array index, processor array index, global array dimension, processor array dimension, and block size. The subroutine takes 5 input parameters of type integer: il, p, n, np, and nb. It returns 1 output parameter of type integer, i, which represents the global array index.", "input": "", "output": "   pure subroutine l2g(il, p, n, np, nb, i)\n      implicit none\n      integer,intent(in) :: il   ! local array index, input\n      integer,intent(in) :: p    ! processor array index, input\n      integer,intent(in) :: n    ! global array dimension, input\n      integer,intent(in) :: np   ! processor array dimension, input\n      integer,intent(in) :: nb   ! block size, input\n      integer,intent(out) :: i    ! global array index, output\n      integer :: ilm1\n      ilm1 = il - 1\n      i = (((ilm1/nb)*np) + p)*nb + mod(ilm1, nb) + 1\n      return\n   end subroutine l2g\n"}, {"instruction": "Create a Fortran subroutine named open_for_write to open a new stream input/output file and return the I/O unit used. The number of input parameters is 1 with the test_data type of ['character(len=*)'], and the number of output parameters is 1 with the test_data type of ['integer'].", "input": "", "output": "subroutine open_for_write(fname, funit)\n! creates a new stream i/o file returning i/o unit used   \n! cgp 2009 jan 28\ncharacter(len=*), intent(in)  :: fname\ninteger, intent(out)          :: funit\n!\nlogical :: exists, open\n! get free i/o unit number\ndo funit = 90, 7, -1\n    inquire(unit=funit, exist=exists, opened=open)\n    if(exists .and. .not. open) exit\nend do\nif(funit < 7) stop 'open_for_write failed - no free i/o units'\nopen (unit=funit, file=fname, access=\"stream\", status=\"replace\")\nend subroutine open_for_write\n"}, {"instruction": "Write a Fortran subroutine named trans that takes a matrix x of real numbers as input and produces the transpose of x as output. The input parameter is of type real, dimension(:,:), and is specified with intent(in). The output parameter is also of type real, dimension(size(x,2), size(x,1)), and is specified with intent(out).", "input": "", "output": "subroutine trans(x,y)\r\n  implicit none\r\n  real, intent(in), dimension(:,:) :: x\r\n  real, intent(out), dimension( size(x,2), size(x,1) ) :: y\r\n  integer :: n, m, i, j\r\n  n = size(x,1)\r\n  m = size(x,2)\r\n  do i=1,n\r\n     do j=1,m\r\n        y(j,i) = x(i,j)\r\n     end do\r\n  end do\r\nend subroutine trans\r\n"}, {"instruction": "Write a Fortran subroutine named \"flatten\" that takes a 2D array as input and outputs a 1D array containing the elements of the input array in row-major order. The input parameter is of type real, dimension(:,:), and the output parameter is of type real, dimension(size(x)).", "input": "", "output": "subroutine flatten(x,y)\r\n  implicit none\r\n  real, intent(in), dimension(:,:) :: x\r\n  real, intent(out), dimension( size(x) ) :: y\r\n  integer :: n, m, i, j, k\r\n  n = size(x,1)\r\n  m = size(x,2)\r\n  k = 1\r\n  do i=1,n\r\n     do j=1,m\r\n        y(k) = x(i,j)\r\n        k = k + 1\r\n     end do\r\n  end do\r\nend subroutine flatten\r\n"}, {"instruction": "Write a Fortran subroutine named locate to locate the index of a value x in a given monotonic array xx. The subroutine takes 2 input parameters of type real: xx (array of monotonic values) and x (value to be located), and 1 output parameter of type integer: j (index where x is located in xx). The subroutine is adapted from the numerical recipe and uses a do loop to step through the array and find the index.", "input": "", "output": "subroutine locate (xx, x, j)\n\n!-------------------------------------------------------------------------------\n! name:     locate\n! purpose:  locates index of value x for given monotonic array xx.\n! input:    xx:  array of monotonic values\n!                for our application, it represents vertical coordinate values\n!           x:   value to bracket in xx\n! output:   j:   index where x is located in xx\n!                            xx(j) <= x < xx(j+1)  \n!                 ***  i hope this is correct - test it dwb    \n! notes:    this routine is adapted from the numerical recipe.\n! revised:  ?? ??? 19??  original version.  (d. byun)\n!           10 sep 2001  converted to free-form f90.  removed n from\n!                        argument list.  (t. otte)\n!           19 mar 2002  corrected upper limit on do loop.  (t. otte)\n!           07 sep 2011  updated disclaimer.  (t. otte)\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  integer,       intent(out)   :: j\n  integer                      :: lbnd\n  real,          parameter     :: small      = 1.0e-6\n  integer                      :: ubnd\n  real,          intent(in)    :: x\n  real,          intent(in)    :: xx         ( : )\n\n  ! step thru array 1 element at a time.\n\n  lbnd = lbound(xx,1)\n  ubnd = ubound(xx,1)\n\n  do j = lbnd, ubnd-1\n    if ( ( x+small >= xx(j) ) .and. ( x < xx(j+1) ) ) exit\n  enddo\n\nend subroutine locate\n"}, {"instruction": "Write a Fortran subroutine named compress. The subroutine takes 4 input parameters of types integer, real*8, real*8, and real*8, and 4 output parameters of types real*8, real*8, real*8, and integer. The subroutine compresses the input Gaussian functions based on their heights, widths, and hill positions, and then outputs the compressed Gaussian functions.", "input": "", "output": "subroutine compress(ng,hill,height,width,cng,c_hill,c_width,c_height)\nimplicit none\n integer, intent(in)::ng\n real*8,  intent(in)::hill(ng),width(ng),height(ng)\n real*8, intent(out)::c_hill(ng),c_width(ng),c_height(ng)\n integer,intent(out)::cng\n!\n integer :: i,j,n,min_j\n real*8  :: distance,cutoff=1.0,dum,new_height,new_width,new_hill,min_d\n!\n! initialization of compressed gaussians\n c_hill(1) =hill(1)\n c_width(1)=width(1)\n c_height(1)=height(1)\n n=1\n \n do i=2,ng\n    min_d=sqrt(abs(((hill(i))-c_hill(1))/c_width(1))**2)\n    min_j=1\n      do j=1,n\n         distance=sqrt(abs(((hill(i))-c_hill(j))/c_width(j))**2)\n         if(distance.lt.min_d) then\n            min_d=distance\n            min_j=j\n         endif\n        ! print*,\"distance: \",distance\n     enddo\n     !print*,\"minimum distance: \",min_d,\"location: \",min_j\n     !if minimun distance is less than given cutoff, it merges the both gaussinas\n     ! add as new compressed kernal otherwise.   \n     if(min_d.lt.cutoff)then\n           new_height=height(i)+c_height(min_j)\n           new_hill  =(1.0/new_height)*((height(i)*hill(i))+(c_height(min_j)*c_hill(min_j)))\n           dum=(height(i)*(width(i)**2+hill(i)**2)+c_height(min_j)*(c_width(min_j)**2+c_hill(min_j)**2))\n           new_width=(1.0/new_height)*dum-new_hill**2\n           ! store new variables to min_jth kernel\n           c_height(min_j)=new_height           \n           c_width(min_j)=new_width\n           c_hill(min_j)=new_hill\n        else\n           n=n+1\n           c_height(n)=height(i)  \n           c_width(n)=width(i)\n           c_hill(n)=hill(i)\n        endif   \n\n enddo\n! store n as no. of compressed gaussians\n cng=n\n\nend subroutine compress\n"}, {"instruction": "Create a Fortran subroutine named get_value_definitions to fetch the definition for a given long variable name and requested value. The subroutine takes 2 input parameters of type character(len=*) and returns 1 output parameter of type character(len=*). The input parameters are long_var_name and req_val, and the output parameter is ret_val.", "input": "", "output": "subroutine get_value_definitions(long_var_name, req_val, ret_val)\n    implicit none\n    character(len=*), intent(in) :: long_var_name\n    character(len=*), intent(in) :: req_val\n    character(len=*), intent(out) :: ret_val\n    print *, 'ltrans_bmi> fetching definition for the long variable name: ', trim(long_var_name)\n    select case( trim(long_var_name) )\n        case('s_coordinate_stretching_curves_at_rho_points')\n            if(trim(req_val) == \"type\")then\n                ret_val = 'double'\n            else if(trim(req_val) == \"rank\")then\n                ret_val = \"1\"\n            else if(trim(req_val) == \"units\")then\n                ret_val = 'nondimensional'\n            else if(trim(req_val) == \"name\")then\n                ret_val = 'cs_r'\n            endif\n        case default\n            print *, 'ltrans_bmi> error in fetching the value for the requested long name'\n            ret_val = \"-1\"\n    end select\nend subroutine get_value_definitions\n"}, {"instruction": "Create a Fortran subroutine named read_int_param to convert a string input into an integer value. The subroutine should have 1 input parameter of type character(len=*) and 1 output parameter of type integer.", "input": "", "output": "  subroutine read_int_param(valstr,par)\n    character(len=*), intent(in) :: valstr\n    integer, intent(out) :: par\n    read(valstr,*) par\n  end subroutine read_int_param\n"}, {"instruction": "Create a Fortran subroutine named read_logical_param to convert a string input to a logical value. The subroutine takes 1 input parameter of type character(len=*) and returns 1 output parameter of type logical.", "input": "", "output": "  subroutine read_logical_param(valstr,par)\n    character(len=*), intent(in) :: valstr\n    logical, intent(out) :: par\n    read(valstr,*) par\n  end subroutine read_logical_param\n"}, {"instruction": "Create a Fortran subroutine named getshapfct_edge to calculate shape functions and their derivatives for a specific edge. The subroutine takes 3 input parameters of type integer, integer, and real*8 and returns 2 output parameters of type real*8, each with a dimension of nvfac.", "input": "", "output": "subroutine getshapfct_edge(ncurv,nvfac,shpf, dshprf, r)\nimplicit none\ninteger,                   intent(in)::ncurv,nvfac\nreal*8, dimension(nvfac), intent(out):: shpf\nreal*8, dimension(nvfac), intent(out):: dshprf\nreal*8,                    intent(in):: r\n!\nif(ncurv.eq.0)then\n!...shape functions\nshpf(1) =  (1.d0-r)/2.d0\nshpf(2) =  (1.d0+r)/2.d0\n\ndshprf(1) =-.5d0\ndshprf(2) = .5d0\n\n!...quadratic cell\nelseif(ncurv.eq.1)then\nshpf(1) =  -0.5d0*(1.d0-r)*r\nshpf(2) =   0.5d0*(1.d0+r)*r\nshpf(3) =         (1.d0+r)*(1.d0-r)\n!\ndshprf(1) = -0.5d0 + r\ndshprf(2) =  0.5d0 + r\ndshprf(3) = -2.d0*r\n\n!...cubic cell\nelseif(ncurv.eq.2)then\n!...shape functions\nshpf(1) =  9.d0/16.d0*(1.d0-r)*(r+1.d0/3.d0)*(r-1.d0/3.d0)\nshpf(2) = -9.d0/16.d0*(1.d0+r)*(1.d0/3.d0-r)*(r+1.d0/3.d0)\nshpf(3) =  27.d0/16.d0*(r-1.d0)*(r+1.d0)*(r-1.d0/3.d0)\nshpf(4) = -27.d0/16.d0*(r-1.d0)*(r+1.d0)*(r+1.d0/3.d0)\n!\ndshprf(1) = 9.d0/16.d0*(1.d0/9.d0-3.d0*r**2+2.d0*r)\ndshprf(2) =-9.d0/16.d0*(1.d0/9.d0-3.d0*r**2-2.d0*r)\ndshprf(3) = 27.d0/16.d0*(-1.d0+3.d0*r**2-2.d0/3.d0*r)\ndshprf(4) =-27.d0/16.d0*(-1.d0+3.d0*r**2+2.d0/3.d0*r)\n!\nendif\n\nend subroutine getshapfct_edge\n"}, {"instruction": "Create a Fortran subroutine named atomic_write to atomically store an integer value into another integer variable. The subroutine takes 1 input parameter of type integer and 1 output parameter of type integer. Ensure that the value is stored atomically into the output parameter, and no part of the output parameter can change until after the entire write operation is completed.", "input": "", "output": "       subroutine atomic_write(p, value)\n       integer, intent(out) :: p\n       integer, intent(in) :: value\n! guarantee that value is stored atomically into p. no part of p can change\n! until after the entire write operation is completed.\n!$omp atomic write\n       p = value\n       end subroutine atomic_write\n"}, {"instruction": "Create a Fortran subroutine named sum, which takes two input arrays: one of integer type and allocatable, and the other of real type and allocatable. It produces one output array of complex type and allocatable. The function computes the sum of the elements from the input arrays and stores the results in the output array. Ensure to deallocate any temporary arrays created during the computation.", "input": "", "output": "subroutine sum(a, b, c)\nimplicit none\n\ninteger, allocatable, intent(in) :: a(:)\nreal, allocatable, intent(in) :: b(:, :)\ncomplex, allocatable, intent(out) :: c(:, :, :)\ninteger :: i, j, k\n\ncomplex, allocatable :: c_copy(:, :, :)\n\nallocate(c_copy(lbound(a, 1):ubound(a, 1), lbound(b, 1):ubound(b, 1), lbound(b, 2):ubound(b, 2)))\nallocate(c(lbound(a, 1):ubound(a, 1), lbound(b, 1):ubound(b, 1), lbound(b, 2):ubound(b, 2)))\n\ndo i = lbound(a, 1), ubound(a, 1)\n    do j = lbound(b, 1), ubound(b, 1)\n        do k = lbound(b, 2), ubound(b, 2)\n            c_copy(i, j, k) = a(i) + b(j, k)\n            c(i, j, k) = a(i) + b(j, k)\n        end do\n    end do\nend do\n\ndeallocate(c_copy)\n\nend subroutine sum\n"}, {"instruction": "Create a Fortran subroutine named mult that takes two real input parameters and computes their product. The number of input parameters is 2 and the test_data type is ['real', 'real']. The number of output parameters is 1 and the test_data type is ['real'].", "input": "", "output": "subroutine mult(x,y,z)\nreal, intent(in) :: x,y\nreal, intent(out) :: z\nz=x*y\nend subroutine mult\n"}, {"instruction": "Create a Fortran subroutine named solve_heat_explicit to solve the heat equation using an explicit method. The subroutine takes 5 input parameters of type real(kind=8), real(kind=8), real(kind=8), real(kind=8), and integer, and 1 output parameter of type real(kind=8).", "input": "", "output": "subroutine solve_heat_explicit(x, u0, t0, tfinal, nsteps, u)\n    implicit none\n    real(kind=8), intent(in) :: x(0:), u0(0:), t0, tfinal\n    integer, intent(in) :: nsteps\n    real(kind=8), intent(out) :: u(0:)\n    integer :: n, i, nstep\n    real(kind=8) :: dx, dt, dtdx2, um1, up1\n    real(kind=8), allocatable :: uxx(:)\n\n    n = size(x) - 2\n    dx = x(2) - x(1)\n    dt = (tfinal - t0) / float(nsteps)\n\n    print 21, n, dx, dt\n21  format(\"solving heat equation with n = \",i6, \" dx = \",e10.3,\" dt = \",e10.3)\n\n    dtdx2 = dt / dx**2\n    print 22, dtdx2\n22  format(\"  dt/dx**2 = \",f7.3)\n\tif (dtdx2 > 0.5d0) then\n\t\tprint *, \"*** warning: the explicit method is unstable\"\n\t\tendif\n\n    allocate(uxx(1:n))\n\n    u = u0\n\n    do nstep=1,nsteps\n\n        do i=1,n\n            uxx(i) = (u(i-1) - 2.d0*u(i) + u(i+1)) / dx**2\n            enddo\n\n        do i=1,n\n            u(i) = u(i) + dt * uxx(i)\n            enddo\n\n        enddo\n\nend subroutine solve_heat_explicit\n"}, {"instruction": "Write a Fortran subroutine named tstar to calculate the saturation point temperature ts [k] given the temperature t [k], pressure p [mb], and specific humidity q [g/kg]. The subroutine should have 6 input parameters of types integer, integer, integer, real(8) arrays of dimensions (km,jm,im), real(8) arrays of dimensions (km,jm,im), and real(8) arrays of dimensions (km,jm,im). It should also have 1 output parameter of type real(8) array of dimensions (km,jm,im).", "input": "", "output": "subroutine tstar(km,jm,im,t,p,q,ts)\n\n! compute saturation point temperature ts [k] \n! (i.e. temperature at lifting condensation level) \n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n! use bolton eqn (12)\n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: ts\n\n! local\n  real(8) :: rv, rd, eps, oneoverk\n  real(8), dimension(km,jm,im) :: r,th,c,e\n\n  rv  = 461.5\n  rd  = 287.04\n  eps = rd/rv\n  oneoverk = 3.504 ! cp/rd\n  r = q/(1.e3 - q)  ! water vap. mixing ratio [kg/kg]\n\n!  call theta(km,jm,im,t,p,q,th)\n!  c=log( r/(r+eps*1.e3)/t**oneoverk / 1.7743e-8 )\n!  ts=217.8*c/(12.992-c) + 273.15\n  e = p*r/(r+eps)\n  ts = 2840./( 3.5*log(t) - log(e) - 4.805) + 55. \n\nend subroutine tstar\n"}, {"instruction": "Create a Fortran subroutine named \"theta\" to compute the potential temperature theta [k] based on the given parameters. The subroutine should have 11 input parameters of types integer, real(8), and real(8) arrays with dimensions km, jm, and im. It should also have 1 output parameter of type real(8) array with dimensions km, jm, and im.", "input": "", "output": "subroutine theta(km,jm,im, rd, rv, cpd, cpv, p0, p, t, q, th)\n\n! compute potential temperature  theta [k]\n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), intent(in)                       :: p0,rd,rv,cpd,cpv\n  real(8), dimension(km,jm,im), intent(in)  :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: th\n\n! local\n  real(8) :: eps\n  real(8), dimension(km,jm,im) :: cp,r,kappa\n\n  eps   = rd/rv\n  r     = rd * (1.+ (1.-eps)/eps*q*1.e-3)\n  cp    = cpd * (1. + (cpv/cpd-1.)*q*1.e-3)\n  kappa = r/cp \n\n  th = t*(p0/p)**kappa\n      \nend subroutine theta\n"}, {"instruction": "Write a Fortran subroutine named theta_old to calculate the potential temperature theta in Kelvin. The subroutine takes 6 input parameters: km, jm, im (all integers), and arrays t, p, q of type real(8) and dimensions km, jm, im. It provides 1 output parameter th of type real(8) and dimensions km, jm, im.", "input": "", "output": "subroutine theta_old(km,jm,im,t,p,q,th)\n\n! compute potential temperature  theta [k]\n! given temperature t [k], pressure p [mb], specific humidity q [g/kg].\n! use bolton eqn (7) \n \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,p,q\n  real(8), dimension(km,jm,im), intent(out) :: th\n\n! local\n  real(8) :: ak\n  real(8), dimension(km,jm,im) :: r\n\n  ak=0.2854 ! r_(dry air)/cp\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  th = t*(1000./p)**( ak*(1.-0.28e-3*r) )\n      \nend subroutine theta_old\n"}, {"instruction": "Create a Fortran subroutine named \"es\" to compute the saturation partial pressure of water vapor. The subroutine should have 4 input parameters: 3 integers (km, jm, im) and a 3D array of real(8) type (t), and 1 output parameter of a 3D array of real(8) type (e). The subroutine calculates the saturation partial pressure using the formula provided and stores the result in the array e.", "input": "", "output": "subroutine es(km,jm,im,t,e)\n\n! compute saturation partial pressure of water vapor es [mb]\n! at temperature t [k].\n! use bohren+albrecht p. 198\n     \n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t\n  real(8), dimension(km,jm,im), intent(out) :: e\n\n! local\n  real(8) :: t0\n\n  t0 = 273.15\n  e  = 6.11 * exp( 6808.*(1./t0 - 1./t) - 5.09*log(t/t0) )\n\nend subroutine es\n"}, {"instruction": "Write a Fortran subroutine named \"esflatau\" to compute the saturation partial pressure of water vapor at a given temperature using an 8th order polynomial fit by Flatau et al. The subroutine takes 5 input parameters: km, jm, im, t, and i with types [integer, integer, integer, integer, real(8), dimension(km,jm,im)]. It produces 1 output parameter: e with type [real(8), dimension(km,jm,im)].", "input": "", "output": "subroutine esflatau(km,jm,im,t,i,e)\n\n! compute saturation partial pressure of water vapor es [mb]\n! at temperature t [k].\n! use 8th order polynomial fit of flatau et al (1992), table 4\n\n! i=1 => vapour pressure over water (valid -85c < t < 70c)\n! i=2 => vapour pressure over ice (valid -90c < t < 0c)\n    \n  implicit none\n  integer,intent(in)                       :: km,jm,im,i\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t\n  real(8), dimension(km,jm,im), intent(out) :: e\n\n! local\n  integer :: n\n  real(8) :: t0\n  real(8), dimension(9,2) :: a\n\n  data a / 6.11239921,    0.443987641,  0.142986287e-1,  0.264847430e-3, &\n       0.302950461e-5, 0.206739458e-7, 0.640689451e-10,-0.952447341e-13, &\n       -0.976195544e-15,                                                 &\n       6.11147274,    0.503160820, 0.188439774e-1,  0.420895665e-3,  &\n   0.615021634e-5, 0.602588177e-7, 0.385852041e-9, 0.146898966e-11,  &\n   0.252751365e-14 /\n\n  t0=273.15\n\n  e = a(9,i)\n  do n=8,1,-1\n     e = e*(t-t0) + a(n,i)\n  enddo\n\nend subroutine esflatau\n"}, {"instruction": "Write a Fortran subroutine named pdryadiab that calculates the pressure level at which a given temperature occurs on a dry adiabat, identified by potential temperature and mixing ratio. The number of input arguments is 6 and the test_data type is [integer, integer, integer, real(8), dimension(km,jm,im), real(8), dimension(km,jm,im)]. The number of output arguments is 1 and the test_data type is [real(8), dimension(km,jm,im)].", "input": "", "output": "subroutine pdryadiab(km,jm,im,t,theta,q,p)\n\n! compute pressure level pdryadiab [mb] at which temperature is t [k]\n! on the dry (i.e. unsaturated) adiabat identified by \n! potential temperature theta [k] and mixing ratio q [g/kg].\n! use bolton eqn (7) \n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: t,theta,q\n  real(8), dimension(km,jm,im), intent(out) :: p\n\n! local\n  real(8) :: oneoverk\n  real(8), dimension(km,jm,im) :: r\n\n  oneoverk=3.504 ! cp/r_(dry air)\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  p = 1000.*(t/theta)**( oneoverk/(1.-0.28e-3*r) )\n\nend subroutine pdryadiab\n"}, {"instruction": "Write a Fortran subroutine named tdryadiab to calculate the temperature t [K] at a given pressure level p [mb] on the dry adiabat using the potential temperature theta [K] and mixing ratio q [g/kg]. The subroutine has 6 input parameters of types integer, integer, integer, real(8) arrays, and outputs a real(8) array.", "input": "", "output": "subroutine tdryadiab(km,jm,im,theta,p,q,t)\n\n! compute temperature t [k] at level p [mb] \n! on the dry (i.e. unsaturated) adiabat identified by \n! potential temperature theta [k] and mixing ratio q [g/kg].\n! use bolton eqn (7) \n\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: theta,p,q\n  real(8), dimension(km,jm,im), intent(out) :: t\n\n! local\n  real(8) :: ak\n  real(8), dimension(km,jm,im) :: r\n\n  ak=0.2854 ! r_(dry air)/cp\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n\n  t = theta*(1000./p)**( -ak*(1.-0.28e-3*r) )\n      \nend subroutine tdryadiab\n"}, {"instruction": "Write a Fortran subroutine named z that performs a specific computation for atmospheric or oceanic modeling. The subroutine takes 8 input parameters: integer km, integer jm, integer im, real(8) r, real(8) g, real(8) arrays p0(jm,im), p(km,jm,im), and t(km,jm,im). It produces 1 output parameter: a real(8) array zz(km,jm,im).", "input": "", "output": "subroutine z(km,jm,im,r,g,p0,p,t,zz)\n\n!\n  implicit none\n  integer, intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), intent(in)                       :: r,g\n  real(8), dimension(jm,im), intent(in)     :: p0\n  real(8), dimension(km,jm,im), intent(in)  :: p,t\n  real(8), dimension(km,jm,im), intent(out) :: zz\n\n! local\n  integer :: k\n  real(8), dimension(jm,im) :: dp,pm,tm\n\n! bottom level\n  dp = (p0 - p(km,:,:))\n  pm = (p0 + p(km,:,:))/2.\n  zz(km,:,:) = r/g * t(km,:,:)/pm * dp\n\n! build up from bottom\n  do k=km-1,1,-1\n     dp = p(k+1,:,:) - p(k,:,:)\n     pm = (p(k+1,:,:) + p(k,:,:))/2.\n     tm = (t(k+1,:,:) + t(k,:,:))/2.\n     zz(k,:,:) = zz(k+1,:,:) + r/g * tm/pm * dp\n  enddo\n\nend subroutine z\n"}, {"instruction": "Create a Fortran subroutine named perm_rsp to calculate the species-level effect of permafrost on growth based on the provided code. The subroutine takes 4 input arguments of type integer, real, real, and real, and returns 1 output argument of type real.", "input": "", "output": "    subroutine perm_rsp(p_tol, l1_p_tol, l2_p_tol, amlt, fc_perm)\n        !\n        !  calculates species-level effect of permafrost on growth\n        !  adapted from bonan 1989 ecological modelling 45:275-306\n        !\n        !  record of revisions:\n        !      date       programmer          description of change\n        !      ====       ==========          =====================\n        !    09/08/19     a. c. foster        original code\n        !\n\n        ! data dictionary: calling arguments\n        integer, intent(in)  :: p_tol    ! relative permafrost tolerane (1-2; 2 = least tolerant)\n        real,    intent(in)  :: amlt     ! active layer depth (m)\n\treal,    intent(in)  :: l1_p_tol ! tolerant species growth response at low active layer depths\n\treal,    intent(in)  :: l2_p_tol ! intolerant species growth response at low active layer depths\n        real,    intent(out) :: fc_perm  ! growth response to permafrost (0-1)\n\n        ! data dictionary: local variables\n        real :: y ! growth response to permafrost (0-1)\n\n       if (amlt .le. 1.0) then\n\t\t\tif (p_tol .eq. 1) then\n\t\t\t\ty = (1*.001)/(.001 + (1-.001)*exp(-l1_p_tol*amlt))\n\t\t\telse\n\t\t\t\ty = (1*.001)/(.001 + (1-.001)*exp(-l2_p_tol*amlt))\n\t\t\tend if\n\t\t\n\t\telse if (amlt .gt. 1.0) then\n\t\t\ty = 1.0\n\t\tend if\n        ! must be between 0.0 and 1.0\n        if (y .ge. 1.0) y = 1.0\n        if (y .le. 0.0) y = 0.0\n\n        fc_perm = y\n\n    end subroutine perm_rsp\n"}, {"instruction": "Create a Fortran subroutine named pbc_mp_kpoint_set to generate k-points in reciprocal space for periodic boundary conditions. The subroutine takes 3 input parameters of type integer, dimension(3), double precision, dimension(3), and integer. It has 2 output parameters of type double precision, dimension(1:3,nkpts) and double precision, dimension(nkpts).", "input": "", "output": "  subroutine pbc_mp_kpoint_set(n, s, nkpts, kpt, w)\n\n    implicit none\n\n    integer,          dimension(3),         intent(in)  :: n\n    double precision, dimension(3),         intent(in)  :: s\n    integer,                                intent(in)  :: nkpts\n    double precision, dimension(1:3,nkpts), intent(out) :: kpt\n    double precision, dimension(nkpts),     intent(out) :: w\n    \n    integer          :: i1, i2, i3, ikpt\n    double precision :: n1_inv, n2_inv, n3_inv\n\n    if (nkpts /= n(1)*n(2)*n(3)) then\n       write(0,*) \"error: ill-sized k-point array in `pbc_mp_kpoint_set()'.\"\n       stop\n    end if\n\n    n1_inv = 1.0d0/dble(n(1))\n    n2_inv = 1.0d0/dble(n(2))\n    n3_inv = 1.0d0/dble(n(3))\n\n    ikpt = 0\n    do i1 = 0, (n(1) - 1)\n    do i2 = 0, (n(2) - 1)\n    do i3 = 0, (n(3) - 1)\n       ikpt = ikpt + 1\n       kpt(1,ikpt) = n1_inv*(dble(i1) + s(1))\n       kpt(2,ikpt) = n2_inv*(dble(i2) + s(2))\n       kpt(3,ikpt) = n3_inv*(dble(i3) + s(3))\n    end do\n    end do\n    end do\n\n    ! for now, all k-points are equally weighted:\n    w(1:nkpts) = 1.0d0/dble(nkpts)\n\n  end subroutine pbc_mp_kpoint_set\n"}, {"instruction": "Create a Fortran subroutine named build_equilateral to generate an equilateral triangle mesh. The subroutine takes 1 input parameter of type integer and returns 5 output parameters: 3 of type integer, 1 of type real(8), and 1 of type integer. The function builds the mesh using the input parameter and calculates the number of elements, number of nodes, xyz points, element map, and boundary condition map.", "input": "", "output": "      subroutine build_equilateral(jjmax, xi, gg, ibc, nelem, nnode)\n      implicit none\n      integer, intent(in)  :: jjmax    ! number of points per side\n      integer, intent(out) :: nelem    ! number of elements\n      integer, intent(out) :: nnode    ! number of nodes\n      real(8), intent(out) :: xi(3,jjmax*jjmax)  ! xyz points\n      integer, intent(out) :: gg(3,jjmax*jjmax)  ! element map\n      integer, intent(out) :: ibc(jjmax*jjmax)   ! boundary condition map\n\n      integer :: i, j, ii\n      real(8) :: delx\n      real(8) :: dely\n      real(8) :: x, y, x1\n\n      write (*,*)\n      write (*,*) 'building equilateral triangle mesh'\n      write (*,*) 'number of points along edge ', jjmax\n\n      delx=1.0d0/dble(jjmax-1)\n      dely=delx*sqrt(3.0d0)/2.0d0\n\n      y=0.0d0\n\n      x1=0.0d0\n      x=0.0d0\n      y=0.0d0\n      do j=1, jjmax\n        x=x1\n        ii=jjmax+1-j\n        do i=1,ii\n\n           nnode=nnode+1\n           xi(1,nnode)=x\n           xi(2,nnode)=y\n           xi(3,nnode)=0.0d0\n           x=x+delx\n           if (i.eq.1 .or. i.eq.ii .or. j.eq.1) then\n             ibc(nnode)=3\n           else\n             ibc(nnode)=0\n           endif\n\n           if (i.lt.ii) then\n             nelem=nelem+1\n             gg(1,nelem)=nnode\n             gg(2,nelem)=nnode+1\n             gg(3,nelem)=nnode+ii\n           endif\n           if (i.lt.ii-1) then\n             nelem=nelem+1\n             gg(1,nelem)=nnode+1\n             gg(2,nelem)=nnode+ii+1\n             gg(3,nelem)=nnode+ii\n           endif\n\n        enddo\n        y=y+dely\n        x1=x1+delx*0.5d0    ! increment half width for start of next time\n      enddo\n\n      write (*,*) 'final nnode ', nnode\n      write (*,*) 'final nelem ', nelem\n\n!!    write (*,*) 'sqrt3/2 = ', sqrt(3.0d0)/2.0d0\n!!    write (*,*) 'final x = ', xi(1,nnode)\n!!    write (*,*) 'final y = ', xi(2,nnode)\n\n      x=xi(1,nnode)\n      y=xi(2,nnode)\n      if (abs(x-0.5d0)            .gt.1.0d-8) stop 'error in final mesh x value'\n      if (abs(y-sqrt(3.0d0)/2.0d0).gt.1.0d-8) stop 'error in final mesh y value'\n\n      return\n      end subroutine build_equilateral\n"}, {"instruction": "Create a Fortran subroutine named powers to calculate the square and cube of an input integer. The subroutine should take 1 input parameter of type integer and provide 2 output parameters of type integer representing the square and cube of the input integer.", "input": "", "output": "subroutine powers(i,isquare,icube)\r\ninteger, intent(in)  :: i\r\ninteger, intent(out) :: isquare,icube\r\nisquare = i**2\r\nicube   = i*isquare\r\nend subroutine powers\r\n"}, {"instruction": "Create a Fortran subroutine named \"wrf_time_to_hms\" that takes a real number as input to represent time in seconds and returns three integers representing hours, minutes, and seconds. The input parameter is 1 of type real, and the output parameters are 3 of type integer.", "input": "", "output": "  subroutine wrf_time_to_hms(wrf_time, hour,minute,second)\n    implicit none\n    real, intent(in)                    :: wrf_time\n    integer, intent(out)                :: hour, minute, second\n    integer                             :: leftover_seconds\n    hour = floor(wrf_time)/3600\n    leftover_seconds = mod(floor(wrf_time),3600)\n    minute = leftover_seconds/60           \n    second = mod(leftover_seconds,60)\n  end subroutine wrf_time_to_hms\n"}, {"instruction": "Write a Fortran subroutine named determinant to calculate the determinant of a 3x3 matrix. The subroutine takes one input parameter, a real array of size 3x3. The input matrix is specified using the \"intent(in)\" keyword. The subroutine also has one output parameter, a real value that represents the determinant of the matrix. The output value is specified using the \"intent(out)\" keyword. The type of the input matrix is \"real(8), dimension(3, 3)\" and the type of the output determinant is \"real(8)\".", "input": "", "output": "        subroutine determinant(matrix, deter_value)\n            real(8), dimension(3, 3), intent(in) :: matrix\n            real(8), intent(out) :: deter_value\n            deter_value=(matrix(1,1)*matrix(2,2)*matrix(3,3)+matrix(1,2)*matrix(2,3)*matrix(3,1)&\n                    +matrix(1,3)*matrix(2,1)*matrix(3,2)&\n                    -matrix(3,1)*matrix(2,2)*matrix(1,3)-matrix(2,1)*matrix(1,2)*matrix(3,3)&\n                    -matrix(1,1)*matrix(3,2)*matrix(2,3))\n        end subroutine determinant\n"}, {"instruction": "Write a Fortran subroutine named \"comp_vel\" that converts wind velocity from speed and direction to u and v components. The subroutine requires two input parameters of type real, representing the wind speed (ff) and wind direction (dd). It also has two output parameters of type real, representing the u and v components of the wind velocity.", "input": "", "output": "      subroutine comp_vel(ff,dd,u,v)\n\n! *** this function converts the wind velocity from:   \n! ***         speed (ff) and direction (dd) \n! *** to:       u   and           v.\n\n\n! *** we require the use of implicit none:\n\n      implicit none\n\n! *** global declarations:\n      real,intent(in)  :: ff,dd\n      real,intent(out) :: u,v\n\n! *** local declarations:\n      real,parameter :: pi  = 3.141592654\n      real,parameter :: rad = pi/180.0\n\n      real :: theta\n\n! *** \"pi\"    - the constant pi.\n! *** \"rad\"   - the conversion from degrees to radians.\n!\n! *** \"dd\" =  0 degrees means wind from the north blowing southards.\n! *** \"dd\" = 90 degrees means wind from the east  blowing westwards.  \n!\n! *** converts the wind direction to radians:\n\n      theta = dd * rad\n\n      u = -ff*sin(theta)\n      v = -ff*cos(theta)\n\n      return\n      \n      end subroutine comp_vel\n"}, {"instruction": "Write a Fortran subroutine named sdf_safe_copy_string that safely copies a string from one variable to another. The subroutine has 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine sdf_safe_copy_string(s1, s2)\n\n    character(len=*), intent(in) :: s1\n    character(len=*), intent(out) :: s2\n    integer :: len1, len2, olen, i\n\n    len1 = len_trim(s1)\n    len2 = len(s2)\n    olen = min(len1,len2)\n    if (olen > 0) then\n      s2(1:olen) = s1(1:olen)\n      do i = olen+1,len2\n        s2(i:i) = ' '\n      end do\n    else\n      do i = 1,len2\n        s2(i:i) = ' '\n      end do\n    end if\n\n  end subroutine sdf_safe_copy_string\n"}, {"instruction": "Write a Fortran subroutine named \"word2hex\" to convert a string of characters into its hexadecimal representation. The subroutine takes 1 input parameter of type \"character (len = 10)\" and 2 output parameters. The first output parameter is an array of integers with dimensions 0 to 31, representing the hexadecimal values of each character in the input string. The second output parameter is a single integer indicating the length of the resulting hexadecimal representation. The subroutine iterates over each character in the input string, converts it to its corresponding hexadecimal value, and stores it in the output array. Finally, it updates the length parameter to reflect the final length of the hexadecimal representation.", "input": "", "output": "      subroutine word2hex(w, h, l)\n\n!   w is usually the word we get from readword(w).\n!   h is the output array, which is w, but in hex.\n!   l is the resultant length. because we are going from native string\n!   to array of integers, we no longer have the luxury of strlen.\n      character (len = 10), intent(in) :: w\n      integer, dimension(0:31), intent(out) :: h\n      integer, intent(out) :: l\n\n!   i is used to iterate through the input, from 1 to len_trim(w),\n!      where len_trim(w) is the usable length of the string.\n!   j is used to keep track of how many characters are being written\n!      to the final output array, h. that way we can assign it to l,\n!      the length of the string\n!   temph is a temporary 2-member array that holds the intermediate\n!      representation of the conversion to hex (e.g. 7f). we then\n!      convert the individual two members to integers in the output\n      integer :: i, j = 0\n      integer, dimension(1:2) :: hex\n      character (len = 2) :: temph\n\n!   here we iterate over every usable character of the input string\n      do i = 1, len_trim(w)\n\n!      i will be our iterator variable, so we take the character at\n!      i of w ( w(i:i) ) and write two characters to the temph array;\n!      these two characters represent the left and right parts of the\n!      hex representation of each character.\n         write(temph, '(z2)') w(i:i)\n\n!      then, we take each of the two characters in temph and write them\n!      to another temporary array of two members, this time it's hex,\n!      which is an array of two integers. they represent the cardinal\n!      value of the hex. from 0-9 it's 0-9, but characters a,b,c,d,e,f\n!      are actually represented as 10,11,12,13,14,15 in decimal, hence\n!      why we are converting it as such\n         read(temph(1:1), '(z1)') hex(1)\n         read(temph(2:2), '(z1)') hex(2)\n\n!      every time this step completes, we increment the j variable to\n!      keep track of the final length of the hex array when writing.\n         h(j) = hex(1)\n         j = j + 1\n         h(j) = hex(2)\n         j = j + 1\n\n      end do\n\n!   finally, we write the final value of j to the length variable.\n      l = j\n\n      end subroutine word2hex\n"}, {"instruction": "Provide a Fortran subroutine named elem that converts a given input key1, which is a string of characters, into a corresponding integer value nat. The subroutine takes one input parameter of type character(*) and one output parameter of type integer. \n\nIn the subroutine, an array of character elements named \"elemnt\" is defined and initialized with two-character representations of chemical elements. The subroutine iterates over each character in the input key1 and checks if it matches any element in the elemnt array. If a match is found, the corresponding integer value is assigned to the output parameter nat. \n\nYour task is to provide the Fortran instruction for this subroutine.", "input": "", "output": "  elemental subroutine elem(key1, nat)\n    character(*), intent(in) :: key1\n    integer, intent(out) :: nat\n\n    character(2), parameter :: elemnt(94) = [&\n        & 'h ','he', &\n        & 'li','be','b ','c ','n ','o ','f ','ne', &\n        & 'na','mg','al','si','p ','s ','cl','ar', &\n        & 'k ','ca','sc','ti','v ','cr','mn','fe','co','ni','cu', &\n        & 'zn','ga','ge','as','se','br','kr', &\n        & 'rb','sr','y ','zr','nb','mo','tc','ru','rh','pd','ag', &\n        & 'cd','in','sn','sb','te','i ','xe', &\n        & 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy', &\n        & 'ho','er','tm','yb','lu','hf','ta','w ','re','os','ir','pt', &\n        & 'au','hg','tl','pb','bi','po','at','rn', &\n        & 'fr','ra','ac','th','pa','u ','np','pu' ]\n\n    character(2) :: e\n    integer :: k, j, n, i\n\n    nat=0\n    e=' '\n    k=1\n    do j=1,len(key1)\n      if (k.gt.2)exit\n      n=ichar(key1(j:j))\n      if (n.ge.ichar('a') .and. n.le.ichar('z') )then\n        e(k:k)=char(n+ichar('a')-ichar('a'))\n        k=k+1\n      end if\n      if (n.ge.ichar('a') .and. n.le.ichar('z') )then\n        e(k:k)=key1(j:j)\n        k=k+1\n      end if\n    end do\n\n    do i=1,94\n      if (e.eq.elemnt(i))then\n        nat=i\n        return\n      end if\n    end do\n\n\n  end subroutine elem\n"}, {"instruction": "Write a Fortran subroutine named \"errp\" to calculate the error between a set of predicted values and actual values. The subroutine takes 4 input parameters: an integer*4 variable \"nt\", real*8 arrays \"p\", \"x\", and a 2D real*8 array \"c\" with dimensions (4,1). It also has 1 output parameter: a real*8 variable \"err\".\n\nInside the subroutine, initialize the \"err\" variable to 0. Then, using a do loop, iterate over the \"nt\" number of values. For each iteration, calculate a polynomial fit using the coefficients from array \"c\" and the corresponding \"x\" value. Compute the squared difference between the predicted value \"pfit\" and the actual value \"p(i)\", and add it to the \"err\" variable. Finally, return from the subroutine.\n\nMake sure to properly declare the variables and use the \"implicit\" statement to specify the variable types.", "input": "", "output": "      subroutine errp(nt,p,x,c,err)\n      implicit real*8(a-h,o-z)\n\n      integer*4, intent(in)  :: nt\n      real*8,    intent(in)  :: p(nt),x(nt),c(4,1)\n      real*8,    intent(out) :: err\n      \n      common/smaple/xmin,xmax,dx\n     \n      err = 0d0\n      do i=1,nt\n        pfit = c(1,1)*x(i)+c(2,1)*x(i)**2+c(3,1)*x(i)**3+c(4,1)\n        err = err+(p(i)-pfit)**2*dx\n      enddo\n\n      return\n      end subroutine\n"}, {"instruction": "Write a Fortran subroutine named derivs to calculate the derivative of a function for multiple trajectories. The number of input arguments is 2 and the test_data type is ['integer*4', 'real*8']. The number of output arguments is 3 and the test_data type is ['real*8', 'real*8', 'real*8']. The subroutine takes an array of trajectories, computes the derivative for each trajectory, and stores the results in separate arrays.", "input": "", "output": "        subroutine derivs(x,ntraj,fx,v,ddv)\n        implicit real*8(a-h,o-z)\n        parameter(ak=1.2d0)\n        integer*4,intent(in) :: ntraj\n        real*8,intent(in) :: x(ntraj)\n        real*8,intent(out) :: fx(ntraj),v(ntraj),ddv(ntraj)\n        \n        do i=1,ntraj\n          fx(i) = -ak*x(i)\n          v(i)  = ak*x(i)**2/2d0\n          ddv(i) = ak\n        enddo\n\n        return\n        end subroutine\n"}]