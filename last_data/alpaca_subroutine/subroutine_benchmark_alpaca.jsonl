{"instruction": "Create a Fortran subroutine named lttb_downsize to downsize a time-series data using the largest-triangle-three-buckets algorithm. The number of input parameters is 2, the test_data type is ['real', 'integer'], and the number of output parameters is 1, the test_data type is ['real, allocatable'].", "input": "", "output": "    subroutine lttb_downsize(data, threshold, series)\n        implicit none\n\n        real, intent(in) :: data(:)\n        integer, intent(in) :: threshold\n        real, intent(out), allocatable :: series(:)\n\n        ! internal variables\n        integer i, sampledindex, a, nexta, datalength\n        real maxareapoint, maxarea, area, every\n\n        datalength = size(data)\n\n        ! just copy the data 'as-is'\n        if (datalength .le. threshold) then\n            print *, 'no downsizing needed, copying time-series'\n\n            allocate (series(datalength))\n            series(:) = data(:)\n\n            return\n        end if\n\n        print *, 'downsizing time-series with largest-triangle-three-buckets'\n\n        allocate (series(threshold))\n\n        ! always add the first point\n        series(1) = data(1)\n        sampledindex = 1\n        a = 0\n        nexta = 0\n        maxareapoint = 0.0\n\n        ! bucket size. leave room for start and end data points\n        every = real(datalength - 2)/real(threshold - 2)\n\n        do i = 0, threshold - 2 - 1\n            block\n                integer avgrangestart, avgrangeend, avgrangelength\n                real avgx, avgy, pointax, pointay\n                integer rangeoffs, rangeto\n\n                avgrangestart = floor((i + 1)*every) + 1\n                avgrangeend = floor((i + 2)*every) + 1\n                avgrangeend = min(avgrangeend, datalength)\n                avgrangelength = avgrangeend - avgrangestart\n\n                avgx = 0.0\n                avgy = 0.0\n\n                do while (avgrangestart < avgrangeend)\n                    avgx = avgx + avgrangestart\n                    avgy = avgy + data(1 + avgrangestart)\n                    avgrangestart = avgrangestart + 1\n                end do\n\n                avgx = avgx/avgrangelength\n                avgy = avgy/avgrangelength\n\n                ! get the range for this bucket\n                rangeoffs = floor((i + 0)*every) + 1\n                rangeto = floor((i + 1)*every) + 1\n\n                ! point a\n                pointax = a\n                pointay = data(1 + a)\n\n                maxarea = -1\n\n                do while (rangeoffs < rangeto)\n                    ! calculate triangle area over three buckets\n                    area = abs((pointax - avgx)*(data(1 + rangeoffs) - pointay) -&\n                    &(pointax - rangeoffs)*(avgy - pointay))*0.5\n\n                    if (area .gt. maxarea) then\n                        maxarea = area\n                        maxareapoint = data(1 + rangeoffs)\n                        nexta = rangeoffs ! next a is this b\n                    end if\n\n                    rangeoffs = rangeoffs + 1\n                end do\n\n                series(1 + sampledindex) = maxareapoint ! pick this point from the bucket\n                sampledindex = sampledindex + 1\n                a = nexta ! this a is the next a (chosen b)\n            end block\n        end do\n\n        ! always add the last element\n        series(1 + sampledindex) = data(datalength)\n        sampledindex = sampledindex + 1\n\n    end subroutine lttb_downsize\n"}
{"instruction": "Write a Fortran subroutine named eisensteinhu that computes the transfer function for the matter power spectrum using the Eisenstein and Hu (1998) model. The subroutine takes 3 input parameters of type double precision (ak, omegamh2, fb) and returns 1 output parameter of type double precision (t).", "input": "", "output": "subroutine eisensteinhu(ak,omegamh2,fb,t)\n! ref: eisenstein and hu, apj, 496, 605 (1998), eq.(29)-(31)\n  implicit none\n  double precision, intent(in) :: ak,omegamh2,fb ! 1/mpc; omega_mh^2; omega_b/omega_m\n  double precision, intent(out):: t\n  double precision :: alpha,sound,shape,aq\n  alpha= 1d0 &\n       -0.328d0*dlog(431d0*omegamh2)*fb &\n       +0.38d0*dlog(22.3d0*omegamh2)*fb**2d0\n  sound= 44.5d0*dlog(9.83d0/omegamh2)  &\n       /dsqrt(1d0+10d0*(fb*omegamh2)**(3d0/4d0))\n  shape= omegamh2 &\n       *(alpha+(1d0-alpha)/(1d0+(0.43d0*ak*sound)**4d0))\n  aq= ak*(2.725d0/2.7d0)**2d0/shape\n  t= dlog(2d0*dexp(1d0)+1.8d0*aq) &\n       /(dlog(2d0*dexp(1d0)+1.8d0*aq) &\n       +(14.2d0+731d0/(1d0+62.5d0*aq))*aq*aq)\n  return\nend subroutine eisensteinhu\n"}
{"instruction": "Write a Fortran subroutine named zdepth to calculate the vertical grid and depths in an ocean model. The subroutine takes 5 input parameters of type real, real, real, real, and integer, and returns 5 output parameters of type real, real, real, real, and real.", "input": "", "output": "subroutine zdepth(h,tcline,theta_s,theta_b,n,z,dz,s,z_w,s_w)\n\nimplicit none\n\nreal,    intent(in)  :: h, tcline, theta_s, theta_b\ninteger, intent(in)  :: n\nreal,    intent(out) :: z(n), s(n), dz(n), z_w(n+1), s_w(n+1)\n\nreal    :: ds, a_w, b_w, c_w, a, b, c\ninteger :: k\n\nds = 1./real(n)\n\n! interface between layers\ndo k=1,n+1\n  s_w(k) = -1. + real(k-1)*ds\n  a_w = sinh(theta_s*s_w(k))/sinh(theta_s)\n  b_w = (tanh(theta_s*(s_w(k)+0.5))-tanh(theta_s*0.5))/(2.*tanh(theta_s*0.5))\n  c_w = (1.-theta_b)*a_w + theta_b*b_w\n  z_w(k) = tcline*s_w(k) + (h-tcline)*c_w\nenddo\n\n! center of layers\ndo k=1,n\n  s(k) = -1. + 0.5*ds + real(k-1)*ds     ! s = -1+ds/2:ds:0-ds/2;\n  a = sinh(theta_s*s(k))/sinh(theta_s)\n  b = (tanh(theta_s*(s(k)+0.5))-tanh(theta_s*0.5))/(2.*tanh(theta_s*0.5))\n  c = (1.-theta_b)*a + theta_b*b\n  z(k) = tcline*s(k) + (h-tcline)*c\nenddo\n\ndo k=1,n\n  dz(k) = z_w(k+1) - z_w(k)\nenddo\n\nreturn\n\nend subroutine zdepth\n"}
{"instruction": "Create a Fortran subroutine named local_minima_potential_energy to identify local minima in potential energy data. It takes 5 input parameters: n_nodes (integer), ktot (integer), t_ind (integer array of size ktot), t_pe (double precision array of size n_nodes), t_start (integer array of size n_nodes+1), and returns 1 output parameter: is_minimum (logical array of size n_nodes).", "input": "", "output": "subroutine local_minima_potential_energy (t_ind,t_pe,t_start,n_nodes,ktot,is_minimum)\n\n    implicit none\n\n    type int_pointer\n        integer,dimension(:),pointer::ip\n    end type int_pointer\n\n    type double_pointer\n        double precision,dimension(:),pointer::dp\n    end type double_pointer\n\n    integer,intent(in)::n_nodes,ktot\n    integer,dimension(ktot),intent(in)::t_ind\n    double precision,dimension(n_nodes),intent(in)::t_pe\n    integer,dimension(n_nodes+1),intent(in)::t_start\n\n    logical,dimension(n_nodes),intent(out)::is_minimum\n\n    integer::ii,jj,kk\n    logical::aux_flag\n    double precision::aux_val\n\n    is_minimum(:)=.false.\n\n    do ii=1,n_nodes\n        aux_flag=.true.\n        aux_val=t_pe(ii)\n        do jj=t_start(ii)+1,t_start(ii+1)\n            kk=t_ind(jj)\n            if(t_pe(kk)<aux_val) then\n                aux_flag=.false.\n                exit\n            end if\n        end do\n        is_minimum(ii)=aux_flag\n    end do\n\nend subroutine local_minima_potential_energy\n"}
{"instruction": "Provide a Fortran subroutine named calc_f_pendula to compute the forces acting on a pendulum system. \n\nThe subroutine takes 10 input parameters:\n1. bc_flag (integer) - indicates the boundary condition flag\n2. lowerbound (integer) - lower bound of the dimension array\n3. upperbound (integer) - upper bound of the dimension array\n4. m (real, dimension(2)) - mass values\n5. b (real, dimension(1)) - damping coefficient\n6. p (real, dimension(1)) - external force\n7. g (real) - acceleration due to gravity\n8. k (real, dimension(1)) - spring constant\n9. l (real, dimension(1)) - length of pendulum\n10. x (real, dimension(lowerbound:upperbound)) - displacement array\n\nThe subroutine has 1 output parameter:\n1. f (real, dimension(2)) - forces acting on the pendulum system\n\nThe subroutine performs calculations based on the given boundary conditions (bc_flag) and computes the forces (f) acting on the pendulum system.\n\nPlease note that the code snippet provided is incomplete and may require additional code to be functional.", "input": "", "output": "    subroutine calc_f_pendula(bc_flag, lowerbound, upperbound, m, b, p, g, k, l, x, f)\n\n    implicit none\n\n    !! data dictionary\n    integer, intent(in) :: bc_flag\n    integer, intent(in) :: lowerbound\n    integer, intent(in) :: upperbound\n    real, intent(in), dimension(2) :: m\n    real, intent(in), dimension(1) :: b\n    real, intent(in), dimension(1) :: p\n    real, intent(in) :: g\n    real, intent(in), dimension(1) :: k\n    real, intent(in), dimension(1) :: l\n    real, intent(in), dimension(lowerbound:upperbound) :: x\n    real, intent(out), dimension(2) :: f\n\n    if (bc_flag == 100) then\n        f(1) = x(1)\n        f(2) = ( p(1) - b(1)*x(1) - (g*l(1)*m(2)*sin(x(0)) - k(1)*x(-2) + 2*k(1)*x(0) - k(1)*x(2)) )/m(1)\n    else if (bc_flag == 110) then\n        f(1) = x(1)\n        f(2) = ( p(1) - b(1)*x(1) - (g*l(1)*m(2)*sin(x(0)) + k(1)*(x(0) - x(2))) )/m(1)\n    else if (bc_flag == 120) then\n        f(1) = x(1)\n        f(2) = ( p(1) - b(1)*x(1) - (g*l(1)*m(2)*sin(x(0)) - k(1)*x(-2) + k(1)*x(0)) )/m(1)\n    else if (bc_flag == 121) then\n        f(1) = 0.\n        f(2) = 0.\n    end if\n\n    end subroutine calc_f_pendula\n"}
{"instruction": "Create a Fortran subroutine named look_up_grib_code that takes an integer input parameter and returns a character string. The purpose of this subroutine is to look up and assign the appropriate variable type based on the given grib code number. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 1 and the test_data type is ['character(len=*)'].", "input": "", "output": "subroutine look_up_grib_code(grib_type, var_type)\n! find the variable type from \n! http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html\n integer,          intent(in)  :: grib_type\n character(len=*), intent(out) :: var_type\n\nselect case (grib_type)\n!    case(2) \n!      var_type = 'mslp'\n    case(7)\n      var_type = 'geopotential_hgt'\n    case(11)\n      var_type = 'temperature'\n    case(17)\n      var_type = 'dewpoint'\n!    case(32)\n!      var_type = 'wind_speed'\n    case(33)\n      var_type = 'u_wind_component'\n    case(34)\n      var_type = 'v_wind_component'\n    case(51)\n      var_type = 'specific_humidity'\n    case(52)\n      var_type = 'relative_humidity'\n!    case(53)\n!      var_type = 'humidity mixing ratio'\n    case(54)\n      var_type = 'precipitable_water'\n    case default\n      var_type = 'not_supported'\nend select\n\nend subroutine look_up_grib_code\n"}
{"instruction": "Create a Fortran subroutine named greg2modjul to convert the Gregorian calendar date to the modified Julian date. The subroutine takes 6 input parameters of type integer (year, month, day, hour, minute, sec) and returns 1 output parameter of type real*8 (mjd).", "input": "", "output": "subroutine greg2modjul(year, month, day, hour, minute, sec, mjd) \n\t! greg2modjul(..., mjd) returns the\n\t! modified julian date (mjd) corresponding to the \n\t! gregorian calendar date (year, month, day, hour, minute, and second).\n\timplicit none\n        integer, intent(in) :: year, month, day, hour, minute, sec\n\treal*8, intent(out) :: mjd \n        real*8              :: yyyy, mm, jd   \n\n        ! january & february\n\tif ( month <= 2 ) then \n        \tyyyy = dfloat(year) - 1_8\t\t\n        \tmm = dfloat(month) + 12_8\n\telse \n        \tyyyy = dfloat(year)\t\t\n        \tmm = dfloat(month)\n        end if\n\n\tjd = floor( 365.25_8*(yyyy + 4716.0_8)) + floor( 30.6001_8*( mm + 1.0_8)) + 2.0_8 - &\n\t     floor( yyyy/100.0_8 ) + floor( floor( yyyy/100.0_8 )/4.0_8 ) + dfloat(day) - 1524.5_8 + &\n             (dfloat(hour) + dfloat(minute)/60_8 + dfloat(sec)/3600_8)/24_8\n        mjd = jd - 2400000.5_8\n\n\treturn\nend subroutine greg2modjul\n"}
{"instruction": "Create a Fortran subroutine named modjul2greg to convert the modified Julian date (mjd) into the corresponding Gregorian calendar date, including year, month, day, hour, minute, and second. The input parameter is a real*8 type, and the output parameters are six integers representing year, month, day, hour, minute, and second.", "input": "", "output": "subroutine modjul2greg(mjd, year, month, day, hour, minute, sec) \n\t! modjul2greg(mjd, ...) returns the\n\t! gregorian calendar date (year, month, day, hour, minute, and second)\n\t! corresponding to the modified julian date (mjd).\n\timplicit none\n        real*8, intent(in)  :: mjd\n\treal*8              :: jd, ijd, fjd, a, b, c, d, e, m\n\tinteger, intent(out):: year, month, day, hour, minute, sec            \n\n\tjd = mjd + 2400000.5_8\n\tijd = floor(jd + 0.5_8)\n        fjd = jd - ijd + 0.5_8\n\n        sec = 86400_8 * fjd\n        hour = ifix( sec / 3600.0 )\n        sec = sec - 3600_8 * hour\n        minute = ifix( sec / 60.0 )\n        sec = sec - 60_8 * minute\n\n        a = ijd + 32044_8\n        b = floor((4_8 * a + 3_8) / 146097_8)\n        c = a - floor((b * 146097_8) / 4_8)\n\td = floor((4_8 * c + 3_8) / 1461_8)\n        e = c - floor((1461_8 * d) / 4_8)\n        m = floor((5_8 * e + 2_8) / 153_8)\n\n        day   = e - floor((153_8 * m + 2_8) / 5_8) + 1_8\n        month = m + 3_8 - 12_8 * floor(m / 10_8)\n        year  = b * 100_8 + d - 4800_8 + floor(m / 10_8)\n\n\treturn\nend subroutine modjul2greg\n"}
{"instruction": "Create a Fortran subroutine named dccon1 to calculate station geometry constants for a point source. The subroutine takes 5 input parameters of type real*8: x, y, d, sd, and cd. It also provides 5 output parameters of type real*8: r, p, q, s, and t. The subroutine's purpose is to calculate the values of r, p, q, s, and t based on the input parameters x, y, d, sd, and cd. Use the imperative tone in the instructions.", "input": "", "output": "subroutine  dccon1(x,y,d,sd,cd,r,p,q,s,t)\n!**********************************************************************\n!*****   calculate station geometry constants for point source    *****\n!**********************************************************************\n!***** input\n!*****   x,y,d : station coordinates in fault system\n!*****   sd,cd : sin, cos of dip-angle\n    implicit none\n    real*8, intent(in) :: x,y,d\n    real*8, intent(in) :: sd,cd\n    real*8, intent(out) :: r\n    real*8, intent(out) :: p,q,s,t\n!-----\n    p=y*cd+d*sd\n    q=y*sd-d*cd\n    s=p*sd+q*cd\n    t=p*cd-q*sd\n    r=dsqrt(x*x+y*y+d*d)\n    return\nend subroutine dccon1\n"}
{"instruction": "Create a Fortran subroutine named eq14_xy to compute the equations (14) for x11, x32, y11, and y32. The subroutine takes 5 input parameters of type real*8, real*8, integer, integer, and real*8. It returns 4 output parameters of type real*8 for x11, x32, y11, and y32. The subroutine calculates the values based on the provided station coordinates and conditions kxi and ket.", "input": "", "output": "subroutine eq14_xy(xi,et,kxi,ket,r,x11,x32,y11,y32)\n!***** input\n!*****   xi,et   : station coordinates in fault system\n!*****   kxi,ket : kxi=1, ket=1 means r+xi<eps, r+et<eps, respectively\n    implicit none\n    real*8, intent(in) :: xi,et\n    integer, intent(in) :: kxi,ket\n    real*8, intent(in) :: r\n    real*8, intent(out) :: x11,x32,y11,y32\n\n    x11 = 0.0d0\n    x32 = 0.0d0\n    y11 = 0.0d0\n    y32 = 0.0d0\n!-----\n    if(kxi/=1) then\n      x11=1.0d0/(r*(r+xi))        ! eq.(14), p.1026\n      x32=(2.0d0*r+xi)*x11*x11/r  ! eq.(14), p.1026\n    endif\n!-----\n    if(ket/=1) then\n      y11=1.0d0/(r*(r+et))        ! eq.(14), p.1026\n      y32=(2.0d0*r+et)*y11*y11/r  ! eq.(14), p.1026\n    endif\n!-----\n    return\nend subroutine eq14_xy\n"}
{"instruction": "Write a Fortran subroutine named stop_acc_data to initialize an accumulation process. The subroutine takes 1 input parameter of type real and returns 2 output parameters, one of type real and the other of type integer. The input parameter represents a missing value, while the output parameters store the accumulation of data and the status of accumulation (0/1) respectively.", "input": "", "output": "  subroutine stop_acc_data(miss,acc,accok)\r\n    \r\n    !argument declaration\r\n    real, intent(in)     :: miss                 !<missing value\r\n    real, intent(out)    :: acc                  !<variable for accumulation of data\r\n    integer, intent(out) :: accok                !<variable for status of accumulation (0/1)\r\n    \r\n    accok = 0\r\n    acc = miss\r\n    \r\n  end subroutine stop_acc_data\r\n"}
{"instruction": "Create a Fortran subroutine named calculate_fit that takes 5 input parameters of types integer, real, real, real, and integer, and 1 output parameter of type real. The subroutine computes fitness criteria for a given set of computed and recorded values based on various statistical calculations.", "input": "", "output": "  subroutine calculate_fit(n,c,r,m,lim,x)\r\n    \r\n    !argument declaration\r\n    integer, intent(in) :: n          !<number of elements\r\n    real, intent(in)    :: c(n)       !<array with computed values\r\n    real, intent(in)    :: r(n)       !<array with recorded values\r\n    real, intent(in)    :: m          !<missing value\r\n    integer, intent(in) :: lim        !<minimum number of elements\r\n    real, intent(out)   :: x(4)       !<fitness criteria; 1=r2 (nash-sutcliff), 2=rmse, 3=bias, and 4=number of data used\r\n    \r\n    !variable declaration\r\n    integer i,nobs\r\n    double precision mse,varr,sumc,sumr,sumr2,sume2,s\r\n    \r\n    !> \\b algorithm \\n\r\n    !> initialize \r\n    nobs = 0\r\n    sumc = 0.d0\r\n    sumr = 0.d0\r\n    sumr2 = 0.d0\r\n    sume2 = 0.d0\r\n    x = m\r\n    !> calculate sum of values and errors (for not missing values)\r\n    do i = 1,n\r\n      if(r(i) == m .or. c(i) == m) then\r\n      else\r\n        nobs = nobs+1\r\n        sumc = sumc+dble(c(i))\r\n        sumr = sumr+dble(r(i))\r\n        sumr2 = sumr2+dble(r(i))**2\r\n        sume2 = sume2+(dble(c(i)-r(i)))**2   !errors^2\r\n      endif\r\n    enddo\r\n    !> if enough values not missing; calculate fitness criteria\r\n    if(nobs>=lim)then\r\n      s = sumr2-(sumr**2)/dble(nobs)       !sum of squares around mean value\r\n      varr = s/dble(nobs)                  !variance (\"/n\")\r\n      mse = sume2/dble(nobs)               !mean square error\r\n      x(1) = real(1.d0-mse/varr)                        !r2\r\n      if(mse>0.d0) x(2) = real(dsqrt(mse))              !rmse\r\n      if(sumr /= 0.d0) x(3) = real((sumc-sumr)/sumr)    !relative bias\r\n      x(4) = real(nobs)\r\n    endif\r\n    \r\n  end subroutine calculate_fit\r\n"}
{"instruction": "Create a Fortran subroutine named calculate_ra to compute the fitness criterion based on given arrays and parameters. The subroutine takes 6 input parameters of types [integer, real array, real array, real, real, integer], and outputs 1 parameter of type real.", "input": "", "output": "  subroutine calculate_ra(n,c,r,m,p,lim,x)\r\n\r\n    !argument declaration\r\n    integer, intent(in) :: n          !<number of elements\r\n    real, intent(in)    :: c(n)       !<array with computed values\r\n    real, intent(in)    :: r(n)       !<array with recorded values\r\n    real, intent(in)    :: m          !<missing value\r\n    real, intent(in)    :: p          !<parameter value of criterion\r\n    integer, intent(in) :: lim        !<minimum number of elements\r\n    real, intent(out)   :: x          !<fitness criterion 1=ra\r\n    \r\n    !variable declaration\r\n    integer i,nobs\r\n    double precision sumr,sumea,meanr\r\n    \r\n    !> \\b algorithm \\n\r\n    !> initialize \r\n    nobs = 0\r\n    sumr = 0.d0\r\n    sumea = 0.d0\r\n    x = m\r\n    !> calculate sum of values and errors (for not missing values)\r\n    do i = 1,n\r\n      if(r(i) == m .or. c(i) == m) then\r\n      else\r\n        nobs = nobs+1\r\n        sumr = sumr+dble(r(i))\r\n      endif\r\n    enddo\r\n    if(nobs>0)then\r\n      meanr = sumr / dble(nobs)\r\n      sumr = 0.d0\r\n      do i = 1,n\r\n        if(r(i) == m .or. c(i) == m) then\r\n        else\r\n          if(abs(r(i)-meanr)>0.) sumr = sumr+(abs(dble(r(i))-meanr))**p\r\n          if(abs(c(i)-r(i))>0.) sumea = sumea+(abs(dble(c(i)-r(i))))**p   !errors^p\r\n        endif\r\n      enddo\r\n    endif\r\n    !> if enough values not missing; calculate fitness criteria\r\n    if(nobs>=lim)then\r\n      x = real(1.d0 - sumea / sumr)                    !ra\r\n    endif\r\n    \r\n  end subroutine calculate_ra\r\n"}
{"instruction": "Create a Fortran subroutine named \"spherical_mesh\" that generates a mesh of points on the surface of a sphere based on the given sphere radius and the number of points per dimension. The subroutine must take 2 input parameters of type real(8) and integer and provide 1 output parameter of type real(8), allocatable.", "input": "", "output": "    subroutine spherical_mesh(sphere_radius, n_points, xyz_list)\n        real(8), intent(in) :: sphere_radius\n        integer, intent(in) :: n_points             ! number of points per dimension\n        real(8), allocatable, intent(out) :: xyz_list(:, :)  ! list of points = [x1, y1, z1; x2, y2, z2; ...]\n\n        integer :: i\n        real(8) :: theta(n_points), phi(n_points)\n        real(8) :: theta_2d(n_points, n_points), phi_2d(n_points, n_points)\n        real(8) :: x(n_points, n_points), y(n_points, n_points), z(n_points, n_points)\n\n        theta = [( pi / n_points * i, i=0, n_points-1)]\n        phi = [( 2 * pi / n_points * i, i=0, n_points-1)]\n\n        theta_2d = spread(theta, 1, n_points)\n        phi_2d = spread(phi, 2, n_points)\n\n        x = sphere_radius * sin(theta_2d) * cos(phi_2d)\n        y = sphere_radius * sin(theta_2d) * sin(phi_2d)\n        z = sphere_radius * cos(theta_2d)\n\n        allocate(xyz_list(3, n_points ** 2))\n        xyz_list(1, :) = pack(x, .true.)\n        xyz_list(2, :) = pack(y, .true.)\n        xyz_list(3, :) = pack(z, .true.)\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"renum1\" to compute the connections between degrees of freedom and store them as a linked list. The subroutine should have 4 input parameters of type integer (kind=4) and 2 output parameters of type integer (kind=4). The function should receive the inputs nnode, npoin, nelem, lnods, and produce the outputs nodad and nposi.", "input": "", "output": "      subroutine renum1(nnode,npoin,nelem,lnods,nodad,nposi)\r\n!***********************************************************************\r\n!*\r\n!*****computes the connections between degrees of freedom (stored as\r\n!*    a linked list)\r\n!*\r\n!***********************************************************************\r\n      implicit none\r\n!     routine parameters\r\n      integer (kind=4),intent(in) :: nnode,npoin,nelem,lnods(:,:)\r\n      integer (kind=4),intent(out):: nodad(:),nposi\r\n!     local variables\r\n      integer (kind=4) :: ipoin,nfree,ielem,inode,jnode,jpoin,nadre,    &\r\n     &                    nadro,kpoin\r\n\r\n      nodad = 0\r\n      nfree = npoin+1\r\n\r\n      do ielem = 1,nelem\r\n        do inode = 1,nnode\r\n          ipoin = lnods(inode,ielem)\r\n          if(ipoin /= 0) then\r\n            do jnode = 1,nnode\r\n              if(jnode /= inode) then\r\n                jpoin = lnods(jnode,ielem)\r\n                if(jpoin /= 0) then\r\n                   nadre = nodad(ipoin)\r\n                   nadro = ipoin\r\n                   do\r\n                     if(nadre <= 0)exit\r\n                     kpoin = nodad(nadre)\r\n                     if(kpoin == jpoin) exit\r\n                     nadro = nadre + 1\r\n                     nadre = nodad(nadro)\r\n                   end do\r\n                   if(kpoin /= jpoin)then\r\n                     nodad(nadro) = nfree\r\n                     nodad(nfree) = jpoin\r\n                     nodad(nfree+1) = 0\r\n                     nfree = nfree + 2\r\n                   end if\r\n                 end if\r\n              end if\r\n            end do\r\n          end if\r\n        end do\r\n      end do\r\n      nposi = nfree\r\n\r\n      return\r\n\r\n      end subroutine renum1\r\n"}
{"instruction": "Write a Fortran subroutine named pan_etal_1994 that calculates the values of psiq and psiq2. The subroutine takes 5 input parameters of real type (z1, ustar, karman, psih, psih2) and returns 2 output parameters of real type (psiq, psiq2). The subroutine computes the values of psiq and psiq2 based on the given equations and parameters.", "input": "", "output": "   subroutine pan_etal_1994(psiq,psiq2,ustar,psih,psih2,karman,z1)\n       implicit none\n       real, intent(in) :: z1,ustar,karman,psih,psih2\n       real, intent(out) :: psiq,psiq2\n       real, parameter :: cpan=1.0\n       real, parameter :: zl=0.01\n       real, parameter :: zmus=0.2e-3\n       real, parameter :: xka = 2.4e-5\n         psiq =max(karman*ustar*zmus/xka + log((karman*ustar*z1)/xka + &\n              & z1/zl) - psih,2.0)\n         psiq2=max(karman*ustar*zmus/xka + log((karman*ustar*2.0)/xka + &\n              & 2./zl) - psih2,2.0)\n    end subroutine pan_etal_1994\n"}
{"instruction": "Create a Fortran subroutine named andreas_2002 to calculate zt and zq based on the input parameters z_0 and ren. The number of input parameters is 2, with test_data type ['real', 'real'], and the number of output parameters is 2, with test_data type ['real', 'real']. The subroutine should use the imperative tone and implement the Andreas (2002) parameterization for the calculation.", "input": "", "output": "    subroutine andreas_2002(z_0,ren,zt,zq)\n       implicit none\n       real, intent(in) :: z_0, ren\n       real, intent(out) :: zt, zq\n       real :: ren2\n       real, parameter :: bt0_s=1.25, bt0_t=0.149, bt0_r=0.317, &\n                           bt1_s=0.0, bt1_t=-0.55, bt1_r=-0.565, &\n                           bt2_s=0.0, bt2_t=0.0, bt2_r=-0.183\n       real, parameter :: bq0_s=1.61, bq0_t=0.351, bq0_r=0.396, &\n                           bq1_s=0.0, bq1_t=-0.628, bq1_r=-0.512, &\n                           bq2_s=0.0, bq2_t=0.0, bq2_r=-0.180\n       ren2 = ren\n       if (ren2 .gt. 1000.) ren2 = 1000.\n       if (ren2 .le. 0.135) then\n          zt = z_0*exp(bt0_s + bt1_s*log(ren2) + bt2_s*log(ren2)**2)\n          zq = z_0*exp(bq0_s + bq1_s*log(ren2) + bq2_s*log(ren2)**2)\n       else if (ren2 .gt. 0.135 .and. ren2 .lt. 2.5) then\n          zt = z_0*exp(bt0_t + bt1_t*log(ren2) + bt2_t*log(ren2)**2)\n          zq = z_0*exp(bq0_t + bq1_t*log(ren2) + bq2_t*log(ren2)**2)\n       else\n          zt = z_0*exp(bt0_r + bt1_r*log(ren2) + bt2_r*log(ren2)**2)\n          zq = z_0*exp(bq0_r + bq1_r*log(ren2) + bq2_r*log(ren2)**2)\n       endif\n       return\n    end subroutine andreas_2002\n"}
{"instruction": "Write a Fortran subroutine named psi_hogstrom_1996 to calculate the Monin-Obukhov stability functions psi_m and psi_h. The subroutine takes 4 input parameters of type real (zl, zt, z_0, za) and returns 2 output parameters of type real (psi_m, psi_h).", "input": "", "output": "    subroutine psi_hogstrom_1996(psi_m, psi_h, zl, zt, z_0, za)\n       implicit none\n       real, intent(in) :: zl, zt, z_0, za\n       real, intent(out) :: psi_m, psi_h\n       real :: x, x0, y, y0, zml, zhl\n       zml = z_0*zl/za\n       zhl = zt*zl/za\n       if (zl .gt. 0.) then\n          psi_m = -5.3*(zl - zml)\n          psi_h = -8.0*(zl - zhl)\n       else\n          x = (1.-19.0*zl)**0.25\n          x0= (1.-19.0*zml)**0.25\n          y = (1.-11.6*zl)**0.5\n          y0= (1.-11.6*zhl)**0.5\n          psi_m = 2.*log((1.+x)/(1.+x0)) + &\n                    &log((1.+x**2.)/(1.+x0**2.)) - &\n                    &2.0*atan(x) + 2.0*atan(x0)\n          psi_h = 2.*log((1.+y)/(1.+y0))\n       endif\n       return\n    end subroutine psi_hogstrom_1996\n"}
{"instruction": "Write a Fortran subroutine named intplt3d to compute interpolation indices and coefficients using bi-linear interpolation. The subroutine takes 5 input parameters of types integer, integer, real, real, and real, and 3 output parameters of types integer, integer, and real.", "input": "", "output": "subroutine intplt3d(x,l,n,d,dm,idx,coe,ier)\n\n!*************************************************\n!  this routine computes an interpolation indices\n!  and coefficients using bi-linear interpolation.\n!\n!  history: jan. 2004 by yuanfu xie.\n!*************************************************\n\n  implicit none\n\n  integer, intent(in) :: l(3),n(3)\n  real,    intent(in) :: x(3),d(3),dm(2,3)\n\n  integer, intent(out) :: idx(3),ier\n  real,    intent(out) :: coe(3)\n\n  ! local variables:\n  integer :: i\n\n  ier = 0\n  ! check in box?\n  do i=1,3\n     if (x(i) .lt. dm(1,i)) ier = -i\n     if (x(i) .gt. dm(2,i)) ier = i\n  enddo\n\n  ! indices:\n  idx = (x-dm(1,1:3))/d\n\n  ! coefficients:\n  coe = (x-idx*d-dm(1,1:3))/d\n\n  idx = idx+1\n\nend subroutine intplt3d\n"}
{"instruction": "Write a Fortran subroutine named split to separate a given string into individual words and store them in an array of strings. The input parameter is a single character array and the output parameter is an array of strings.", "input": "", "output": "  subroutine split( value, buf )\n    character(len=*), intent(out) :: value(:)\n    character(len=*), intent(in) :: buf\n\n    integer :: lbuf, i, j, lval\n    character :: mark\n    integer :: iend\n\n    lbuf = len(buf)\n    lval = 0\n    j=1\n    value(:) = \"\"\n    i = 1\n    do while( i <= lbuf )\n       if( buf(i:i) == \" \" ) then\n          if( lval>0 ) then\n             j = j + 1\n             lval = 0\n          end if\n       else if( buf(i:i) == \"'\" .or. buf(i:i) == '\"' ) then\n          mark = buf(i:i)\n          iend = i + index(buf(i+1:), mark)\n          if( iend == i ) then ! symbol, not matching quotes\n             value(j) = trim(value(j)) // buf(i:i)\n             lval = lval + 1\n          else ! matching quotes\n             if( lval>0 ) then\n                j = j + 1\n             end if\n             value(j) = buf(i:iend)\n             j = j + 1\n             lval = 0\n          end if\n          i = iend\n       else\n          value(j) = trim(value(j)) // buf(i:i)\n          lval = lval + 1\n       end if\n       i = i + 1\n    end do\n\n  end subroutine split\n"}
{"instruction": "Write a Fortran subroutine named normalweight that calculates the points and weights based on the given spread and returns them as output parameters. The number of input parameters is 1 and the test_data type is ['real(kind=8)']. The number of output parameters is 2 and the test_data type is ['real(kind=8)', 'real(kind=8)'].", "input": "", "output": "subroutine normalweight(pspread,points,weights)\r\nimplicit none\r\n\r\nreal(kind=8),intent(in)::pspread\r\nreal(kind=8),intent(out)::points(:),weights(:)\r\n\r\n!\ti counts points.\r\n\r\ninteger::i\r\n!\tave is the average of the integers 1 to size(points)\r\n!\tb is the multiplier.\r\n!\tbase is the raw grid.\r\n\r\n\r\n\r\n\r\nreal(kind=8)::ave,b,base(size(points)),div\r\n\r\nave=(1.0_8+size(points))/2.0_8\r\nb=0.0_8\r\ndo i=1,size(points)\r\n\tbase(i)=i-ave\r\nend do\r\n!\tif pspread is positive, then points are determined from spread.\r\nif(pspread>0.0_8) then\r\n\tb=pspread/(size(points)-1)\r\n\t\r\nelse\r\n    if(size(points)>0) b=2.0_8/(size(points)-1.0_8)**0.333333333333333_8\r\nend if\r\npoints=b*base\r\nweights=exp(-points*points/2.0_8)\r\ndiv=sum(weights)\r\nweights=weights/div\r\nreturn\r\nend subroutine normalweight\r\n"}
{"instruction": "Create a Fortran subroutine named displacement to calculate the best shift value for a given set of data. The subroutine takes 4 input parameters of types integer, real*8 array, real*8 array, and real*8 array, and returns 3 output parameters of types real*8, real*8, and real*8 array.", "input": "", "output": "subroutine displacement (no_data,dm_smooth_data, dm_data,sigma_data,shift_best,chi_smooth,chi_min)\n\timplicit none\n\tinteger,intent(in) :: no_data\n\treal*8,intent(in),dimension(no_data) :: dm_smooth_data, dm_data,sigma_data\n\treal*8,intent(out) :: shift_best,chi_min\n\treal*8,intent(out),dimension(no_data) :: chi_smooth\n\treal*8,dimension(no_data) :: chi\n\treal*8 :: shift\n\tinteger :: i\n\n\tchi_min = 10d5\n\tshift_best = 0.0d0\n\tchi = 0.0d0\n\n!   shift = 0.0d0\n\tshift = -0.05d0\t! this is kinda marginalization over hubble, since hubble constant move data vertically\n\tdo while (shift .le. 0.05d0 )\t\n\n\tdo i = 1, no_data\n\t\tchi(i) = (( (dm_smooth_data(i) + shift) - (dm_data(i))  ) / (sigma_data(i)) )\n\tend do\n\tif (sum(chi**2) .le. chi_min) then\n\t\tshift_best = shift\n\t\tchi_min = sum(chi**2)\n\t\tchi_smooth = chi\n!\t\tprint*,\"guess model is shifted\",shift_best,chi_min !to see the effect of data movement in each step\n\tend if\n!\t\tprint*,\"guess model is shifted\",shift,chi !to see the effect of data movement in each step\n\tshift = shift + 0.1d-3\n\tend do\n!\t\tprint*,\"guess model is shifted\",shift_best,chi_min !to see the effect of data movement in each itera\nreturn\nend subroutine displacement\n"}
{"instruction": "Create a Fortran subroutine named dot_d to calculate the dot product of two 3-dimensional vectors and their corresponding derivatives. The subroutine takes 4 input parameters of type real(kind=8) - a(3), ad(3), b(3), bd(3). It returns 2 output parameters of type real(kind=8) - dot_prod and dot_prodd.", "input": "", "output": "  subroutine dot_d(a, ad, b, bd, dot_prod, dot_prodd)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(in) :: ad(3), bd(3)\n    real(kind=8), intent(out) :: dot_prod\n    real(kind=8), intent(out) :: dot_prodd\n    dot_prodd = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3&\n&     )*b(3) + a(3)*bd(3)\n    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)\n  end subroutine dot_d\n"}
{"instruction": "Create a Fortran subroutine named cross_d. It takes 4 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8). The function computes the cross product of two 3D vectors and their derivatives. The resulting cross product and its derivatives are stored in the output parameters.", "input": "", "output": "  subroutine cross_d(a, ad, b, bd, c, cd)\n    implicit none\n    real(kind=8), intent(in) :: a(3), b(3)\n    real(kind=8), intent(in) :: ad(3), bd(3)\n    real(kind=8), intent(out) :: c(3)\n    real(kind=8), intent(out) :: cd(3)\n    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)\n    c(1) = a(2)*b(3) - a(3)*b(2)\n    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)\n    c(2) = a(3)*b(1) - a(1)*b(3)\n    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)\n    c(3) = a(1)*b(2) - a(2)*b(1)\n  end subroutine cross_d\n"}
{"instruction": "Write a Fortran subroutine named exp1reg to calculate the value and derivative of a function. The subroutine takes 2 input parameters of type real*8 and an array of real*8 as input, and returns 2 output parameters of type real*8. The test_data type for input parameters is ['real*8', 'real*8'], and for output parameters is ['real*8 ', 'real*8 '].", "input": "", "output": "subroutine exp1reg(h,hder,r,damagepar)\n\treal*8 , intent(out) :: h , hder\n\treal*8, intent(in) :: r , damagepar(:)\n\treal*8 :: r0, gf, lmu, h0\n\t\n\tr0 = damagepar(3)\n\tgf = damagepar(4)\n\tlmu = damagepar(5)\n\t\n!~ \th0 =  (0.5d0-gf/(r0*r0*lmu))**(-1.0d0)\n!~ \twrite(0,*) 'h0 == ' ,  h0\n\t\n\th0 =  -r0*r0*lmu/gf\n\t\n\th = h0*dexp(h0*(r- r0)/r0)\n\n\thder = h*(h0/r0)\n\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named func to calculate the product of two real(8) numbers. The subroutine should have 2 input parameters of type real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine func(x, y, z)\n    ! the function to be integrated\n    implicit none\n    real(8), intent(in) :: x, y\n    real(8), intent(out) :: z\n\n    z = x * y\nend subroutine func\n"}
{"instruction": "Create a Fortran subroutine named split_first_last to compute the first and last indices of tokens in an input string, delimited by specified characters. The number of input parameters is 2, with test_data types ['character(*)', 'character(*)']. The number of output parameters is 2, with test_data types ['integer, allocatable', 'integer, allocatable'].", "input": "", "output": "  pure subroutine split_first_last(string, set, first, last)\n    !! computes the first and last indices of tokens in input string, delimited\n    !! by the characters in set, and stores them into first and last output\n    !! arrays.\n    character(*), intent(in) :: string\n    character(*), intent(in) :: set\n    integer, allocatable, intent(out) :: first(:)\n    integer, allocatable, intent(out) :: last(:)\n\n    character :: set_array(len(set))\n    logical, dimension(len(string)) :: is_first, is_last, is_separator\n    integer :: n, slen\n\n    slen = len(string)\n\n    do concurrent (n = 1:len(set))\n      set_array(n) = set(n:n)\n    end do\n\n    do concurrent (n = 1:slen)\n      is_separator(n) = any(string(n:n) == set_array)\n    end do\n\n    is_first = .false.\n    is_last = .false.\n\n    if (.not. is_separator(1)) is_first(1) = .true.\n\n    do concurrent (n = 2:slen-1)\n      if (.not. is_separator(n)) then\n        if (is_separator(n - 1)) is_first(n) = .true.\n        if (is_separator(n + 1)) is_last(n) = .true.\n      else\n        if (is_separator(n - 1)) then\n          is_first(n) = .true.\n          is_last(n-1) = .true.\n        end if\n      end if\n    end do\n\n    if (.not. is_separator(slen)) is_last(slen) = .true.\n\n    first = pack([(n, n = 1, slen)], is_first)\n    last = pack([(n, n = 1, slen)], is_last)\n\n  end subroutine split_first_last\n"}
{"instruction": "Write a Fortran subroutine named compute_min_oxygen to calculate the minimum dissolved oxygen concentration and the time at which it occurs based on environmental parameters. The subroutine takes 7 input parameters of type real: bod, oxy, k, ka, h, oxysat, and dt. It also returns 2 output parameters of type real: oxymin and time. This subroutine uses imperative programming to iterate and calculate the minimum dissolved oxygen concentration and the corresponding time.", "input": "", "output": "subroutine compute_min_oxygen( bod, oxy, k, ka, h, oxysat, dt, oxymin, time )\n    real, intent(in)  :: bod\n    real, intent(in)  :: oxy\n    real, intent(in)  :: k\n    real, intent(in)  :: ka\n    real, intent(in)  :: h\n    real, intent(in)  :: oxysat\n    real, intent(in)  :: dt\n    real, intent(out) :: oxymin\n    real, intent(out) :: time\n\n    real              :: timemax\n    real              :: t\n    real              :: dbod\n    real              :: doxy\n    real              :: bodn\n    real              :: oxyn\n\n    if ( k <= 0.0 .or. ka <= .0 .or. dt <= 0.0 ) then\n        time   = -999.0\n        oxymin = -999.0\n        return\n    endif\n\n    oxymin  = oxy\n    time    = 0.0\n\n    bodn    = bod\n    oxyn    = oxy\n\n    timemax = 10.0 / k ! more than safe time interval\n\n    do while ( t < timemax )\n        dbod = -k * bodn\n        doxy = -k * bodn + ka * ( oxysat - oxyn ) / h\n\n        t    = t    + dt\n        bodn = bodn + dbod *dt\n        oxyn = oxyn + doxy *dt\n\n        if ( oxyn < oxymin ) then\n            oxymin = oxyn\n            time   = t\n        endif\n    enddo\n\nend subroutine compute_min_oxygen\n"}
{"instruction": "Create a Fortran subroutine named dof_locglobunimult_p1_1d to calculate the global degrees of freedom for a list of elements with q1 shape and uniform grid. The subroutine should take 2 input parameters of type ['integer, dimension(:,:)', 'integer, dimension(:)'] and 1 output parameter of type ['integer, dimension(:,:)'].", "input": "", "output": "  subroutine dof_locglobunimult_p1_1d(iverticesatelement, ielidx, idofglob)\n\n!<description>\n\n  ! of the degrees of freedom of the elements in the list ielidx.\n  ! all elements in the list are assumed to be q1.\n  ! a uniform grid is assumed, i.e. a grid completely discretised the\n  ! same element.\n!</description>\n\n!<input>\n\n  ! an array with the number of vertices adjacent to each element of the\n  ! triangulation.\n  integer, dimension(:,:), intent(in) :: iverticesatelement\n\n  ! element indices, where the mapping should be computed.\n  integer, dimension(:), intent(in) :: ielidx\n\n!</input>\n\n!<output>\n\n  ! array of global dof numbers; for every element in ielidx there is\n  ! a subarray in this list receiving the corresponding global dof`s.\n  integer, dimension(:,:), intent(out) :: idofglob\n\n!</output>\n\n\n  ! local variables\n  integer :: i\n\n    ! loop through the elements to handle\n    !$omp parallel do default(shared)\n    do i=1,size(ielidx)\n      ! calculate the global dof`s - which are simply the vertex numbers of the\n      ! corners.\n      idofglob(1:2,i) = iverticesatelement(1:2,ielidx(i))\n    end do\n    !$omp end parallel do\n\n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named running_average to calculate the running average, standard deviation, and number of data points based on the received data values. The subroutine takes 2 input parameters of type real and logical and returns 3 output parameters of type real, real, and integer. If the reset flag is true, the subroutine clears the running sums and exits.", "input": "", "output": "subroutine running_average ( x, ave, std_dev, nvals, reset )\r\n!\r\n!  purpose:\r\n!    to calculate the running average, standard deviation,\r\n!    and number of data points as data values x are received. \r\n!    if \"reset\" is .true., clear running sums and exit. \r\n!\r\n!  record of revisions:\r\n!      date       programmer          description of change\r\n!      ====       ==========          =====================\r\n!    06/26/02    s. j. chapman        original code\r\n!\r\nimplicit none\r\n\r\n! data dictionary: declare calling parameter types & definitions\r\nreal, intent(in) :: x           ! input data value.\r\nreal, intent(out) :: ave        ! running average.\r\nreal, intent(out) :: std_dev    ! running standard deviation.\r\ninteger, intent(out) :: nvals   ! current number of points.\r\nlogical, intent(in) :: reset    ! reset flag: clear sums if true\r\n\r\n! data dictionary: declare local variable types & definitions\r\ninteger, save :: n              ! number of input values.\r\nreal, save :: sum_x             ! sum of input values.\r\nreal, save :: sum_x2            ! sum of input values squared.\r\n\r\n! if the reset flag is set, clear the running sums at this time.\r\ncalc_sums: if ( reset ) then\r\n\r\n   n       = 0 \r\n   sum_x   = 0.\r\n   sum_x2  = 0.\r\n   ave     = 0.\r\n   std_dev = 0.\r\n   nvals   = 0\r\n   \r\nelse\r\n \r\n   ! accumulate sums.\r\n   n      = n + 1\r\n   sum_x  = sum_x + x\r\n   sum_x2 = sum_x2 + x**2\r\n \r\n   ! calculate average.\r\n   ave = sum_x / real(n)\r\n\r\n   ! calculate standard deviation.\r\n   if ( n >= 2 ) then \r\n      std_dev = sqrt( (real(n) * sum_x2 - sum_x**2) &\r\n              / (real(n) * real(n-1)) )\r\n   else\r\n      std_dev = 0.\r\n   end if\r\n\r\n   ! number of data points.\r\n   nvals = n\r\n\r\nend if calc_sums\r\n \r\nend subroutine running_average\r\n"}
{"instruction": "Write a Fortran subroutine named iup_ to unpack the canonical index for a symmetric matrix (1e). The number of input parameters is 1, with test_data type ['integer'], and the number of output parameters is 2, with test_data type ['integer', 'integer'].", "input": "", "output": "        subroutine iup_(ij,i,j)\n          ! unpack the canonical index for a symmetric matrix (1e).\n          implicit none\n          integer,intent(in)::ij\n          integer,intent(out)::i,j\n          real(8)::vt\n          vt=0.5d0*(-1d0+sqrt(1d0+8*ij))\n          i=ceiling(vt)\n          j=ij-(i-1)*i/2\n        end subroutine\n"}
{"instruction": "Create a Fortran subroutine named m33inv to calculate the inverse of a 3x3 matrix. The subroutine takes 1 input parameter of type double precision and returns 2 output parameters of type double precision and logical, respectively.", "input": "", "output": "subroutine m33inv (a, ainv, ok_flag)\n\n      implicit none\n\n      double precision, intent(in)  :: a(:,:)\n      double precision, intent(out)  :: ainv(:,:)\n      logical, intent(out) :: ok_flag\n\n      double precision, parameter :: eps = 1.0d-50\n      double precision :: det\n      double precision, dimension(3,3) :: cofactor\n      \n      if (size(a).ne.9) then\n         write(*,*) 'dimension of the matrix- function do not agree'\n           stop  \n        end if\n\n      det =   a(1,1)*a(2,2)*a(3,3)  &\n            - a(1,1)*a(2,3)*a(3,2)  &\n            - a(1,2)*a(2,1)*a(3,3)  &\n            + a(1,2)*a(2,3)*a(3,1)  &\n            + a(1,3)*a(2,1)*a(3,2)  &\n            - a(1,3)*a(2,2)*a(3,1)\nwrite(*,*) 'det', det\n      if (abs(det) .le. eps) then\n         ainv = 0.0d0\n         ok_flag = .false.\n         return\n      end if\n\n      cofactor(1,1) = +(a(2,2)*a(3,3)-a(2,3)*a(3,2))\n      cofactor(1,2) = -(a(2,1)*a(3,3)-a(2,3)*a(3,1))\n      cofactor(1,3) = +(a(2,1)*a(3,2)-a(2,2)*a(3,1))\n      cofactor(2,1) = -(a(1,2)*a(3,3)-a(1,3)*a(3,2))\n      cofactor(2,2) = +(a(1,1)*a(3,3)-a(1,3)*a(3,1))\n      cofactor(2,3) = -(a(1,1)*a(3,2)-a(1,2)*a(3,1))\n      cofactor(3,1) = +(a(1,2)*a(2,3)-a(1,3)*a(2,2))\n      cofactor(3,2) = -(a(1,1)*a(2,3)-a(1,3)*a(2,1))\n      cofactor(3,3) = +(a(1,1)*a(2,2)-a(1,2)*a(2,1))\n\n      ainv = transpose(cofactor) / det\n\n      ok_flag = .true.\n\n      return\n\n      end subroutine m33inv\n"}
{"instruction": "Create a Fortran subroutine named calc_hartree_radial_1d to calculate the Hartree potential and energy for a one-dimensional system. It takes 3 input parameters of type real(8) in arrays rad, rab, and rho, and 2 output parameters of type real(8) in arrays vh and eh.", "input": "", "output": "  subroutine calc_hartree_radial_1d( rad, rab, rho, vh, eh )\n    implicit none\n    real(8),intent(in) :: rad(:), rab(:)\n    real(8),intent(in) :: rho(:)\n    real(8),intent(out) :: vh(:)\n    real(8),intent(out) :: eh\n    integer :: nrad,i,j\n    real(8) :: pi4,sum0,sum1\n\n    vh=0.0d0\n    eh=0.0d0\n    nrad=size(rad)\n    pi4=4.0d0*acos(-1.0d0)\n\n    do i=1,nrad\n\n       sum0=0.5d0*rad(1)**2*rho(1)*rab(1) &\n           +0.5d0*rad(i)**2*rho(i)*rab(i)\n       do j=2,i-1\n          sum0=sum0+rad(j)**2*rho(j)*rab(j)\n       end do\n       sum0=sum0/rad(i)*pi4\n\n       sum1=0.5d0*rad(i)*rho(i)*rab(i) &\n           +0.5d0*rad(nrad)*rho(nrad)*rab(nrad)\n       do j=i+1,nrad-1\n          sum1=sum1+rad(j)*rho(j)*rab(j)\n       end do\n       sum1=sum1*pi4\n\n       vh(i) = sum1\n\n       write(20,'(1x,4g20.10)') rad(i),sum0+sum1,sum0,sum1\n\n    end do !i\n\n  end subroutine calc_hartree_radial_1d\n"}
{"instruction": "Create a Fortran subroutine named datefromsecondssince1970 to calculate the date and time from the seconds that have passed since the start of the year 1970. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "      subroutine datefromsecondssince1970(ndate,nseconds,printdate)\n!*** calculate date from seconds that have passed since the start of the year 1970\n          implicit none\n\n          integer, intent(out) :: ndate(4)\n          integer, intent(in) :: nseconds\n          integer, intent(in) :: printdate\n\n          integer :: n,nday,nmdays(12),nmdays2(13)\n          nmdays = (/31,28,31,30,31,30,31,31,30,31,30,31/) \n\n          nmdays2(1:12)=nmdays\n          nmdays2(13)=0\n          ndate(1)=1969\n          n=0\n          do while(n<=nseconds)\n            n=n+24*3600*365\n            ndate(1)=ndate(1)+1\n            if(mod(ndate(1),4)==0)n=n+24*3600\n          enddo\n          n=n-24*3600*365\n          if(mod(ndate(1),4)==0)n=n-24*3600\n          if(mod(ndate(1),4)==0)nmdays2(2)=29\n          ndate(2)=0\n          do while(n<=nseconds)\n             ndate(2)=ndate(2)+1\n             n=n+24*3600*nmdays2(ndate(2))\n          enddo\n          n=n-24*3600*nmdays2(ndate(2))\n          ndate(3)=0\n          do while(n<=nseconds)\n             ndate(3)=ndate(3)+1\n             n=n+24*3600\n          enddo\n          n=n-24*3600\n          ndate(4)=-1\n          do while(n<=nseconds)\n             ndate(4)=ndate(4)+1\n             n=n+3600\n          enddo\n          n=n-3600\n          !    ndate(5)=nseconds-n\n          if(printdate>0)then\n          write(*,*)'year: ',ndate(1),', month: ',ndate(2),', day: ',ndate(3),', hour: ',ndate(4),', seconds: ',nseconds-n\n          endif\n\n      end subroutine datefromsecondssince1970\n"}
{"instruction": "Create a Fortran subroutine named datefromhourssince1900 to calculate the date and time from the number of hours that have passed since the start of the year 1900. The subroutine takes 2 input parameters of type integer and returns 1 output parameter of type integer.", "input": "", "output": "      subroutine datefromhourssince1900(ndate,nhours,printdate)\n!*** calculate date from hours that have passed since the start of the year 1900\n!*** nb: 1900 is not a leap year\n\n          implicit none\n\n          integer, intent(out) :: ndate(4)\n          integer, intent(in) :: nhours\n          integer, intent(in) :: printdate\n\n          integer :: n,nday,nmdays(12),nmdays2(13)\n          nmdays = (/31,28,31,30,31,30,31,31,30,31,30,31/) \n\n          nmdays2(1:12)=nmdays\n          nmdays2(13)=0\n          ndate(1)=1899\n          n=0\n          do while(n<=nhours)\n             n=n+24*365\n             ndate(1)=ndate(1)+1\n             if(mod(ndate(1),4)==0)n=n+24\n             if(ndate(1)==1900)n=n-24\n          enddo\n          n=n-24*365\n          if(mod(ndate(1),4)==0)n=n-24\n          if(ndate(1)==1900)n=n+24\n          if(mod(ndate(1),4)==0)nmdays2(2)=29\n          if(ndate(1)==1900)nmdays2(2)=28\n!  write(*,*)ndate(1),n\n          ndate(2)=0\n          do while(n<=nhours)\n             ndate(2)=ndate(2)+1\n             n=n+24*nmdays2(ndate(2))\n          enddo\n          n=n-24*nmdays2(ndate(2))\n!  write(*,*)ndate(2),n\n          ndate(3)=0\n          do while(n<=nhours)\n             ndate(3)=ndate(3)+1\n             n=n+24\n          enddo\n          n=n-24\n!  write(*,*)ndate(3),n\n          ndate(4)=nhours-n\n\n          if(printdate>0)then\n             write(*,*)'year: ',ndate(1),', month: ',ndate(2),', day: ',ndate(3),', hour: ',ndate(4)\n          endif\n\n      end subroutine datefromhourssince1900\n"}
{"instruction": "Create a Fortran subroutine named \"secondssince1970\" to calculate the number of seconds that have passed since the start of the year 1970 based on the given date. The input parameter is an integer array with 4 elements. The output parameter is an integer representing the number of seconds.", "input": "", "output": "      subroutine secondssince1970(ndate,nseconds)\n!*** calculate how many seconds have passed since the start of the year\n\n          implicit none\n\n          integer, intent(in) :: ndate(4)\n          integer, intent(out) :: nseconds\n          integer :: n,nday,nmdays(12)\n          nmdays = (/31,28,31,30,31,30,31,31,30,31,30,31/) \n          n=ndate(1)\n             if(4*(n/4)==n)nmdays(2)=29\n          nday=0\n          do n=1,ndate(2)-1\n             nday=nday+nmdays(n)\n          enddo\n          nday=nday+ndate(3)\n\n          nseconds=3600*(ndate(4)+24*(nday-1))\n\n!***  add seconds from each year since 1970\n          do n=1970,ndate(1)-1\n            nseconds=nseconds+24*3600*365\n            if(4*(n/4)==n)nseconds=nseconds+24*3600\n          enddo\n!     write(*,*)ndate(1),ndate(2),ndate(3),ndate(4),nseconds\n\n      end subroutine secondssince1970\n"}
{"instruction": "Create a Fortran subroutine named scattering_matrix_fresnel to calculate the scattering matrix for Fresnel reflection and transmission. The subroutine takes 3 input parameters of types complex*16, complex*16, and double precision, and returns 1 output parameter of type complex*16, dimension(2,2).", "input": "", "output": "    subroutine scattering_matrix_fresnel(k1, k2, sigma, s)\n        complex*16, intent(in) :: k1, k2\n        double precision, intent(in) :: sigma\n        !f2py double precision, intent(in), optional:: sigma=0\n        complex*16, dimension(2,2), intent(out) :: s\n        \n        complex*16 :: r, t\n        \n        r = (k1-k2) / (k1+k2) * cdexp(-2*sigma**2*k1*k2)\n        t = 2*cdsqrt(k1*k2) / (k1+k2) * cdexp(5d-1*sigma**2*(k1-k2)**2)\n        s(1,1) = r\n        s(1,2) = t\n        s(2,1) = t\n        s(2,2) = -r\n    end subroutine scattering_matrix_fresnel\n"}
{"instruction": "Create a Fortran subroutine named dayfraction2hms_int to convert a fractional number representing a time of day into hours, minutes, and seconds. The subroutine takes 1 input parameter of type real*8. The output consists of 3 parameters of type integer representing hour, minute, and second, respectively.", "input": "", "output": "  elemental subroutine dayfraction2hms_int(frac, hour, minute, second)\n\n    real*8,  intent(in)  :: frac\n    integer, intent(out) :: hour\n    integer, intent(out) :: minute\n    integer, intent(out) :: second\n\n    real*8 :: tmp\n\n    tmp = frac*24.d0\n\n    hour   = int(tmp)\n    minute = int((tmp - hour)*60.d0)\n    second = nint((tmp - hour - minute/60.d0)*3.6d3)\n\n    if(second == 60) then\n\n      minute = minute + 1\n      second = 0\n\n      if(minute == 60) then\n\n        hour   = hour + 1\n        minute = 0\n\n        if(hour == 24) then\n\n          hour = 0\n\n        end if\n\n      end if\n\n    end if\n\n  end subroutine dayfraction2hms_int\n"}
{"instruction": "Create a Fortran subroutine named dp_dt that takes 5 input parameters of type real(8) and one 2-dimensional array of real(8), and returns 1 output parameter of type real(8). The input parameters are rho, delta, tau, r, ar, and the output parameter is dpdt. The subroutine calculates dpdt as rho times r times (1.d0 plus delta times ar(2, 1) minus delta times tau times ar(3, 3)).", "input": "", "output": "   subroutine dp_dt(rho, delta, tau, r, ar, dpdt)\n      real(8), intent(in) :: delta, r, rho, tau\n      real(8), intent(out) :: dpdt\n      real(8), dimension(3, 3), intent(in) :: ar\n\n      dpdt = rho * r * (1.d0 + delta * ar(2, 1) - delta * tau * ar(3, 3))\n\n   end subroutine dp_dt\n"}
{"instruction": "Create a Fortran subroutine named dp_dv to calculate the derivative of pressure with respect to molar volume. It takes 5 input parameters of type real(8) and outputs 1 parameter of type real(8). The input parameters are delta, r, rho, t, and ar(3,3). The output parameter is dpdv.", "input": "", "output": "   subroutine dp_dv(rho, delta, t, r, ar, dpdv) ! !recordar que ac\u00e1 hablamos de volumen molar!!\n      real(8), intent(in) :: delta, r, rho, t\n      real(8), intent(out) :: dpdv\n      real(8), dimension(3, 3), intent(in) :: ar\n\n      dpdv = - (rho ** 2) * r * t * (1.d0 + 2.d0 * delta * ar(2, 1) + (delta ** 2) * ar(3, 1))\n\n   end subroutine dp_dv\n"}
{"instruction": "Create a Fortran subroutine named entropy that takes in four real(8) input parameters: tau, r, ao(3,3), and ar(3,3). It also has one real(8) output parameter, s. The subroutine computes the value of s using the formula: s = (tau * (ao(2,2) + ar(2,2)) - ao(1,1) - ar(1,1)) * r.", "input": "", "output": "   subroutine entropy(tau, r, ao, ar, s)\n      real(8), intent(in) :: tau, r, ao(3, 3), ar(3, 3)\n      real(8), intent(out) :: s\n\n      s = (tau * (ao(2, 2) + ar(2, 2)) - ao(1, 1) - ar(1, 1)) * r\n   end subroutine entropy\n"}
{"instruction": "Write a Fortran subroutine code named four_point_triangle_real that calculates the derivative of a given function using the four-point triangle method. The subroutine takes 3 input parameters: an integer llim, a real array f with dimensions llim and above, and a real value del. It also has 1 output parameter: a real array df with dimensions llim and above. \n\nIn the subroutine, the input array f is used to calculate the derivative values, which are stored in the output array df. The subroutine implements a second-order accurate centered difference approximation. The derivative values are computed at specific points using the four-point triangle formula. The derivative values at the boundaries of the array f are computed differently than the interior points.\n\nTo use the subroutine, call it and provide the necessary input parameters: llim, f, and del. After the subroutine is executed, the derivative values will be stored in the df array.", "input": "", "output": "   subroutine four_point_triangle_real(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      real, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, n, istart, iend\n\n      n = size(f)\n      istart = llim\n      iend = llim + n - 1\n\n      ! zero bc\n      i = istart\n      df(i) = f(i + 1) / (2.0 * del)\n      i = istart + 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = istart + 2\n      df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1)) / (18.0 * del)\n\n      i = iend\n      df(i) = -f(i - 1) / (2.0 * del)\n      i = iend - 1\n      df(i) = (f(i + 1) - f(i - 1)) / (2.0 * del)\n      i = iend - 2\n      df(i) = (9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n\n      ! 2nd order accurate centered\n      do i = istart + 3, iend - 3\n         df(i) = (-2.*f(i + 3) + 9.*f(i + 1) - 9.*f(i - 1) + 2.*f(i - 3)) / (18.0 * del)\n      end do\n\n   end subroutine four_point_triangle_real\n"}
{"instruction": "Implement a Fortran subroutine named second_order_centered_zed_real that performs second-order finite difference calculations for a given range of data. The subroutine takes in 9 input parameters: llim (integer), iseg (integer), nseg (integer), f (real array with dimension(llim:)), sgn (integer), del (real), fl (real array), fr (real array), and periodic (logical). It also has 1 output parameter: df (real array with dimension(llim:)).\n\nThe subroutine computes the central difference approximation for the derivative of the input data within the specified range. It handles boundary conditions and determines the appropriate neighboring values to calculate the derivative accurately. The resulting derivative values are stored in the df array.\n\nTo use the subroutine, provide the required input parameters and allocate memory for the output array. After calling the subroutine, you can access the derivative values stored in df.\n\nEnsure that the input and output arrays have the correct dimensions and types to avoid any runtime errors.\n\n", "input": "", "output": "   subroutine second_order_centered_zed_real(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df)\n\n      implicit none\n\n      integer, intent(in) :: llim, iseg, nseg\n      real, dimension(llim:), intent(in) :: f\n      integer, intent(in) :: sgn\n      real, intent(in) :: del\n      real, dimension(:), intent(in) :: fl, fr\n      logical, intent(in) :: periodic\n      real, dimension(llim:), intent(out) :: df\n\n      integer :: i, ulim\n\n      ulim = size(f) + llim - 1\n\n      i = llim\n      if (iseg == 1 .and. sgn > 0 .and. .not. periodic) then\n         ! sgn > 0 corresponds to negative advection speed\n         ! upwind at boundary requires taking information from right\n         df(i) = (f(i + 1) - f(i)) / del\n      else\n         df(i) = 0.5 * (f(i + 1) - fl(2)) / del\n      end if\n\n      i = ulim\n      if (iseg == nseg .and. sgn < 0 .and. .not. periodic) then\n         ! sgn < 0 corresponds to positive advection speed\n         ! upwind at boundary requires taking information from left\n         df(i) = (f(i) - f(i - 1)) / del\n      else\n         df(i) = 0.5 * (fr(1) - f(i - 1)) / del\n      end if\n\n      do i = llim + 1, ulim - 1\n         df(i) = 0.5 * (f(i + 1) - f(i - 1)) / del\n      end do\n\n   end subroutine second_order_centered_zed_real\n"}
{"instruction": "Write a Fortran subroutine named \"second_order_centered_vpa\" that calculates the centered finite difference approximation of the derivative of a complex-valued function. The subroutine takes 3 input parameters: an integer \"llim\", representing the lower limit of the array indices; a complex array \"f\" with indices ranging from \"llim\" to the upper limit; and a real value \"del\" representing the step size. The subroutine also has 1 output parameter: a complex array \"df\" with indices ranging from \"llim\" to the upper limit.", "input": "", "output": "   subroutine second_order_centered_vpa(llim, f, del, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, ulim\n\n      ulim = size(f) + llim - 1\n\n      i = llim\n      df(i) = 0.5 * f(i + 1) / del\n\n      i = ulim\n      df(i) = -0.5 * f(i - 1) / del\n\n      do i = llim + 1, ulim - 1\n         df(i) = 0.5 * (f(i + 1) - f(i - 1)) / del\n      end do\n\n   end subroutine second_order_centered_vpa\n"}
{"instruction": "Create a Fortran subroutine named \"fd_cell_centres_zed\" that computes the spatial derivatives of a given complex array with respect to a specified spacing. The subroutine should take 6 input parameters of types integer, complex array, real, integer, complex, and complex, and 1 output parameter of type complex array.", "input": "", "output": "   subroutine fd_cell_centres_zed(llim, f, del, sgn, fl, fr, df)\n\n      implicit none\n\n      integer, intent(in) :: llim\n      complex, dimension(llim:), intent(in) :: f\n      real, intent(in) :: del\n      integer, intent(in) :: sgn\n      complex, intent(in) :: fl, fr\n      complex, dimension(llim:), intent(out) :: df\n\n      integer :: i, ulim\n\n      ulim = size(f) + llim - 1\n\n      if (sgn > 0) then\n         ! if sgn > 0, then stream speed is negative\n         ! so sweep from more positive to more negative zed\n         i = ulim\n         df(i) = (fr - f(i)) / del\n         do i = ulim - 1, llim, -1\n            df(i) = (f(i + 1) - f(i)) / del\n         end do\n      else\n         ! if sgn < 0, then stream speed is positive\n         ! so sweep from more negative to more positive zed\n         i = llim\n         df(i) = (f(i) - fl) / del\n         do i = llim + 1, ulim\n            df(i) = (f(i) - f(i - 1)) / del\n         end do\n      end if\n\n   end subroutine fd_cell_centres_zed\n"}
{"instruction": "Create a Fortran subroutine named stretch to calculate stretch and strain values. The subroutine takes 6 input parameters of type real(kind=8) and returns 2 output parameters of type real(kind=8). The input parameters are u(3), du(3), coords(2), et, cosd(2), zeta, and the output parameters are lambda(2) and strain(3).", "input": "", "output": " subroutine stretch(u,du,coords,et,cosd,zeta,lambda,strain)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: u(3),du(3),coords(2)  !u(nmdof)\n  real(kind=8),intent(in) :: et,cosd(2),zeta\n  real(kind=8),intent(out) :: lambda(2),strain(3)\n  !internal variables\n  !stretch\n  lambda(1) = sqrt((1.d0+du(1))**2.d0+du(2)**2.d0 &\n   & -2.d0*zeta*((1.d0+du(1))*cos(u(3))+du(2)*sin(u(3)))*du(3))\n  lambda(2) = sqrt((1.d0+et)**2.d0 &\n          & + 2.d0*zeta*((1.d0+et)*sin(asin(cosd(2))-u(3))-cosd(2))/coords(2))\n  !lambda(2) = sqrt((1.d0+et)**2.d0 &\n  !        & + 2.d0*zeta*(cosd(1)-(1.d0+et)*cos(asin(cosd(2))-u(3)))/rm)\n  !strains\n  strain(1) = du(1)+0.5d0*(du(1)**2.d0+du(2)**2.d0) &\n          & - zeta*((1.d0+du(1))*cos(u(3))+du(2)*sin(u(3)))*du(3)\n  strain(2) = et + 0.5d0*et**2.d0 &\n          & + zeta*((1.d0+et)*sin(asin(cosd(2))-u(3))-cosd(2))/coords(2)\n  !strain(2) = et + 0.5d0*et**2.d0 &\n  !        & + zeta*(cosd(1)-(1.d0+et)*cos(asin(cosd(2))-u(3)))/rm\n  strain(3) = -(1.d0+du(1))*sin(u(3))+du(2)*cos(u(3))\n end subroutine stretch\n"}
{"instruction": "The subroutine named \"gmatrix\" in Fortran is designed to perform a series of calculations related to geometric matrices. It takes 8 input parameters of real(kind=8) type and produces 3 output parameters, also of real(kind=8) type. This subroutine is responsible for computing and populating matrices g1_mb, g2_mb, and g_pen based on the input parameters provided.", "input": "", "output": " subroutine gmatrix(nfunc,dnds,u,du,cosd,coords,et,zeta,g1_mb,g2_mb,g_pen)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: nfunc(2),dnds(2),u(3),du(3),cosd(2),coords(2)\n  real(kind=8),intent(in) :: et,zeta\n  real(kind=8),intent(out) :: g1_mb(3,3,2,2),g2_mb(3,3,2,2),g_pen(3,3,2,2)\n  !internal variables\n  integer(kind=4) :: i1,i2\n  !routine\n  !cycle for g1_ij\n  do i1=1,2\n    do i2=1,2\n      g1_mb(1,1,i1,i2) = dnds(i1)*dnds(i2)\n      g1_mb(1,2,i1,i2) = 0.d0\n      g1_mb(1,3,i1,i2) = zeta*(du(3)*sin(u(3))*nfunc(i2)-cos(u(3))*dnds(i2))*dnds(i1)\n      g1_mb(2,1,i1,i2) = 0.d0\n      g1_mb(2,2,i1,i2) = dnds(i1)*dnds(i2)\n      g1_mb(2,3,i1,i2) = -zeta*(du(3)*cos(u(3))*nfunc(i2)+sin(u(3))*dnds(i2))*dnds(i1)\n      g1_mb(3,1,i1,i2) = zeta*(du(3)*sin(u(3))*nfunc(i1)-cos(u(3))*dnds(i1))*dnds(i2)\n      g1_mb(3,2,i1,i2) = -zeta*(du(3)*cos(u(3))*nfunc(i1)+sin(u(3))*dnds(i1))*dnds(i2)\n      g1_mb(3,3,i1,i2) = zeta*((1.d0+du(1))*du(3)*cos(u(3))*nfunc(i1)*nfunc(i2) &\n              & + du(2)*du(3)*sin(u(3))*nfunc(i1)*nfunc(i2) &\n              & + (1.d0+du(1))*sin(u(3))*nfunc(i1)*dnds(i2) &\n              & - du(2)*cos(u(3))*nfunc(i1)*dnds(i2) &\n              & + (1.d0+du(1))*sin(u(3))*dnds(i1)*nfunc(i2) &\n              & - du(2)*cos(u(3))*dnds(i1)*nfunc(i2))\n    end do\n  end do\n  !cycle for g2_ij\n  do i1=1,2\n    do i2=1,2\n      g2_mb(1,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)**2.d0/coords(2)**2.d0\n      g2_mb(1,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_mb(1,3,i1,i2) = -zeta*cosd(1)*cos(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/coords(2)**2.d0\n      g2_mb(2,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/coords(2)**2.d0\n      g2_mb(2,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(2)**2.d0/coords(2)**2.d0\n      g2_mb(2,3,i1,i2) = -zeta*cosd(2)*cos(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/coords(2)**2.d0\n      g2_mb(3,1,i1,i2) = -zeta*cosd(1)*cos(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/coords(2)**2.d0\n      g2_mb(3,2,i1,i2) = -zeta*cosd(2)*cos(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/coords(2)**2.d0\n      g2_mb(3,3,i1,i2) = -zeta*(1.d0+et)*sin(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/coords(2)\n      !g2_mb(1,1,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(2)**2.d0/rm**2.d0\n      !g2_mb(1,2,i1,i2) = -nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/rm**2.d0\n      !g2_mb(1,3,i1,i2) = zeta*cosd(2)*sin(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/rm**2.d0\n      !g2_mb(2,1,i1,i2) = -nfunc(i1)*nfunc(i2)*cosd(1)*cosd(2)/rm**2.d0\n      !g2_mb(2,2,i1,i2) = nfunc(i1)*nfunc(i2)*cosd(2)**2.d0/rm**2.d0\n      !g2_mb(2,3,i1,i2) = -zeta*cosd(1)*sin(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/rm**2.d0\n      !g2_mb(3,1,i1,i2) = zeta*cosd(2)*sin(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/rm**2.d0\n      !g2_mb(3,2,i1,i2) = -zeta*cosd(1)*sin(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/rm**2.d0\n      !g2_mb(3,3,i1,i2) = zeta*(1.d0+et)*cos(asin(cosd(2))-u(3))*nfunc(i1)*nfunc(i2)/rm\n    end do\n  end do\n  !cycle for gpen_ij\n  do i1=1,2\n    do i2=1,2\n      g_pen(1,1,i1,i2) = 0.d0\n      g_pen(1,2,i1,i2) = 0.d0\n      g_pen(1,3,i1,i2) = -cos(u(3))*dnds(i1)*nfunc(i2)\n      g_pen(2,1,i1,i2) = 0.d0\n      g_pen(2,2,i1,i2) = 0.d0\n      g_pen(2,3,i1,i2) = -sin(u(3))*dnds(i1)*nfunc(i2)\n      g_pen(3,1,i1,i2) = -cos(u(3))*dnds(i2)*nfunc(i1)\n      g_pen(3,2,i1,i2) = -sin(u(3))*dnds(i2)*nfunc(i1)\n      g_pen(3,3,i1,i2) = (1.d0+du(1))*sin(u(3))*nfunc(i1)*nfunc(i2) &\n              & - du(2)*cos(u(3))*nfunc(i1)*nfunc(i2)\n    end do\n  end do\n\n end subroutine gmatrix\n"}
{"instruction": "Create a Fortran subroutine named \"getctandcb\" that takes 9 input parameters of types integer and double precision, and 2 output parameters of type double precision. The subroutine calculates the values of \"ct\" and \"cb\" based on the value of the \"form\" input parameter and the given double precision parameters \"zz1t, zz2t, zz3t, zz4t, zz1b, zz2b, zz3b, zz4b\".", "input": "", "output": "  subroutine getctandcb(form,zz1t,zz2t,zz3t,zz4t,zz1b,zz2b,zz3b,zz4b,ct,cb)\r\n    integer, intent(in) :: form\r\n    double precision, intent(in) :: zz1t,zz2t,zz3t,zz4t,zz1b,zz2b,zz3b,zz4b\r\n    double precision, intent(out) :: ct,cb\r\n\r\n    ct = 0.0\r\n    cb = 0.0\r\n\r\n    !calculate based on form\r\n    select case(form)\r\n    case(0,15)\r\n      ct = (zz1t+zz2t+zz3t+zz4t) / dble(4)\r\n      cb = (zz1b+zz2b+zz3b+zz4b) / dble(4)\r\n    case(1)\r\n      ct = (zz1t+zz2t+zz3t) / dble(3)\r\n      cb = (zz1b+zz2b+zz3b) / dble(3)\r\n    case(2)\r\n      ct = (zz2t+zz3t+zz4t) / dble(3)\r\n      cb = (zz2b+zz3b+zz4b) / dble(3)\r\n    case(3)\r\n      ct = (zz2t+zz3t) / dble(2)\r\n      cb = (zz2b+zz3b) / dble(2)\r\n    case(4)\r\n      ct = (zz1t+zz2t+zz4t) / dble(3)\r\n      cb = (zz1b+zz2b+zz4b) / dble(3)\r\n    case(5)\r\n      ct = (zz1t+zz2t) / dble(2)\r\n      cb = (zz1b+zz2b) / dble(2)\r\n    case(7)\r\n      ct = (zz2t)\r\n      cb = (zz2b)\r\n    case(8)\r\n      ct = (zz1t+zz3t+zz4t) / dble(3)\r\n      cb = (zz1b+zz3b+zz4b) / dble(3)\r\n    case(10)\r\n      ct = (zz3t+zz4t) / dble(2)\r\n      cb = (zz3b+zz4b) / dble(2)\r\n    case(11)\r\n      ct = (zz3t)\r\n      cb = (zz3b)\r\n    case(12)\r\n      ct = (zz1t+zz4t) / dble(2)\r\n      cb = (zz1b+zz4b) / dble(2)\r\n    case(13)\r\n      ct = (zz1t)\r\n      cb = (zz1b)\r\n    case(14)\r\n      ct = (zz4t)\r\n      cb = (zz4b)\r\n    case(16,17)\r\n      ct = (zz2t+zz4t) / dble(2)\r\n      cb = (zz2b+zz4b) / dble(2)\r\n    case(18,19)\r\n      ct = (zz1t+zz3t) / dble(2)\r\n      cb = (zz1b+zz3b) / dble(2)\r\n    case default\r\n      write(*,*)'error: undefined case'\r\n      stop\r\n    end select\r\n\r\n  end subroutine getctandcb\r\n"}
{"instruction": "Create a Fortran subroutine named meanline6 to compute the displacement and slope of a 6-series mean line. The subroutine takes 3 input parameters of type real and real, dimension(:), and produces 2 output parameters of type real, dimension(:).", "input": "", "output": "subroutine meanline6(a,cl,x,ym,ymp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the displacement and slope of a 6-series mean line.\r\n! ref - eq. 4-26 and 4-27, p.74 of abbott and von doenhoff.\r\n\r\n  real,intent(in):: a  ! chordwise extent of uniform loading 0<=a<=1\r\n  real,intent(in):: cl ! design cl of the mean line\r\n  real,intent(in), dimension(:):: x   ! fraction of chord\r\n  real,intent(out),dimension(:):: ym   ! y-coor of meanline\r\n  real,intent(out),dimension(:):: ymp   ! dy/dx of mean line\r\n\r\n  real,parameter:: zero=0.0, one=1.0, two=2.0, half=0.5, fourth=0.25\r\n  real,parameter:: pi=3.141592654, twopi=two*pi, eps= 1e-7\r\n\r\n  real:: amx\r\n  real:: g,h\r\n  integer:: k,n\r\n  real:: oma\r\n  real:: omx\r\n  real:: term1,term2, term1p,term2p\r\n  real:: xx\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)\r\n  ym(1:n) = zero\r\n  ymp(1:n)= zero\r\n\r\n  oma=one-a\r\n  if (abs(oma) < eps) then    \r\n    do k=1,n                    ! a==1\r\n      xx=x(k)\r\n      omx= one-xx\r\n      if (xx<eps .or. omx<eps) then\r\n        ym(k)=zero\r\n        ymp(k)=zero\r\n        cycle\r\n      end if\r\n      ym(k)=omx*log(omx)+xx*log(xx)\r\n      ymp(k)=log(omx)-log(xx)\r\n    end do\r\n    ym(1:n)=-ym(1:n)*cl*(fourth/pi)\r\n    ymp(1:n)=ymp(1:n)*cl*(fourth/pi)\r\n    return\r\n  end if\r\n\r\n  do k=1,n \r\n    xx=x(k)\r\n    omx= one-xx\r\n    if (xx<eps .or. abs(omx)<eps) then\r\n      ym(k)=zero\r\n      ymp(k)=zero\r\n      cycle\r\n    end if\r\n\r\n    if (abs(a) < eps) then                               ! a=0\r\n      g=-fourth\r\n      h=-half\r\n    else\r\n      g=-(a*a*(half*log(a)-fourth)+fourth)/oma\r\n      h=g+(half*oma*oma*log(oma)-fourth*oma*oma)/oma\r\n    end if\r\n\r\n    amx= a-xx\r\n    if (abs(amx) < eps) then\r\n      term1=zero\r\n      term1p=zero\r\n    else\r\n      term1=amx*amx*(two*log(abs(amx))-one)\r\n      term1p=-amx*log(abs(amx))\r\n    end if\r\n\r\n    term2=omx*omx*(one-two*log(omx))\r\n    term2p=omx*log(omx)\r\n\r\n    ym(k)=fourth*(term1+term2)/oma - xx*log(xx) + g - h*xx\r\n    ymp(k)=(term1p+term2p)/oma - one - log(xx) - h\r\n  end do\r\n\r\n  ym(1:n)=cl*ym(1:n)/(twopi*(a+one))\r\n  ymp(1:n)=cl*ymp(1:n)/(twopi*(a+one))\r\n\r\n  return\r\nend subroutine meanline6  ! ----------------------------------------------------\r\n"}
{"instruction": "Create a Fortran subroutine named parametrizeairfoil to parametrically define the shape of an airfoil using inscribed arc length. The subroutine takes 4 input parameters of type real arrays and outputs 3 parameters of type real arrays. The input parameters are xupper, yupper, xlower, ylower, and the output parameters are s, x, y.", "input": "", "output": "subroutine parametrizeairfoil(xupper,yupper,xlower,ylower, s,x,y)\r\n! ------------------------------------------------------------------------------\r\n! purpose - define the shape of an airfoil parametrically using s, the\r\n!   inscribed arc length, s. s=0 at the trailing edge, then increases by\r\n!   moving forward along the upper surface, then around the nose and rearward\r\n!   along the lower surface. the final value of s is somewhat greater than 2.\r\n  real,intent(in),dimension(:):: xupper,yupper,xlower,ylower\r\n  real,intent(out),dimension(:):: s,x,y\r\n\r\n  integer:: k,nn\r\n  integer:: nupper,nlower   ! don't have to be the same\r\n!-------------------------------------------------------------------------------\r\n  nupper=size(xupper)\r\n  nlower=size(xlower)\r\n\r\n  if (size(yupper)<nupper .or. size(ylower)<nlower) then\r\n    write(*,*) \"disaster #1\"\r\n    stop\r\n  end if\r\n\r\n  nn=nupper+nlower-1\r\n  if (size(s)<nn .or. size(x)<nn .or. size(y)<nn) then\r\n    write(*,*) \"disaster #2\"\r\n    stop\r\n  end if\r\n\r\n  x(1:nupper)=xupper(nupper:1:-1)\r\n  y(1:nupper)=yupper(nupper:1:-1)\r\n  x(nupper+1:nn)=xlower(2:nlower)\r\n  y(nupper+1:nn)=ylower(2:nlower)\r\n\r\n  s(1)=0.0\r\n  do k=2,nn\r\n    s(k)=s(k-1) + sqrt((x(k)-x(k-1))**2 + (y(k)-y(k-1))**2)\r\n  end do\r\n\r\n  return\r\nend subroutine parametrizeairfoil   ! ------------------------------------------\r\n"}
{"instruction": "Write a Fortran subroutine named checkatom to classify atoms based on their labels. The subroutine takes 1 input parameter of type character with a length of 4, and 4 output parameters of type real, real, integer, and character with a length of 2. The subroutine should use a select case statement to assign values to the output parameters based on the input label. If the input label does not match any case, the subroutine should output an error message.", "input": "", "output": " subroutine checkatom(label,m,s,z,zlabel)\n  implicit none\n  character(len=4),intent(in)  :: label\n  real,intent(out)             :: m,s\n  integer,intent(out)          :: z\n  character(len=2),intent(out) :: zlabel\n  select case(label)\n   case('c   ','c0  ':'c999')\n    z=6\n    m=12.0107\n    s=0.720\n    zlabel=' c'\n   case('h   ','h0  ':'h999')\n    z=1\n    m=1.00794\n    s=0.320\n    zlabel=' h'\n   case('n   ','n0  ':'n999')\n    z=7\n    m=14.00674\n    s=0.7\n    zlabel=' n'\n   case('o   ','o0  ':'o999','oh  ')\n    z=8\n    m=15.9994\n    s=0.7\n    zlabel=' o'\n   case('si  ','si0 ':'si99')\n    z=14\n    m=28.0855\n    s=1.14\n    zlabel='si'\n   case('al  ')\n    z=13\n    m=26.9800\n    s=1.14\n    zlabel='al'\n   case('ar  ')\n    z=18\n    m=39.948\n    zlabel=\"ar\"\n    s=0.0\n   case('xe  ')\n    z=54\n    m=131.293\n    s=0.0001\n    zlabel='xe'\n   case('zn  ','zn0 ':'zn99')\n    z=30\n    m=65.37\n    s=1.6\n    zlabel='zn'\n   case('cl  ',' cl ','cl0 ':'cl99')\n    z=17\n    m=35.453\n    s=1.0\n    zlabel='cl'\n   case default\n    write(6,'(a1,a4,a1)')\"'\",label,\"'\"\n    stop 'atom unknowed'\n  end select\n end subroutine checkatom\n"}
{"instruction": "Write a Fortran subroutine named gen_seq to generate a numeric vector with minimum, maximum, and length inputs. The number of input arguments is 3 and the test_data type is [real, real, integer]. The number of output arguments is 2 and the test_data type is [real, real].", "input": "", "output": "subroutine gen_seq(xmin, xmax, length, x, dx)\n    !generate a numeric vector with min, max and length\n    implicit none\n    real,   intent(in)  :: xmin, xmax\n    integer,intent(in)  :: length\n    real,   intent(out) :: x(length),dx\n    integer :: i\n\n    if (xmin >= xmax) then\n      write(*,'(f12.3,a20,f12.3)') xmin,\" not smaller than \",xmax\n      stop\n    endif\n    dx    = (xmax - xmin)/float(length-1)\n    x(1)  = xmin\n    do i  = 2, length\n      x(i)= x(i-1) + dx  !log size of each class\n    enddo\nend subroutine gen_seq\n"}
{"instruction": "Create a Fortran subroutine named get_overlap to calculate the overlap between two sets of Gaussian distributions. The subroutine should have 5 input parameters of type integer, logical, real*8 array, real*8 array, and real*8 array, and 1 output parameter of type real*8.", "input": "", "output": "subroutine get_overlap(vs1, vs2, sigmas, nv, ifactor, ov)\n\n    ! \n    ! calculate the overlap between two \n    ! gaussian distribution \n    !\n    ! parameters\n    ! =============================================\n    ! \n    ! \n\n    implicit none\n\n    integer, intent(in) :: nv\n    logical, intent(in) :: ifactor\n    real*8, intent(in) :: vs1(nv), vs2(nv), sigmas(nv)\n    real*8, intent(out) :: ov\n    integer :: i\n    real*8, parameter :: pi = 3.1415926\n    real*8 :: dv, factor\n\n    ov = 1.0\n    do i = 1,nv\n        dv = vs1(i) - vs2(i)\n        factor = 1.0\n        if ( ifactor ) then \n            factor = 2.0 * sigmas(i) * sqrt(pi)\n        endif\n        ov = ov * exp( -dv*dv/(4.0*sigmas(i)*sigmas(i)) )/factor\n    enddo\n\nend subroutine get_overlap\n"}
{"instruction": "Create a Fortran subroutine named get_overlapn to calculate the overlap between n Gaussian distributions. The subroutine has 5 input parameters of types: integer, integer, logical, real*8, and real*8. It also has 1 output parameter of type real*8.", "input": "", "output": "subroutine get_overlapn(vss, n, nv, sigmas, ifactor, ov)\n\n    ! \n    ! calculate the overlap between n\n    ! gaussian distribution \n    !\n    ! parameters\n    ! =============================================\n    ! nv        :  number of values assigned to \n    !              characterize each atom\n    ! n         :  number of atoms\n    ! vss(n,nv) :  values for input atoms (state of atoms)\n    !              each row characterizes an atom\n\n    implicit none\n\n    integer, intent(in) :: nv, n\n    logical, intent(in) :: ifactor\n    real*8, intent(in) :: vss(n,nv), sigmas(nv)\n    real*8, intent(out) :: ov\n    integer :: i\n    real*8, parameter :: pi = 3.1415926\n    real*8 :: const\n    real*8 :: sigma, factor, dv, vsi(n), svsi\n\n    const = 1.0/sqrt(dble(nv))\n    ov = 1.0\n    do i = 1,nv\n        vsi = vss(:,i)\n        svsi = sum(vsi)\n        dv = sum(vsi*vsi) - svsi*svsi/dble(n)\n        factor = 1.0\n        sigma = sigmas(i)\n        if ( ifactor ) then \n            factor = const *(sigma**2 * sqrt(pi) )**(0.5-0.5*dble(n))\n        endif\n        ov = ov * exp( -dv/(2.0*sigma*sigma) )/factor\n    enddo\nend subroutine get_overlapn\n"}
{"instruction": "Create a Fortran subroutine named tridiagonal to solve a linear equation with a tridiagonal matrix structure using the Thomas algorithm. The subroutine takes 7 input parameters of types: integer, integer, integer, real(8) arrays of dimension (n), real(8) arrays of dimension (n), real(8) arrays of dimension (n), and real(8) arrays of dimension (n). It outputs 1 parameter of type real(8).", "input": "", "output": "subroutine tridiagonal(n,au,bu,cu,du,fi,lt,value)\n!\n! !description:\n! a linear equation with tridiagonal matrix structure is solved here. the main\n! diagonal is stored on {\\tt bu}, the upper diagonal on {\\tt au}, and the\n! lower diagonal on {\\tt cu}, the right hand side is stored on {\\tt du}.\n! the method used here is the simplified gauss elimination, also called\n! \\emph{thomas algorithm}.\n!\n! !uses:\n   implicit none\n!\n! !input parameters:\n   integer, intent(in)                 :: n,fi,lt\n   real(8), dimension(n), intent(in)   :: au, bu, cu, du\n!\n! !output parameters:\n   real(8), intent(out)                :: value(n)\n!\n!eop\n!\n! !local variables:\n   integer                             :: i\n   real(8), dimension(n)               :: ru, qu\n!\n!-----------------------------------------------------------------------\n!boc\n   ru(lt)=au(lt)/bu(lt)\n   qu(lt)=du(lt)/bu(lt)\n\n   do i=lt-1,fi+1,-1\n      ru(i)=au(i)/(bu(i)-cu(i)*ru(i+1))\n      qu(i)=(du(i)-cu(i)*qu(i+1))/(bu(i)-cu(i)*ru(i+1))\n   end do\n\n   qu(fi)=(du(fi)-cu(fi)*qu(fi+1))/(bu(fi)-cu(fi)*ru(fi+1))\n\n   value(fi)=qu(fi)\n\n!   write(6,*) 'fi = ',fi\n!   write(6,*) 'value(fi) = ',value(fi)\n\n   do i=fi+1,lt\n      value(i)=qu(i)-ru(i)*value(i-1)\n   end do\n\n!   write(6,*) 'value(lt) = ',value(lt)\n\n   return\nend subroutine tridiagonal\n"}
{"instruction": "Create a Fortran subroutine called cross_product to calculate the cross product of two 3D vectors. This subroutine takes 6 input parameters of type real(8) (x1, y1, z1, x2, y2, z2) and returns 3 output parameters of type real(8) (x3, y3, z3). Use the given formula to perform the cross product calculation.", "input": "", "output": "      subroutine cross_product(x1,y1,z1,x2,y2,z2,x3,y3,z3)\n      implicit real*8(a-h,o-z)\n      real(8),intent(in) :: x1,y1,z1,x2,y2,z2\n      real(8),intent(out) :: x3,y3,z3\n\n      x3=y1*z2-y2*z1\n      y3=x2*z1-x1*z2\n      z3=x1*y2-x2*y1\n\n      end subroutine cross_product\n"}
{"instruction": "Write a Fortran subroutine named handle_infoflag that takes 2 input parameters of type integer and character(*), and 1 optional output parameter of type integer. If the output parameter is provided, it will be assigned the value of the first input parameter. If the output parameter is not provided and the first input parameter is not equal to 0, the subroutine will display an error message including the second input parameter and the value of the first input parameter, and then stop.", "input": "", "output": "  subroutine handle_infoflag(info0, msg, info)\n    integer, intent(in) :: info0\n    character(*), intent(in) :: msg\n    integer, intent(out), optional :: info\n\n    if (present(info)) then\n      info = info0\n    elseif (info0 /= 0) then\n      write(*, \"(a)\") \"scalapack operation failed!\"\n      write(*, \"(a)\") msg\n      write(*, \"(a,i0)\") \"info: \", info0\n      stop\n    end if\n\n  end subroutine handle_infoflag\n"}
{"instruction": "Write a Fortran subroutine named decodedate to extract the year, month, and day from a date string. The number of input arguments is 1 and the test_data type is ['character(len=*)']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "input": "", "output": "    subroutine decodedate(sdate, iyear, imonth, iday)\n    \n        ! routine arguments\n        character(len=*), intent(in)    :: sdate\n        integer, intent(out)            :: iyear\n        integer, intent(out)            :: imonth\n        integer, intent(out)            :: iday\n        \n        ! locals\n        integer :: ilength\n        integer :: iretcode\n        \n        ! infer type of date from string length\n        ilength = len_trim(sdate)\n        select case(ilength)\n        case(8)\n            ! short-form date\n            read(sdate,\"(i2,1x,i2,1x,i2)\",iostat=iretcode) iday, imonth, iyear\n            if(iretcode == 0) then\n                if(iyear > 70) then\n                    iyear = iyear + 1900\n                else\n                    iyear = iyear + 2000\n                end if\n            else\n                iyear  = -9999\n                imonth = -9999\n                iday   = -9999\n            end if\n        case(10)\n            ! long-form date\n            read(sdate,\"(i2,1x,i2,1x,i4)\",iostat=iretcode) iday, imonth, iyear\n            if(iretcode /= 0) then\n                iyear  = -9999\n                imonth = -9999\n                iday   = -9999\n            end if\n        case default\n            iyear  = -9999\n            imonth = -9999\n            iday   = -9999\n        end select\n        \n    end subroutine decodedate\n"}
{"instruction": "Create a Fortran subroutine named \"vrinitial\" to calculate the initial value for the volume ratio (vr), along with the minimum and maximum values. The subroutine takes 4 input parameters of type real, real, integer, and integer. It returns 3 output parameters, all of type real. The subroutine adapts equations for volume and compressibility factor (z) based on the provided parameters, and calculates the initial, minimum, and maximum values for vr.", "input": "", "output": "  subroutine vrinitial(pr,tr,usedphase,simporref,vrinit,vrmin,vrmax)\n    implicit none\n    !     upodated apr 2007 to work up to critical point\n    !     see worksheet: c:\\twophase\\cott\\tplib\\adaptingvminmax.xls\n    !\n    !     calcualtes initial valuwe for vr\n    !     assume it is at evaporating pressure and uses adapted equations\n    !     for volume and z\n    !     find also minimum and maaximum values\n    !     for liquid pr(tr,vr) = z*tr/vr  have local minimum for vr = vrmax\n    !     for gas pr(tr,vr) have local maximum for vr = vrmin\n    !     the curves for vr and z is adapted in the area 0.3<tr<1\n    !     the curves for vrmax and vrmin is adapted in area 0.4 < tr < 1\n\n    real, intent(in)    :: pr, tr\n    integer, intent(in) :: usedphase, simporref\n    real, intent(out)   :: vrinit, vrmin, vrmax\n    real :: trnew, z, vr,  x\n\n    trnew = max(tr, 0.4)      !adapted curves down to tr = 0.4\n\n    if (trnew < 1 ) then\n      x = 1.0 - trnew\n      if (usedphase==1) then\n        vrmin = 0.05\n        if (simporref == 2) then\n          vr = (0.0507597 + 0.0203290*trnew - 0.0684645*trnew**2)      &\n                       /(1.0 - 0.9898632*trnew)\n          vrmax =  0.260004781 - 0.243586952*x**0.299442804 +     &\n                       x*(0.153866542 + x*(-0.24318588 + x*0.18830192))\n        else\n          vr = (0.0589257 + 0.0293946*trnew - 0.0852730*trnew**2)      &\n                        /(1 - 0.9895063*trnew)\n          vrmax = 0.29357705 - 0.52850447 * x**0.410968967        &\n                        + 0.77547108 * x**0.756622288 - 0.462790587*x &\n                        + 0.001906586 *x*x\n        endif\n        if (vr >= vrmax-0.001) then\n          vr = vrmax- 0.001\n        endif\n      else                   ! if gas\n        vrmax = 1e10\n        if (simporref == 2) then\n          z =  (0.9503235  - 0.5999993*trnew  - 0.3009715*trnew**2)  &\n                       /(1.0 - 0.8485730*trnew)\n          vrmin = 0.260004781 + 1.135875238 *x**0.536171251   &\n                       + 165.7526983 * x**8.546977142       &\n                       + x*x*(5.710834142+1.369944361*x+15.33422908*x*x)\n        else\n          z = (1.0352651  - 0.9144101*trnew  - 0.0706954 *trnew**2)  &\n                        /(1 - 0.8544288 *trnew)\n          vrmin = 0.29357705 + 0.93528691 *x**0.54719415   &\n                        + 41.00382077 *x**7.496078769      &\n                        + x*x*(2.479091038 + 3.90973725 *x)\n        endif               !assume z changes less than vr:\n        vr = trnew * z / pr\n        if (vr < vrmin + 0.01 )then\n          vr = vrmin + 0.01\n        endif\n      endif\n    else                      ! if trnew >= 1\n      vrmin = 0.05\n      vrmax = 1e10\n      if (usedphase==1) then\n        if (simporref == 2) then\n          vr = 0.2588817\n        else\n          vr = 0.2903920\n        endif\n      else\n        if (simporref == 2) then\n          z = 0.3259176\n        else\n          z = 0.3445706\n        endif\n        vr = trnew * z / pr\n      endif\n    endif\n    vrinit =  vr\n\n  end subroutine vrinitial\n"}
{"instruction": "Create a Fortran subroutine named calcdistances to calculate the distances between possible cities based on their latitude and longitude. The subroutine takes one input parameter of type real*8 and outputs one parameter of type real*8.", "input": "", "output": "subroutine calcdistances(places,distances)\n  ! calculates distances between all posible cities. we deal with a problem of minimal path, so we set the distance between city with itself as infinity (or very large). to calculate the distance from lattitude and longitude, we assume that the earth is a sphere (not elipsoid). then, we use the cosine rules for spherical trigonometry: https://en.wikipedia.org/wiki/spherical_trigonometry#cosine_rules_and_sine_rules\n  ! the angular distance ds between two points of lattitudes fi1 and fi2 and longitudes  difference deltalong is:\n  ! ds = arccos(sin(f1)sin(f2)+cos(fi1)cos(fi2)cos(deltalong)). then, the final distance between points is d=r*ds, where r is mean radius of the earth.\n  real*8,  intent(in)  :: places(:,:)\n  real*8,  intent(out) :: distances(:,:)\n  real*8,  parameter   :: r=6371.d0\n  integer :: genno, i, j\n  real*8  :: dlong, fi1, fi2, dist\n  genno = size(places,2)\n  distances = inf\n  do i=1,genno\n    do j=i+1,genno\n      dlong = dabs(places(2,i)-places(2,j))\n      fi1 = places(1,i)\n      fi2 = places(1,j)\n      dist = acos(sin(fi1)*sin(fi2) + cos(fi1)*cos(fi2)*cos(dlong))\n      distances(i,j) = dist*r\n      distances(j,i) = dist*r\n    end do!j\n  end do!i\n  ! todo check\nend subroutine calcdistances\n"}
{"instruction": "Create a Fortran subroutine named cart_sph to convert the position vector from Cartesian coordinates to spherical coordinates. The input parameter is a 2D array of real numbers with kind=8 and the output parameter is another 2D array of real numbers with kind=8.", "input": "", "output": "subroutine cart_sph(x,r)\n\t!----------------------------------------------------------\n\t! switching from cartesian to spherical coordinates\n\t! calling sequence: call cart_sph(x,r)\n\t! input:  x: position vector in cartesian coordinates\n\t! output: r: position vector in spherical coordinates \n\t!            (radial distance,azimuthal angle,polar angle)\t\t\t!\n\t!----------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: x\n\treal(kind=8), dimension(:,:), intent(out) :: r\n\n\tr(1,:) = sqrt(x(1,:)**2+x(2,:)**2+x(3,:)**2)\n\t\n\t!longitude\n\twhere (x(2,:) < 0.d0)\n\t\tr(2,:) = 2.d0*pi-acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\telsewhere  \n\t\tr(2,:) = acos(x(1,:)/sqrt(x(1,:)**2+x(2,:)**2)) \n\tend where\n\n\twhere (x(1,:) .eq. 0.d0 .and. x(2,:).eq. 0.d0)\n\t\tr(2,:) = pi/2.d0\n\tend where\n\t\n\t!colatitude\n\twhere (r(1,:) .ne. 0.d0)\n\t\tr(3,:) = pi/2.d0 - acos(x(3,:)/r(1,:))\n\telsewhere\n\t\tr(3,:) = pi/2.d0\n\tend where\n\nend subroutine cart_sph\n"}
{"instruction": "Create a Fortran subroutine named sph_cart_vect to convert a vector from spherical coordinates to cartesian coordinates. The subroutine takes 2 input arguments of type real(kind=8), dimension(:,:) for both 'r' and 'vr', and 1 output argument of type real(kind=8), dimension(:,:) for 'vx'.", "input": "", "output": "subroutine sph_cart_vect(vr,r,vx)\n\t!-------------------------------------------------------------------------------------\n\t! switching from spherical to cartesian coordinates for a vector at a point r\n\t! calling sequence: call sph_cart_vect(vr,r,vx)\n\t! input: vr : vector in spherical coordinates\n\t!\t     (radial distance,azimuthal angle,polar angle)\t\n\t!         r : position vector in spherical coordinates\n\t!\t     (radial distance,azimuthal angle,polar angle)\n\t! output: vx: vector in cartesian coordinates  (vx,vy,vz)\n\t!-------------------------------------------------------------------------------------\n\n\treal(kind=8), dimension(:,:), intent(in)  :: r,vr\n\treal(kind=8), dimension(:,:), intent(out) :: vx\n\t\n\tvx(1,:)=vr(1,:)*cos(r(2,:))*cos(r(3,:))-vr(2,:)*sin(r(2,:))-vr(3,:)*sin(r(3,:))*cos(r(2,:))\n\tvx(2,:)=vr(1,:)*sin(r(2,:))*cos(r(3,:))+vr(2,:)*cos(r(2,:))-vr(3,:)*sin(r(2,:))*sin(r(3,:))\n\tvx(3,:)=vr(1,:)*sin(r(3,:))+vr(3,:)*cos(r(3,:))\n\nend subroutine sph_cart_vect\n"}
{"instruction": "Write a Fortran subroutine named \"rot\" to perform the rotation of a given vector by a specified angle. The number of input arguments is 2, where the test_data type is ['real(kind=8), dimension(:,:)', 'real(kind=8), dimension(:)']. The number of output arguments is 1, with the test_data type being ['real(kind=8), dimension(:,:)'].", "input": "", "output": "subroutine rot(vin,theta,vout)\n\t!------------------------------------------------------\n\t! rotation of the vin vector by an angle theta\n\t! calling sequence: call rot(vin,theta,vout)\n\t! input:  vin: vector in cartesian coordinates\n\t!       theta: angle in degre\n\t!\t\t\t\t\n\t! output: vout: modified vector in cartesian coordinates.\n\t!------------------------------------------------------\n\treal(kind=8), dimension(:,:), intent(in)  :: vin\n\treal(kind=8), dimension(:), intent(in)    :: theta\n\treal(kind=8), dimension(:,:), intent(out) :: vout\n\treal(kind=8), dimension(3,3)\t\t\t  :: matrot\n\tinteger\t\t\t\t\t\t\t\t\t  :: i\n\t\n\twrite(*,*) theta\n\tdo i=1,size(theta)\n!\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) = -sin(theta(i)*pi/180.) ; matrot(1,3)=0.d0\n!\t\tmatrot(2,1) = sin(theta(i)*pi/180.) ; matrot(2,2) = cos(theta(i)*pi/180.)  ; matrot(2,3)=0.d0\n!\t\tmatrot(3,1) = 0.d0\t\t \t\t    ; matrot(3,2) = 0.d0\t\t\t\t   ; matrot(3,3)=1.d0\n\n\t\tmatrot(1,1) = cos(theta(i)*pi/180.) ; matrot(1,2) =  0.d0\t\t; matrot(1,3)=-sin(theta(i)*pi/180.)\n\t\tmatrot(2,1) = 0.d0\t\t\t\t    ; matrot(2,2) =  1.d0\t\t; matrot(2,3)=0.d0\n\t\tmatrot(3,1) = sin(theta(i)*pi/180.) ; matrot(3,2) = 0.d0\t\t; matrot(3,3)=cos(theta(i)*pi/180.) \n\n\t\tvout(:,i) = matmul(matrot,vin(:,i)) \n\n\tenddo\n\nend subroutine rot\n"}
{"instruction": "Write a Fortran subroutine named isoha14 to calculate the yield stress and the strain hardening exponent based on the given isotropic hardening type and material parameters. The subroutine takes 6 input parameters of type integer(kind=4) and real(kind=8), and returns 2 output parameters of type real(kind=8). The subroutine uses a select case statement to determine the isotropic hardening type and computes the yield stress and the strain hardening exponent accordingly. Use the keyword \"subroutine\" and other Fortran-specific terms in the instruction.", "input": "", "output": " subroutine isoha14(isohd,yield,aprim,eps,c0,c1,c2,c3)\r\n implicit none\r\n\r\n integer(kind=4),intent(in) :: isohd\r\n real(kind=8),intent(in):: c0, c1, c2, c3, eps\r\n real(kind=8),intent(out):: yield,aprim\r\n !local variables\r\n! integer (kind=4) :: i\r\n real(kind=8),parameter:: tol=1d-10\r\n\r\n select case (isohd)\r\n ! c0    = props(1)     !c0 constant or initial yield\r\n ! c1    = props(2)     !efref or hardening constant\r\n ! c2    = props(3)     !exponent\r\n ! c3    = props(4)     !residual flow stress\r\n case(1)   !no hardening\r\n     yield = c0\r\n     aprim = 0d0\r\n\r\n case(2,5)   !linear law (include defined by points)\r\n     yield = c0 + c1*eps\r\n     aprim = c1\r\n\r\n case(3)   !ludwik-nadai law\r\n     yield = c0*(c1 + eps)**c2\r\n     aprim = c0*c2*(c1 + eps)**(c2-1d0)\r\n\r\n case(4)   !exponential + saturation\r\n     yield = c0 + c1*eps+(c3-c0)*(1d0-1d0/exp(c2*eps))\r\n     aprim = c1 + (c3-c0)*c2/exp(c2*eps)               !derivative\r\n\r\n case(6)   !hollomon law\r\n     yield = c0*(eps + tol)**c2\r\n     aprim = c0*c2*(eps + tol)**(c2-1d0)\r\n\r\n case(7)   !voce law\r\n     yield = c0 + c1*(1d0 - exp(-c2*eps))\r\n     aprim = c1*c2*exp(-c2*eps)\r\n\r\n end select\r\n\r\n return\r\n end subroutine isoha14\r\n"}
{"instruction": "Create a Fortran subroutine named solvsmbe to solve a 2x2 matrix equation. The subroutine takes 6 input parameters of type real (sma11, sma22, sma1, sma2, smb11, smb22) and provides 2 output parameters of type real (smv1, smv2). Ensure to handle a singular matrix by checking the determinant, and calculate the solution using the provided input parameters.", "input": "", "output": "subroutine solvsmbe(smv1,smv2,sma11,sma22,sma1,sma2,smb11,smb22)  \n  \n  ! solve 2x2 matrix  \n  !----------------------------------------------------------------------!  \n  ! change record  \n  ! date modified     by               description\n  !----------------------------------------------------------------------!\n  ! 2013-03           paul m. craig    restructed to f90, updated variables for omp\n  \n  implicit none\n\n  real, intent(in)  :: sma11, sma22, sma1, sma2, smb11, smb22\n  real, intent(out) :: smv1, smv2\n  real :: sma12, sma21, smdet\n\n  sma12 = -sma2  \n  sma21 = -sma1  \n  smdet = sma11*sma22 - sma12*sma21  \n  if( smdet == 0.0 )then  \n    print*, 'singular matrix: a11, a12, a21, a22, b11, b22'  \n    print*, sma11,sma12,sma21,sma22,smb11,smb22  \n    stop  \n  endif  \n  smdet = 1.0 / smdet  \n  smv1 = (smb11*sma22 - smb22*sma12) * smdet  \n  smv2 = (smb22*sma11 - smb11*sma21) * smdet  \n\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named eos that computes the density of a substance based on the inputs ec, t, s, z, and ieos. The number of input arguments is 5 and the test_data type is [real, real, real, real, integer]. The number of output arguments is 1 and the test_data type is [real].", "input": "", "output": "  subroutine eos(ec, t, s, z, ieos, rho)\n    implicit none\n    real, intent(in) :: ec(5), t, s, z\n    integer, intent(in) :: ieos\n    real, intent(out) :: rho\n\n    if (ieos == 0) then\n       ! no thermobaricity term\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3\n    elseif (ieos == 1) then\n       ! thermobaricity term is in\n       rho = ec(1) * t + ec(2) * s + ec(3) * t**2 + ec(4) * t**3 + ec(5) * t * z\n    end if\n  end subroutine eos\n"}
{"instruction": "Create a Fortran subroutine named errora_endur to calculate the relative error between two matrices y and y0, including all elements. The subroutine takes 4 input parameters of types integer, integer, real(8), and real(8), and 2 output parameters of type real(8), real(8).", "input": "", "output": "subroutine errora_endur(y,y0,n,m,aerror,merror) bind(c)\n! \u8ba1\u7b97\u77e9\u9635y\u548cy0\u7684\u76f8\u5bf9\u8bef\u5dee\uff08\u5305\u62ec\u6240\u6709\u5143\u7d20\uff09\uff0caerror \u4e3a\u5e73\u5747\u8bef\u5dee\uff0cmerror \u4e3a\u6700\u5927\u8bef\u5dee\n    integer, intent(in) :: n, m\n    real(8), intent(in) :: y(n,m), y0(n,m)\n    real(8), intent(out) :: aerror, merror\n\n    real(8) :: eij\n\n    integer :: i,j\n\n    aerror = 0.d0\n    merror = 0.d0\n    do i = 1, n, 1\n        do j = 1, m, 1\n            eij = (y(i,j) - y0(i,j))/y0(i,j)\n            !aerror = aerror + abs(eij)\n            aerror = aerror + eij*eij\n            if ( merror < abs(eij) ) merror = abs(eij)\n        end do\n    end do\n\n    aerror = aerror/dble(n*m)\n\nend subroutine errora_endur\n"}
{"instruction": "Create a Fortran subroutine named \"maketanmesh\" that generates a mesh based on tangent functions. The subroutine takes 5 input parameters: 2*n real*8 values (output array), an integer n, and 4 real*8 values tanc, tanw, b0, and b1. The subroutine produces a single real*8 output.", "input": "", "output": "subroutine maketanmesh(x, n, tanc, tanw, b0, b1)\n  implicit none\n  real*8, intent(out) :: x(2*n)\n  integer, intent(in) :: n\n  real*8, intent(in)  :: tanc, tanw, b0, b1\n  ! locals\n  integer :: i\n  real*8 :: du, b1n, m0\n  if (.not.(b0<b1)) print *,  \"relation must hold: b0<b1!\"\n  if (.not.(b0<tanw .and. tanw<b1)) print *, \"relation mesu hold: b0<tanw<b1!\"\n  if (.not.(b0>0))  print *, \"b0 must be positive!\"\n  du = atan(((tanc-b0)/tanw))\n  b1n = atan((b1-tanc)/tanw)+du\n  !m0 = [tanc + tanw * tan(b1n*(i-1)/(n-2)-du) for i in range(1,n)]\n  do i=1,n\n     m0 = tanc + tanw * tan(b1n*(i-1)/(n-1)-du)\n     x(n+i) = m0\n     x(n-(i-1)) = -m0\n  end do\nend subroutine maketanmesh\n"}
{"instruction": "Create a Fortran subroutine named bfgs_fstatus to calculate the maximum value and root mean square of an array of double precision numbers. The subroutine takes 2 input parameters: an integer n and an array of double precision numbers. It returns 2 output parameters: double precision values representing the maximum value and the root mean square of the input array. Use the imperative tone to define the subroutine and its parameters.", "input": "", "output": "  subroutine bfgs_fstatus(n, f, f_max, f_rms)\n    \n    implicit none\n\n    integer,                        intent(in)  :: n\n    double precision, dimension(n), intent(in)  :: f\n    double precision,               intent(out) :: f_max\n    double precision,               intent(out) :: f_rms\n\n    integer          :: i\n\n    f_max = 0.0d0\n    f_rms = 0.0d0\n    do i = 1, n\n       if (abs(f(i)) > abs(f_max)) f_max = f(i)\n       f_rms = f_rms + f(i)*f(i)\n    end do\n    f_rms = sqrt(f_rms)\n\n  end subroutine bfgs_fstatus\n"}
{"instruction": "Write a Fortran subroutine named parsedt that takes a character string as input and outputs four integers. The input parameter is of type character(len=*), and the output parameters are of type integer.", "input": "", "output": "subroutine parsedt(dt,dday,dh,dn,ds)\ncharacter(len=*), intent(in)  :: dt\ninteger,          intent(out) :: dday\ninteger,          intent(out) :: dh\ninteger,          intent(out) :: dn\ninteger,          intent(out) :: ds\n\ncharacter(len=1 ) :: ch\ninteger :: n,i,d,s,nounit\n\n! initialize time and sign\nnounit=1\ndday=0\ndh=0\ndn=0\nds=0\nd=0\ns=1\n\ndo n = 1, len_trim(dt)\n   ch = dt(n:n)\n   select case (ch)\n      case ('0':'9')\n        read(ch,fmt='(i1)') i\n        d=d*10+i\n      case ('-')\n        s=-1\n      case ('+')\n        s=1\n      case ('d')\n        nounit=0\n        dday=dday+d*s\n        d=0\n      case ('h')\n        nounit=0\n        dh=dh+d*s\n        d=0\n      case ('n','m')\n        nounit=0\n        dn=dn+d*s\n        d=0\n      case ('s')\n        nounit=0\n        ds=ds+d*s\n        d=0\n      case default\n        continue\n   end select\nend do\n\nif (nounit==1) dh=d*s\n\nend subroutine parsedt\n"}
{"instruction": "Create a Fortran subroutine named set_child_name to modify the names of child entities based on the names of parent entities. The subroutine takes 1 input argument of type character(*) and provides 1 output argument of type character(*).", "input": "", "output": "  subroutine set_child_name(parentname,childname)\n    !\n    character(*),intent(in) :: parentname\n    character(*),intent(out) :: childname\n    character(2) :: prefix\n    integer :: pos\n    !   \n    pos  = index(trim(parentname),'/',back=.true.)\n    !\n    prefix=parentname(pos+1:pos+2)\n    if (prefix == '1_') then\n       childname = '2_'//parentname(pos+3:len(parentname)) \n    elseif (prefix == '2_') then\n       childname = '3_'//parentname(pos+3:len(parentname)) \n    elseif (prefix == '3_') then\n       childname = '4_'//parentname(pos+3:len(parentname)) \n    elseif (prefix == '4_') then\n       childname = '5_'//parentname(pos+3:len(parentname)) \n    else\n       childname = '1_'//parentname(pos+1:len(parentname)) \n    endif\n    !   \n  end subroutine set_child_name\n"}
{"instruction": "Provide a Fortran subroutine named setup_sto3g_ to initialize the basis set parameters for different atomic orbital types. The number of input arguments is 1 with the test_data type ['character(*)'], and the number of output arguments is 3 with the test_data type ['integer', 'real(8)', 'real(8)'].", "input": "", "output": "        subroutine setup_sto3g_(key,lp,ex,cf)\n          implicit none\n          integer,parameter::nc=3\n          character(*),intent(in)::key\n          integer,intent(out)::lp(nc)\n          real(8),intent(out)::ex(nc),cf(nc)\n          lp(:)=(/0,0,0/)\n          if (key=='hs') then\n            ex(:)=(/3.4252509d0,0.6239137d0,0.1688554d0/)\n            cf(:)=(/0.154328967295d0,0.535328142282d0,0.444634542185d0/)\n          else if (key=='cs') then\n            ex(:)=(/2.9412494d0,0.6834831d0,0.2222899d0/)\n            cf(:)=(/-0.099967229187d0,0.399512826089d0,0.70011546888d0/)\n          else if (key(1:2)=='cp') then\n            ex(:)=(/2.9412494d0,0.6834831d0,0.2222899d0/)\n            cf(:)=(/0.155916274999d0,0.607683718598d0,0.391957393099d0/)\n          else if (key(1:2)=='pp') then\n            ex(:)=(/1.4618890d0,0.4078633d0,0.1596349d0/)\n            cf(:)=(/0.010587604289d0,0.595167005266d0,0.462001011973d0/)\n          else if (key(1:2)=='pd') then\n            ex(:)=(/0.55d0,1d0,1d0/)\n            cf(:)=(/1d0,0d0,0d0/)\n          else\n            write(*,'(\"error: no such key: \",a)') key\n            stop 1\n          end if\n          if (key(2:2)=='p') then\n            if (key(3:3)=='x') lp(1)=1\n            if (key(3:3)=='y') lp(2)=1\n            if (key(3:3)=='z') lp(3)=1\n          end if\n          if (key(2:2)=='d') then\n            if (key(3:3)=='x') lp(1)=1\n            if (key(3:3)=='y') lp(2)=1\n            if (key(3:3)=='z') lp(3)=1\n            if (key(4:4)=='x') lp(1)=lp(1)+1\n            if (key(4:4)=='y') lp(2)=lp(2)+1\n            if (key(4:4)=='z') lp(3)=lp(3)+1\n          end if\n        end subroutine\n"}
{"instruction": "Write a Fortran subroutine named comp_poly_and_dpoly to compute the polynomial p(x) and its derivative dp(x)/dx based on given coefficients and input value. The subroutine takes 3 input parameters of type integer, real(16), and real(16), and 2 output parameters of type real(16). The input values are n (degree of polynomial), bet (array of coefficients), and x (input value). The subroutine computes the polynomial p(x) and its derivative dp(x)/dx and stores them in the output arrays p and b, respectively.", "input": "", "output": "  subroutine comp_poly_and_dpoly(n,bet,x,p,b)\n    integer,intent(in) :: n\n    real(16),intent(in) :: bet(n-1), x\n    real(16),intent(out) :: p(0:n), b(0:n,0:n)\n\n    integer :: i, j\n    p(0)=1.q0\n    p(1)=x\n    do i=2,n\n       p(i)=x*p(i-1)-bet(i-1)*p(i-2)\n    end do\n\n    b(:,:)=0.q0\n    do j=1,n-1\n       b(j+1,j)=-p(j-1)\n    end do\n    do j=0,n\n       do i=j+2,n\n          b(i,j)=x*b(i-1,j)-bet(i-1)*b(i-2,j)\n       end do\n    end do\n    \n  end subroutine comp_poly_and_dpoly\n"}
{"instruction": "Create a Fortran subroutine named spline to compute the second derivatives of a given set of data points for use in cubic spline interpolation. The subroutine takes 5 input parameters of types integer, real, real, real array of size n, and real array of size n. It outputs 1 parameter of type real array of size n.", "input": "", "output": "  subroutine spline(x,y,n,yp1,ypn,y2)\n    implicit none\n    integer, intent(in) :: n\n    real, intent(in) :: yp1,ypn\n    real, dimension(n), intent(in) :: x,y\n    real, dimension(n), intent(out) :: y2\n    integer, parameter :: nmax=1500\n    integer :: i,k\n    real :: p,qn,sig,un\n    real, dimension(nmax) :: u\n    if (yp1>.99e30) then\n       y2(1)=0.\n       u(1)=0.\n    else\n       y2(1)=-0.5\n       u(1)=(3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)\n    endif\n    do i=2,n-1\n       sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))\n       p=sig*y2(i-1)+2.\n       y2(i)=(sig-1.)/p\n       u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-x(i-1))) &\n            /(x(i+1)-x(i-1))-sig*u(i-1))/p\n    enddo\n    if (ypn>.99e30) then\n       qn=0.\n       un=0.\n    else\n       qn=0.5\n       un=(3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))\n    endif\n    y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)\n    do k=n-1,1,-1\n       y2(k)=y2(k)*y2(k+1)+u(k)\n    enddo\n    \n  end subroutine spline\n"}
{"instruction": "Create a Fortran subroutine named p850_to_msl to convert pressure at 850 hPa to mean sea level (MSL) pressure. The subroutine takes 5 input parameters of type integer, integer, integer, double precision, and double precision, representing lon, lat, time, zg_array, and ta_array respectively. It also has 1 output parameter of type double precision, representing output_array. The subroutine performs calculations using the input parameters to populate the output_array with MSL pressure values.", "input": "", "output": "subroutine p850_to_msl(lon,lat,time,zg_array,ta_array,output_array)\n\timplicit none\n\tinteger, intent(in) :: lon,lat,time\n\tinteger :: x,y,t\n\tdouble precision, intent(in) :: zg_array(lon,lat,time),ta_array(lon,lat,time)\n\tdouble precision, intent(out) :: output_array(lon,lat,time)\n\tdo 20,t=1,time \n\t  do 10, x=1,lon\n\t   do 5, y=1,lat\n\t   output_array(x,y,t) = 85000*(1 - ((0.0065* zg_array(x,y,t))&\n\t\t\t\t/(ta_array(x,y,t)+(0.0065* zg_array(x,y,t)))))** (-5.257)\n\n5          end do \n10         end do \t\n20\tend do  \n\tend subroutine p850_to_msl\n"}
{"instruction": "Create a Fortran subroutine named sample_chem to simulate the local copper and nickel content in a welding process. The subroutine takes 4 input parameters of type real (cu_ave, ni_ave, cu_sig, ni_sig) and provides 2 output parameters of type real (cu_local, ni_local).", "input": "", "output": "    subroutine sample_chem(cu_ave, ni_ave, cu_sig, ni_sig, cu_local, ni_local)\n\n        !variables\n        real, intent(in) :: cu_ave, ni_ave, cu_sig, ni_sig\n        real, intent(out) :: cu_local, ni_local\n        real :: u, cu_bar, cu_sig_star, cu_sig_local\n\n        !sample local copper content based on weld copper sampling procedure\n        cu_bar = cu_ave * cu_sig\n        cu_sig_star = min(0.0718*cu_ave, 0.0185)\n        call random_number(u)\n        cu_sig_local = cu_bar + cu_sig_star*sqrt(2.0)*erfc(2*u-1)\n        call random_number(u)\n        cu_local = cu_ave + cu_sig_local*sqrt(2.0)*erfc(2*u-1)\n\n        !sample local nickel content based on weld nickel heat 34b009 & w5214 procedure\n        call random_number(u)\n        ni_local = ni_ave + ni_sig*sqrt(2.0)*erfc(2*u-1)\n\n    end subroutine sample_chem\n"}
{"instruction": "Write a Fortran subroutine named intplt3d to calculate interpolation coefficients and indices of a given location from a 3D grid in space. The subroutine takes 4 input parameters of types integer, real, real, and real, and 3 output parameters of types integer, integer, and real.", "input": "", "output": "subroutine intplt3d(pstn,ngrd,gspc,domn,indx,coef,ierr)\n\n!==========================================================\n!  this routine returns interpolation coefficients and\n!  indices of a given location from a grid in 3d space.\n!\n!  history:\n!\tcreation: 9-2005 by yuanfu xie.\n!==========================================================\n\n  implicit none\n\n  integer, intent(in) :: ngrd(3)\t! numbers gridpoint\n  real,    intent(in) :: pstn(3)\t! interpolate point\n  real,    intent(in) :: gspc(3)\t! grid spacing\n  real,    intent(in) :: domn(2,3)\t! domain\n\n  integer, intent(out) :: indx(6)\t! indices\n  integer, intent(out) :: ierr\t\t! error flag\n  real,    intent(out) :: coef(6)\t! coefficients\n\n  ! local variables:\n  integer :: i\n\n  ierr = 0\n  ! check if it is in box?\n  do i=1,3\n     if (pstn(i) .lt. domn(1,i)) ierr = -i\n     if (pstn(i) .gt. domn(2,i)) ierr = i\n  enddo\n\n  ! indices:\n  indx(1:3) = (pstn-domn(1,1:3))/gspc\n\n  ! coefficients:\n  coef(1:3) = (pstn-indx(1:3)*gspc-domn(1,1:3))/gspc\n\n  indx(1:3) = indx(1:3)+1\n\n  indx(4:6) = min(indx(1:3)+1,ngrd)\n  coef(4:6) = coef(1:3)\n  coef(1:3) = 1.0-coef(4:6)\n\nend subroutine intplt3d\n"}
{"instruction": "Create a Fortran subroutine called \"def_pde\" that takes 9 input parameters and 1 output parameter. The input parameters consist of 7 real numbers of kind 8 (real(kind=8)), 1 integer array of any dimension (integer, dimension(*)), and 1 real array of any dimension (real(kind=8), dimension(*)). The output parameter is a real number of kind 8 (real(kind=8)).\n\nThe purpose of this subroutine is to compute the value of \"g\" based on the values of the input parameters \"u\", \"ux\", \"uxx\", \"uxxx\", \"uxxxx\", \"uxxxxx\", \"uxxxxxx\", \"rpar\", and \"ipar\". The subroutine performs calculations using these input parameters and assigns the computed value to the output parameter \"g\".\n\nTo compute \"g\", the subroutine extracts the regularizing parameter \"p\" from the \"rpar\" array and assigns it to a local variable \"p\". It also assigns a value of 1.0E-3 to the local variable \"delta\". The subroutine then checks the value of the integer variable \"cons\" from the \"ipar\" array.\n\nIf \"cons\" is equal to 0, the subroutine calculates \"g\" using the formula: g = ux*uxxxxx + u*uxxxxxx - 30*(u**4.0d0)*(ux**2.0d0) - 6*(u**5.0d0)*uxx.\n\nIf \"cons\" is equal to 1, the subroutine calculates \"g\" using the formula: g = u*uxxxxx - 6.0d0*(u**5.0d0)*ux.\n\nMake sure to include the necessary \"implicit none\" statement at the beginning of the subroutine to require explicit declaration of variables.", "input": "", "output": "  subroutine def_pde(g,u,ux,uxx,uxxx,uxxxx,uxxxxx,uxxxxxx,rpar,ipar)\n    implicit none\n    real(kind=8), intent(out) :: g\n    real(kind=8), intent(in) :: u, ux, uxx, uxxx, uxxxx, uxxxxx, uxxxxxx\n    integer, dimension(*), intent(in) :: ipar\n    real(kind=8), dimension(*), intent(in) :: rpar\n    real(kind=8) :: p, delta\n    integer :: cons\n\n    p = rpar(1)\n    delta = 1.0d-3 ! regularizing parameter\n    cons = ipar(7)\n\n    if (cons == 0) then\n       g = ux*uxxxxx + u*uxxxxxx - 30*(u**4.0d0)*(ux**2.0d0) - 6*(u**5.0d0)*uxx\n    elseif (cons == 1) then\n       g = u*uxxxxx - 6.0d0*(u**5.0d0)*ux\n    endif\n  end subroutine def_pde\n"}
{"instruction": "Write a Fortran subroutine named def_monitor that calculates a monitor function value based on the input parameters. The subroutine takes 6 input parameters: x (real kind=8), u (real kind=8), ux (real kind=8), uxx (real kind=8), ipar (integer, dimension(*)), and rpar (real(kind=8), dimension(*)). It also has 1 output parameter: m (real kind=8).\n\nIn the subroutine, assign the value of rpar(1) to the variable p. Calculate the monitor function value, m, using the formula: m = u**7.0d0 + abs((x**2.0d0)*uxx)**7.0d0.\n\nEnsure that the \"implicit none\" statement is included at the beginning of the subroutine to enforce explicit variable declaration.", "input": "", "output": "  subroutine def_monitor(m,x,u,ux,uxx,rpar,ipar)\n    implicit none\n    real(kind=8), intent(out) :: m\n    real(kind=8), intent(in) :: x, u, ux, uxx\n    integer, dimension(*), intent(in) :: ipar\n    real(kind=8), dimension(*), intent(in) :: rpar\n    real(kind=8) :: p, nu, delta\n\n    p = rpar(1)\n    m = u**7.0d0 + abs((x**2.0d0)*uxx)**7.0d0\n  end subroutine def_monitor\n"}
{"instruction": "Create a Fortran subroutine named \"in1_ord11\" to calculate the first inner product of two arrays. The subroutine takes 3 input parameters: an integer \"idm\", and two real(8) arrays \"t1f_a\" and \"t1f_b\" both of size \"idm\". It returns 1 output parameter of type real(8) \"res\".", "input": "", "output": "      subroutine in1_ord11 (res, t1f_a, t1f_b, idm)\n      ! returns the first inner product of a and b\n      ! res = a_i * b_i\n      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         implicit none\n         integer, intent(in)  :: idm\n         real(8), intent(out) :: res\n         real(8), intent(in)  :: t1f_a (idm)\n         real(8), intent(in)  :: t1f_b (idm)\n      \n         !### var ###!\n         integer  :: ii\n         \n         !### code ###!\n         res = 0.0d0\n         do ii = 1,idm\n            res = res + t1f_a(ii) * t1f_b(ii)\n         enddo\n      \n      end subroutine\n"}
{"instruction": "Write a Fortran subroutine named compute_gravity that calculates the gravitational force at different heights. The subroutine takes 4 input parameters: an integer nz, an array of real(8) z, a real(8) r0, and a real(8) grav_surf. It also has 1 output parameter of type real(8) named grav_z.", "input": "", "output": "  subroutine compute_gravity(nz,z,r0,grav_surf,grav_z)\n    implicit none\n    integer, intent(in) :: nz\n    real(8), intent(in) :: z(nz), r0, grav_surf\n    real(8), intent(out) :: grav_z(nz)\n    integer :: i\n    \n    do i = 1,nz\n      grav_z(i) = grav_surf*r0**2.d0/(r0 + z(i))**2.d0\n    enddo\n    \n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named dcomputetd that calculates the dew point temperature from pressure and specific humidity. The subroutine takes 3 input parameters of types integer, real(kind=8) array of size nx, and real(kind=8) array of size nx, and returns 1 output parameter of type real(kind=8) array of size nx.", "input": "", "output": "subroutine dcomputetd(td, pressure, qv_in, nx)\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: td\n\n    integer, intent(in) :: nx\n    real(kind=8), dimension(nx), intent(in) :: pressure\n    real(kind=8), dimension(nx), intent(in) :: qv_in\n    real(kind=8), dimension(nx), intent(out) :: td\n\n! nclend\n\n    real(kind=8) :: qv,tdc\n\n    integer :: i\n\n    !$omp parallel do private(i,qv,tdc) schedule(runtime)\n    do i = 1,nx\n        qv = max(qv_in(i), 0.d0)\n         ! vapor pressure\n         tdc = qv*pressure(i)/(.622d0 + qv)\n\n         ! avoid problems near zero\n         tdc = max(tdc, 0.001d0)\n         td(i) = (243.5d0*log(tdc) - 440.8d0)/(19.48d0 - log(tdc))\n    end do\n    !$omp end parallel do\n\n    return\n\nend subroutine dcomputetd\n"}
{"instruction": "Create a Fortran subroutine named get_field to extract the nth whitespace-separated block from a given string. The subroutine takes 3 input parameters of type integer, character(len=*), and optional character(len=1), and returns 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine get_field(n, field, str, sep)\n    !--------------------------------------------------------------------------\n    ! extract whitespace-separated nth block from string\n    implicit none\n    integer,intent(in) :: n\n    character(len=*),intent(out) :: field\n    character(len=*),intent(in)  :: str\n    character(len=1),optional,intent(in) :: sep\n    integer :: i,j,z ! block start and end\n    integer :: k     ! block counter\n    character(len=1) :: sep1, sep2\n    !print*, \"------------- parser start -------------\"\n    !print '(3a)', \"string: -->\", str,\"<--\"\n    if(present(sep)) then\n      sep1 = sep\n      sep2 = sep ! redundant, but easy\n    else\n      sep1 = char(32)  ! ... blank character\n      sep2 = char(9)   ! ... tab char\n    endif\n    !\n    k = 1 ! counter for the required block\n    !\n    do i = 1,len(str)\n    ! look for the beginning of the required block\n      z = max(i-1,1)\n      !print '(2a1,3i4,2l)', str(i:i), str(z:z), i,z,k,n,&\n      !       (str(i:i) == sep1 .or. str(i:i) == sep2), (str(z:z) /= sep1 .and. str(z:z) /= sep2)\n      if( k == n) exit\n      if( (str(i:i) == sep1 .or. str(i:i) == sep2) &\n           .and. &\n          (str(z:z) /= sep1 .and. str(z:z) /= sep2) &\n        ) &\n        k = k+1\n    enddo\n    !\n    !print*, \"i found: \",i\n    do j = i,len(str)\n    ! look for the beginning of the next block\n      z = max(j-1,1)\n      if( (str(j:j) == sep1 .or. str(j:j) == sep2) &\n           .and. &\n          (str(z:z) /= sep1 .and. str(z:z) /= sep2) &\n        ) &\n        k = k+1\n      if( k >n) exit\n    enddo\n    !print*, \"j found: \",j\n    !\n    if (j <= len(str)) then\n      ! if we are here, the reqired block was followed by a separator\n      ! and another field, we have to trash one char (a separator)\n      field = trim(adjustl(str(i:j-1)))\n      !print*, \"taking: \",i,j-2\n    else\n      ! if we are here, it was the last block in str, we have to take\n      ! all the remaining chars\n      field = trim(adjustl(str(i:len(str))))\n      !print*, \"taking from \",i\n    endif\n    !print*, \"------------- parser end -------------\"\n\n  end subroutine get_field\n"}
{"instruction": "Create a Fortran subroutine named initialize_two_body to initialize the distance, scaling, and counts arrays based on the input coordinates, charges, distance matrix, maximum ID, and power. The subroutine takes 5 input parameters of types double precision, dimension(:,:), integer, dimension(:), double precision, dimension(:,:), integer, and double precision, and returns 3 output parameters of types double precision, dimension(:,:), double precision, dimension(:,:), and integer, dimension(:).", "input": "", "output": "subroutine initialize_two_body(coords, charges, dmat, distance, scaling, counts, max_id, power)\n\n    implicit none\n    \n    double precision, dimension(:,:), intent(in) :: coords\n    integer, dimension(:), intent(in) :: charges \n    double precision, dimension(:,:), intent(in) :: dmat\n\n    double precision, dimension(:,:), intent(out) :: distance\n    double precision, dimension(:,:), intent(out) :: scaling\n    integer, dimension(:), intent(out) :: counts\n    \n    integer, intent(in) :: max_id\n    double precision, intent(in) :: power\n\n    integer :: i, j, n, key\n    integer :: qi, qj\n    \n    n = size(charges)\n    ! max_id = maxval(charges)\n\n    distance = 0.0d0\n    scaling  = 0.0d0\n    counts   = 0\n\n\n    do i = 1, n\n        do j = i+1, n\n\n            qi = charges(i)\n            qj = charges(j)\n            key = (min(qi, qj) - 1)*max_id + max(qi, qj)\n\n            ! write (*,*) min(qi, qj), max(qi, qj), key, size(counts), size(distance, dim=1), size(distance, dim=2)\n\n            counts(key) = counts(key) + 1\n            ! write (*,*) key, counts(key), dmat(i,j)\n            \n            distance(key,counts(key)) = dmat(i,j)\n            scaling(key,counts(key)) = dmat(i,j)**(-power)\n\n\n        enddo\n    enddo       \n   \n    ! write (*,*) counts \n\n    ! stop\nend subroutine initialize_two_body\n"}
{"instruction": "Create a Fortran subroutine named matrix_bits that performs matrix multiplication and transposition. It takes 3 input parameters of types integer, real 2D array, and real 2D array. It also has 2 output parameters of types real 2D array and real 2D array. The subroutine calculates the matrix product of the input arrays and stores the result in the first output array. Additionally, it computes the transpose of the first input array and stores the result in the second output array.", "input": "", "output": "    subroutine matrix_bits(a, b, c, a_t, n)\n        implicit none\n\n        integer, intent(in) :: n\n        real, dimension(:,:), intent(in) :: a, b\n        real, dimension(:,:), intent(out) :: c, a_t\n        integer :: i, j, k\n\n        do i = 1, n\n            do j = 1, n\n                c(i,j) = 0.\n                do k = 1, n\n                    c(i,j) = c(i,j)+a(i,k)*b(k,j)\n                end do\n            end do\n        end do\n\n        do i = 1, n\n            do j = 1, n\n                a_t(i,j) = a(j,i)\n            end do\n        end do\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named ranvar3 that calculates the variance of an ensemble of real(8) numbers. The subroutine takes 4 input parameters of type integer, integer, real(8) array, and real(8) array, and 1 output parameter of type real(8).", "input": "", "output": "subroutine ranvar3(ens,ave,var,n_var,n_ens)\r\n! return ensemble variance vector\r\n!\r\n  implicit none\r\n  integer             :: j\r\n  integer,intent(in)  :: n_var,n_ens\r\n  real(8),intent(in)  :: ens(n_var,n_ens)\r\n  real(8),intent(in)  :: ave(n_var)\r\n  real(8),intent(out) :: var(n_var)\r\n!\r\n  var(:)=0.d0\r\n  do j=1,n_ens\r\n    var(:)=var(:)+(ens(:,j)-ave(:))*(ens(:,j)-ave(:))\r\n  enddo\r\n  var(:)=var(:)/dble(n_ens-1)\r\n!\r\nend subroutine ranvar3\r\n"}
{"instruction": "Create a Fortran subroutine named get_location_id_and_quantity_id to calculate the location ID and quantity ID based on the exchange item ID. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer.", "input": "", "output": "subroutine get_location_id_and_quantity_id(exchange_item_id, location_id,quantity_id)\n    !arguments\n    integer, intent(in) :: exchange_item_id\n    integer, intent(out) :: location_id, quantity_id\n\n    integer :: eid2\n\n    eid2 = exchange_item_id\n    if (exchange_item_id.ge. 10000) eid2 = exchange_item_id - 10000  ! providing\n    location_id  = eid2 / 100\n    quantity_id = mod(eid2, 100)\n\nend subroutine get_location_id_and_quantity_id\n"}
{"instruction": "Write a Fortran subroutine named order that takes 4 input parameters of type integer, integer, integer, and real, and 1 output parameter of type real. The subroutine copies elements from the source array (src) to the destination array (dst) based on the indices provided in the ndx array.", "input": "", "output": "   subroutine order( ns, src, nd, dst, ndx )\n\n   integer, intent(in) :: ns, nd\n   integer, intent(in) :: ndx(nd)\n   real,    intent(in) :: src(ns)\n   real,    intent(out) :: dst(nd)\n\n   dst(:) = src(ndx(:))\n\n   end subroutine order\n"}
{"instruction": "Create a Fortran subroutine named compute_profile to calculate the result based on the provided parameters. The subroutine takes 4 input parameters of type real(8), real(8), real(8) array, and integer. It also has 1 output parameter of type real(8) array. The subroutine uses the input parameters to perform a mathematical operation and store the result in the output parameter.", "input": "", "output": "    subroutine compute_profile(a_param, damping_param, pressure, nlayers, result)\n        real(8), intent(in) :: a_param\n        real(8), intent(in) :: damping_param\n        real(8), intent(in) :: pressure(nlayers)\n        integer, intent(in) :: nlayers\n        real(8), intent(out) :: result(nlayers)\n\n        result = a_param*exp(damping_param*log10(pressure))\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named define_connect_enr to construct a nodal connectivity matrix. It takes 5 input arguments of type integer (emin, emax, p, nenr, nb) and 1 output argument of type integer array (ibenr). The subroutine uses imperative tone to initialize and populate the ibenr array based on the input parameters and loop indices.", "input": "", "output": "subroutine define_connect_enr(emin, emax, p, nenr, nb, ibenr)\ninteger, intent(in) :: emin, emax, p, nenr, nb\ninteger, intent(out) :: ibenr(:,:,:)\ninteger :: e, i, alpha, idx\n! construct nodal connectivity matrix\nibenr = 0\nidx = nb\ndo alpha=1,nenr\ndo e=emin,emax\ndo i=1,p+1\n    if (i == 1 .and. e == emin) cycle\n    if (i == p+1 .and. e == emax) cycle\n    if (i > 1) idx = idx + 1\n    ibenr(i,alpha,e) = idx\nend do\nend do\nend do\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named d2_nu_l2_dx2 that calculates the gradient with respect to l of nu_l2. The subroutine takes 5 input parameters: nd (integer), na (integer), xa (real(8) array), xb (real(8) array), l2inv (real(8) array). It also has 1 output parameter: out (real(8) array). The subroutine computes the output by setting each column of the out array to the l2inv array. Use the !$omp simd directive for optimization.", "input": "", "output": "subroutine d2_nu_l2_dx2(nd, na, xa, xb, l2inv, out)\n  ! gradient w.r.t. l of nu_l2\n  integer, intent(in)    :: nd, na             ! dimension and number of points\n  real(8), intent(in)    :: xa(nd, na), xb(nd) ! points\n  real(8), intent(in)    :: l2inv(nd)          ! inverse length scales squared\n  real(8), intent(out)   :: out(nd, na)        ! output\n\n  integer :: ka\n\n  !$omp simd\n  do ka = 1, na\n    out(:, ka) = l2inv\n  end do\nend subroutine d2_nu_l2_dx2\n"}
{"instruction": "Create a Fortran subroutine named time_interp to interpolate model data based on observational data and model time. The subroutine takes 5 input parameters of types integer, integer, integer, real(8), and real(8), and 1 output parameter of type real(8). The subroutine should be used to perform time interpolation for model data using observational data and model time.", "input": "", "output": "subroutine time_interp(time, n, nrow, obs_time, obs_data, mod_data)\n  ! time: model time\n  !    n: number of time-series observations in observational data\n  ! nrow: number of vertical points in observation data\n  ! obs_time: time of observational data, should be a vector of length n\n  ! obs_data: observational data, should be a vector of length n\n  ! mod_data: model data as output\n  implicit none\n  integer, intent(in)    :: n, time, nrow\n  real(8), intent(in)    :: obs_time(n), obs_data(nrow,n)\n  real(8), intent(out)   :: mod_data(nrow)\n\n  integer, parameter     :: y_per_s = 31104000 \n  integer                :: i,j\n  real(8)                :: timemod, rat\n\n! get time of the year (mod):\n   timemod = float(mod(time,y_per_s))\n\n! deal with the case between two years:\n   if ((timemod .lt. obs_time(1))) then \n\n      rat = (timemod    -obs_time(n)+float(y_per_s))   &\n          / (obs_time(1)-obs_time(n)+float(y_per_s))\n\n      do i=1,nrow\n         mod_data(i)=obs_data(i,n)*(1d0-rat)+obs_data(i,1)*rat\n      enddo\n\n   elseif (timemod .ge. obs_time(n)) then\n\n      rat = (timemod    -obs_time(n))   &\n          / (obs_time(1)-obs_time(n)+float(y_per_s))\n\n      do i=1,nrow\n         mod_data(i)=obs_data(i,n)*(1d0-rat)+obs_data(i,1)*rat\n      enddo\n\n   else\n\n      do j = 1, n-1\n         if ((timemod.lt.obs_time(j+1)) .and. (timemod.ge.obs_time(j))) then\n            \n            rat=(timemod-obs_time(j))/(obs_time(j+1)-obs_time(j))\n       \n            do i=1,nrow\n               mod_data(i)=obs_data(i,j)*(1d0-rat)+obs_data(i,j+1)*rat \n            enddo\n            exit\n         endif\n      enddo \n \n   endif\n   return\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named fit_quadratic to calculate the coefficients of a quadratic equation that fits the given three points. The number of input arguments is 6 and the test_data type is [real, real, real, real, real, real]. The number of output arguments is 3 and the test_data type is [real, real, real].", "input": "", "output": "  subroutine fit_quadratic(a2,a1,a0,x1,y1,x2,y2,x3,y3)\n\n    implicit none\n    real, intent(out) :: a0, a1, a2\n    real, intent(in) :: x1, y1, x2, y2, x3, y3\n\n    !given xi, yi i=1,2,3 fits a quadratic between these points\n\n    a2=((y2-y1)/(x2-x1)-(y3-y1)/(x3-x1))/(x2-x3)\n    a1=(y2-y1)/(x2-x1)-a2*(x2+x1)\n    a0=y1-a2*(x1**2.)-a1*x1\n\n  end subroutine fit_quadratic\n"}
{"instruction": "Create a Fortran subroutine named fit_cubic to calculate the coefficients of a cubic polynomial that fits the given set of points. The subroutine takes 8 input parameters of type real (x1, y1, x2, y2, x3, y3, x4, y4) and returns 4 output parameters of type real (a, b, c, d). Ensure that the coefficients are computed and assigned correctly within the subroutine.", "input": "", "output": "  subroutine fit_cubic(a,b,c,d,x1,y1,x2,y2,x3,y3,x4,y4)\n\n    implicit none\n    real, intent(out) :: a, b, c, d\n    real, intent(in) :: x1, y1, x2, y2, x3, y3, x4, y4\n    real :: f1, f2, f3\n\n    !given xi, yi i=1,2,3,4 fits a cubic between these points\n\n    f1=(y4-y1)/((x4-x2)*(x4-x1)*(x4-x3))\n    f2=(y3-y1)/((x3-x2)*(x3-x1)*(x4-x3))\n    f3=(y2-y1)/((x2-x1)*(x4-x3))*(1./(x4-x2)-1./(x3-x2))\n\n    a=f1-f2-f3\n\n    f1=(y3-y1)/((x3-x2)*(x3-x1))\n    f2=(y2-y1)/((x2-x1)*(x3-x2))\n    f3=a*(x3+x2+x1)\n\n    b=f1-f2-f3\n\n    f1=(y4-y1)/(x4-x1)\n    f2=a*(x4**2.+x4*x1+x1**2.)\n    f3=b*(x4+x1)\n\n    c=f1-f2-f3\n\n    d=y1-a*x1**3.-b*x1**2.-c*x1\n\n  end subroutine fit_cubic\n"}
{"instruction": "Write a Fortran subroutine named split_kv to extract key-value pairs from a string. The subroutine takes 1 input parameter of type character(len=*), and 2 output parameters of type character(len=*). The function of the code is to split the input string at the '=' character into key and value strings and store them in the output parameters \"key\" and \"val\" respectively. Use the imperative tone in the instructions.", "input": "", "output": "    subroutine split_kv(par,key,val)\n    character(len=*),intent(in):: par\n    character(len=*),intent(out):: key,val\n    character:: eq='='\n    integer:: id\n    id=index(par,eq)\n    key=trim(adjustl(par(1:id-1)))\n    val=trim(adjustl(par(id+1:)))\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named calc_rsdft_ecut to calculate the energy cutoff for real space density functional theory (DFT) calculations. The subroutine takes 2 input parameters of type real(8) and integer, and 1 output parameter of type real(8).", "input": "", "output": "subroutine calc_rsdft_ecut( bb, nggrid, ecut )\n  implicit none\n  real(8),intent(in) :: bb(3,3)\n  integer,intent(in) :: nggrid(3)\n  real(8),intent(out) :: ecut\n  real(8) :: b1,b2,b3,b12,c,s,r1,r2,r3,b0(3),gcut\n  b1=sqrt(sum(bb(1:3,1)**2))*(2*nggrid(1)+1)\n  b2=sqrt(sum(bb(1:3,2)**2))*(2*nggrid(2)+1)\n  b3=sqrt(sum(bb(1:3,3)**2))*(2*nggrid(3)+1)\n  b12=sum(bb(1:3,1)*bb(1:3,2))\n  c=b12/(b1*b2)*(2*nggrid(1)+1)*(2*nggrid(2)+1)\n  s=sqrt(1.d0-c**2)\n  r1=s*b1\n  r2=s*b2\n  b0(1)=bb(2,1)*bb(3,2)-bb(3,1)*bb(2,2)\n  b0(2)=bb(3,1)*bb(1,2)-bb(1,1)*bb(3,2)\n  b0(3)=bb(1,1)*bb(2,2)-bb(2,1)*bb(1,2)\n  r3=abs( sum(bb(1:3,3)*b0(1:3))*(2*nggrid(3)+1)/sqrt(sum(b0**2)) )\n  gcut=min(r1,r2,r3)*0.5d0\n  ecut=gcut**2\nend subroutine calc_rsdft_ecut\n"}
{"instruction": "Write a Fortran subroutine called \"grid2d_coords\" that determines the row and column coordinates of a processor in a 2D grid. The subroutine takes in four input parameters: an order character ('c' or 'r'), the rank of the processor (starting from 0), and the dimensions of the processor grid (nprow and npcol). The output parameters are the row and column coordinates of the processor. The input parameter types are ['character', 'integer', 'integer', 'integer'], and the output parameter types are ['integer', 'integer'].", "input": "", "output": "subroutine grid2d_coords( order, rank, nprow, npcol, row, col )\n   !\n\n   !  of the processor whose mpi task id is \"rank\". \n   !  note that if the rank is larger that the grid size\n   !  all processors whose mpi task id is greather or equal \n   !  than nprow * npcol are placed on the diagonal extension of the grid itself\n   !\n   implicit none\n   character, intent(in) :: order\n   integer, intent(in)  ::  rank          ! process index starting from 0\n   integer, intent(in)  ::  nprow, npcol  ! dimensions of the processor grid\n   integer, intent(out) ::  row, col\n   if( rank >= 0 .and. rank < nprow * npcol ) then\n      if( order == 'c' .or. order == 'c' ) then\n         !  grid in column major order\n         row = mod( rank, nprow )\n         col = rank / nprow\n      else\n         !  grid in row major order\n         row = rank / npcol\n         col = mod( rank, npcol )\n      end if\n   else\n      row = rank\n      col = rank\n   end if\n   return\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named grid2d_rank to calculate the rank of a 2D grid in row or column major order. The subroutine takes 5 input parameters of type ['character', 'integer', 'integer', 'integer', 'integer'], representing the order, dimensions of the processor grid, and cartesian coordinates. It outputs 1 parameter of type ['integer'], which represents the process index starting from 0.", "input": "", "output": "subroutine grid2d_rank( order, nprow, npcol, row, col, rank )\n   !\n\n   !  whose cartesian coordinate are \"row\" and \"col\".\n\n   !\n   implicit none\n   character, intent(in) :: order\n   integer, intent(out) ::  rank         ! process index starting from 0\n   integer, intent(in)  ::  nprow, npcol  ! dimensions of the processor grid\n   integer, intent(in)  ::  row, col\n   \n   if( order == 'c' .or. order == 'c' ) then\n     !  grid in column major order\n     rank = mod( row + nprow, nprow ) + mod( col + npcol, npcol ) * nprow\n   else\n     !  grid in row major order\n     rank = mod( col + npcol, npcol ) + mod( row + nprow, nprow ) * npcol\n   end if\n   !\n   return\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named s_transcoeff to calculate the transfer function coefficients for a given frequency and Peclet number. The subroutine takes 2 input parameters of type real(kind(0.d0)) and returns 2 output parameters of the same type.", "input": "", "output": "        subroutine s_transcoeff( omega,peclet,re_trans,im_trans )\n\n            real(kind(0.d0)), intent(in) :: omega\n            real(kind(0.d0)), intent(in) :: peclet\n            real(kind(0.d0)), intent(out) :: re_trans\n            real(kind(0.d0)), intent(out) :: im_trans\n            complex :: trans, c1, c2, c3\n            complex :: imag = ( 0.,1. )\n            real(kind(0.d0)) :: f_transcoeff\n\n            c1 = imag*omega*peclet\n            c2 = csqrt( c1 )\n            c3 = ( cexp(c2)-cexp(-c2) )/( cexp(c2)+cexp(-c2) ) ! tanh(c2)\n            trans = ( (c2/c3-1.d0)**(-1)-3.d0/c1 )**( -1 ) ! transfer function\n\n            re_trans = dble( trans )\n            im_trans = aimag( trans )\n\n        end subroutine s_transcoeff\n"}
{"instruction": "Write a Fortran subroutine named interpolation to perform linear interpolation between two points. The subroutine takes 4 input parameters of type real(8) - fl, dl, fr, and dr, and 1 output parameter of type real(8) - f.", "input": "", "output": "subroutine interpolation(fl, dl, fr, dr, f)\n  implicit none\n  real(8), intent(in) :: fl, dl, fr, dr\n  real(8), intent(out) :: f\n  f = (fl*dr+fr*dl)/(dl+dr)\nend subroutine interpolation\n"}
{"instruction": "Write a Fortran subroutine named mem2d_stretch to calculate the stretch and strains of a 2D material. The subroutine takes 5 input parameters of type real(kind=8) and 2 output parameters of type real(kind=8). The input parameters are u(2), du(2), coords(2), et, and cosd(2), and the output parameters are lambda(2) and strain(2). The subroutine computes the stretch and strains based on the input parameters and stores the results in the output parameters.", "input": "", "output": " subroutine mem2d_stretch(u,du,coords,et,cosd,lambda,strain)\n  implicit none\n  !external variables\n  real(kind=8),intent(in) :: u(2),du(2),coords(2)  !u(nmdof)\n  real(kind=8),intent(in) :: et,cosd(2)\n  real(kind=8),intent(out) :: lambda(2),strain(2)\n  !internal variables\n  !stretch\n  lambda(1) = sqrt((1.d0+du(1))**2.d0+du(2)**2.d0)\n  lambda(2) = 1.d0+et\n  !strains\n  strain(1) = du(1)+0.5d0*(du(1)**2.d0+du(2)**2.d0)\n  strain(2) = et + 0.5d0*et**2.d0\nend subroutine mem2d_stretch\n"}
{"instruction": "Create a Fortran subroutine named volume_strain that takes 3 input parameters of type real, real, and integer, and 1 output parameter of type real. The subroutine calculates the element-wise product of the input arrays s and v, and stores the results in the output array w.", "input": "", "output": "subroutine volume_strain(s, v, w, n)\nreal, intent(in) :: s(n), v(n)\nreal, intent(out) :: w(n)\ninteger, intent(in) :: n\ninteger :: i\ndo i = 1, n\n    w(i) = s(i) * v(i)\nend do\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named decrypt to process the decryption of an array using a key array. The subroutine takes 2 input parameters of type integer arrays and 1 output parameter of type integer array. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].", "input": "", "output": "    subroutine decrypt(encrypted, key, decrypted)\n        integer, intent(in) :: encrypted(:), key(:)\n        integer, intent(out) :: decrypted(:)\n        integer :: i, k\n\n        do i = 1, size(encrypted)\n            k = mod(i, 3)\n            if (k == 0) k = 3\n            decrypted(i) = ieor(encrypted(i), key(k))\n        end do\n    end subroutine decrypt\n"}
{"instruction": "Write a Fortran subroutine named quadroots to compute the roots of a quadratic equation. The subroutine takes 3 input parameters of type real, representing coefficients of the quadratic equation, and provides 2 output parameters: an array of real numbers and an integer indicating the number of roots.", "input": "", "output": "    subroutine quadroots(a, b, c, numroots, roots)\n        real, intent(in) :: a,b,c\n        real, intent(out) :: roots(2)\n        integer, intent(out) :: numroots\n\n        real :: t\n\n        if (a==0) then\n            roots(1) = -c/b\n            roots(2) = 0\n            numroots = 1\n        else\n            t = b**2 - 4*a*c\n            if (t>0) then\n                roots(1) = (-b+sqrt(t)) / (2*a)\n                roots(2) = (-b-sqrt(t)) / (2*a)\n                numroots = 2\n            else\n                roots = 0\n                numroots = 0\n            end if\n        end if\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named star_potential to calculate the gravitational potential at specific points in space due to multiple sources. This subroutine has 16 input parameters of various types, including integers and real*8 arrays, and 1 output parameter of type real*8, dimension(ns). The subroutine utilizes parallel processing with OpenMP for improved performance.", "input": "", "output": "subroutine star_potential(md,xd,yd,zd,mg,xg,yg,zg,ms,xs,ys,zs,eps,nd,ng,ns,pots)\nuse omp_lib\nimplicit none\n\ninteger*4, intent(in) :: nd,ng,ns\nreal*8, intent(in), dimension(nd) :: md,xd,yd,zd\nreal*8, intent(in), dimension(ng) :: mg,xg,yg,zg\nreal*8, intent(in), dimension(ns) :: ms,xs,ys,zs\nreal*8, intent(in) :: eps\nreal*8, intent(out), dimension(ns) :: pots\ninteger*4 :: i,j\nreal*8 :: dist\ninteger :: num_threads\n\nreal*8, dimension(ns) :: ms2,xs2,ys2,zs2\n\ndo i=1,ns\n  pots(i) = 0.0\n  ms2(i) = ms(i)\n  xs2(i) = xs(i)\n  ys2(i) = ys(i)\n  zs2(i) = zs(i)\nenddo\n\n!$omp parallel do private(i,j,dist) shared(pots,xs,ys,zs,ms,xd,yd,zd,md)\ndo i=1,ns\n  do j=1,nd\n    dist = sqrt( (xs(i)-xd(j))**2 + (ys(i)-yd(j))**2 + (zs(i)-zd(j))**2 + eps**2)\n    pots(i) = pots(i)+md(j)/dist\n  enddo\nenddo\n!$omp end parallel do\n\n!$omp parallel do private(i,j,dist) shared(pots,xs,ys,zs,ms,xg,yg,zg,mg)\ndo i=1,ns\n  do j=1,ng\n    dist = sqrt( (xs(i)-xg(j))**2 + (ys(i)-yg(j))**2 + (zs(i)-zg(j))**2 + eps**2)\n    pots(i) = pots(i)+mg(j)/dist\n  enddo\nenddo\n!$omp end parallel do\n\n!$omp parallel do private(i,j,dist) shared(pots,xs,ys,zs,ms,xs2,ys2,zs2,ms2)\ndo i=1,ns\n  do j=1,ns\n    dist = sqrt( (xs(i)-xs2(j))**2 + (ys(i)-ys2(j))**2 + (zs(i)-zs2(j))**2 + eps**2)\n    pots(i) = pots(i)+ms2(j)/dist\n  enddo\nenddo\n!$omp end parallel do\n\nend subroutine star_potential\n"}
{"instruction": "The Fortran subroutine named midplane_vcirc2 calculates the circular velocity components for a given set of particles and mass distribution. The subroutine takes 20 input parameters of types ['integer*4', 'integer*4', 'integer*4', 'integer*4', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(nd)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ng)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ns)', 'real*8, dimension(ni)', 'real*8, dimension(ni)', 'real*8, dimension(ni)', 'real*8'], and has 1 output parameter of type ['real*8, dimension(ni)']. Use the imperative tone to specify the input and output parameter details for the subroutine midplane_vcirc2.", "input": "", "output": "subroutine midplane_vcirc2(md,xd,yd,zd,mg,xg,yg,zg,ms,xs,ys,zs,xin,yin,zin,eps,nd,ng,ns,ni,vcirc2)\nimplicit none\n\ninteger*4, intent(in) :: nd,ng,ns,ni\nreal*8, intent(in), dimension(nd) :: md,xd,yd,zd\nreal*8, intent(in), dimension(ng) :: mg,xg,yg,zg\nreal*8, intent(in), dimension(ns) :: ms,xs,ys,zs\nreal*8, intent(in), dimension(ni) :: xin,yin,zin\nreal*8, intent(in) :: eps\nreal*8, intent(out), dimension(ni) :: vcirc2\ninteger*4 :: i,j\nreal*8 :: dist32\nreal*8, dimension(ni) :: acc_x, acc_y, acc_z\n\ndo i=1,ni\n  acc_x(i) = 0.0\n  acc_y(i) = 0.0\n!   acc_z(i) = 0.0\nenddo\n\ndo i=1,ni\n  do j=1,nd\n    dist32 = (sqrt( (xin(i)-xd(j))**2 + (yin(i)-yd(j))**2 + (zin(i)-zd(j))**2 + eps**2))**3\n    acc_x(i) = acc_x(i)+md(j)/dist32*(xin(i)-xd(j))\n    acc_y(i) = acc_y(i)+md(j)/dist32*(yin(i)-yd(j))\n!     acc_z(i) = acc_z(i)+md(j)/dist32*(zin(i)-zd(j))\n  enddo\nenddo\n\ndo i=1,ni\n  do j=1,ng\n    dist32 = (sqrt( (xin(i)-xg(j))**2 + (yin(i)-yg(j))**2 + (zin(i)-zg(j))**2 + eps**2))**3\n    acc_x(i) = acc_x(i)+mg(j)/dist32*(xin(i)-xg(j))\n    acc_y(i) = acc_y(i)+mg(j)/dist32*(yin(i)-yg(j))\n!     acc_z(i) = acc_z(i)+mg(j)/dist32*(zin(i)-zg(j))\n  enddo\nenddo\n\ndo i=1,ni\n  do j=1,ns\n    dist32 = (sqrt( (xin(i)-xs(j))**2 + (yin(i)-ys(j))**2 + (zin(i)-zs(j))**2 + eps**2))**3\n    acc_x(i) = acc_x(i)+ms(j)/dist32*(xin(i)-xs(j))\n    acc_y(i) = acc_y(i)+ms(j)/dist32*(yin(i)-ys(j))\n!     acc_z(i) = acc_z(i)+ms(j)/dist32*(zin(i)-zs(j))\n  enddo\nenddo\n\ndo i=1,ni\n  vcirc2(i) = acc_x(i)*xin(i) + acc_y(i)*yin(i)\nenddo    \n\nend subroutine midplane_vcirc2\n"}
{"instruction": "Write a Fortran subroutine named julian_to_date to convert a Julian date to a calendar date. The subroutine takes 1 input parameter of type integer and returns 5 output parameters of type integer, where 4 of them are optional. The output parameters represent the day, month, year, and an array of length 3 containing the year, month, and day.", "input": "", "output": "      subroutine julian_to_date(julian,day,month,year,values,ierr)\n\n      implicit none\n      integer,parameter      :: igreg=2299161\n      integer,parameter      :: k = kind(0.0d0)\n      integer,intent(in)     :: julian\n      integer,intent(out),optional    :: day, month, year\n      integer,intent(out),optional    :: values(:)\n      integer,intent(out)             :: ierr\n      integer                :: ia, ja, jb, jc, jd, je, iday, imonth, iyear\n      real(kind=k)           :: xc\n\n      if(julian < 0) then\n        ierr = -1\n        return\n      else\n        ierr = 0\n      endif\n      if(.not.present(values).and..not.present(day).and. &\n         .not.present(month).and..not.present(year)) then\n        ierr=-2\n        return\n      endif\n\n      if (julian.ge.igreg) then\n        ia = (real(julian-1867216,k)-0.25d0)/36524.25d0\n        ja = julian + 1+ia-int(0.25*ia)\n      else\n        ja = julian\n      end if\n\n      jb = ja + 1524\n      xc = (real(jb-2439870,k)-122.1d0)/365.25d0\n      jc = 6680.0d0 + xc\n      jd = 365*jc + int(0.25d0*real(jc,k))\n      je = int(real(jb-jd,k)/30.6001d0)\n\n      iday = jb - jd - int(30.6001d0*real(je,k))\n\n      imonth = je - 1\n      if (imonth.gt.12) imonth = imonth - 12\n\n      iyear = jc - 4715\n      if (imonth.gt.2) iyear = iyear - 1\n      if (iyear.le.0) iyear = iyear - 1\n!\n! assign output values\n!\n      if(present(values)) then\n        values(1) = iyear\n        values(2) = imonth\n        values(3) = iday\n      endif\n      if(present(year)) year=iyear\n      if(present(month)) month=imonth\n      if(present(day)) day=iday\n\n      end subroutine julian_to_date\n"}
{"instruction": "Write a Fortran subroutine named index_intersec to calculate the intersection of two index ranges. The subroutine takes 4 input parameters of type integer: hs, ts, hb, and tb, and 4 output parameters of type integer: hsi, tsi, hbi, and tbi. The subroutine determines the intersection of the small vector index range [hs, ts] with the big vector's index range [hb, tb], and updates the output parameters accordingly.", "input": "", "output": "subroutine index_intersec(hsi,tsi, hbi,tbi, hs,ts, hb,tb)\n! a short vector whose index range on the domain of a big vector is\n! supposedly [hs,ts].  the big vector's valid index range is [hb,tb].\n! intersect them, so now the [hsi,tsi] of the small vec resides on \n! [hbi, tbi] of the big one.\n\ninteger, intent(out):: hsi,tsi, hbi,tbi\ninteger, intent(in) :: hs, ts,  hb, tb\ninteger  :: l\n\nl = ts-hs+1   ! small vec's length\n\nif (hs>=hb) then\n   hsi = 1\n   hbi = hs\nelse\n   hsi = 1+hb-hs\n   hbi = hb\nend if\n\nif (ts<=tb) then\n   tsi = l\n   tbi = ts\nelse\n   tsi = l - (ts-tb)\n   tbi = tb\nend if\n\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named squashnega to modify the input vector x and its corresponding gradient vector g based on the specified mode and parameter alph. The subroutine takes 3 input parameters of type real, real, and integer, and 2 output parameters of type real.", "input": "", "output": "subroutine squashnega(f,g, x, alph, mode)\n! idea is: reduce the influence of the negative part of x\n! x:  vector\n! alph:  1x1\n! f:  same size as x\n! g:  gradient elem-wise, \\partial f_k / \\partial x_k, so same size as x\n!\n! mode == 0:\n! map x \\in [-1, 1] to f \\in [0, 1]  ~ exp(x)\n!     x is normalized, so \\in [-1, 1]\n!\n! mode == 1, 2:\n! f(x) = exp(alph.*x), when x<=0.  when x>0:\n! 1:\n!     1 + alph.*x      f, f' conti\n! 2:\n!     alph^2/2 .*(x+ 1/alph).^2 + 1/2,   f, f', f\" conti\n\nreal, intent(out) :: f(:), g(:)\nreal, intent(in)  :: x(:), alph\ninteger,intent(in):: mode\nreal  :: bet, exa\n\nselect case (mode)\ncase (0)\n   exa = exp(alph)\n   bet = 1./(exa - 1./exa)\n   g   = exp(alph*x)\n   f   = bet * (g - 1./exa)\n   g   = (alph*bet) * g\ncase (1)\n   where (x<0)\n      f = exp(alph*x)\n      g = alph*f\n   elsewhere\n      f = 1 + alph*x\n      g = alph\n   end where\ncase (2)\n   bet = alph*alph\n   where (x<0)\n      f = exp(alph*x)\n      g = alph*f\n   elsewhere\n      f = 0.5*(1. + bet* (x + 1/alph)**2)\n      g =       bet* (x + 1/alph)\n   end where\nend select\n\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named genheadr to populate a header array based on specific input parameters. The subroutine takes 5 input parameters of type integer(kind=4) and returns 1 output parameter of type integer(kind=4), dimension(hcols,nmon). The purpose of the subroutine is to assign values to the header array based on the input parameters.", "input": "", "output": "  subroutine genheadr(kcode,hcols,nmon,nlon,nlat,ihead)\n\n    implicit none\n\n    ! global namespace\n    integer(kind=4), intent(in)  :: kcode\n    integer(kind=4), intent(in)  :: hcols\n    integer(kind=4), intent(in)  :: nmon\n    integer(kind=4), intent(in)  :: nlat\n    integer(kind=4), intent(in)  :: nlon\n    integer(kind=4), dimension(hcols,nmon), intent(out) :: ihead\n    \n    ! local namespace\n    integer(kind=4) :: i\n    integer(kind=4) :: ilevel = 0\n    integer(kind=4) :: idate\n    integer(kind=4) :: itime\n    integer(kind=4) :: idispo1 = 0\n    integer(kind=4) :: idispo2 = 0\n        \n    if (kcode == 129) then\n       idate = 20070101\n       itime = 0\n    else if (kcode == 169) then\n       idate = 20090000\n       itime = -1\n    else if (kcode == 172) then\n       idate = 20090101\n       itime = 0\n    else if (kcode == 173) then\n       idate = 990100\n       itime = -1\n    else if (kcode == 174) then\n       idate = 20090001\n       itime = 0\n    else if (kcode == 199) then\n       idate = 20090001\n       itime = 0\n    else if (kcode == 200) then\n       idate = 20090001\n       itime = 0\n    else if (kcode == 210) then\n       idate = 20090000\n       itime = -1\n    else if (kcode == 212) then\n       idate = 990100\n       itime = -1\n    else if (kcode == 229) then\n       idate = 990100\n       itime = -1\n    else if (kcode == 232) then\n       idate = 990100\n       itime = -1\n    else if (kcode == 1730) then\n       idate = 0\n       itime = 0\n    else if (kcode == 1731) then\n       idate = 990100\n       itime = -1\n    else if (kcode == 1740) then\n       idate = 20090101\n       itime = 0\n    else if (kcode == 1741) then\n       idate = 20090101\n       itime = 0\n    end if\n    \n    ! fill header array\n    do i=1,nmon\n       ihead(1,i) = kcode\n       ihead(2,i) = ilevel\n       ! these dates need a bit of pampering\n       if (i == 1) then\n          ihead(3,i) = idate\n       else   \n          if (itime == 0) then\n             ihead(3,i) = idate + ((i-1)*100) ! add 100 when i=2\n          else if (itime == -1) then\n             ihead(3,i) = idate + ((i-1)*100) + 1 ! add 100 when i=2 plus 1\n          end if\n       end if\n       ihead(4,i) = itime\n       ihead(5,i) = nlon\n       ihead(6,i) = nlat\n       ihead(7,i) = idispo1\n       ihead(8,i) = idispo2\n    end do\n    \n    return\n  end subroutine genheadr\n"}
{"instruction": "Create a Fortran subroutine named \"latlons64\" to populate latitude and longitude arrays with pre-defined values. The subroutine should have 2 input parameters of type 'integer(kind=4)' representing the number of latitude and longitude elements, and 2 output parameters of type 'real(kind=8), dimension(nlat)' and 'real(kind=8), dimension(nlon)' representing the latitude and longitude arrays respectively.", "input": "", "output": "  subroutine latlons64(nlat,nlon,lat,lon)\n    \n    integer(kind=4), intent(in)  :: nlat\n    integer(kind=4), intent(in)  :: nlon    \n    real(kind=8), dimension(nlat), intent(out) :: lat\n    real(kind=8), dimension(nlon), intent(out) :: lon\n\n    ! solved legendre polynomials (not here)\n    lat = (/87.8637988392326, 85.0965269883174,&\n    &82.3129129478863, 79.5256065726594, 76.7368996803683,&\n    &73.9475151539896, 71.1577520115873, 68.3677561083132,&\n    &65.5776070108278, 62.7873517989631, 59.9970201084913,&\n    &57.2066315276433, 54.4161995260862, 51.6257336749383,&\n    &48.8352409662506, 46.0447266311017, 43.2541946653509,&\n    &40.463648178115, 37.6730896290453, 34.8825209937735,&\n    &32.091943881744, 29.3013596217627, 26.510769325211,&\n    &23.7201739335347, 20.9295742544895, 18.1389709902393,&\n    &15.3483647594915, 12.5577561152307, 9.76714555919557,&\n    &6.97653355394864, 4.18592053318915, 1.3953069108195,&\n    &-1.3953069108195, -4.18592053318915, -6.97653355394864,&\n    &-9.76714555919557, -12.5577561152307, -15.3483647594915,&\n    &-18.1389709902393, -20.9295742544895, -23.7201739335347,&\n    &-26.510769325211, -29.3013596217627, -32.091943881744,&\n    &-34.8825209937735, -37.6730896290453, -40.463648178115,&\n    &-43.2541946653509, -46.0447266311017, -48.8352409662506,&\n    &-51.6257336749383, -54.4161995260862, -57.2066315276433,&\n    &-59.9970201084913, -62.7873517989631, -65.5776070108278,&\n    &-68.3677561083132, -71.1577520115873, -73.9475151539896,&\n    &-76.7368996803683, -79.5256065726594, -82.3129129478863,&\n    &-85.0965269883174, -87.8637988392326/)\n\n    lon = (/0.0, 2.8125, 5.625, 8.4375, 11.25, 14.0625,&\n    &16.875, 19.6875, 22.5, 25.3125, 28.125, 30.9375, 33.75, 36.5625,&\n    &39.375, 42.1875, 45.0, 47.8125, 50.625, 53.4375, 56.25, 59.0625,&\n    &61.875, 64.6875, 67.5, 70.3125, 73.125, 75.9375, 78.75, 81.5625,&\n    &84.375, 87.1875, 90.0, 92.8125, 95.625, 98.4375, 101.25, 104.0625,&\n    &106.875, 109.6875, 112.5, 115.3125, 118.125, 120.9375, 123.75,&\n    &126.5625, 129.375, 132.1875, 135.0, 137.8125, 140.625, 143.4375,&\n    &146.25, 149.0625, 151.875, 154.6875, 157.5, 160.3125, 163.125,&\n    &165.9375, 168.75, 171.5625, 174.375, 177.1875, 180.0, 182.8125,&\n    &185.625, 188.4375, 191.25, 194.0625, 196.875, 199.6875, 202.5,&\n    &205.3125, 208.125, 210.9375, 213.75, 216.5625, 219.375, 222.1875,&\n    &225.0, 227.8125, 230.625, 233.4375, 236.25, 239.0625, 241.875,&\n    &244.6875, 247.5, 250.3125, 253.125, 255.9375, 258.75, 261.5625,&\n    &264.375, 267.1875, 270.0, 272.8125, 275.625, 278.4375, 281.25,&\n    &284.0625, 286.875, 289.6875, 292.5, 295.3125, 298.125, 300.9375,&\n    &303.75, 306.5625, 309.375, 312.1875, 315.0, 317.8125, 320.625,&\n    &323.4375, 326.25, 329.0625, 331.875, 334.6875, 337.5, 340.3125,&\n    &343.125, 345.9375, 348.75, 351.5625, 354.375, 357.1875/)\n\n    return    \n  end subroutine latlons64\n"}
{"instruction": "Create a Fortran subroutine named getpointcoordsfromcellcoords to calculate the coordinates of a point within a cell based on the corner index, cell coordinates, and half-width of the cell. The subroutine takes 3 input parameters of type integer, double precision, and double precision, and returns 1 output parameter of type double precision.", "input": "", "output": "    subroutine getpointcoordsfromcellcoords(corner,cellcoords,halfwidth,pointcoords)\n    implicit none\n        integer, intent(in) :: corner\n        double precision, intent(in) :: cellcoords(:), halfwidth(:)\n        double precision, intent(out) :: pointcoords(:)\n\n        if(corner == 1) then !left top\n            pointcoords(1) = cellcoords(1) - halfwidth(1)\n            pointcoords(2) = cellcoords(2) + halfwidth(2)\n\n        else if(corner == 2) then !right top\n            pointcoords(1) = cellcoords(1) + halfwidth(1)\n            pointcoords(2) = cellcoords(2) + halfwidth(2)\n\n        else if(corner == 3) then !right bottom\n            pointcoords(1) = cellcoords(1) + halfwidth(1)\n            pointcoords(2) = cellcoords(2) - halfwidth(2)\n\n        else if(corner == 4) then !left bottom\n            pointcoords(1) = cellcoords(1) - halfwidth(1)\n            pointcoords(2) = cellcoords(2) - halfwidth(2)\n\n        end if\n\n        return\n    end subroutine getpointcoordsfromcellcoords\n"}
{"instruction": "Write a Fortran subroutine named gpad1 that takes an array of real numbers as input and outputs another array of real numbers. The input array should be of type real and have a dimension of (:), while the output array should also be of type real and have a dimension of (:).", "input": "", "output": "  subroutine gpad1( gxx, xx )\n  implicit none\n  real,    intent(in),  dimension(:) :: gxx\n  real,    intent(out), dimension(:) :: xx\n  integer :: i, ix, ip \n  integer :: nx, nx2, nxp1\n  real    :: dx\n\n  nx2  = size( xx ) - size( gxx )\n  nx   = nx2 / 2\n  nxp1 = nx + 1\n\n  ix = size( gxx )\n  ip = size(  xx ) + 1\n\n  xx(nxp1:ix+nx) = gxx(:) \n\n  dx = xx(nx+2) - xx(nx+1)\n\n  do i = 1,nx\n     xx(   i) =  xx(   nxp1) - ( nxp1 - i ) * dx\n     xx(ip-i) =  xx(ip-nxp1) + ( nxp1 - i ) * dx \n  end do\n\n  end subroutine gpad1\n"}
{"instruction": "Write a Fortran subroutine named getformat to extract a format qualifier from a string. The subroutine takes 1 input parameter of type character(len=*) and returns 2 output parameters of type character(len=*) and integer. The input parameter is the string to analyze, and the output parameters are the extracted format string and its length. Use the imperative tone to explain the function of the code.", "input": "", "output": "  subroutine getformat (sstring,sformat,ilen)\n\n  !<description>\n    ! local routine. extracts a format qualifier from a string.\n    ! the qualifier must have the format \"%... \" ending with a space or\n    ! the string end.\n  !</description>\n\n  !<input>\n    ! string to analyse\n    character(len=*), intent(in) :: sstring\n  !</input>\n  \n  !<output>\n    ! format string.\n    character(len=*), intent(out) :: sformat\n    \n    ! length of the format string\n    integer, intent(out) :: ilen\n  !</output>\n\n\n    ! position of the first format specifier\n    ilen = scan(sstring,\"dfs\")\n    if (ilen .eq. 0) ilen = len_trim(sstring)\n    \n    sformat = sstring(1:ilen)\n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named cosine2 that calculates the value of c using the given input parameters. The number of input arguments is 8 with test_data type ['real', 'real', 'real', 'real', 'real', 'real', 'real', 'real']. The number of output arguments is 1 with test_data type ['real'].", "input": "", "output": "subroutine cosine2(a,a_err,b,b_err,t1,t1_err,t2,t2_err,c)\n    implicit none\n\n    real, intent(in) :: a,a_err,b,b_err,t1,t2,t1_err,t2_err\n    real, intent(out):: c\n    real:: theta\n\n    theta=(t2-t2_err)-(t1+t1_err)\n    c=sqrt((a-a_err)**2 + (b-b_err)**2 - 2.*(a-a_err)*(b-b_err)*cos(theta))\n\nend subroutine cosine2\n"}
{"instruction": "Create a Fortran subroutine named mergearr that takes 4 input parameters: 2 integers (na and nb), and 2 real arrays of size na and nb. It also has 1 output parameter, a real array of size (na+nb). The subroutine merges the two input arrays into one sorted array based on their values.", "input": "", "output": "   subroutine mergearr(a, b, c, na, nb)\n      implicit none\n      ! dummy arguments\n      integer, intent(in) :: na, nb\n      real, dimension(na), intent(in) :: a\n      real, dimension(nb), intent(in) :: b\n      real, dimension(na+nb), intent(out) :: c\n      ! local variables\n      integer :: i, j, k\n      ! processing\n      i = 1\n      j = 1\n      k = 1\n      do\n         if (i > na .or. j > nb) exit\n         if (a(i) < b(j)) then\n            c(k) = a(i)\n            i = i + 1\n         else\n            c(k) = b(j)\n            j = j + 1\n         end if\n         k = k + 1\n      end do\n      do\n         if (i > na) exit\n         c(k) = a(i)\n         k = k + 1\n         i = i + 1\n      end do\n      do\n         if (j > nb) exit\n         c(k) = b(j)\n         k = k + 1\n         j = j + 1\n      end do\n   end subroutine mergearr\n"}
{"instruction": "Write a Fortran subroutine named average_tiles to calculate the average of a 2-dimensional field over tiles. The subroutine takes 3 input parameters of type real, real, and logical, and 1 output parameter of type real.", "input": "", "output": "subroutine average_tiles ( x, area, mask, out )\n! ============================================================================\n! average 2-dimensional field over tiles\n  ! --- arguments ------------------------------------------------------------\n  real,    intent(in)  :: x   (:,:,:) ! (lon, lat, tile) field to average\n  real,    intent(in)  :: area(:,:,:) ! (lon, lat, tile) fractional area\n  logical, intent(in)  :: mask(:,:,:) ! (lon, lat, tile) land mask\n  real,    intent(out) :: out (:,:)   ! (lon, lat)       result of averaging\n\n  ! --- local vars -----------------------------------------------------------------\n  integer  :: it                      ! iterator over tile number\n  real     :: s(size(x,1),size(x,2))  ! area accumulator\n\n  s(:,:)   = 0.0\n  out(:,:) = 0.0\n\n  do it = 1,size(area,3)\n     where (mask(:,:,it)) \n        out(:,:) = out(:,:) + x(:,:,it)*area(:,:,it)\n        s(:,:)   = s(:,:) + area(:,:,it)\n     endwhere\n  enddo\n\n  where( s(:,:) > 0 ) &\n       out(:,:) = out(:,:)/s(:,:)\n\nend subroutine average_tiles\n"}
{"instruction": "Write a Fortran subroutine named ntoi to perform a nearest neighbor interpolation operation. The subroutine takes 4 input parameters of type integer, integer, real, and real. It returns 1 output parameter of type integer.", "input": "", "output": "subroutine  ntoi(value,nrow,grid,n,ind)\nimplicit none\ninteger, intent(in) :: nrow, n\nreal, intent(in) :: value(nrow,1), grid(n,1)\ninteger, intent(out) :: ind(nrow,1)\nreal, allocatable :: ones(:,:), aux(:,:)\nreal :: step=0.0\nallocate (aux(nrow,1))\naux = min(value,grid(n,1))\naux = max(aux,grid(1,1))\nstep = (grid(n,1)-grid(1,1))/(n-1)\nallocate (ones(nrow,1))\nones = 1.0\nind = nint(((aux-grid(1,1)*ones)/step)+ones)\ndeallocate(ones)\ndeallocate(aux)\nreturn\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named test_r_i that takes 4 input parameters of type integer, integer, real array, and integer array. It also has 2 output parameters of type real array and integer array. The subroutine copies the input integer and real arrays to the output integer and real arrays, respectively. The number of input arguments is 4 and the test_data type is ['integer', 'integer', 'real', 'integer']. The number of output arguments is 2 and the test_data type is ['real', 'integer'].", "input": "", "output": "          subroutine test_r_i(orr,oii,  rr,nr,ii,ni)\n\n          implicit none\n          integer, intent(in) :: nr,ni\n!         ! real, intent(out) :: orr(nr)\n!         ! integer, intent(out) :: oii(ni)\n!         ! real, intent(in) :: rr(nr)\n!         ! integer, intent(in) :: ii(ni)\n          real, intent(out) :: orr(nr)\n          integer, intent(out) :: oii(ni)\n          real, intent(in) :: rr(:)\n          integer, intent(in) :: ii(:)\n\n          print *,'rr:',rr\n          print *,'ii:',ii\n          orr=rr\n          oii=ii\n          return\n          end subroutine test_r_i\n"}
{"instruction": "Create a Fortran subroutine named ij2latlonps to convert grid indices to latitude and longitude. The subroutine takes 6 input parameters of type integer, integer, integer, real, real, and real, and 2 output parameters of type real, real.", "input": "", "output": "subroutine ij2latlonps(i,j,ihem,xc,yc,dlat,lat,lon)\n  integer, intent(in)  :: i, j, ihem\n  real,    intent(in)  :: xc, yc, dlat\n  real,    intent(out) :: lat, lon\n  integer :: dir\n  real :: pi\n  real :: deg2rad, rad2deg\n  real :: r0, phi0, rate\n  real :: di, dj\n  real :: alpha, a2, phi\n  if( ihem == 1 ) then\n    dir = 1\n  else\n    dir = -1\n  end if\n  pi = 4.0 * atan(1.0)\n  deg2rad = pi/180.0\n  rad2deg = 180.0/pi\n  r0 = sqrt((xc-1)*(xc-1)+(yc-1)*(yc-1))\n  phi0 = dlat * deg2rad\n  rate = r0 * (1.0+cos(phi0)) / sin(phi0);\n  di = xc - i;\n  dj = j - yc;\n  alpha = sqrt(di*di+dj*dj) / rate\n  a2 = alpha * alpha;\n  phi = acos( (1.0-a2)/(1.0+a2) )\n  lon = atan2(dir*di,dj) * rad2deg\n  lat = dir * ( 90.0 - phi * rad2deg )\n  if( lon > 180.0 ) then\n    lon = lon - 360.0\n  end if\nend subroutine ij2latlonps\n"}
{"instruction": "Create a Fortran subroutine named fmrmat that takes 4 input parameters of type real(iwp) and 1 output parameter of type real(iwp). The subroutine performs matrix calculations based on the input parameters and modifies the output parameter accordingly.", "input": "", "output": "subroutine fmrmat(vmfl,dsbar,dlam,dee,rmat)\n!\n\n!\n implicit none\n integer,parameter::iwp=selected_real_kind(15)\n real(iwp),intent(in)::vmfl(:),dsbar,dlam,dee(:,:)\n real(iwp),intent(out)::rmat(:,:)\n real(iwp)::acat(4,4),acatc(4,4),qmat(4,4),temp(4,4),con,zero=0.0_iwp,    &\n   pt5=0.5_iwp,one=1.0_iwp,three=3.0_iwp\n integer::i,j  \n temp=zero\n temp(1,1)=one\n temp(1,2)=-pt5\n temp(1,4)=-pt5\n temp(2,1)=-pt5\n temp(2,2)=one\n temp(2,4)=-pt5\n temp(3,3)=three\n temp(4,1)=-pt5\n temp(4,2)=-pt5\n temp(4,4)=one\n do i=1,4\n   do j=1,4\n     acat(i,j)=vmfl(i)*vmfl(j)\n   end do\n end do\n acat=(temp-acat)/dsbar\n acatc=matmul(dee,acat)\n qmat=acatc*dlam\n do i=1,4\n   qmat(i,i)=qmat(i,i)+one\n end do\n do i=1,4\n   con=qmat(i,i)\n   qmat(i,i)=one\n   qmat(i,:)=qmat(i,:)/con\n   do j=1,4\n     if(j/=i)then\n       con=qmat(j,i)\n       qmat(j,i)=zero\n       qmat(j,:)=qmat(j,:)-qmat(i,:)*con\n     end if\n   end do\n end do\n rmat=matmul(qmat,dee)\nreturn\nend subroutine fmrmat\n"}
{"instruction": "Create a Fortran subroutine named read_tile to read data from a binary file and store it in a 3D array. The subroutine takes 2 input parameters of type character(*) and integer, and 1 output parameter of type real, dimension(:,:,:) to store the read data.", "input": "", "output": "subroutine read_tile(filename,buf4,kmax)\n  character(*), intent(in) :: filename\n  real, dimension(:,:,:), intent(out) :: buf4\n  integer, intent(in) :: kmax\n  integer :: reclen\n  integer :: mx,ny,lz\n  logical :: ex\n  integer :: fid = 22\n  logical :: dodebug = .false.\n\n  mx = size(buf4,1)\n  ny = size(buf4,2)\n  lz = min(size(buf4,3),kmax)\n\n  reclen = mx * ny * lz * reclen_mult\n\n  if (dodebug) then\n    write(6,*) \"mx     = \", mx\n    write(6,*) \"ny     = \", ny\n    write(6,*) \"lz     = \", lz\n    write(6,*) \"_mult  = \", reclen_mult\n    write(6,*) \"mx * ny * lz * reclen_mult = \", mx * ny * lz * reclen_mult\n    write(6,*) \"reclen = \", reclen\n  endif\n\n  inquire (file=trim(filename), exist=ex)\n  if (ex) then\n    if (dodebug) write(6,*) \"read_tile:: opening file: \", trim(filename)\n    open (unit=fid, file=trim(filename), status='old', access='direct', form='unformatted', recl=reclen)\n    read (fid,rec=1) buf4(:,:,1:kmax)\n    close (fid)\n    if (dodebug) write (6, *) 'read_tile:: finished reading analysis tile file: ', trim(filename)\n  else\n    write (6, *) 'read_tile:: analysis tile file missing: ', trim(filename)\n    stop(\"merge_tiles.f90:: exiting...\")\n  endif\n\n  if (dodebug) then\n    print *, \"max(buf4) = \", maxval(buf4)\n    print *, \"min(buf4) = \", minval(buf4)\n    print *, \"avg(buf4) = \", sum(buf4)/(mx*ny*lz)\n    print *, \"maxloc(buf4) = \", maxloc(buf4)\n    print *, \"minloc(buf4) = \", minloc(buf4)\n  endif\n\nend subroutine read_tile\n"}
{"instruction": "Create a Fortran subroutine named encode that takes a single input argument of type character(*) and returns a single output argument of type character(*). The subroutine encodes the input string based on the frequency of characters, producing a new string with the format \"count\" + \"character\". If the input contains characters other than lowercase letters, the output will be \"invalid input\".", "input": "", "output": "subroutine encode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(8) :: tempstr = \"\"\n  character(26) :: validchars = \"abcdefghijklmnopqrstuvwxyz\"\n  integer :: a, b, c, i\n\n  if(verify(trim(instr), validchars) /= 0) then\n    outstr = \"invalid input\"\n    return\n  end if\n  outstr = \"\"\n  c = 1\n  a = iachar(instr(1:1))\n  do i = 2, len(trim(instr))\n    b = iachar(instr(i:i))\n    if(a == b) then\n      c = c + 1\n    else\n      write(tempstr, \"(i0)\") c\n      outstr = trim(outstr) // trim(tempstr) // achar(a)\n      a = b\n      c = 1\n    end if\n  end do\n  write(tempstr, \"(i0)\") c\n  outstr = trim(outstr) // trim(tempstr) // achar(b)\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"block_cyclic_1d\" that takes 4 input parameters of type integer: i, nb, p1st, np. It should also have 2 output parameters of type integer: ip, il. The subroutine should calculate the values of ip and il using the provided formulae and return the results.", "input": "", "output": "        subroutine block_cyclic_1d( i, nb, p1st, np, ip, il )\n        implicit none\n        integer, intent(in)  :: i, nb, p1st, np\n        integer, intent(out) :: ip, il\n        ip = mod( p1st + (i-1)/nb , np )\n        il = ((i-1)/(np*nb))*nb + mod( i-1, nb ) + 1\n        end subroutine\n"}
{"instruction": "Write a Fortran subroutine named juliandatenumbertogregorianyearmonthday to convert a Julian date number to Gregorian year, month, and day. The subroutine takes 1 input parameter of type integer and returns 3 output parameters of type integer representing the calculated Gregorian year, month, and day respectively.", "input": "", "output": "      subroutine juliandatenumbertogregorianyearmonthday(jdn, year, month, day)\n         integer, intent(in)  :: jdn   !< julian date number\n         integer, intent(out) :: year  !< calculated gregorian year\n         integer, intent(out) :: month !< calculated gregorian month\n         integer, intent(out) :: day   !< calculated gregorian day\n         !\n         integer :: j !< helper variable\n         integer :: l !< helper variable\n         integer :: m !< helper variable\n         integer :: n !< helper variable\n         !\n         l      = jdn + 68569\n         n      = 4 * l / 146097\n         l      = l - (146097*n + 3)/4\n         j      = 4000 * (l + 1) / 1461001\n         l      = l - 1461*j/4 + 31\n         m      = 80 * l / 2447\n         day    = l - 2447*m/80\n         l      = m / 11\n         month  = m + 2 - 12*l\n         year   = 100*(n-49) + j + l\n      end subroutine juliandatenumbertogregorianyearmonthday\n"}
{"instruction": "Create a Fortran subroutine named spline to calculate the coefficients of a cubic interpolational spline. The subroutine takes 3 input parameters of type integer, real*8, and real*8, and 3 output parameters of type real*8.", "input": "", "output": "subroutine spline(n,x,y,b,c,d)\n  implicit none\n  integer, intent(in) :: n\n  real*8, intent(in)  :: x(n), y(n)\n  real*8, intent(out) :: b(n), c(n), d(n)\n  !---------------------------------------------------------\n  !     calculate coefficients b(i),c(i),d(i),i=1,2,...,n\n  !     for cubic interpolational spline:\n  !     s(x) = y(i) + b(i) * (x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3\n  !     for x(i).le.x.le.x(i+1),\n  !     where: n - number of points (n.ge.2),\n  !     x - abscises (in strictly increasing order),\n  !     y - ordinates.\n  !---------------------------------------------------------\n  !     \n  integer :: nm1, ib, i\n  real*8  :: t\n  !     \n  nm1=n-1\n  if(n .lt. 2) return\n  if(n .lt. 3) go to 50\n  !---------------------------------------------------------\n  !     construct 3-diagonal system with b - diagonal,\n  !     d - overdiagonal, c - right sides\n  !---------------------------------------------------------\n  !     \n  d(1)=x(2)-x(1)\n  c(2)=(y(2)-y(1))/d(1)\n  do i=2,nm1\n     d(i)=x(i+1)-x(i)\n     b(i)=2.d0*(d(i-1)+d(i))\n     c(i+1)=(y(i+1)-y(i))/d(i)\n     c(i)=c(i+1)-c(i)\n  enddo\n  !----------------------------------------------------------\n  !     boundary conditions\n  !----------------------------------------------------------\n  !     \n  b(1)= -d(1)\n  b(n)= -d(n-1)\n  c(1)=0.d00\n  c(n)=0.d00\n  if(n .eq. 3) go to 15\n  c(1)=c(3)/(x(4)-x(2))-c(2)/(x(3)-x(1))\n  c(n)=c(n-1)/(x(n)-x(n-2))-c(n-2)/(x(n-1)-x(n-3))\n  c(1)=c(1)*d(1)*d(1)/(x(4)-x(1))\n  c(n)= -c(n)*d(n-1)*d(n-1)/(x(n)-x(n-3))\n  !----------------------------------------------------------\n  !     upward step\n  !----------------------------------------------------------\n  !     \n15 continue\n  do i=2,n\n     t=d(i-1)/b(i-1)\n     b(i)=b(i)-t*d(i-1)\n     c(i)=c(i)-t*c(i-1)\n  enddo\n  !----------------------------------------------------------\n  !     backward substitution\n  !----------------------------------------------------------\n  !     \n  c(n)=c(n)/b(n)\n  do ib =1,nm1\n     i=n-ib\n     c(i)=(c(i)-d(i)*c(i+1))/b(i)\n  enddo\n  !----------------------------------------------------------\n  !     calculate coefficients of the polinomials\n  !----------------------------------------------------------\n  !     \n  b(n)=(y(n)-y(nm1))/d(nm1)+d(nm1)*(c(nm1)+2.d00*c(n))\n  do i=1,nm1\n     b(i)=(y(i+1)-y(i))/d(i)-d(i)*(c(i+1)+2.d00*c(i))\n     d(i)=(c(i+1)-c(i))/d(i)\n     c(i)=3.d00*c(i)\n  enddo\n     \n  c(n)=3.d00*c(n)\n  d(n)=d(n-1)\n  return\n!     \n50 continue\n  b(1)=(y(2)-y(1))/(x(2)-x(1))\n  c(1)=0.d00\n  d(1)=0.d00\n  b(2)=b(1)\n  c(2)=0.d00\n  d(2)=0.d00\n  !     \n  return\nend subroutine spline\n"}
{"instruction": "Create a Fortran subroutine named get_diffs to calculate the differences between corresponding elements of two 3D real arrays (var1 and var2). The subroutine should also compute the absolute differences and squared differences, considering the dimensions (nx, ny, nz) and a specified missing value. The number of input arguments is 6 with test_data types ['real, dimension(:,:,:)', 'real, dimension(:,:,:)', 'integer', 'integer', 'integer', 'real'], and the number of output arguments is 3 with test_data types ['real, dimension(:,:,:)', 'real, dimension(:,:,:)', 'real, dimension(:,:,:)'].", "input": "", "output": "  subroutine get_diffs(var1, var2, diff, absdiff, sqdiff, nx, ny, nz, missing)\n    \n    real, intent(in), dimension(:,:,:)             :: var1, var2\n    real, intent(out), dimension(:,:,:)            :: diff, absdiff, sqdiff\n    integer, intent(in)                            :: nx, ny, nz\n    integer                                        :: i,j,k\n    real, intent(in)                               :: missing\n\n    do k = 1, nz\n    do j = 1, ny\n    do i = 1, nx\n       if ( var1(i,j,k) /= missing .and. var2(i,j,k) /= missing ) then\n         diff(i,j,k)   = var2(i,j,k) - var1(i,j,k) \n         absdiff(i,j,k)   = abs(var2(i,j,k) - var1(i,j,k)) \n         sqdiff(i,j,k) = (var2(i,j,k) - var1(i,j,k) )*(var2(i,j,k) - var1(i,j,k) ) \n       else\n         diff(i,j,k)   = missing \n         absdiff(i,j,k)   = missing \n         sqdiff(i,j,k) = missing\n       endif\n    enddo\n    enddo\n    enddo\n\n  end subroutine get_diffs \n"}
{"instruction": "Create a Fortran subroutine named \"ldsmall\" to calculate limb darkened flux using the small-planet approximation. The subroutine takes 8 input parameters of type real(8) and dimension(n), and one input parameter of type integer. The output parameter is of type real(8) and dimension(n). This subroutine uses the imperative tone and follows the features of Fortran subroutines.", "input": "", "output": " subroutine ldsmall(s,ar_occ,c1,c2,c3,c4,r,i0,n)\n ! computes limb darkened flux assuming small-planet approximation\n\n implicit none\n real(8), dimension(n), intent(in) :: s, ar_occ\n real(8), intent(in) :: c1, c2, c3, c4, r\n integer, intent(in) :: n\n integer :: i\n real(8) :: ftot\n real(8), dimension(n) :: am, bm, amr, bmr\n real(8), dimension(n) :: ar_ann, fl_ann\n real(8), dimension(n), intent(out) :: i0\n real(8), parameter :: pi = 3.14159265358979323846d0\n real(8), parameter :: third = 0.33333333333333333333d0\n real(8), parameter :: seventh = 0.1428571428571428d0\n \n ftot = 1.0d0 - 0.2d0*c1 - third*c2 - 3.0d0*seventh*c3 - 0.5d0*c4\n\n do i=1,n\n am(i) = (s(i)-r)**2\n bm(i) = (s(i)+r)**2\n amr(i) = dsqrt(dsqrt(1.0d0-am(i)))\n bmr(i) = dsqrt(dsqrt(1.0d0-bm(i)))\n ! 4 cases\n  if( s(i).gt.(1.0d0+r) ) then\n   ! case i\n   ar_ann(i) = 0.0d0\n   fl_ann(i) = 0.0d0\n   i0(i) = 1.0d0\n  else if( s(i).gt.r .and. s(i).lt.(1.0d0-r) ) then \n   ! case iii\n   ! area of annulus is given by...\n   ar_ann(i) = pi*(bm(i) - am(i))\n   ! flux of annulus is given by...\n   fl_ann(i) = (am(i)-bm(i))*(c1+c2+c3+c4-1.0d0) + &\n               0.8d0*c1*amr(i)**5 + 2.0d0*third*c2*amr(i)**6 + &\n               4.0d0*seventh*c3*amr(i)**7 + 0.5d0*c4*amr(i)**8 - &\n               0.8d0*c1*bmr(i)**5 - 2.0d0*third*c2*bmr(i)**6 - &\n               4.0d0*seventh*c3*bmr(i)**7 - 0.5d0*c4*bmr(i)**8\n    ! intensity...\n    i0(i) = 1.0d0 - (ar_occ(i)/ar_ann(i))*(fl_ann(i)/ftot)\n  else if( s(i).lt.r ) then \n   ! case ix\n   ! area of annulus is given by...\n   ar_ann(i) = pi*bm(i)\n   ! flux of annulus is given by...\n   fl_ann(i) = -bm(i)*(c1+c2+c3+c4-1.0d0) + &\n               0.8d0*c1 + 2.0d0*third*c2 + 4.0d0*seventh*c3 + 0.5d0*c4 - &\n               0.8d0*c1*bmr(i)**5 - 2.0d0*third*c2*bmr(i)**6 - &\n               4.0d0*seventh*c3*bmr(i)**7 - 0.5d0*c4*bmr(i)**8\n   ! intensity...    \n   i0(i) = 1.0d0 - (ar_occ(i)/ar_ann(i))*(fl_ann(i)/ftot)\n  else !if( s(i).lt.(1.0d0+r) .and. s(i).lt.(1.0d0-r) ) then\n   ! case ii\n   ! area of annulus is given by...\n   ar_ann(i) = pi*(1.0d0-am(i))\n   ! flux of annulus is given by...\n   fl_ann(i) = (am(i)-1.0d0)*(c1+c2+c3+c4-1.0d0) + &\n               0.8d0*c1*amr(i)**5 + 2.0d0*third*c2*amr(i)**6 + &\n               4.0d0*seventh*c3*amr(i)**7 + 0.5d0*c4*amr(i)**8\n   ! intensity...    \n   i0(i) = 1.0d0 - (ar_occ(i)/ar_ann(i))*(fl_ann(i)/ftot)\n  end if\n end do\n\n end subroutine ldsmall\n"}
{"instruction": "Create a Fortran subroutine named get_mass that takes a character(2) input parameter and returns two output parameters: an integer and a double precision value. The subroutine retrieves the mass and atomic number of an element based on its atomic symbol. If the element is found, the mass and atomic number are returned; if not found, an error message is displayed, and the program stops.", "input": "", "output": "subroutine get_mass(elem,mass,atgrp)\nimplicit none\ncharacter(2), intent(in) :: elem\ncharacter(2),dimension(109) :: pertab\ninteger :: i\ninteger,intent(out) :: atgrp\ndouble precision,dimension(109) :: atommass\ndouble precision,intent(out) :: mass\n\npertab=(/'h ','he','li','be','b ','c ','n ','o ','f ','ne',&\n'na','mg','al','si','p ','s ','cl','ar','k ','ca',&\n'sc','ti','v ','cr','mn','fe','co','ni','cu','zn',&\n'ga','ge','as','se','br','kr','rb','sr','y ','zr',&\n'nb','mo','tc','ru','rh','pd','ag','cd','in','sn',&\n'sb','te','i ','xe','cs','ba','la','ce','pr','nd',&\n'pm','sm','eu','gd','tb','dy','ho','er','tm','yb',&\n'lu','hf','ta','w ','re','os','ir','pt','au','hg',&\n'tl','pb','bi','po','at','rn','fr','ra','ac','th',&\n'pa','u ','np','pu','am','cm','bk','cf','es','fm',&\n'md','no','lr','rf','db','sg','bh','hs','mt'/)\n\natommass=(/1.007825d0, 4.0026d0,    7.016d0,    9.01218d0, 11.00931d0,&\n 12.0d0,     14.00307d0,  15.99491d0, 18.9984d0,  19.99244d0,&\n 22.9898d0,  23.98504d0,  26.98154d0, 27.97693d0, 30.97376d0,&\n 31.97207d0, 34.96885d0,  39.9624d0,  38.96371d0, 39.96259d0,&\n 44.95592d0, 45.948d0,    50.9440d0,  51.9405d0,  54.9381d0,&\n 55.9349d0,  58.9332d0,   57.9353d0,  62.9298d0,  63.9291d0,&\n 68.9257d0,  73.9219d0,   74.9216d0,  78.9183d0,  79.9165d0,&\n 83.912d0,   84.9117d0,   87.9056d0,  88.9054d0,  89.9043d0,&\n 92.9060d0,  97.9055d0,   97.9072d0, 101.9037d0, 102.9048d0,&\n105.9032d0, 106.90509d0, 113.9036d0, 114.9041d0, 117.9018d0,&\n 120.9038d0, 129.9067d0, 126.9004d0, 131.9042d0, 132.9051d0,&\n 137.9050d0, 138.9061d0, 139.9053d0, 140.9074d0, 143.9099d0,&\n 144.9128d0, 151.9195d0, 152.9209d0, 157.9241d0, 159.9250d0,&\n 163.9288d0, 164.9303d0, 165.9304d0, 168.9344d0, 173.9390d0,&\n 174.9409d0, 179.9468d0, 180.948d0,  183.9510d0, 186.9560d0,&\n 189.9586d0, 192.9633d0, 194.9648d0, 196.9666d0, 201.9706d0,&\n 204.9745d0, 207.9766d0, 208.9804d0, 209.9829d0, 210.9875d0,&\n 222.0175d0, 223.0198d0, 226.0254d0, 227.0278d0, 232.0382d0,&\n 231.0359d0, 238.0508d0, 237.0482d0, 244.0642d0, 243.0614d0,&\n 247.0704d0, 247.0703d0, 251.0796d0, 252.0829d0, 257.0950d0,&\n 258.0986d0, 259.1009d0, 262.1100d0, 261.1087d0, 262.1138d0,&\n 266.1219d0, 262.1229d0, 267.1318d0, 268.1388d0 /)\n\nmass=0.d0\ndo i=1,109\n if (elem==pertab(i)) then\n  mass=atommass(i)\n  atgrp=i\n  exit\n end if\nend do\nif (mass==0.d0) then\n write(*,*) 'element not found'\n stop\nend if\nend subroutine get_mass\n"}
{"instruction": "Create a Fortran subroutine named gaussian_product to compute the product of two Gaussian functions. The subroutine takes 4 input parameters: aa and bb as real*8, and ra and rb as real*8 arrays of size 3. It also has 3 output parameters: pp and cp as real*8, and rp as a real*8 array of size 3.", "input": "", "output": "        subroutine gaussian_product(aa,bb,ra,rb,pp,rp,cp)\n            implicit none\n\n            ! input\n            real*8, intent(in) :: aa, bb ! gaussian exponential coefficients\n            real*8, dimension(3), intent(in) :: ra, rb ! gaussian centers\n\n            ! intermediate variable\n            real*8, dimension(3) :: rab ! differente between gaussian centers\n\n            ! output\n            real*8, intent(out) :: pp ! gaussian product exponential coefficient\n            real*8, intent(out) :: cp ! gaussian product coefficient\n            real*8, dimension(3), intent(out) :: rp ! gaussian product center\n\n            ! compute gaussian product exponential coefficient\n            pp = aa + bb\n\n            ! compute difference between gaussian centers\n            rab = ra - rb\n\n            ! compute gaussian product coefficient\n            cp = dot_product(rab,rab)\n            cp =  - aa * bb / pp * cp\n            cp = exp(cp)\n\n            ! compute gaussian product center\n            rp = (aa * ra + bb * rb) / pp\n\n        end subroutine gaussian_product\n"}
{"instruction": "Write a Fortran subroutine named d3dot that takes 3 input parameters of type integer, real(kind=8), and real(kind=8), and 1 output parameter of type real(kind=8). The subroutine computes the dot product of two 3x3 matrices represented by the input arrays a and b, performing the operation n times and storing the result in the array t.", "input": "", "output": "  subroutine d3dot(t,a,b,n)\n    implicit none\n    !------\n    integer, intent(in):: n\n    real(kind=8), intent(in):: a(9,*)\n    real(kind=8), intent(in):: b(9,*)\n    real(kind=8), intent(out):: t(9)\n    !------\n    integer:: jj\n\n    t(1:9) = 0.0d0\n    do jj = 1, n\n      t(1) = t(1) + a(1,jj)*b(1,jj) + a(4,jj)*b(4,jj) + a(7,jj)*b(7,jj)\n      t(2) = t(2) + a(2,jj)*b(1,jj) + a(5,jj)*b(4,jj) + a(8,jj)*b(7,jj)\n      t(3) = t(3) + a(3,jj)*b(1,jj) + a(6,jj)*b(4,jj) + a(9,jj)*b(7,jj)\n\n      t(4) = t(4) + a(1,jj)*b(2,jj) + a(4,jj)*b(5,jj) + a(7,jj)*b(8,jj)\n      t(5) = t(5) + a(2,jj)*b(2,jj) + a(5,jj)*b(5,jj) + a(8,jj)*b(8,jj)\n      t(6) = t(6) + a(3,jj)*b(2,jj) + a(6,jj)*b(5,jj) + a(9,jj)*b(8,jj)\n\n      t(7) = t(7) + a(1,jj)*b(3,jj) + a(4,jj)*b(6,jj) + a(7,jj)*b(9,jj)\n      t(8) = t(8) + a(2,jj)*b(3,jj) + a(5,jj)*b(6,jj) + a(8,jj)*b(9,jj)\n      t(9) = t(9) + a(3,jj)*b(3,jj) + a(6,jj)*b(6,jj) + a(9,jj)*b(9,jj)\n    enddo\n  end subroutine d3dot\n"}
{"instruction": "Create a Fortran subroutine named \"invx\" to perform a specific matrix inversion calculation. The subroutine should take 1 input parameter of type integer and 2 output parameters, one of type integer and the other of type real(kind=8).", "input": "", "output": "  subroutine invx(dsln,ndeg,ir)\n    implicit none\n    !------\n    integer, intent(in):: ndeg\n    integer, intent(out):: ir\n    real(kind=8), intent(out):: dsln(*)\n    !------\n    integer:: i\n    integer:: j\n    integer:: k\n    integer:: k0\n    integer:: l\n    integer:: l0\n    integer:: ld\n    integer:: ll\n    real(kind=8):: t\n    real(kind=8):: tem\n\n    ir = 0\n    l = 1\n    dsln(1) = 1.0d0/dsln(1)\n    do i = 2, ndeg\n      ld = 0\n      l0 = l\n      do j = 1, i - 1\n        l = l + 1\n        do k = 1, j - 1\n          ld = ld + 1\n          dsln(l) = dsln(l) - dsln(l0+k)*dsln(ld)\n        enddo\n        ld = ld + 1\n      enddo\n      t = 0.0d0\n      k0 = 0\n      ll = 0\n      do k = l - i + 2, l\n        ll = ll + 1\n        k0 = k0 + ll\n        tem = dsln(k)*dsln(k0)\n        t = t + tem*dsln(k)\n        dsln(k) = tem\n      enddo\n      l = l + 1\n      dsln(l) = dsln(l) - t\n      dsln(l) = 1.0d0/dsln(l)\n    enddo\n  end subroutine invx\n"}
{"instruction": "Create a Fortran subroutine named \"analyze_distances\" to analyze distances and generate a histogram. The subroutine takes 8 input parameters of types: integer, integer, integer array, double precision 2D array, integer 2D array, double precision, double precision, and integer. It also has 1 output parameter of type double precision array with dimension nr. The subroutine calculates and writes the histogram of distances to a file named \"disthist.dat\".", "input": "", "output": "  subroutine analyze_distances(ne, nd, ndist, dist, count, r0, r1, nr, p)\n\n    implicit none\n\n    integer,                             intent(in)  :: ne, nd\n    integer,          dimension(ne),     intent(in)  :: ndist\n    double precision, dimension(nd, ne), intent(in)  :: dist\n    integer,          dimension(nd, ne), intent(in)  :: count\n    double precision,                    intent(in)  :: r0, r1\n    integer,                             intent(in)  :: nr\n    double precision, dimension(nr),     intent(out) :: p\n\n    integer, parameter :: u_hist = 50\n\n    double precision :: r, dr\n    integer          :: ir, ie, id\n\n    p(:) = 0\n\n    dr = (r1-r0)/dble(nr)\n    r  = r0\n    do ir = 1, nr\n       do ie = 1, ne\n       do id = 1, ndist(ie)\n          if ((dist(id,ie) > r) .and. (dist(id,ie) <= r+dr)) then\n             p(ir) = p(ir) + count(id,ie)\n          end if\n       end do\n       end do\n       r = r + dr\n    end do\n\n    p(:) = p(:)/sum(p(:))/dr\n\n    open(u_hist, file='disthist.dat', status='replace', action='write')\n    r  = r0 + 0.5d0*dr\n    do ir = 1, nr\n       write(u_hist,'(1x,2(es15.8,2x))') r, p(ir)\n       r = r + dr\n    end do\n    close(u_hist)\n\n  end subroutine analyze_distances\n"}
{"instruction": "Create a Fortran subroutine named cutoff_poly3 to implement a 3rd order polynomial tail function. The subroutine takes 5 input parameters of type double precision, namely r, r1, rc, f1, and df1, and returns 4 output parameters of type double precision, namely t, dt, d2t, and d3t. The subroutine computes the values of t(r), dt(r), d2t(r), and d3t(r) based on the input parameters and the defined polynomial function.", "input": "", "output": "  subroutine cutoff_poly3(r, r1, rc, f1, df1, t, dt, d2t, d3t)\n\n    implicit none\n\n    !------------------------------------------------------------------!\n    ! the 3rd order polynomial tail function t(r) takes a function     !\n    ! f(r) smoothly to zero.  f(r) will be replaced by the polynomial  !\n    ! on the interval [r1,rc].                                         !\n    !                                                                  !\n    ! t(r) = a*(rc - r)**2 + b*(rc - r)**3                             !\n    ! with:  a =  [ 3*f(r1) - df(r1)/dr * (r1-rc) ]/(rc-r1)**2         !\n    !        b = -[ 2*f(r1) + df(r1)/dr * (rc-r1) ]/(rc-r1)**3         !\n    !                                                                  !\n    ! r   : evaulate the function at r                                 !\n    ! rc  : cut-off radius                                             !\n    ! r1  : t(r) is defined on [r1,rc]                                 !\n    ! f1  : f(r1)                                                      !\n    ! df1 : df(r1)/dr                                                  !\n    !------------------------------------------------------------------!\n\n    double precision, intent(in)  :: r, r1, rc, f1, df1\n    double precision, intent(out) :: t, dt, d2t, d3t\n\n    double precision :: a, b\n    double precision :: k1, k2\n\n    k1 = (rc-r1)\n    k2 = k1*k1\n    a =  ( 3.0d0*f1 + k1*df1 )/k2\n    b = -( 2.0d0*f1 + k1*df1 )/(k1*k2)\n\n    k1 = (rc-r)\n    t   =  ( a + b*k1 )*k1*k1\n    dt  = -( 2.0d0*a + 3.0d0*b*k1 )*k1\n    d2t =  2.0d0*a + 6.0d0*b*k1\n    d3t = -6.0d0*b\n\n  end subroutine cutoff_poly3\n"}
{"instruction": "Write a Fortran subroutine named pinter that takes 4 input parameters of types integer, real(kind=8) arrays of dimension npts, and a single real(kind=8) value. It also has 1 output parameter of type real(kind=8). The subroutine performs piecewise linear interpolation to calculate the value of yv corresponding to the input xv based on the given xx and yy arrays. The subroutine utilizes binary search to find the appropriate indices for interpolation.", "input": "", "output": "    subroutine pinter(npts,xx,yy,xv,yv)\n      implicit none\n      integer,intent(in)                       :: npts\n      integer                                  :: klo, khi, kp\n      real(kind=8),dimension(npts),intent(in) :: xx, yy\n      real(kind=8),intent(in)                 :: xv\n      real(kind=8),intent(out)                :: yv\n      real(kind=8)                            :: dx\n      if(xx(1) > xv) then\n     !  extrapolate solution\n        klo = 1\n        khi = 2\n      elseif(xx(npts) < xv)then\n     !  extrapolate solution\n        klo = npts-1\n        khi = npts\n      else\n        klo = 1\n        khi = npts\n        do while (khi-klo > 1)\n          kp = (khi+klo)/2\n          if(xx(kp).gt.xv) then\n            khi = kp\n          else\n            klo = kp\n          end if\n        end do\n      end if\n      dx = (xv - xx(klo))/(xx(khi)-xx(klo))\n      yv = dx*yy(khi) + (1. - dx)*yy(klo)\n      return\n    end subroutine pinter\n"}
{"instruction": "Write a Fortran subroutine named compute_gregorian to convert a Julian day to Gregorian date. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 3 and the test_data type is ['integer', 'integer', 'integer'].", "input": "", "output": "      subroutine compute_gregorian(julday, year, month, day)\n      implicit none\n      ! arguments\n      integer, intent(out) :: year, month, day\n      integer, intent(in) :: julday\n      ! functions\n      intrinsic floor, nint\n      ! local variables\n      integer m, n\n!***********************************************************************\n      m = julday + 68569\n      n = 4*m/146097\n      m = m - (146097*n+3)/4\n      year = 4000*(m+1)/1461001\n      m = m - 1461*year/4+31\n      month = 80*m/2447\n      day = m - 2447*month/80\n      m = month/11\n      month = month + 2 - 12*m\n      year = 100*(n-49) + year + m\n\n      !\n      !z = julday + 0.5\n      !w = floor((z - 1867216.25)/36524.25)\n      !x = floor(w/4.0)\n      !a = z + 1.0 + w - x\n      !b = a + 1524.0\n      !c = floor((b - 122.1)/365.25)\n      !d = floor(365.25*c)\n      !e = floor((b - d)/30.6001)\n      !f = floor(30.6001*e)\n      !day = nint(b - d -f)\n      !month = nint(e - 1)\n      !if ( month>12 ) month = month - 12\n      !if ( month<3 ) then\n      !  year = nint(c - 4715)\n      !else\n      !  year = nint(c - 4716)\n      !endif\n      end subroutine compute_gregorian\n"}
{"instruction": "Create a Fortran subroutine named delfino to calculate the strain energy density (psi) in a material based on the Delfino et al. rubber-like potential for carotid arteries. The subroutine should have 2 input parameters of type real*8 and 1 output parameter of type real*8. The input parameters are named invc and matpar, and the output parameter is named psi.", "input": "", "output": "subroutine delfino(psi,invc,matpar)\n! delfino et al. [10] proposed an (isotropic) rubber-like potential for carotid arteries\n          ! [10] a. delfino, n. stergiopulos, j.e. moore and j.-j. meister, \n          ! residual strain effects on the stress field in a thick wall\n          ! finite element model of the human carotid bifurcation. \n          ! j. biomech. 30 (1997) 777\u0096786.\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(2)\n\treal*8 :: c1,c2,c3,i1bar,j,ri33\n\tc1 = matpar(1) ! a\n\tc2 = matpar(2)*0.5d0 ! b/2\n\t\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\t\n\tpsi = 0.5d0*(c1/c2)*( dexp(c2*(i1bar-3.0d0))-1.0d0 )\n\t\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named `fibre` to calculate the value of `psi` based on the input parameters `invcm` and `matpar`. The number of input parameters is 2, of type `real*8`, and the test_data type is ['real*8 ', 'real*8 ']. The number of output parameters is 1, of type `real*8`, and the test_data type is ['real*8 ']. Use the imperative tone.", "input": "", "output": "subroutine fibre(psi,invcm,matpar) ! see my dissertation\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invcm(:),matpar(2) ! matpar is only the material coeficient, a0 was splitted\n \treal*8 :: c1,c2,i4\n\tc1 = matpar(1) ! k1\n\tc2 = matpar(2) ! k2\n\t\n\ti4 = invcm(2) !! already incompressible\n\t\n\tpsi = 0.5d0*(c1/c2)*( dexp(c2*(i4-1.0d0)**2.0d0)-1.0d0 ) \n\t\nend subroutine \n"}
{"instruction": "Create a Fortran subroutine named \"thwats\" to calculate the values of \"h\" and \"l\" using Thwaite's correlation formulas. The subroutine should take 1 input parameter of type real and provide 2 output parameters of type real.", "input": "", "output": "  pure subroutine thwats(lambda, h, l)\n    !! thwaite's correlation formulas\n    real, intent(in) :: lambda\n    real, intent(out) :: h, l\n\n    if (lambda < 0.0) then\n       l = 0.22 + 1.402*lambda + 0.18*lambda / (0.107 + lambda)\n       h = 2.088 + 0.0731 / (0.14 + lambda)\n    else\n       l = 0.22 + lambda*(1.57 - 1.8*lambda)\n       h = 2.61 - lambda*(3.75 - 5.24*lambda)\n    end if\n    \n  end subroutine thwats\n"}
{"instruction": "Create a Fortran subroutine named crdtrf to compute the transformation matrix and two transformation parameters based on the input vectors. The subroutine takes 2 input parameters of type real*8, dimension(:) and 3 output parameters of types real*8, dimension(:,:), real*8, and real*8.", "input": "", "output": "subroutine crdtrf(r,m,capr,theta, derv)\nimplicit none\nreal*8, dimension(:), intent(in) :: r(3), m(3)\nreal*8, dimension(:,:), intent(out) :: derv(3,3)\nreal*8, intent(out) :: capr, theta\nreal*8, parameter :: pc = sqrt(epsilon(1.0d0))\nreal*8 :: cmu1, cmu2, rcm1, rcm2\n\n!        3\n!       /|\\\n!      / | \\\n!   r3/ r|  \\r2\n!    /   |th \\\n!   /____|____\\ \n!  1    r1    2\n\ncmu1 = m(2) / (m(1)+m(2))\ncmu2 = m(1) / (m(1)+m(2))\n\nrcm1 = r(1) * cmu1\nrcm2 = r(1) * cmu2\n\ncapr = sqrt (r(2)**2/r(1)*rcm1 + r(3)**2/r(1)*rcm2 - rcm1*rcm2 )\nif (abs(capr) < pc) capr = pc\n\ntheta = (rcm2**2+capr**2-r(2)**2)/2.0d0/rcm2/capr\ntheta=min(1.0d0,max(-1.0d0,theta))\n\ntheta = acos(theta)\nif (theta==acos(-1.d0)) then\n        !nprint*,\"shite\"\n        theta=theta-1.d-5\nend if \nderv(1,1) = -cmu1*cmu2*r(1)/capr   !dr/dr1\n  \nderv(1,2) = r(2)*cmu1/capr !dr/dr2\n\nderv(1,3) = r(3)*cmu2/capr\n\nderv(2,1) = 1.0d0\nderv(2,2) = 0.0d0\nderv(2,3) = 0.0d0\n\nderv(3,1) = (derv(1,1)/capr*cos(theta)+cos(theta)/r(1)-(capr*derv(1,1)+rcm2*cmu2)/rcm2/capr)&\n            /sqrt(1.0d0-cos(theta)**2)\n\nderv(3,2) = (r(2)/rcm2/capr-derv(1,2)/rcm2+cos(theta)/capr*derv(1,2))/sqrt(1.0d0-cos(theta)**2)\n\nderv(3,3) = (cos(theta)/capr*derv(1,3)-derv(1,3)/rcm2)/sqrt(1.0d0-cos(theta)**2)\n\nreturn\n\nend subroutine crdtrf\n"}
{"instruction": "Write a Fortran subroutine named `fibrelinearcomp` to calculate the compressive response of a material based on given material coefficients and the fourth invariant. The subroutine takes 2 input parameters of type real*8 and an array of real*8, and 1 output parameter of type real*8. The subroutine uses the imperative tone to declare the purpose of the code and its input/output parameters.", "input": "", "output": "subroutine fibrelinearcomp(psi,i4,matpar) ! works on compression\n\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: i4, matpar(:) ! matpar is only the material coeficient, a0 was splitted\n\treal*8 :: c1, c2, lfa, lrel\n\tc1 = matpar(1) ! k1\n\tc2 = matpar(2)\n\tlfa = matpar(3)\n\t\t\n\tlrel = dsqrt(i4) - lfa\n\t\n\tif(lrel > 0.0d0) then \n\t\tpsi = (c1/8.0d0)*lrel**2.0d0 \n\telse \n\t\tpsi = (c2/8.0d0)*lrel**2.0d0\n\tend if\n\t\nend subroutine \n"}
{"instruction": "Create a Fortran subroutine named fibrelinearregnew to calculate the value of psi based on the input parameters i4 and matpar. The subroutine takes 2 input parameters of type real*8, and an array of real*8 for matpar. It returns 1 output parameter of type real*8.", "input": "", "output": "subroutine fibrelinearregnew(psi,i4,matpar) ! works on compression\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: i4, matpar(:) ! matpar is only the material coeficient, a0 was splitted\n\treal*8 :: k1, k2, lfa, l1, l2, l3, eps, delta, l, dl21, dl32, alpha\n\treal*8 :: a0, a1, a2, b0, b1, b2, b3, c0, c1, c2\n\treal*8 , parameter :: tol = 1.0e-15\n\t\n\tk1 = matpar(1) \n\tk2 = matpar(2)\n\tlfa = matpar(3) !! reserved entry, given by param, should be 0.0 in commonpar\n\tl1 = matpar(4)\n\tdelta = matpar(5)\n\teps = matpar(6)\n\t\n\tif(l1<0.0d0) then\n\t\tl1 = lfa\n\tend if\n\n\tl2 = lfa - delta*(lfa-l1)\n\tl3 = lfa + delta*(lfa-l1)\n\t\n\tl = dsqrt(i4)\n\tdl21 = l2 - l1\n\tdl32 = l3 - l2\n\talpha = (k2 - k1)/dl32\n\t\t\n\tif((k2-k1)<tol .and. dl32 < tol) then\n\t\talpha = 0.0d0\n\telse\n\t\talpha = (k2 - k1)/dl32\n\tend if\n\t\n\ta0 = 0.0d0\n\tb0 = eps\n\ta2 = 0.5d0*k1\n\tb2 = 0.5d0*k1\n\tc2 = 0.5d0*k2\n\tb3 = alpha/6.0d0\n\tif((b0-a0)<tol .and. dl21 < tol) then\n\t\ta1 = 0.0d0\n\telse\n\t\ta1 = (b0 - a0)/dl21 - a2*dl21\n\tend if\n\t\n\tb1 = 2.0d0*a2*dl21 + a1\n\tc1 = 3.0d0*b3*dl32**2.0d0 + 2.0d0*b2*dl32 + b1\n\tc0 = b3*dl32**3.0d0 + b2*dl32**2.0d0 + b1*dl32 + b0\n\t\n\tpsi = 0.0d0\n\t\n!~ \tif(l<l1) then \n!~ \t\tpsi = a0\n\tif(l < l2) then\n\t\tpsi = a2*(l-l1)**2.0d0 + a1*(l-l1) + a0\n\telse if (l < l3) then\n\t\tpsi = b3*(l-l2)**3.0d0 + b2*(l-l2)**2.0d0 + b1*(l-l2) + b0\n\telse\n\t\tpsi = c2*(l-l3)**2.0d0 + c1*(l-l3) + c0\n\tend if\n\t\nend subroutine \n"}
{"instruction": "Write a Fortran subroutine named dfibrelinearcomp to calculate the change in the potential function dpsi. The subroutine takes 2 input parameters of type real*8 and an array of real*8. The output parameter is of type real*8.", "input": "", "output": "subroutine dfibrelinearcomp(dpsi,i4,matpar) ! see my wriggers  sx = e ex\n\treal*8 , intent(out) :: dpsi\n\treal*8 , intent(in) :: i4, matpar(:) ! matpar is only the material coeficient, a0 was splitted\n \treal*8 :: c1, c2,lfa, lrel\n\tc1 = matpar(1) ! k1\n\tc2 = matpar(2) ! k2\n\tlfa = matpar(3)\n\t\t\n\tlrel = dsqrt(i4) - lfa\n\t\n\tif(lrel >= 0.0d0) then \n\t\tdpsi = (c1/8.0)*lrel/(lrel + lfa)\n\telse \n\t\tdpsi = (c2/8.0)*lrel/(lrel + lfa)\n\tend if\n\t\n\t\nend subroutine \n"}
{"instruction": "Create a Fortran subroutine named mag to calculate the magnitude of a vector. The subroutine takes 2 input parameters of types integer and real, denoted as n and a respectively. It also has 1 output parameter of type real, denoted as a_mag.", "input": "", "output": "    subroutine mag(n, a, a_mag)\n        implicit none\n        integer, intent(in) :: n\n        real, intent(in)    :: a(n)\n        real, intent(out)   :: a_mag\n        a_mag = sqrt(sum(a**2))\n        return\n    end subroutine mag\n"}
{"instruction": "Create a Fortran subroutine named poisson_prob to calculate the Poisson probability mass function and cumulative distribution function. The subroutine takes 3 input parameters of type integer, integer, and double precision, and 2 output parameters of type double precision.", "input": "", "output": "  subroutine poisson_prob(lambda, left, right, prob, weight)\n\n    integer, intent(in) :: left, right\n    double precision, intent(in) :: lambda\n    double precision, intent(out) :: prob(left:right), weight\n    \n    ! work variables\n    integer :: mode, j, t, s\n\n    mode = floor(lambda)\n    if (mode >= 1) then\n     prob(mode) = exp(-lambda + real(mode, kind=8) * log(lambda) &\n      - log2piover2 &\n      - (real(mode, kind=8) + 1.0d0/2.0d0) &\n      * log(real(mode, kind=8)) + real(mode, kind=8))\n    else\n      prob(mode) = exp(-lambda)\n    end if\n    ! -- down --\n    do j = mode, left+1, -1\n      prob(j-1) = (real(j, kind=8)/lambda)*prob(j)\n    end do\n    ! -- up --\n    do j = mode, right-1\n      prob(j+1) = (lambda/real(j+1, kind=8))*prob(j)\n    end do\n    ! -- compute w --\n    weight = 0.0\n    s = left\n    t = right\n    do while (s < t)\n      if (prob(s) <= prob(t)) then\n        weight = weight + prob(s)\n        s = s + 1\n      else\n        weight = weight + prob(t)\n        t = t - 1\n      end if\n    end do\n    weight = weight + prob(s)\n  end subroutine poisson_prob\n"}
{"instruction": "Create a Fortran subroutine named fgroup_aqns to process and group input arrays. The subroutine takes 3 input parameters of type integer, integer, and real*8, and 3 output parameters of type integer, integer, and real*8. The subroutine should be able to process and group the input arrays according to specified conditions and update the output arrays accordingly.", "input": "", "output": "subroutine fgroup_aqns(qns_sorted,n,m,nnr,gqns,nn)\n    implicit none\n    integer,intent(in) :: n,m\n    real*8,intent(in) :: qns_sorted(n,m)\n    integer,intent(out) :: nn,nnr(n)\n    real*8,intent(out) :: gqns(n,m)\n    integer :: i,temp\n    real*8 :: qn_pre(m),qn(m)\n    \n    !f2py intent(in) :: qns_sorted,n,m\n    !f2py intent(out) :: nnr,gqns,nn\n\n    qn_pre=(/-1d8,-1d8/)\n    temp=0\n    nn=0\n    do i=1,n\n        qn=qns_sorted(i,:)\n        if(i==1 .or. sum((qn-qn_pre)**2)>1d-8) then\n            nn=nn+1\n            gqns(nn,:)=qn(:)\n            if(i/=1) then\n                nnr(nn-1)=temp\n            endif\n            temp=1\n            qn_pre=qn\n        else\n            temp=temp+1\n        endif\n    enddo\n    nnr(nn)=temp\nend subroutine fgroup_aqns\n"}
{"instruction": "Write a Fortran subroutine named \"simple\" to calculate the sum of two real numbers. The subroutine takes 2 input parameters of type real and returns 1 output parameter of type real.", "input": "", "output": "subroutine simple(a,b,c)\n\n\treal, intent(in) :: a, b\n\treal, intent(out) :: c\n\n\tc = a + b\n\nend subroutine simple\n"}
{"instruction": "Create a Fortran subroutine named diag_mark to implement the diagonal Markowitz algorithm for finding permutations that produce near-optimal LU fill-in. The subroutine takes 2 input parameters of type integer and logical and 1 output parameter of type integer.", "input": "", "output": "      subroutine diag_mark( order, matrix, perm )\n!---------------------------------------------------------------------------\n!\t... find permuatation via diagonal markowitz to produce\n!           near optimal lu fillin\n!---------------------------------------------------------------------------\n\n      implicit none\n\n!---------------------------------------------------------------------------\n!\t... dummy args\n!---------------------------------------------------------------------------\n      integer, intent(in)  :: order\n      integer, intent(out) :: perm(order)\n      logical, intent(in)  :: matrix(order,order)\n\n!---------------------------------------------------------------------------\n!\t... local variables\n!---------------------------------------------------------------------------\n      integer :: row, rowp1, col, maxrow\n      integer :: beta, cnt\n      integer :: i, j\n      logical :: holder(order)\n      logical :: pattern(order,order)\n\n      cnt = count( matrix )\n      perm(:order) = (/ (row,row=1,order) /)        ! no permutations\n      pattern = matrix\n      do row = 1,order-1\n\t rowp1 = row + 1\n\t beta = (order - 1)**2\n\t maxrow = row\n\t do col = row,order\n\t    cnt = (count(pattern(col,row:order)) - 1) * &\n\t          (count(pattern(row:order,col)) - 1)\n\t    if( cnt < beta ) then\n\t       beta = cnt\n\t       maxrow = col\n\t    end if\n\t end do\n\t if( maxrow /= row ) then\n!----------------------------------------------------------------\n!\t... row and column permuatation\n!----------------------------------------------------------------\n\t    holder(row:order) = pattern(row,row:order)\n\t    pattern(row,row:order) = pattern(maxrow,row:order)\n\t    pattern(maxrow,row:order) = holder(row:order)\n\t    holder(row:order) = pattern(row:order,row)\n\t    pattern(row:order,row) = pattern(row:order,maxrow)\n\t    pattern(row:order,maxrow) = holder(row:order)\n\t    beta = perm(row)\n\t    perm(row) = perm(maxrow)\n\t    perm(maxrow) = beta\n\t end if\n!----------------------------------------------------------------\n!\t... now do \"symbolic\" decomposition on sub-matrix\n!----------------------------------------------------------------\n\t do col = rowp1,order\n\t    if( pattern(row,col) ) then\n\t       pattern(rowp1:order,col) = pattern(rowp1:order,row) .or. &\n\t\t\t\t\t  pattern(rowp1:order,col)\n\t    end if\n\t end do\n      end do\n\n      end subroutine diag_mark\n"}
{"instruction": "Create a Fortran subroutine named eigen_max that implements the power method to compute the eigenvector and eigenvalue of maximum modulus for a given symmetric matrix. The subroutine takes in four input parameters: a real matrix 'a', an integer 'maxiter' representing the maximum number of iterations, a real 'err_v' specifying the precision for the stop criterion, and a real vector 'v_0' as the initial vector for the iteration. The subroutine returns two output parameters: a real vector 'v' representing the eigenvector and a real 'lambda' representing the eigenvalue.", "input": "", "output": "    subroutine eigen_max(a, v, lambda, maxiter, err_v, v_0)\n      !! given the matrix **a**, computes the eigenvector **v** associated to\n      !! the eivenvalue of maximum modulus **lambda**  using the power method.\n        real, intent(in) :: a(:,:)\n      !! symmetric matrix\n        real, intent(out) :: v(size(a,1))\n      !! eigenvector\n        real, intent(out) :: lambda\n      !! eigenvalue\n        real, intent(in) :: err_v\n      !! precision for the stop criterion\n        integer, intent(in) :: maxiter\n      !! maximum number of iterations\n        real, intent(in) :: v_0(size(a,1))\n      !! initial vector for the iteration\n\n        integer :: i\n        real :: u(size(a,1))\n\n        u = v_0\n        u = u/norm2(u)\n\n        do i = 1, maxiter\n            v = matmul(a,u)\n            lambda = dot_product(u,v)/dot_product(u,u)\n            v = v/norm2(v)\n            if ( dot_product(u,v)>0)then\n              if (norm2(u-v)<err_v) exit\n            elseif( dot_product(u,v)<0) then\n              if (norm2(u+v)<err_v) exit\n            end if\n            u = v\n        end do\n        if( i>maxiter ) print*, 'the maximum number of iteration was reached &\n                                & without obtaining convergence'\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"recenter_positions\" to calculate the center of mass for a system of particles. The subroutine takes 5 input parameters: 2 integers, 1 real*8 array of size nat, 1 integer array of size nat, and 1 real*8 3D array of size (nstep, nat, 3). It produces 1 output parameter of type real*8 3D array of size (nstep, nat, 3).", "input": "", "output": "subroutine recenter_positions(positions, masses, factors, positions_, nstep, nat)\n    implicit none\n    integer, intent(in)                             ::  nstep, nat\n    ! masses are the masses of the atoms, factors are an additional factor so that we can\n    ! calculate the center of mass only for certain species\n    real*8, intent(in), dimension(nat)              ::  masses\n    integer, intent(in), dimension(nat)             :: factors\n    real*8, intent(in),  dimension(nstep, nat, 3)   :: positions\n    real*8, intent(out), dimension(nstep, nat, 3)   :: positions_\n\n    integer                                         :: iat, istep, ipol\n    real*8, dimension(nat)                          :: rel_masses\n    real*8, dimension(3)                            :: com\n    real*8                                          ::  m\n\n    do iat=1, nat\n        rel_masses(iat) = dble(factors(iat)) * masses(iat)\n    end do\n\n    m = sum(rel_masses)\n    rel_masses(:) = rel_masses(:) / m\n    do istep=1, nstep\n        com(1:3) = 0.d0\n        do iat=1, nat\n            do ipol=1, 3\n                com(ipol) = com(ipol) + rel_masses(iat)*positions(istep, iat, ipol) ! / m\n            end do\n        end do\n\n        do iat=1, nat\n            do ipol=1, 3\n                positions_(istep, iat, ipol) = positions(istep, iat, ipol)  - com(ipol)\n            end do\n        end do\n    end do\nend subroutine recenter_positions\n"}
{"instruction": "Write a Fortran subroutine named fkron_coo with 10 input parameters of types integer and complex*16, and 3 output parameters of types integer and complex*16. The subroutine computes the Kronecker product of two sparse matrices in coordinate format and stores the result in the output parameters. The input parameters represent the dimensions and data of the two sparse matrices, and the output parameters store the dimensions and data of the resulting Kronecker product in coordinate format.", "input": "", "output": "subroutine fkron_coo(row1,col1,dat1,row2,col2,dat2,n1,n2,nrow2,ncol2,rown,coln,datn)\n    implicit none\n    integer,intent(in) :: n1,n2,nrow2,ncol2\n    integer,intent(in) :: row1(n1),col1(n1),row2(n2),col2(n2)\n    complex*16,intent(in) :: dat1(n1),dat2(n2)\n    integer,intent(out) :: rown(n1*n2),coln(n1*n2)\n    complex*16,intent(out) :: datn(n1*n2)\n    integer :: op,ed,i\n    \n    !f2py intent(in) :: n1,n2,nrow2,ncol2,row1,col1,dat1,row2,col2,dat2\n    !f2py intent(out) :: rown,coln,datn\n\n    do i=1,n1\n        op=(i-1)*n2+1\n        ed=i*n2\n        rown(op:ed)=row1(i)*nrow2+row2\n        coln(op:ed)=col1(i)*ncol2+col2\n        datn(op:ed)=dat1(i)*dat2\n    enddo\nend subroutine fkron_coo\n"}
{"instruction": "Write a Fortran subroutine named findfactor that takes an integer as input and returns the factors of the input number in an integer array along with the total number of factors. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 2, where the first output argument is an integer array and the second output argument is an integer.", "input": "", "output": "  subroutine findfactor(num, factors, nfact)\n    implicit none\n    integer,intent(in)::num\n    integer,intent(out),dimension(*)::factors\n    integer,intent(out)::nfact\n\n    ! locals\n    integer :: i, m\n\n    ! find the factors <= sqrt(num)\n    m = int(sqrt(real(num)))\n    nfact = 1\n    do i=1,m\n      if(num/i*i /= num)cycle\n      factors(nfact)= i\n      nfact = nfact + 1\n    enddo\n    nfact = nfact - 1\n\n    ! derive those > sqrt(num)\n    if(factors(nfact)**2/=num) then\n      do i=nfact+1, 2*nfact\n        factors(i) = num/factors(2*nfact-i+1)\n      enddo\n      nfact = nfact * 2\n    else\n      do i=nfact+1, 2*nfact-1\n        factors(i)= num/factors(2*nfact-i)\n      enddo\n      nfact = nfact * 2 - 1\n    endif\n  end subroutine findfactor\n"}
{"instruction": "Create a Fortran subroutine named calc_delo_p_thin_single to calculate a specific operation involving matrix multiplication and mathematical operations. The subroutine takes 6 input parameters of type real(kind=8) and dimensions, and 1 output parameter of type real(kind=8) and dimension. The input parameters are imatrix (4x4 real matrix), dx (real), j (4 real array), j1 (4 real array), ki (real), and ki1 (real). The subroutine computes the values for the output parameter p using matrix multiplication and arithmetic operations.", "input": "", "output": "      subroutine calc_delo_p_thin_single(imatrix,dx,j,j1,ki,ki1,p)\n        real(kind=8), intent(in), dimension(4,4) :: imatrix\n        real(kind=8), intent(in) :: dx,ki,ki1\n        real(kind=8), intent(in), dimension(4) :: j,j1\n        real(kind=8), intent(out), dimension(4) :: p\n        p = matmul(imatrix,(0.5d0*dx*j-1d0/6d0*dx**2d0*ki*j)+ &\n             (0.5d0*j1*dx-1d0/3d0*dx**2d0*ki*j1))\n      end subroutine calc_delo_p_thin_single\n"}
{"instruction": "Create a Fortran subroutine named calc_delo_q_thin_single to calculate the value of matrix q based on the input parameters. The subroutine takes 6 input parameters of type real(kind=8) and dimension(4,4) and one output parameter of type real(kind=8) and dimension(4,4). The subroutine performs a series of matrix calculations using the input parameters to compute the value of matrix q.", "input": "", "output": "      subroutine calc_delo_q_thin_single(imatrix,dx,ki,ki1,k1,identity,q)\n        real(kind=8), intent(in), dimension(4,4) :: imatrix,k1,identity\n        real(kind=8), intent(in) :: dx,ki,ki1\n        real(kind=8), intent(out), dimension(4,4) :: q\n        q = matmul(imatrix,identity*(1d0-0.5d0*dx*ki+1d0/6d0*dx**2d0*ki**2d0) &\n             -(0.5d0*dx-1d0/3d0*dx**2d0)*k1)\n      end subroutine calc_delo_q_thin_single\n"}
{"instruction": "Create a Fortran subroutine named \"to1stquadrant\" that transforms the input array into the first quadrant of the coordinate system. The input parameter is a 1D real array, and the output parameters are two 1D arrays of real and integer types.", "input": "", "output": "        subroutine to1stquadrant( x2in, x2out, ismirrored )\n          real(kind=8), intent(in), dimension(:) :: x2in\n          real(kind=8), intent(out), dimension(size(x2in)) :: x2out\n          integer, intent(out), dimension(size(x2in)) :: ismirrored\n          real(kind=8), dimension(size(x2in)) :: ntimes\n      \n          x2out = x2in\n          ismirrored=0\n          ntimes = floor( (x2in+2.0)/4.0 )\n          x2out = x2out - 4.*ntimes\n\n          where(x2out.gt.0.)\n             x2out = -x2out\n             ismirrored = 1-ismirrored\n          endwhere\n          where(x2out.lt.-1.)\n             x2out = -2.-x2out\n             ismirrored = 1-ismirrored\n          endwhere\n        end subroutine to1stquadrant\n"}
{"instruction": "Write a Fortran subroutine named compute_lneta_f to calculate the lneta values based on the given input parameters. The subroutine takes 7 input parameters of types integer, integer, real(8), real(8), real(8), real(8), real(8), and has 1 output parameter of type real(8). The subroutine uses imperative tone to loop through the calculations and assign the lneta values to the output parameter.", "input": "", "output": "subroutine compute_lneta_f(t,n,lnalpha,lna,lnbeta,lnf,lnp_f,lneta)\n    implicit none\n    integer, intent(in) :: t,n\n    real(8), intent(in) :: lna(n,n), lnf(t,n), lnalpha(t,n), lnbeta(t,n), lnp_f\n    real(8), intent(out) :: lneta(t-1,n,n)\n    integer :: i,j,tt\n\n    do tt = 1, t-1\n        do i = 1, n\n            do j = 1, n\n                lneta(tt,i,j) = lnalpha(tt,i) + lna(i,j) &\n                    + lnf(tt+1,j) + lnbeta(tt+1,j) - lnp_f\n            enddo\n        enddo\n    enddo\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named viterbi_f to perform the Viterbi algorithm for hidden Markov models. The subroutine takes 5 input parameters of type integer, integer, real(8), real(8), and real(8), and returns 2 output parameters of type integer(8) and real(8). ", "input": "", "output": "subroutine viterbi_f(t,n,lnpi,lna,lnf,z,lnp)\n    implicit none\n    integer, intent(in) :: t,n\n    real(8), intent(in) :: lnpi(n), lna(n,n), lnf(t,n)\n    integer(8), intent(out) :: z(t)\n    real(8), intent(out) :: lnp\n    integer :: tt,i,j,imax(1)\n    real(8) :: lndelta(t,n)\n    real(8) :: temp(n)\n\n    ! initialization\n    lndelta(1,:) = lnpi + lnf(1,:)\n\n    ! induction\n    do tt = 2, t\n        do j = 1, n\n            temp(:) = lndelta(tt-1,:) + lna(:,j)\n            lndelta(tt,j) = maxval(temp(:)) + lnf(tt,j)\n        enddo\n    enddo\n\n    lnp = maxval(lndelta(t,:))\n\n    ! traceback\n    imax = maxloc(lndelta(t,:))\n    z(t) = imax(1)\n    \n    do tt = t-1, 1, -1\n        imax = maxloc(lndelta(tt,:) + lna(:,z(tt+1)))\n        z(tt) = imax(1)\n    enddo\n\n    ! make numbering consistent to that of python\n    z(:) = z(:) - 1\n\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named check_name_value_pair_validity to validate the input name and value pairs. The subroutine takes 2 input parameters of type character(len=*) and 2 output parameters of type logical.", "input": "", "output": "  subroutine check_name_value_pair_validity( name, value, name_valid, value_valid )\n    implicit none\n\n    character(len=*), intent(in) :: name, value\n    logical, intent(out) :: name_valid, value_valid\n\n    name_valid = .true.\n    ! check validity of name\n    if ( index(name, '--', back=.true.) /= 1 ) then\n      if ( index(name, '--', back=.true.) == 0 ) then\n        write(*,*) '-- does not occur in \"', trim(name), '\"'\n        name_valid = .false.\n      else\n        write(*,*) 'name \"', trim(name), '\" is not valid - too many or incorrectly placed --s'\n        name_valid = .false.\n      end if\n    end if\n\n    value_valid = .true.\n    ! check validity of value - just check it hasn't got any spaces\n    ! todo: note that this can't really fail unless empty\n    if ( len(trim(value)) == 0) then\n      if ( trim(name) /= '--help' ) then\n        write(*,*) 'flag \"', trim(name), '\" has no associated value supplied.'\n        value_valid = .false.\n      end if\n    end if\n    if ( index(trim(value), ' ') /= 0 ) then\n      write(*,*) 'value \"', value, '\" is invalid as it contains a space'\n      value_valid = .false.\n    end if\n\n  end subroutine check_name_value_pair_validity\n"}
{"instruction": "Create a Fortran subroutine named tolowercase that takes an input string of type character(*) and converts it to lowercase. The subroutine has 1 input parameter of type character(*) and 1 output parameter of type character(*).", "input": "", "output": "\tsubroutine tolowercase( str, lcstr )\n\t\tcharacter(*), intent(in) :: str\n\t\tcharacter(*), intent(out) :: lcstr\n\t\t\n\t\tcharacter(*), parameter :: lc = 'abcdefghijklmnopqrstuvwxyz'\n\t\tcharacter(*), parameter :: uc = 'abcdefghijklmnopqrstuvwxyz'\n\t\t\n\t\tinteger :: j,k\n\t\t\n\t\tlcstr = str\n\t\tdo j=1,len_trim(str)\n\t\t\tk = index( uc, str(j:j) )\n\t\t\tif (k > 0) lcstr(j:j) = lc(k:k)\n\t\tend do\n\tend subroutine tolowercase\n"}
{"instruction": "Create a Fortran subroutine named \"appminbtomolinvol\" to calculate the mole quantities of two elements within a given volume. The subroutine takes 6 input parameters of types integer, real(8), and real(8), and 2 output parameters of type real(8). The input parameters include the scale of mole values, ppm values, mass per mole for two different elements, density, and volume. The output parameters represent the mole quantities of the two elements within the given volume.", "input": "", "output": "subroutine appminbtomolinvol(dappm, damasspermol, dbmasspermol, dbdens, dvol, imolscale, damol, dbmol)\n\n  ! input\n  ! dappm          = element a, ppm, 0.000001 mu/mu\n  ! damasspermol   = element a, mu / mol\n  ! dbmasspermol   = element b, mu / mol\n  ! dbdens         = element b, density, mass unit per unit volume  mu/lu^3\n  ! dvol           = volume, lu^3\n  ! imolscale      = scale mol values wrt to 1, 2, or total\n  ! output\n  ! damol          = mol of element a in dvol\n  ! dbmol          = mol of element b in dvol\n\n  implicit none\n\n  integer, intent(in)  :: imolscale\n  real(8), intent(in)  :: dappm, damasspermol, dbmasspermol, dbdens, dvol\n  real(8), intent(out) :: damol, dbmol\n  real(8)              :: datotalmass, dbtotalmass\n\n  ! ppm is 0.000001 mu/mu\n  ! assume total density is equal to density of solvent\n  dbtotalmass = dbdens * dvol\n  datotalmass = dbtotalmass * 0.000001 * dappm\n\n  damol = datotalmass / damasspermol\n  dbmol = dbtotalmass / dbmasspermol\n\n  if( imolscale == 1 )then\n     dbmol = dbmol / damol\n     damol = 1d0\n  else if( imolscale == 2 )then\n     damol = damol / dbmol\n     dbmol = 1d0\n  else if( imolscale == 3 )then\n     damol = damol / (damol+dbmol)\n     dbmol = 1d0 - damol\n  end if\n\n  return\n\nend subroutine appminbtomolinvol\n"}
{"instruction": "Write a Fortran subroutine named triangle to compute the squares of the lengths of the sides and the area of a triangle defined by three points x1, x2, and x3 in 3D Euclidean space. The number of input arguments is 3 and the test_data type is ['real*8', 'real*8', 'real*8'].The number of output arguments is 4 and the test_data type is ['real*8', 'real*8', 'real*8', 'real*8'].", "input": "", "output": "subroutine triangle(x1,x2,x3,l1sq,l2sq,l3sq,area)\n\n! compute the squares of the lengths of the sides and the area of\n! a triangle defined by three points x1, x2 and x3 in 3d euclidean\n! space. side 1 is opposite vertex 1, etc.\n\nimplicit none\nreal*8, intent(in) :: x1(3), x2(3), x3(3)\nreal*8, intent(out) :: l1sq, l2sq, l3sq, area\nreal*8 :: a, b, c\n\n! ---------------------------------------------------------------\n\n! squares of side by pythagoras\nl1sq = (x2(1) - x3(1))**2 + (x2(2) - x3(2))**2 + (x2(3) - x3(3))**2\nl2sq = (x3(1) - x1(1))**2 + (x3(2) - x1(2))**2 + (x3(3) - x1(3))**2\nl3sq = (x1(1) - x2(1))**2 + (x1(2) - x2(2))**2 + (x1(3) - x2(3))**2\n\n! area by heron's formula\na = sqrt(l1sq)\nb = sqrt(l2sq)\nc = sqrt(l3sq)\narea = 0.25d0*sqrt((a + b + c)*(b + c - a)*(c + a - b)*(a + b - c))\n\n! ---------------------------------------------------------------\n\nend subroutine triangle\n"}
{"instruction": "Write a Fortran subroutine named integer_flux_x to calculate the flux of a three-dimensional array based on input arrays c and q. The number of input parameters is 2, with test_data types ['real, dimension(:,:,:)','real, dimension(:,:,:)'], and the number of output parameters is 1, with test_data type ['real, dimension(:,:,:)'].", "input": "", "output": "subroutine integer_flux_x(flux, c, q)\n\nreal, intent(out),  dimension(:,:,:) :: flux\nreal, intent(in) ,  dimension(:,:,:) :: c, q\n\ninteger, dimension(size(c,1),size(c,2),size(c,3)) :: ii\ninteger :: n, i, j, k\n\nn = size(c,1)\nii = int(c)\n\nflux = 0.0\n\ndo k = 1, size(c,3)\n  do j = 1, size(c,2)\n\n      do i = 1, size(c,1)\n        if(ii(i,j,k) >= 1) then\n          if(i-ii(i,j,k) >= 1) then\n             flux(i,j,k) = sum(q(i-ii(i,j,k):i-1,j,k))\n          else\n             flux(i,j,k) = sum(q(1:i-1,j,k)) + sum(q(i-ii(i,j,k)+n:n,j,k))\n          end if\n        else if (ii(i,j,k) <= -1) then\n          if(i-1-ii(i,j,k) <= n) then\n            flux(i,j,k) = -sum(q(i:i-1-ii(i,j,k),j,k))\n          else\n            flux(i,j,k) = -sum(q(i:n,j,k)) - sum(q(1:i-1-ii(i,j,k)-n,j,k))\n          end if\n        end if\n      end do\n\n  end do\nend do\nreturn\nend subroutine integer_flux_x\n"}
{"instruction": "Write a Fortran subroutine named \"mooneyrivlinmodified\" to calculate the strain energy density \"psi\" based on the given input parameters. The subroutine should take 2 input parameters of type real*8, invc and matpar, and 1 output parameter of type real*8, psi. The \"mooneyrivlinmodified\" subroutine should use the \"intent(in)\" attribute for the input parameters and the \"intent(out)\" attribute for the output parameter.", "input": "", "output": "subroutine mooneyrivlinmodified(psi,invc,matpar)  !! the constants decrease with the deformation\n\timplicit none\n\treal*8 , intent(out) :: psi\n\treal*8 , intent(in) :: invc(:),matpar(2)\n\treal*8 :: c1,c2,i1bar,i2bar,j,ri33\n\tc1 = matpar(1)\n\tc2 = matpar(2)\n\n\tj = dsqrt(invc(3)) ! j\n\tri33 = j**(-2.0d0/3.0d0)\n\ti1bar = ri33*invc(1) ! i1bar\n\ti2bar = ri33*ri33*invc(2) ! i2bar\n\t\n\tc1 = c1/j\n\tc2 = c2/j\n\t\n\tpsi = c1*(i1bar-3.0d0) + c2*(i2bar-3.0d0)\n\treturn\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named find_bounds to calculate the bounds of a given value within an array of profile data. The subroutine takes 3 input parameters of type real, dimension(:), real, and returns 2 output parameters of type real, dimension(2).", "input": "", "output": "  subroutine find_bounds(aprof, bprof, a, abound, bbound)\n    real, dimension(:), intent(in)  :: aprof, bprof\n    real,               intent(in)  :: a\n    real, dimension(2), intent(out) :: abound, bbound\n\n    integer :: i, asize\n    logical :: found\n    \n    ! make sure input arrays match\n    asize = size(aprof)\n    if (asize /= size(bprof)) then\n       print *, \"aprof and bprof have different sizes!\", asize, size(bprof)\n       stop\n    end if\n\n    ! find bounds\n    found = .false.\n    do i = 1, asize-1\n       if (aprof(i) >= a .and. aprof(i+1) < a .or.  &\n            aprof(i) <= a .and. aprof(i+1) > a) then\n          found = .true.\n          abound(1) = aprof(i)\n          abound(2) = aprof(i+1)\n          bbound(1) = bprof(i)\n          bbound(2) = bprof(i+1)\n          exit\n       end if\n    end do\n\n    if (.not. found) then\n       print *, \"could not find bounds!\"\n       print *, aprof, a\n       stop\n    end if\n  end subroutine find_bounds\n"}
{"instruction": "Write a Fortran subroutine named getarg_a to retrieve the command-line arguments. The subroutine takes 1 input argument of type integer and returns 1 output argument of type character(*). The input argument specifies the order of the argument to retrieve.", "input": "", "output": "  subroutine getarg_a (i, arg)\n\n    integer,      intent(in)  :: i   ! order of the arguments\n    character(*), intent(out) :: arg ! argument    \n    !----\n\n    call get_command_argument( i, arg )\n    \n  end subroutine getarg_a\n"}
{"instruction": "Write a Fortran subroutine named mop4_kursawe to calculate the fitness and violation of an individual for a multi-objective optimization problem. The subroutine takes 3 input parameters of type integer, integer, and real, and 2 output parameters of type real and integer.", "input": "", "output": "subroutine mop4_kursawe(fit, indv, viol, nf, np)\n\timplicit none\n\tinteger, intent(in)::nf, np\n\treal, intent(in):: indv(np)\n\treal, intent(out):: fit(nf)\n\tinteger, intent(out)::viol\n\t\n\treal::a, b, x1, x2, x3\n\t\n\ta = 0.8\n\tb = 3.0\n\tx1 = indv(1)\n\tx2 = indv(2)\n\tx3 = indv(3)\n\t\n\tfit(1) = -10 * (exp(-0.2 * sqrt(x1**2.0 + x2**2.0)) &\n    \t\t\t  + exp(-0.2 * sqrt(x2**2.0 + x3**2.0)))\n\tfit(2) =(abs(x1))**a + 5.0*sin(x1**b) + &\n    \t\t(abs(x2))**a + 5.0*sin(x2**b) + &\n    \t\t(abs(x3))**a + 5.0*sin(x3**b)\n    \n\tviol = 0\nend subroutine mop4_kursawe\n"}
{"instruction": "Write a Fortran subroutine named c_mult to perform complex multiplication. The subroutine takes 4 input arguments of type real(kind=8) - ar, ai, br, bi and 2 output arguments of type real(kind=8) - cr, ci.", "input": "", "output": "subroutine c_mult (ar,ai,br,bi,cr,ci)\n\nimplicit none\n\nreal(kind=8), intent(in)              :: ar,ai,br,bi\nreal(kind=8), intent(out)             :: cr,ci\n\ncr = ar*br - ai*bi\nci = ar*bi + ai*br\n\nreturn\nend subroutine c_mult\n"}
{"instruction": "Write a Fortran subroutine named \"diag_double\" that takes a vector as input and generates a matrix with the diagonal elements containing the vector values. The input parameter is of type double precision, dimension(:), and intent(in), while the output parameter is of type double precision, dimension(size(vector), size(vector)), and intent(out).", "input": "", "output": "subroutine diag_double(vector, matrix)\n! provides matrix with the diagonal containing vector\n! suitable for double precision\nimplicit none\ninteger :: i\ndouble precision, dimension(:), intent(in) :: vector\ndouble precision, dimension(size(vector), size(vector)), intent(out):: matrix\nmatrix = 0.d0\n\ndo i = 1, size(vector)\n matrix(i,i) = vector(i)\nend do\nend subroutine diag_double\n"}
{"instruction": "Create a Fortran subroutine named mmul that takes two input parameters of type real, dimension(:,:) and one output parameter of type real, dimension(:,:). The subroutine computes the matrix multiplication of the input arrays a and b and stores the result in the output array c.", "input": "", "output": "  subroutine mmul(c, a, b)\n    real, dimension(:,:), intent(in) :: a,b\n    real, dimension(:,:), intent(out) :: c\n    c = matmul(a,transpose(b))\n  end subroutine mmul\n"}
{"instruction": "Write a Fortran subroutine named \"est_weirdim\" to estimate rectangular weir dimensions based on the width-depth ratio of the weir at different stages. The subroutine should take 3 input parameters of type real (depwid, desdis, cd) and provide 2 output parameters of type real (wwidth, wdepth).", "input": "", "output": "\t   subroutine est_weirdim(depwid,desdis,wwidth,wdepth,cd)\n\n   !!\tthis program estimates rectangular weir dimensions based on \n   !!\twidth-depth ratio of wier at different stages\n\n       implicit none\n       \n\t   real, intent(in) :: depwid          !             |\n       real, intent(in) :: cd              !             |\n       real, intent(in) :: desdis          !             |\n\t   real, intent(out) :: wdepth         !             |\n       real, intent(out) :: wwidth         !             |\n       real :: tempvar                     !             |\n      \n\t   tempvar=depwid**1.5\n\t   wwidth=(desdis*tempvar/(1.84*cd))**0.4\n\t   wdepth=wwidth/depwid\n\n\t   return\n\t   end subroutine est_weirdim\n"}
{"instruction": "Create a Fortran subroutine named field_h to calculate the electric and magnetic field components for a given set of input parameters. The subroutine takes 11 input parameters of types real(8), complex(8), and integer(8), and returns 3 output parameters of type complex(8).", "input": "", "output": "subroutine field_h(z,k0,y0in,kh,nh,muh,h,a,ein,eout,l,field_hy,field_ex,field_ez)\nimplicit none\n!>\n!>hy in hole cavity normalized by incident hy \n!>\nreal(8)   , intent(in) :: z\nreal(8)   , intent(in) :: k0\ncomplex(8), intent(in) :: y0in \ncomplex(8), intent(in) :: kh\ncomplex(8), intent(in) :: nh\ncomplex(8), intent(in) :: muh \nreal(8),    intent(in) :: h \nreal(8),    intent(in) :: a \ncomplex(8), intent(in) :: ein \ncomplex(8), intent(in) :: eout \nreal(8),    intent(in) :: l\ncomplex(8), intent(out):: field_hy\ncomplex(8), intent(out):: field_ex\ncomplex(8), intent(out):: field_ez \n\n!>local variables\nreal(8),    parameter :: pi = 3.d0*acos(0.5d0) \ncomplex(8), parameter :: iu=dcmplx(0.d0,1.d0)\ncomplex(8) :: hy,ex,ez \nreal(8)    :: gx01\ncomplex(8) :: gz01 \ncomplex(8) :: sin_x \nreal(8)    :: basis \n\n!>gx01\ngx01 = pi/a \n\n!>gz01\ngz01 = sqrt(dcmplx(kh**2 - gx01**2))\n\n!>obtain sin_x\nsin_x = (exp(iu*gz01*h) - exp(-iu*gz01*h))/(2.d0*iu)\n\n!>basis function  te01 normalized by amplitude of plane wave basis  \nbasis = (sqrt(2.d0)/a)*cos(0.d0)/(1.d0/l)             !y=0\n\n!>hy\nhy = ((gz01/k0)/y0in)*((ein*exp(-iu*gz01*h)+eout)*exp(iu*gz01*z)/(-2.d0*iu*sin_x) - &\n                       (ein*exp(iu*gz01*h)+eout)*exp(-iu*gz01*z)/(2.d0*iu*sin_x))*basis \n\n!>ex,ez \nex = ((ein*exp(-iu*gz01*h)+eout)*exp(iu*gz01*z)/(-2.d0*iu*sin_x) + &\n      (ein*exp(iu*gz01*h)+eout)*exp(-iu*gz01*z)/(2.d0*iu*sin_x))*basis \n\nez = 0.d0\n\n!>return values \nfield_hy = hy \nfield_ex = ex \nfield_ez = ez\nreturn \nend subroutine field_h\n"}
{"instruction": "Create a Fortran subroutine named deriv_s to carry out differentiation by wavenumber multiplication. It takes 4 input parameters: m (integer), n (integer), k (double precision array of length n), var (double precision 2D array with dimensions m and n). It outputs a double precision 2D array der with dimensions m and n+1.", "input": "", "output": "        subroutine deriv_s(m, n, k, var, der)\n            integer,          intent(in)  :: m,n\n            double precision, intent(in)  :: k(n), var(m,n)\n            double precision, intent(out) :: der(m, 0:n)\n            integer                       :: i, j\n            double precision              :: ktmp\n\n            ! carry out differentiation by wavenumber multiplication:\n            do i = 1, n-1\n                ktmp = k(i)\n                do j = 1, m\n                    der(j,i) = ktmp * var(j,i)\n                enddo\n            enddo\n\n            do j = 1, m\n                der(j, 0) = zero\n                der(j, n) = zero\n            enddo\n        end subroutine\n"}
{"instruction": "Create a Fortran subroutine named utility_recip_lattice to calculate the reciprocal lattice vectors and the cell volume. The subroutine takes 1 input parameter of type real*8 and returns 2 output parameters of type real*8.", "input": "", "output": "  subroutine utility_recip_lattice (real_lat,recip_lat,volume)  !\n    !==================================================================!\n    !                                                                  !\n    !!  calculates the reciprical lattice vectors and the cell volume\n    !                                                                  !\n    !===================================================================\n\n    implicit none\n    real*8, intent(in)  :: real_lat (3, 3)\n    real*8, intent(out) :: recip_lat (3, 3)\n    real*8, intent(out) :: volume\n\n    recip_lat(1,1)=real_lat(2,2)*real_lat(3,3)-real_lat(3,2)*real_lat(2,3)\n    recip_lat(2,1)=real_lat(3,2)*real_lat(1,3)-real_lat(3,3)*real_lat(1,2)\n    recip_lat(3,1)=real_lat(1,2)*real_lat(2,3)-real_lat(2,2)*real_lat(1,3)\n    recip_lat(1,2)=real_lat(2,3)*real_lat(3,1)-real_lat(3,3)*real_lat(2,1)\n    recip_lat(2,2)=real_lat(3,3)*real_lat(1,1)-real_lat(1,3)*real_lat(3,1)\n    recip_lat(3,2)=real_lat(2,1)*real_lat(1,3)-real_lat(2,3)*real_lat(1,1)\n    recip_lat(1,3)=real_lat(2,1)*real_lat(3,2)-real_lat(3,1)*real_lat(2,2)\n    recip_lat(2,3)=real_lat(3,1)*real_lat(1,2)-real_lat(1,1)*real_lat(3,2)\n    recip_lat(3,3)=real_lat(2,2)*real_lat(1,1)-real_lat(2,1)*real_lat(1,2)\n\n    volume=real_lat(1,1)*recip_lat(1,1) + &\n         real_lat(2,1)*recip_lat(2,1) + &\n         real_lat(3,1)*recip_lat(3,1)\n\n    recip_lat=2.*acos(-1.0)*recip_lat/volume\n    volume=abs(volume)\n\n  end subroutine utility_recip_lattice\n"}
{"instruction": "Create a Fortran subroutine named dcomputewspd to calculate the wind speed magnitude from the horizontal wind components. The subroutine takes 3 input parameters of types integer, real(kind=8) arrays of dimension n, and real(kind=8) arrays of dimension n. It returns 1 output parameter of type real(kind=8) array of dimension n.", "input": "", "output": "subroutine dcomputewspd(wspd, u, v, n)\n\n    implicit none\n\n    !f2py threadsafe\n    !f2py intent(in,out) :: wspd\n\n    integer, intent(in) :: n\n    real(kind=8), dimension(n), intent(out) :: wspd\n    real(kind=8), dimension(n), intent(in) :: u, v\n! nclend\n\n    integer i\n\n    !$omp parallel do schedule(runtime)\n    do i = 1,n\n        wspd(i) = sqrt(u(i)*u(i) + v(i)*v(i))\n    end do\n    !$omp end parallel do\n\nend subroutine dcomputewspd\n"}
{"instruction": "Write a Fortran subroutine named linur to solve a system of linear equations using the Upper-Right Cholesky Decomposition method. The subroutine takes 4 input parameters of types integer, integer, double precision array, and double precision array. It returns 2 output parameters of types integer and double precision array.", "input": "", "output": "  subroutine linur(dimen,npar,coeff,constant,solution,error)\n\n  integer,intent(in)  :: dimen,npar\n  integer,intent(out) :: error \n  double precision,intent(in)  :: coeff(npar,npar),constant(npar)\n  double precision,intent(out) :: solution(npar)\n  double precision          :: a0(npar,npar)\n  double precision          :: c\n  integer                   :: i1,i2,i,k8,k,l,k9\n\n  !----- begin ----!\n  \n    do i1=1,dimen\n    do i2=1,dimen \n       a0(i1,i2)=coeff(i1,i2)\n    enddo\n    enddo\n\n    do i=1,dimen\n      solution(i)=constant(i)\n    enddo\n    error=0\n    do i=1,dimen\n      c=0\n      k8=i-1\n      do k=1,k8\n        c=c+a0(k,i)*a0(k,i)\n      enddo\n\n      if (c.ge.a0(i,i)) then\n      !      write(f_out,*) '(',i,'-th adj. parameter is wrong )'\n       error=i\n       return\n      endif\n\n      a0(i,i)=sqrt(a0(i,i)-c)\n      if (a0(i,i).eq.0) then\n      !      write(f_out,*) '(',i,'-th adj. parameter is wrong )'\n         error=i\n         return\n      endif\n      k8=i+1\n      do l=k8,dimen\n         k9=i-1\n         c=0.0\n         do k=1,k9 \n            c=c+a0(k,i)*a0(k,l)\n         enddo\n         a0(i,l)=(a0(l,i)-c)/a0(i,i)\n      enddo\n    enddo\n    do i=1,dimen\n      k8=i-1\n      c=0.0\n      do k=1,k8\n         c=c+a0(k,i)*solution(k)\n      enddo\n      solution(i)=(solution(i)-c)/a0(i,i)\n    enddo\n    do i1=1,dimen\n      i=1+dimen-i1\n      k8=i+1\n      c=0.0\n      do k=k8,dimen\n          c=c+a0(i,k)*solution(k)\n      enddo\n      solution(i)=(solution(i)-c)/a0(i,i)\n    enddo\n  return\n  end subroutine linur\n"}
{"instruction": "Create a Fortran subroutine named \"dhkmrk\" to evaluate a feature based on the input feature index and value. The subroutine should take 2 input parameters of type integer and 1 output parameter of type integer. The input parameters should be named \"iknmrk\" and \"kenmrk\", and the output parameter should be named \"knmrki\".", "input": "", "output": "subroutine dhkmrk ( iknmrk , kenmrk , knmrki )\n!----- gpl ---------------------------------------------------------------------\n!                                                                               \n!  copyright (c)  stichting deltares, 2012-2016.                                \n!                                                                               \n!  this program is free software: you can redistribute it and/or modify         \n!  it under the terms of the gnu general public license as published by         \n!  the free software foundation version 3.                                      \n!                                                                               \n!  this program is distributed in the hope that it will be useful,              \n!  but without any warranty; without even the implied warranty of               \n!  merchantability or fitness for a particular purpose.  see the                \n!  gnu general public license for more details.                                 \n!                                                                               \n!  you should have received a copy of the gnu general public license            \n!  along with this program.  if not, see <http://www.gnu.org/licenses/>.        \n!                                                                               \n!  contact: delft3d.support@deltares.nl                                         \n!  stichting deltares                                                           \n!  p.o. box 177                                                                 \n!  2600 mh delft, the netherlands                                               \n!                                                                               \n!  all indications and logos of, and references to, \"delft3d\" and \"deltares\"    \n!  are registered trademarks of stichting deltares, and remain the property of  \n!  stichting deltares. all rights reserved.                                     \n!                                                                               \n!-------------------------------------------------------------------------------\n!  $id: dhkmrk.f90 5717 2016-01-12 11:35:24z mourits $\n!  $headurl: https://svn.oss.deltares.nl/repos/delft3d/tags/6686/src/utils_gpl/morphology/packages/morphology_proclib/src/dhkmrk.f90 $\n!!--description-----------------------------------------------------------------\n!\n! utility that evaluates a feature from the \"feature\" integer\n!\n!!--declarations----------------------------------------------------------------\n    integer, intent(in)  :: iknmrk  ! index of feature\n    integer, intent(in)  :: kenmrk  ! feature\n    integer, intent(out) :: knmrki  ! evaluated feature\n!\n!   local\n!\n    integer dhimis\n!\n    if ( iknmrk .eq. 1 ) then\n       knmrki = mod(kenmrk,10)\n    elseif ( iknmrk .eq. 2 ) then\n       knmrki = kenmrk / 10\n       knmrki = mod(knmrki,10)\n    elseif ( iknmrk .le. 0 .or. iknmrk .gt. 9 ) then\n       dhimis = -999.\n       knmrki = dhimis\n    else\n       knmrki = kenmrk / 10**(iknmrk-1)\n       knmrki = mod(knmrki,10)\n    endif\n\n    return\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"io_pathextract\" to extract the path and filename from a given path+filename string. The subroutine should have 1 input parameter of type character(len=*), and 3 optional output parameters of types character(len=*), character(len=*), and logical.", "input": "", "output": "  subroutine io_pathextract (sfile, sfilepath, sfilename, babsolute)\n\n  !<description>\n    ! extracts the path of a file from a path+filename string.\n  !</description>\n\n  !<input>\n    ! filename + path of a specific file (or directory).\n    character(len=*), intent(in) :: sfile\n  !</input>\n\n  !<output>\n    ! optional: receives the directory that contains the specific file,\n    ! or \"\" if no directory was specified in sfile.\n    character(len=*), intent(out), optional :: sfilepath\n\n    ! optional: receives the name of the file without a probably preceding\n    ! directory string.\n    character(len=*), intent(out), optional :: sfilename\n\n    ! optional: returns true if the path specification in sfile points to an\n    ! absolute path. returns false if the path in sfile is relative.\n    logical, intent(out), optional :: babsolute\n  !</output>\n\n\n    integer :: i\n    character(len=10) :: ssubpath\n\n    ! find the last \"/\" or \"\\\" in sfile.                                (!\" cpp fix)\n    ! note that we specified \"\\\\\" and not \"\\\" because the pgi compiler  (!\" cpp fix)\n    ! (stupid thing) would otherwise use the backslash to escape the quote\n    ! character. so pgi sees \"/\\\" and other compiler see \"/\\\\\", but this (!\" cpp fix)\n    ! does not matter since the string must only contain a couple of\n    ! delimiters which may occur more than once in the string.\n    i = scan(sfile,\"/\\\\\",.true.)\n    if (i .ne. 0) then\n      ! directory ends at position i.\n      if (present(sfilepath)) sfilepath = sfile(1:i-1)\n      if (present(sfilename)) sfilename = sfile(i+1:)\n    else\n      ! no directory specified.\n      if (present(sfilepath)) sfilepath = \"\"\n      if (present(sfilename)) sfilename = sfile\n    end if\n\n    if (present(babsolute)) then\n      ! take a look if this is an absolute or relative path.\n      i = scan(trim(adjustl(sfile)),\"/\\\\\",.false.)\n      babsolute = i .eq. 1\n\n      ! in windows environments, the path is also absolute if\n      ! a volume descriptor like \"c:\" precedes the (back-)slash.\n      if (.not. babsolute) then\n        if (i .eq. 3) then\n          ! extract the first 10 characters and check\n          ssubpath = trim(adjustl(sfile))\n          if (ssubpath(2:2) .eq. \":\") then\n            babsolute = .true.\n          end if\n        end if\n      end if\n    end if\n\n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named linear_regression to perform linear regression analysis. The subroutine takes 2 input parameters of type real, and the output consists of 3 parameters, all of type real.", "input": "", "output": "    subroutine linear_regression(x_arr, y_arr, a, b, r)\n        implicit none\n        real, intent(in)  :: x_arr(:)\n        real, intent(in)  :: y_arr(:)\n        real, intent(out) :: a\n        real, intent(out) :: b\n        real, intent(out) :: r\n        integer :: n\n        real :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, det\n\n        n = size(x_arr)\n        if (n /= size(y_arr)) then\n            stop \"linear_regression: arrays must be of the same size.\"\n        end if\n        sum_x  = sum(x_arr)\n        sum_y  = sum(y_arr)\n        sum_xx = sum(x_arr * x_arr)\n        sum_yy = sum(y_arr * y_arr)\n        sum_xy = sum(x_arr * y_arr)\n        det = n * sum_xx - sum_x**2\n        b = (n * sum_xy - sum_x * sum_y) / det\n        a = (sum_y - b * sum_x) / n\n        r = b * sqrt( det / (n * sum_yy - sum_y**2) )\n        return\n    end subroutine linear_regression\n"}
{"instruction": "Write a Fortran subroutine named get1dpbc to calculate periodic boundary conditions for a one-dimensional system. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are pos and lsze, while the output parameters are r and l. The subroutine should calculate the values of r and l based on the input parameters pos and lsze using periodic boundary conditions.", "input": "", "output": "\tsubroutine get1dpbc(pos, lsze, r, l)\n\t  integer, intent(in) :: pos, lsze\n\t  integer, intent(out) :: r, l\n\t  r = pos + 1\n\t  if(pos .eq. lsze)  then\n\t    r = 1\n\t  endif\n\t  l = pos - 1\n\t  if(l .eq. 0)  then\n\t    l = lsze\n\t  endif\n\tend subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"inverse_ordered_comb2_iterator\" to handle the inverse ordered combination of binary data. The subroutine should take 3 input arguments of type integer, integer, and integer array with dimensions (0:h-1, 0:l-1), and 1 output argument of type integer array with dimensions (0:h-1, 0:l/2-1).", "input": "", "output": "    subroutine inverse_ordered_comb2_iterator(binary, h, l, returnparam)\n      implicit none\n      integer, intent(in) :: h, l\n      integer, dimension(0:h-1, 0:l-1), intent(in) :: binary\n      integer, dimension(0:h-1, 0:l/2-1), intent(out) :: returnparam\n\n      integer :: i, j, m\n      integer ::  selectedlevel, x\n      integer, dimension(0:3, 0:1) :: level\n      integer, dimension(0:h-1, 0:l/2-1) :: restored\n      real :: top, base, color, intervalsize\n\n      level(0, :) = (/ 0, 0/)\n      level(1, :) = (/ 0, 1 /)\n      level(2, :) = (/ 1, 0 /)\n      level(3, :) = (/ 1, 1 /)\n      intervalsize = 255.0 / 4.0\n      do i = 0, h - 1\n        do j = 0, l - 1, 2\n          do x = 0, 3\n            selectedlevel = 0\n            do m = 0, 1\n              if (binary(i, j + m) == level(x, m)) then\n                selectedlevel = selectedlevel + 1\n              end if\n            end do\n            if (selectedlevel == 2) then\n              selectedlevel = x\n              exit\n            end if\n          end do\n          base = selectedlevel * intervalsize\n          top = base + intervalsize\n          color = base + (top - base) * rand()\n          restored(i, j / 2) = int(color)\n        end do\n      end do\n      returnparam = restored\n    end subroutine inverse_ordered_comb2_iterator\n"}
{"instruction": "Create a Fortran subroutine named inverse_3_3 to calculate the inverse of a 3x3 real-valued matrix. The subroutine takes one input parameter of type real(kind=8), dimension(3,3) and one output parameter of the same type and dimensions.", "input": "", "output": "   subroutine inverse_3_3 (a,ainv)\n\n      real(kind=8), dimension(3,3), intent(in) :: a\n      real(kind=8), dimension(3,3), intent(out) :: ainv\n      real(kind=8) :: deta\n      integer :: i, j\n\n      if (size(a,1) .ne. 3) then\n         write(*,*) \"matrix is not 3x3\"\n         stop\n      end if\n\n      if (size(a,2) .ne. 3) then\n         write(*,*) \"matrix is not 3x3\"\n         stop\n      end if\n\n      ! determine the determinant\n      deta = a(1,1)*a(2,2)*a(3,3) - a(1,1)*a(2,3)*a(3,2) - &\n         a(1,2)*a(2,1)*a(3,3) + a(1,2)*a(2,3)*a(3,1) + &\n         a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1)\n      write(*,*) \"deta:\", deta\n\n      if (dabs(deta) .le. 0.0000000001) then\n         write(*,*) \"matrix is sinuglar (deta ~ 0)\"\n         stop\n      end if\n\n      ! determine the inverse:\n      ainv(1,1) = 1/deta * (a(2,2)*a(3,3) - a(3,2)*a(2,3))\n      ainv(1,2) = 1/deta * (a(1,3)*a(3,2) - a(3,3)*a(1,2))\n      ainv(1,3) = 1/deta * (a(1,2)*a(2,3) - a(2,2)*a(1,3))\n      ainv(2,1) = 1/deta * (a(2,3)*a(3,1) - a(3,3)*a(2,1))\n      ainv(2,2) = 1/deta * (a(1,1)*a(3,3) - a(3,1)*a(1,3))\n      ainv(2,3) = 1/deta * (a(1,3)*a(2,1) - a(2,3)*a(1,1))\n      ainv(3,1) = 1/deta * (a(2,1)*a(3,2) - a(3,1)*a(2,2))\n      ainv(3,2) = 1/deta * (a(1,2)*a(3,1) - a(3,2)*a(1,1))\n      ainv(3,3) = 1/deta * (a(1,1)*a(2,2) - a(2,1)*a(1,2))\n      do i = 1, 3\n         write(*,*) (ainv(i,j), j = 1, 3)\n      end do\n\n   end subroutine inverse_3_3\n"}
{"instruction": "Create a Fortran subroutine named assigncomplex to convert a complex number to a 2x2 real matrix. The subroutine has 1 input parameter of type complex*16 and 1 output parameter of type real*8.", "input": "", "output": "subroutine assigncomplex(realmat,complexf)\n  implicit none\n  complex*16,intent(in) :: complexf\n  real*8,intent(out) :: realmat(2,2)\n  realmat(1,1)=real(complexf,8);  realmat(2,2)=real(complexf,8)\n  realmat(2,1)=imag(complexf);  realmat(1,2)=(-1)*imag(complexf)\nend subroutine assigncomplex\n"}
{"instruction": "Write a Fortran subroutine named xpoint to calculate the intersection point of two given lines. The subroutine takes 6 input parameters of type real(8) and returns 2 output parameters of type real(8).", "input": "", "output": "  pure subroutine xpoint(x1,y1,x2,y2,xp,yp,xx,yx)\n    real(8),intent(in)  :: x1,y1,x2,y2,xp,yp\n    real(8),intent(out) :: xx,yx\n\n    !local variables\n    real(8)::slopel,slopeg\n\n    if (x1.ne.x2 .and. y1.ne.y2) then\n        slopel = (y2-y1)/(x2-x1)\n        slopeg = -1d0/slopel\n        xx     = (slopel*x1-slopeg*xp+yp-y1)/(slopel-slopeg)\n        yx     = slopeg*xx - slopeg*xp + yp\n    elseif (x1 .eq. x2) then\n        xx = x1\n        yx = yp\n    elseif (y1 .eq. y2) then\n        xx = xp\n        yx = y1\n    end if\n\n  end subroutine xpoint\n"}
{"instruction": "Write a Fortran subroutine named preparetitle that constructs a title string from an array of strings. The subroutine takes 3 input parameters of type character array, integer, and integer, and 1 output parameter of type character.", "input": "", "output": "  subroutine preparetitle(title,titlelines,titlelength,titlestartlocation)\n    character(len=*),intent(out)::title\n    character(len=*),intent(in),dimension(:)::titlelines\n    integer,intent(in)::titlelength,titlestartlocation\n\n    !local variables\n    integer::indx\n    character(len=titlestartlocation-1)::lead\n    lead=adjustl('*')\n\n    !first line\n    title=lead//repeat('*',titlelength)//new_line('x')\n\n    !middle lines\n    do indx=1,size(titlelines)\n      title=trim(title)//lead//'*'//titlelines(indx)(1:titlelength-2)//'*'//new_line('x')\n    end do\n\n    !last line\n    title=trim(title)//lead//repeat('*',titlelength)\n\n  end subroutine preparetitle  \n"}
{"instruction": "Write a Fortran subroutine named convertid_to_index_array. The subroutine takes 2 input parameters of type integer array and 1 output parameter of type integer array. The function maps the values of the first input array to their corresponding indices in the second input array and returns the indices in the output array.", "input": "", "output": "  subroutine convertid_to_index_array(ids,allids,indices)\n    integer,intent(in)  :: ids(:),allids(:)\n    integer,intent(out) :: indices(:)\n    \n    !local variables\n    integer :: indx,indx1\n    \n    !initialize\n    indices = 0\n    \n    do indx=1,size(ids)\n        if (ids(indx) .eq. 0) cycle\n        \n        do indx1=1,size(allids)\n            if (ids(indx) .eq. allids(indx1)) then\n                indices(indx) = indx1\n                exit\n            end if\n        end do\n    end do\n\n  end subroutine convertid_to_index_array\n"}
{"instruction": "Write a Fortran subroutine named k2indx that takes 2 input arguments of type integer array and produces 1 output argument of type integer. The input arguments are intent(in) and the output argument is intent(out). The function computes the index using the provided formula and assigns it to the output argument.", "input": "", "output": "subroutine k2indx(indx, k, div)\n  implicit none\n  integer, intent(out):: indx\n  integer, intent(in) :: k(3), div(3)\n  indx = ( k(1)*div(2) + k(2) )*div(3) + k(3)\nend subroutine k2indx\n"}
{"instruction": "Create a Fortran subroutine named \"indx2k\" to convert a single index value into a three-dimensional array index. The subroutine should take 2 input parameters of type integer and 1 output parameter of type integer. The input parameters should be named \"indx\" and \"div\" and the output parameter should be named \"k\".", "input": "", "output": "subroutine indx2k(k, indx, div)\n  implicit none\n  integer, intent(out):: k(3)\n  integer, intent(in) :: indx, div(3)\n  !\n  integer :: i1 \n  k(3) = mod(indx,  div(3))\n  i1 = indx / div(3)\n  k(2) = mod(i1, div(2))\n  k(1) = i1 / div(2)\nend subroutine indx2k\n"}
{"instruction": "Create a Fortran subroutine named matrixinverse3x3 to compute the inverse of a 3x3 matrix. The subroutine takes one input parameter of type real array with dimensions (3,3) and one output parameter of type real array with dimensions (3,3). The subroutine uses the Gauss-Jordan method to calculate the inverse of the input matrix.", "input": "", "output": "  subroutine matrixinverse3x3(ia,a)\n    !--------------------------------------------------------------------------\n    implicit none\n    !--------------------------------------------------------------------------\n    ! argument list declaration\n    real                        :: ia(3,3)\n    real                        :: a(3,3)\n    ! local variable declaration\n    real                        :: t4,t6,t8,t10,t12,t14,t17\n    !--------------------------------------------------------------------------\n    intent(in)                  :: a\n    intent(out)                 :: ia\n    !--------------------------------------------------------------------------\n    !\n    t4 = a(1,1)*a(2,2)      \n    t6 = a(1,1)*a(2,3)\n    t8 = a(1,2)*a(2,1)\n    t10 = a(1,3)*a(2,1)\n    t12 = a(1,2)*a(3,1)\n    t14 = a(1,3)*a(3,1)\n    t17 = 1/(t4*a(3,3)-t6*a(3,2)-t8*a(3,3)+t10*a(3,2)+t12*a(2,3)-t14*a(2,2))\n    ia(1,1) = (a(2,2)*a(3,3)-a(2,3)*a(3,2))*t17\n    ia(1,2) = -(a(1,2)*a(3,3)-a(1,3)*a(3,2))*t17\n    ia(1,3) = (a(1,2)*a(2,3)-a(1,3)*a(2,2))*t17\n    ia(2,1) = -(a(2,1)*a(3,3)-a(2,3)*a(3,1))*t17\n    ia(2,2) = (a(1,1)*a(3,3)-t14)*t17\n    ia(2,3) = -(t6-t10)*t17\n    ia(3,1) = (a(2,1)*a(3,2)-a(2,2)*a(3,1))*t17\n    ia(3,2) = -(a(1,1)*a(3,2)-t12)*t17\n    ia(3,3) = (t4-t8)*t17\n    !\n  end subroutine matrixinverse3x3\n"}
{"instruction": "Create a Fortran subroutine named decrypt that takes two input arguments of type character(*) and one input argument of type character(*). The input arguments are intxt, k, and the output argument is outtxt. The subroutine decrypts the input text using a specified key and stores the decrypted text in the outtxt variable.", "input": "", "output": "subroutine decrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n\n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    chrn = iachar(intxt(i:i))\n    outtxt(cp:cp) = achar(modulo(chrn - iachar(k(kp:kp)), 26) + 65)\n    cp = cp + 1\n    kp = kp + 1\n    if(kp > len(k)) kp = kp - len(k)\n   end do\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named args_env_c that retrieves the value of an environment variable specified by the input parameter name. The number of input parameters is 1, with a test_data type of ['character(len=*)']. The number of output parameters is 2, with a test_data type of ['character(len=*)', 'integer, optional'].", "input": "", "output": "  subroutine args_env_c(name, value, stat)\n\n    implicit none\n    \n    character(len=*),           intent(in)  :: name\n    character(len=*),           intent(out) :: value\n    integer,          optional, intent(out) :: stat\n\n    integer :: status\n\n    status = 0\n    call get_environment_variable(name=trim(name), value=value, status=status)\n    if (present(stat)) stat = status\n\n  end subroutine args_env_c\n"}
{"instruction": "Create a Fortran subroutine named poly_long_div to perform polynomial long division. It takes 2 input parameters of type real, dimension(:) and allocates 2 output parameters of type real, dimension(:), allocatable and real, dimension(:), allocatable, optional. Ensure to allocate memory for the output arrays as needed.", "input": "", "output": "  subroutine poly_long_div(n, d, q, r)\n    real, dimension(:), intent(in) :: n, d\n    real, dimension(:), intent(out), allocatable :: q\n    real, dimension(:), intent(out), allocatable, optional :: r\n\n    real, dimension(:), allocatable :: nt, dt, rt\n    integer :: gn, gt, gd\n\n    if ( (size(n) >= size(d)) .and. (size(d) > 0) .and. (size(n) > 0) ) then\n       allocate(nt(size(n)), dt(size(n)), rt(size(n)))\n\n       nt = n\n       dt = 0\n       dt(1:size(d)) = d\n       rt = 0\n       gn = size(n)-1\n       gd = size(d)-1\n       gt = 0\n\n       do while ( d(gd+1) == 0 )\n          gd = gd - 1\n       end do\n\n       do while( gn >= gd )\n          dt = eoshift(dt, -(gn-gd))\n          rt(gn-gd+1) = nt(gn+1) / dt(gn+1)\n          nt = nt - dt * rt(gn-gd+1)\n          gt = max(gt, gn-gd)\n          do\n             gn = gn - 1\n             if ( nt(gn+1) /= 0 ) exit\n          end do\n          dt = 0\n          dt(1:size(d)) = d\n       end do\n\n       allocate(q(gt+1))\n       q = rt(1:gt+1)\n       if ( present(r) ) then\n          if ( (gn+1) > 0 ) then\n             allocate(r(gn+1))\n             r = nt(1:gn+1)\n          else\n             allocate(r(1))\n             r = 0.0\n          end if\n       end if\n       deallocate(nt, dt, rt)\n    else\n       allocate(q(1))\n       q = 0\n       if ( present(r) ) then\n          allocate(r(size(n)))\n          r = n\n       end if\n    end if\n\n  end subroutine poly_long_div\n"}
{"instruction": "Create a Fortran subroutine named mooney_rivlin_s_sv_and_c to calculate stress, second Piola-Kirchhoff stress, and material stiffness. The subroutine takes 4 input parameters of type real(8) and produces 3 output parameters of type real(8).", "input": "", "output": "subroutine mooney_rivlin_s_sv_and_c(e, s, sv, c_se, a10, a01, kappa)\n      implicit none\n      real(8), intent(in) :: e(3,3), a10, a01, kappa\n      real(8), intent(out) :: s(3,3), sv(6), c_se(6,6)\n      real(8) :: c(3,3), i1e(6,1), i2e(6,1), i3e(6,1), i2ee(6,6), i3ee(6,6), &\n                 j1e(6,1), j2e(6,1), j3e(6,1), eye(3,3), j1ee(6,6), j2ee(6,6), j3ee(6,6)\n      real(8) :: c11, c22, c33, c23, c13, c12, i1, i2, i3, j3, &\n                 j1i1, j1i3, j2i2, j2i3, j3i3, j1i1i3, j1i3i3, j2i2i3, j2i3i3, j3i3i3\n\n      eye = reshape((/1, 0, 0, 0, 1, 0, 0, 0, 1/), shape(eye))\n      c = 2*e + eye\n\n      c11 = c(1,1)\n      c22 = c(2,2)\n      c33 = c(3,3)\n      c23 = c(2,3)\n      c13 = c(1,3)\n      c12 = c(1,2)\n!     invariants and reduced invariants\n      i1  = c11 + c22 + c33\n      i2  = c11*c22 + c11*c33 - c12**2 - c13**2 + c22*c33 - c23**2\n      i3  = c11*c22*c33 - c11*c23**2 - c12**2*c33 + 2*c12*c13*c23 - c13**2*c22\n\n      j3  = sqrt(i3)\n!     derivatives\n      j1i1 = i3**(-1.0/3.0d0)\n      j1i3 = -i1/(3*i3**(4.0d0/3.00d0))\n      j2i2 = i3**(-2.0d0/3)\n      j2i3 = -2.0d0*i2/(3.0d0*i3**(5.0d0/3))\n      j3i3 = 1./(2.0d0*sqrt(i3))\n\n      i1e = reshape((/2., 2., 2., 0., 0., 0./), shape(i1e))\n      i2e = reshape((/2*c22 + 2*c33, 2*c11 + 2*c33, 2*c11 + 2*c22, -2*c23, -2*c13, -2*c12/), shape(i2e))\n      i3e = reshape((/2*c22*c33 - 2*c23**2, 2*c11*c33 - 2*c13**2, 2*c11*c22 - 2*c12**2, &\n           -2*c11*c23 + 2*c12*c13, 2*c12*c23 - 2*c13*c22, -2*c12*c33 + 2*c13*c23/), shape(i3e))\n\n      j1e = j1i1*i1e + j1i3*i3e\n      j2e = j2i2*i2e + j2i3*i3e\n      j3e = j3i3*i3e\n\n!       sv = reshape(j3e, (/6/))\n      sv = a10*reshape(j1e, (/6/)) + a01*reshape(j2e, (/6/)) + kappa*(j3 - 1)*reshape(j3e, (/6/))\n      s = reshape((/sv(1), sv(6), sv(5), &\n                    sv(6), sv(2), sv(4), &\n                    sv(5), sv(4), sv(3)/), shape(s))\n\n      i2ee = reshape((/0.0d0, 4.0d0, 4.0d0,  0.0d0,  0.0d0,  0.0d0, &\n                       4.0d0, 0.0d0, 4.0d0,  0.0d0,  0.0d0,  0.0d0, &\n                       4.0d0, 4.0d0, 0.0d0,  0.0d0,  0.0d0,  0.0d0, &\n                       0.0d0, 0.0d0, 0.0d0, -2.0d0,  0.0d0,  0.0d0, &\n                       0.0d0, 0.0d0, 0.0d0,  0.0d0, -2.0d0,  0.0d0, &\n                       0.0d0, 0.0d0, 0.0d0,  0.0d0,  0.0d0, -2.0d0/), shape(i2ee))\n\n      i3ee = reshape((/    0.0d0,  4.0d0*c33,  4.0d0*c22, -4.0d0*c23,      0.0d0,      0.0d0, &\n                       4.0d0*c33,      0.0d0,  4.0d0*c11,      0.0d0, -4.0d0*c13,      0.0d0, &\n                       4.0d0*c22,  4.0d0*c11,      0.0d0,      0.0d0,      0.0d0, -4.0d0*c12, &\n                      -4.0d0*c23,      0.0d0,      0.0d0, -2.0d0*c11,  2.0d0*c12,  2.0d0*c13, &\n                           0.0d0, -4.0d0*c13,      0.0d0,  2.0d0*c12, -2.0d0*c22,  2.0d0*c23, &\n                           0.0d0,      0.0d0, -4.0d0*c12,  2.0d0*c13,  2.0d0*c23, -2.0d0*c33/), shape(i3ee))\n\n!     second derivatives\n      j1i1i3 = -1.0d0/(3.0d0*i3**(4.0d0/3))\n      j1i3i3 = 4*i1/(9*i3**(7.0d0/3))\n      j2i2i3 = -2.0d0/(3*i3**(5.0d0/3))\n      j2i3i3 = 10*i2/(9*i3**(8.0d0/3))\n      j3i3i3 = -1.0d0/(4*i3**(3.0d0/2))\n\n      j1ee = j1i1i3*(matmul(i1e, transpose(i3e)) + matmul(i3e, transpose(i1e))) &\n               + j1i3i3*matmul(i3e, transpose(i3e)) + j1i3*i3ee\n      j2ee = j2i2i3*(matmul(i2e, transpose(i3e)) + matmul(i3e, transpose(i2e))) &\n                        + j2i3i3*matmul(i3e, transpose(i3e)) + j2i2*i2ee + j2i3*i3ee\n      j3ee = j3i3i3*(matmul(i3e, transpose(i3e))) + j3i3*i3ee\n\n      c_se = a10*j1ee + a01*j2ee + kappa*(matmul(j3e, transpose(j3e))) + kappa*(j3-1)*j3ee\n\nend subroutine mooney_rivlin_s_sv_and_c\n"}
{"instruction": "Create a Fortran subroutine named \"neo_hookean_s_sv_and_c\" to calculate the stress, second Piola-Kirchhoff stress, and tangent modulus tensor based on the input strain and material parameters. The subroutine takes 3 input parameters of type real(8) and 3 output parameters of type real(8).", "input": "", "output": "subroutine neo_hookean_s_sv_and_c(e, s, sv, c_se, mu, kappa)\n      implicit none\n      real(8), intent(in) :: e(3,3), mu, kappa\n      real(8), intent(out) :: s(3,3), sv(6), c_se(6,6)\n      real(8) :: c(3,3), i1e(6,1), i3e(6,1), i3ee(6,6), j1e(6,1), j3e(6,1), eye(3,3), j1ee(6,6), j3ee(6,6)\n      real(8) :: c11, c22, c33, c23, c13, c12, i1, i3, j3, j1i1, j1i3, j3i3, j1i1i3, j1i3i3, j3i3i3\n\n      eye = reshape((/1, 0, 0, 0, 1, 0, 0, 0, 1/), shape(eye))\n      c = 2*e + eye\n\n      c11 = c(1,1)\n      c22 = c(2,2)\n      c33 = c(3,3)\n      c23 = c(2,3)\n      c13 = c(1,3)\n      c12 = c(1,2)\n!     invariants and reduced invariants\n      i1  = c11 + c22 + c33\n      i3  = c11*c22*c33 - c11*c23**2 - c12**2*c33 + 2*c12*c13*c23 - c13**2*c22\n\n      j3  = sqrt(i3)\n!     derivatives\n      j1i1 = i3**(-1.0/3.0d0)\n      j1i3 = -i1/(3*i3**(4.00d0/3.00d0))\n      j3i3 = 1./(2.0d0*sqrt(i3))\n\n      i1e = reshape((/2., 2., 2., 0., 0., 0./), shape(i1e))\n      i3e = reshape((/2*c22*c33 - 2*c23**2, 2*c11*c33 - 2*c13**2, 2*c11*c22 - 2*c12**2, &\n           -2*c11*c23 + 2*c12*c13, 2*c12*c23 - 2*c13*c22, -2*c12*c33 + 2*c13*c23/), shape(i3e))\n\n      j1e = j1i1*i1e + j1i3*i3e\n      j3e = j3i3*i3e\n\n      sv = mu/2.*reshape(j1e, (/6/)) + kappa*(j3 - 1)*reshape(j3e, (/6/))\n      s = reshape((/sv(1), sv(6), sv(5), &\n                    sv(6), sv(2), sv(4), &\n                    sv(5), sv(4), sv(3)/), shape(s))\n\n      i3ee = reshape((/    0.0d0,  4.0d0*c33,  4.0d0*c22, -4.0d0*c23,      0.0d0,      0.0d0, &\n                       4.0d0*c33,      0.0d0,  4.0d0*c11,      0.0d0, -4.0d0*c13,      0.0d0, &\n                       4.0d0*c22,  4.0d0*c11,      0.0d0,      0.0d0,      0.0d0, -4.0d0*c12, &\n                      -4.0d0*c23,      0.0d0,      0.0d0, -2.0d0*c11,  2.0d0*c12,  2.0d0*c13, &\n                           0.0d0, -4.0d0*c13,      0.0d0,  2.0d0*c12, -2.0d0*c22,  2.0d0*c23, &\n                           0.0d0,      0.0d0, -4.0d0*c12,  2.0d0*c13,  2.0d0*c23, -2.0d0*c33/), shape(i3ee))\n\n!     second derivatives\n      j1i1i3 = -1.0d0/(3.0d0*i3**(4.0d0/3))\n      j1i3i3 = 4*i1/(9*i3**(7.0d0/3))\n      j3i3i3 = -1.0d0/(4*i3**(3.0d0/2))\n\n      j1ee = j1i1i3*(matmul(i1e, transpose(i3e)) + matmul(i3e, transpose(i1e))) &\n               + j1i3i3*matmul(i3e, transpose(i3e)) + j1i3*i3ee\n      j3ee = j3i3i3*(matmul(i3e, transpose(i3e))) + j3i3*i3ee\n\n      c_se = mu/2*j1ee + kappa*(matmul(j3e, transpose(j3e))) + kappa*(j3-1)*j3ee\n\nend subroutine neo_hookean_s_sv_and_c\n"}
{"instruction": "Write a Fortran subroutine named \"kirchhoff_s_sv_and_c\" that takes 3 input parameters of type real(8) and 3 output parameters of type real(8). The subroutine computes the stress tensor (s), the symmetric part of the strain tensor (sv), and the elasticity matrix (c_se) based on the input strain tensor (e), the Young's modulus (e_modul), and Poisson's ratio (nu). Use the imperative tone to define the subroutine and specify the number and type of input and output parameters.", "input": "", "output": "subroutine kirchhoff_s_sv_and_c(e, s, sv, c_se, e_modul, nu)\n    implicit none\n    real(8), intent(in) :: e(3,3), e_modul, nu\n    real(8), intent(out) :: s(3,3), sv(6), c_se(6,6)\n    real(8) :: lam, mu, ev(6)\n\n    lam = nu*e_modul / ((1.0d0 + nu) * (1.0d0 - 2*nu))\n    mu  = e_modul / (2.0d0*(1 + nu))\n\n    c_se = reshape((/lam + 2*mu, lam, lam, 0.0d0, 0.0d0, 0.0d0, &\n            lam, lam + 2*mu, lam, 0.0d0, 0.0d0, 0.0d0, &\n            lam, lam, lam + 2*mu, 0.0d0, 0.0d0, 0.0d0, &\n            0.0d0, 0.0d0, 0.0d0, mu, 0.0d0, 0.0d0, &\n            0.0d0, 0.0d0, 0.0d0, 0.0d0, mu, 0.0d0, &\n            0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, mu/), (/6,6/))\n\n    ev = (/e(1,1), e(2,2), e(3,3), 2*e(2,3), 2*e(1,3), 2*e(1,2)/)\n    sv = matmul(c_se, ev)\n    s = reshape((/sv(1), sv(6), sv(5), &\n                    sv(6), sv(2), sv(4), &\n                    sv(5), sv(4), sv(3)/), shape(s))\n\nend subroutine kirchhoff_s_sv_and_c\n"}
{"instruction": "Create a Fortran subroutine named kirchhoff_s_sv_and_c_2d to calculate the stress, strain vector, and material stiffness matrix in 2D. The subroutine takes 4 input parameters of types ['logical', 'real(8)', 'real(8)', 'real(8)'] and returns 3 output parameters of types ['real(8)', 'real(8)', 'real(8)'].", "input": "", "output": "subroutine kirchhoff_s_sv_and_c_2d(e, s, sv, c_se, e_modul, nu, plane_stress)\n    implicit none\n    logical, intent(in) :: plane_stress\n    real(8), intent(in) :: e(2,2), e_modul, nu\n    real(8), intent(out) :: s(2,2), sv(3), c_se(3,3)\n    real(8) :: lam, mu, ev(3)\n\n    lam = nu*e_modul / ((1.0d0 + nu) * (1.0d0 - 2*nu))\n    mu  = e_modul / (2.0d0*(1 + nu))\n\n!     this is slow, maybe one wants to change that in the future\n    if (plane_stress) then\n        c_se = e_modul/(1.0d0-nu**2)*reshape((/1.0d0, nu, 0.0d0, &\n                                             nu, 1.0d0, 0.0d0, &\n                                             0.0d0, 0.0d0, (1-nu)/2.0d0/), shape(c_se))\n    else\n        c_se = reshape((/lam + 2*mu, lam, 0.0d0, &\n                         lam, lam + 2*mu, 0.0d0, &\n                         0.0d0, 0.0d0, mu/), shape(c_se))\n    end if\n\n    ev = (/e(1,1), e(2,2), 2*e(1,2)/)\n    sv = matmul(c_se, ev)\n    s = reshape((/sv(1), sv(3), &\n                  sv(3), sv(2) /), shape(s))\n\nend subroutine kirchhoff_s_sv_and_c_2d\n"}
{"instruction": "Create a Fortran subroutine named calc_index_new to calculate the index positions based on given input parameters. The subroutine takes 6 input parameters of type integer (l1, l2, l3, m1, m2, m3) and returns 2 output parameters of type integer (l_index, m_index).", "input": "", "output": "  subroutine calc_index_new(l1,l2,l3,m1,m2,m3,l_index,m_index)\n\n    implicit none\n\n    integer, intent(in) ::  l1,l2,l3,m1,m2,m3\n    integer, intent(out) :: l_index,m_index\n    integer :: i,j,k,l1_dum,l2_dum,m1_dum,m2_dum\n    \n    !taking care of case where l2>l1;\n    if(l2.gt.l1) then !switching so largest l comes first in indexing scheme\n       l1_dum = l2\n       m1_dum = m2\n       l2_dum = l1\n       m2_dum = m1\n    else  !no switching necessary\n       !write(io_lun,*) 'l1 greater or equal to l2'\n       l1_dum = l1\n       m1_dum = m1\n       l2_dum = l2\n       m2_dum = m2\n    endif\n       \n    !work out l_index, position of l-triplet in\n    !coefficients array\n    l_index=1\n    if(l1_dum>0) then\n       do i=0,l1_dum-1\n          l_index = l_index + (i+1)*(i+2)/2\n       enddo\n    end if\n    if(l2_dum>0) then\n       do i=0,l2_dum-1\n          l_index = l_index + (i+1)\n       enddo\n    end if\n    l_index = l_index + (l3 - (l1_dum-l2_dum))/2\n\n    !also working out position of m_triplet within m_combs array\n    !write(io_lun,*) l1_dum,m1_dum,l2_dum,m2_dum\n    m_index = 1\n    m_index = m_index + (2*l1_dum+1)*(m2_dum+l2_dum)\n    m_index = m_index + (m1_dum+l1_dum)\n\n  end subroutine calc_index_new\n"}
{"instruction": "Create a Fortran subroutine named spline to calculate the second derivatives of the interpolating function for a tabulated set of points. The subroutine takes 4 input parameters: yp1 of type real, ypn of type real, x of type real, dimension(:), and y of type real, dimension(:); and returns 1 output parameter: y2 of type real, dimension(:).", "input": "", "output": "  subroutine spline( x, y, yp1, ypn, y2 )\n!-----------------------------------------------------------------------\n! given arrays x and y of lenght n containing a tabulated function,i.e. \n! yi = f(xi), with x1<x2<...<xn, and given values yp1 and ypn for the\n! first derivative of the interpolating function at points 1 and n, \n! respectively, this routine returns an array y2 of length n which\n! contains the second derivatives of the interpolating function\n! of the tabulated points xi.\n! if yp1 and/or ypn are equal to 1.e30 or larger, the routine \n! is signalled to set the corresponding boundary  condition\n! for a natural spline, wuth zero derivative on that boundary.\n!-----------------------------------------------------------------------\n  implicit none\n\n  real, intent(in)                :: yp1, ypn \n  real, intent(in),  dimension(:) :: x,   y \n  real, intent(out), dimension(:) :: y2\n\n  real, dimension(size(x)) :: u,  sig, p  \n  real                     :: qn, un\n  integer                  :: n,  i\n\n  real, parameter :: yptest = 0.99e30\n\n!-----------------------------------------------------------------------\n\n  n = size( x )\n\n  if ( yp1 > yptest  ) then\n       y2(1) = 0.\n        u(1) = 0.\n  else\n       y2(1) = -0.5\n        u(1) = ( 3.0 / ( x(2) - x(1) ) ) * &\n                     ( ( y(2) - y(1) ) / ( x(2) - x(1) ) - yp1 )\n  endif\n\n  do i = 2,n-1\n! %%%%%%%%%%%%%%\n  sig(i) = ( x(i) - x(i-1) ) / ( x(i+1) - x(i-1) )\n    p(i) = sig(i) * y2(i-1) + 2.\n   y2(i) = ( sig(i) - 1. ) / p(i)\n    u(i) = ( 6.0 * ( ( y(i+1) - y(i)   )    &\n                   / ( x(i+1) - x(i)   )    &\n                   - ( y(i)   - y(i-1) )    &\n                   / ( x(i)   - x(i-1) ) )  &\n                   / ( x(i+1) - x(i-1) ) - sig(i) * u(i-1) ) / p(i)\n! %%%%%%%%%%%%%%\n  end do\n\n  if ( ypn > yptest ) then\n       qn = 0.\n       un = 0.\n  else\n       qn = 0.5\n       un = ( 3.0 / ( x(n) - x(n-1) ) ) * &\n            ( ypn - ( y(n) - y(n-1) ) / ( x(n) - x(n-1) ) )\n  endif\n\n       y2(n) = ( un - qn * u(n-1) ) / ( qn * y2(n-1) + 1. )\n  do i = n-1,1,-1\n       y2(i) = y2(i) * y2(i+1) + u(i)\n  end do\n\n!-----------------------------------------------------------------------\n  end subroutine spline\n"}
{"instruction": "Create a Fortran subroutine named splint to perform cubic-spline interpolation. The subroutine takes 4 input parameters of type real, with dimensions (:), and one output parameter of type real. Additionally, it has two output parameters of type real.", "input": "", "output": "  subroutine splint( xa, ya, y2a, x, y, dy, dyy )\n!-----------------------------------------------------------------------\n! given the arrays xa and ya of length n, which tabulate a function\n! (with the xa's in order), and given the array y2a, which is the output\n! from spline above, and given a value of x, this routine\n! returns a cubic-spline interpolated value y.\n!-----------------------------------------------------------------------\n  implicit none\n\n  real, intent(in),  dimension(:) :: xa, ya, y2a \n  real, intent(in)                :: x\n  real, intent(out)               :: y,  dy, dyy \n\n  integer :: n, k, klo, khi\n  real    :: h, a, b,   ddy\n\n!-----------------------------------------------------------------------\n\n  n = size( xa )\n\n         klo = 1\n         khi = n\n\n1 if ( ( khi - klo ) > 1 ) then\n         k = ( khi + klo ) / 2\n    if ( xa(k) > x ) then\n         khi = k\n    else\n         klo = k\n    endif\n  goto 1\n  endif\n\n  h = xa(khi) - xa(klo)\n\n  if ( h == 0. ) print *, ' *** splint: bad xa input'\n\n  a = ( xa(khi) - x ) / h\n  b = ( x - xa(klo) ) / h\n\n  y = a * ya(klo) + b * ya(khi)  &\n     + ( ( a**3 - a ) * y2a(klo) &\n       + ( b**3 - b ) * y2a(khi) ) * ( h**2 ) / 6.\n\n  dy = ( ya(khi) - ya(klo) ) / h                  &\n     - ( 3.0 * a**2 - 1.0 ) * h * y2a(klo) / 6.0  &\n     + ( 3.0 * b**2 - 1.0 ) * h * y2a(khi) / 6.0\n\n  ddy = a * y2a(klo) + b * y2a(khi)\n! dyy = ddy\n\n!-----------------------------------------------------------------------\n  end subroutine splint\n"}
{"instruction": "Write a Fortran subroutine named smmv that performs a sparse matrix-vector multiplication. The subroutine takes 5 input parameters: an integer n, integer arrays ia and ja, and real*8 arrays a and b. It also has 1 output parameter, a real*8 array c. \n\nThe subroutine calculates the product of a sparse matrix represented by arrays a, ia, and ja, with a vector represented by array b, and stores the result in array c. The size of the matrix and vector is given by the integer n. \n\nUsing a loop over the rows of the matrix, the subroutine computes the dot product of each row of the matrix with the corresponding elements of the vector, and stores the result in array c. \n\nEnsure that the subroutine is declared with the \"subroutine\" keyword and uses the \"implicit none\" statement to enforce explicit variable declarations.", "input": "", "output": "subroutine smmv(n, a, ia, ja, b, c)\n    implicit none\n    integer, intent(in) :: n, ia(*), ja(*)\n    real*8, intent(in) :: a(*), b(*)\n    real*8, intent(out) :: c(*)\n\n    real*8 :: t\n    integer :: i, j\n\n    do i = 1, n\n        t = 0.0d0\n        do j = ia(i), ia(i+1)-1\n            t = t + a(j) * b(ja(j))\n        end do\n        c(i)=t\n    end do\nend subroutine smmv\n"}
{"instruction": "Write a Fortran subroutine named compute_stats that calculates various statistical measures for a given array of real numbers. The subroutine takes one input parameter, data, which is a one-dimensional array of real numbers. It also has three output parameters: mean, stddev, and n, all of which are of type real, real, and integer respectively.\n\nInside the subroutine, the size of the input array is determined and stored in n. The sum of the elements in the array is calculated and stored in data_sum. The sum of the squares of the elements is calculated and stored in data_sum2. Using these values, the mean is computed as data_sum divided by n, while the standard deviation is computed as the square root of [(data_sum2 - (data_sum^2)/n) / (n - 1)].\n\nRemember to use the \"intent(in)\" attribute for the input parameter and the \"intent(out)\" attribute for the output parameters.", "input": "", "output": "    subroutine compute_stats(data, mean, stddev, n)\n        implicit none\n        real, dimension(:), intent(in) :: data\n        real, intent(out) :: mean, stddev\n        integer, intent(out) :: n\n        real :: data_sum, data_sum2\n\n        n = size(data)\n        data_sum = sum(data)\n        data_sum2 = sum(data**2)\n        mean = data_sum/n\n        stddev = sqrt((data_sum2 - data_sum**2/n)/(n - 1))\n    end subroutine compute_stats\n"}
{"instruction": "Write a Fortran subroutine named \"egrad_mueller\" that computes the energy and gradient of a system based on the Mueller-Brown potential energy surface. The subroutine takes in an array of coordinates of the system as a single input parameter, where each coordinate is of type \"real(kind=8)\". The subroutine has three output parameters: \"epot\" of type \"real(kind=8)\", representing the potential energy of the system, \"grad\" of type \"real(kind=8)\", representing the gradient of the potential energy with respect to each coordinate, and \"info\" of type \"integer\", which is not used in this subroutine.\n\nIn the subroutine, the Mueller-Brown parameters are defined as arrays of type \"real(kind=8)\". The subroutine calculates the potential energy by summing over four terms, using the provided parameters and the input coordinates. The gradient is also determined by summing over the four terms, using the chain rule and the calculated energy parts. The final values for the potential energy and gradient are assigned to the respective output parameters.\n\nAt the end of the subroutine, the calculated potential energy and gradient are returned as output.", "input": "", "output": "subroutine egrad_mueller(coords,epot,grad,info)\nimplicit none\n!     the input coordinates\nreal(kind=8), intent(in) :: coords(3)\n!     the energy\nreal(kind=8), intent(out) :: epot\n!     the gradient\nreal(kind=8), intent(out) :: grad(3)\n!     info parameter (not used)\ninteger, intent(out) :: info\n!     single coordinate components\nreal(kind=8)::x,y\n!     mueller-brown parameters\nreal(kind=8)::a1_par(4)\nreal(kind=8)::a2_par(4)\nreal(kind=8)::x0_par(4)\nreal(kind=8)::y0_par(4)\nreal(kind=8)::b_par(4)\nreal(kind=8)::c_par(4)\n!     auxiliary array: sum components\nreal(kind=8)::e_parts(4)\n!     loop indices\ninteger::i\n!\n!      fill the parameter vectors\n!\na1_par=[-200.d0,-100.d0,-170.d0,15.d0]\na2_par=[-1.d0,-1.d0,-6.5d0,0.7d0]\nx0_par=[1.d0,0.d0,-0.5d0,-1.d0]\ny0_par=[0.d0,0.5d0,1.5d0,1.d0]\nb_par=[0.d0,0.d0,11.d0,0.6d0]\nc_par=[-10.d0,-10.d0,-6.5d0,0.7d0]\n!\n!      determine current coordinates\n!\nx=coords(1)\ny=coords(2)\n!\n!      calculate the energy for the actual point\n!\nepot=0.d0\ndo i=1,4\n   e_parts(i)=a1_par(i)*exp(a2_par(i)*(x-x0_par(i))*(x-x0_par(i))+&\n        &  b_par(i)*(x-x0_par(i))*(y-y0_par(i))+c_par(i)*&\n        &  (y-y0_par(i))*(y-y0_par(i)))\nend do\nepot=sum(e_parts)\n!\n!       calculate the gradient for the actual point\n!\ngrad=0.d0\ndo i=1,4\n   grad(1)=grad(1)+a1_par(i)*(2.d0*a2_par(i)*(x-x0_par(i))+b_par(i)*&\n        & (y-y0_par(i)))*e_parts(i)\n   grad(2)=grad(2)+a1_par(i)*(2.d0*c_par(i)*(y-y0_par(i))+b_par(i)*&\n        & (x-x0_par(i)))*e_parts(i)\nend do\n\n\nreturn\nend subroutine egrad_mueller\n"}
{"instruction": "Create a Fortran subroutine named splint to perform cubic spline interpolation. The subroutine takes 5 input parameters of types integer, real(8), real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "  subroutine splint( xa,ya,y2a,n,x,y )\n    implicit none\n    integer,intent(in) :: n\n    real(8),intent(in) :: xa(n),ya(n),y2a(n),x\n    real(8),intent(out) :: y\n    integer :: k,khi,klo\n    real(8) :: a,b,c,d,h\n    klo = 1\n    khi = n\n1   if ( khi - klo > 1 ) then\n       k = ( khi + klo )/2\n       if ( xa(k) > x ) then\n          khi = k\n       else\n          klo = k\n       end if\n       goto 1\n    end if\n    h = xa(khi) - xa(klo)\n    if ( h == 0.0d0 ) stop \"splint\"\n    a = ya(klo)\n    b = ( ya(khi)-ya(klo) )/h - ( y2a(khi) + 2.0d0*y2a(klo) )*h/6.0d0\n    c = y2a(klo)/2.0d0\n    d = ( y2a(khi)-y2a(klo) )/(6.0d0*h)\n    h = x - xa(klo)\n    y = a + b*h + c*h**2 + d*h**3\n  end subroutine splint\n"}
{"instruction": "Write a Fortran subroutine named test3 that takes 4 input parameters of type real(kind=kind(1.0d0)), dimension(:), real(kind=kind(1.0d0)), dimension(:), integer(kind=kind(1)), dimension(:), and integer(kind=kind(1)), dimension(:). The output parameter is of type real(kind=kind(1.0d0)), dimension(:). The subroutine updates the output parameter by performing element-wise multiplication and addition between the input arrays ix, iyz, e_x, and ii_ivec, and then adding the result to the existing values of the esss array.", "input": "", "output": "subroutine test3(esss,ix,iyz, e_x, ii_ivec)\n  real(kind=kind(1.0d0)), dimension(:), intent(out) :: esss\n  real(kind=kind(1.0d0)), dimension(:), intent(in) :: ix,iyz\n  integer(kind=kind(1)), dimension(:), intent(in) :: e_x,ii_ivec\n  esss = esss + ix(e_x) * iyz(ii_ivec)\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named tritrafoxieta2xy that takes 4 input arguments of unspecified type and 2 output arguments of unspecified type. The purpose of the subroutine is to transform the local coordinates xi and eta to global coordinates x and y using the vertex coordinates x(3) and y(3).", "input": "", "output": "  subroutine tritrafoxieta2xy(xp,yp,xi,eta,x,y)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    integer     :: etype                               ! element type         !\n    real        :: xp, yp                              ! input:  xp, yp       !\n    real        :: xi, eta, zeta                       ! output: xi eta       !\n    real        :: x(3), y(3)                          ! vertex coordinates   !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,xi,eta\n    intent(out) :: xp,yp\n    !-------------------------------------------------------------------------!\n    !\n    xp = x(1) + (x(2)-x(1))*xi + (x(3)-x(1))*eta\n    yp = y(1) + (y(2)-y(1))*xi + (y(3)-y(1))*eta\n    !\n  end subroutine tritrafoxieta2xy\n"}
{"instruction": "Create a Fortran subroutine named \"hexatrafoxietazeta2xyz\" to perform a coordinate transformation from xi, eta, zeta to x, y, z. The subroutine takes 6 input parameters of type real (x, y, z, xi, eta, zeta) and computes 3 output parameters of type real (xp, yp, zp) representing the transformed coordinates.", "input": "", "output": "  subroutine hexatrafoxietazeta2xyz(xp,yp,zp,xi,eta,zeta,x,y,z)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xp, yp, zp                          ! output: xp, yp, zp   !\n    real        :: xi, eta, zeta                       ! input:  xi eta zeta  !\n    real        :: x(8), y(8), z(8)                    ! vertex coordinates   !\n    ! local variable declaration\n    integer     :: i                                   ! loop index           ! \n    real        :: xiu, etau, zetau                    ! modified xi eta zeta !\n    real        :: l01xi, l01eta, l01zeta              ! lagrangian polynomial!\n    real        :: l11xi, l11eta, l11zeta              ! lagrangian polynomial!\n    real        :: sf(8)                               ! shape function       !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: x,y,z,xi,eta,zeta\n    intent(out) :: xp,yp,zp\n    !-------------------------------------------------------------------------!\n    !\n    ! compute lagrangian polynomials of degree 1 for 8-node hexahedron (straight edges)\n    !\n    l01xi   = 1  -xi\n    l11xi   =     xi\n    l01eta  = 1 -eta\n    l11eta  =    eta\n    l01zeta = 1-zeta\n    l11zeta =   zeta\n    !\n    ! compute shape functions of 8-node hexahedron\n    !\n    sf(1) = l01xi * l01eta * l01zeta\n    sf(2) = l11xi * l01eta * l01zeta\n    sf(3) = l01xi * l11eta * l01zeta\n    sf(4) = l11xi * l11eta * l01zeta\n    sf(5) = l01xi * l01eta * l11zeta\n    sf(6) = l11xi * l01eta * l11zeta\n    sf(7) = l01xi * l11eta * l11zeta\n    sf(8) = l11xi * l11eta * l11zeta\n    !\n    ! coordinate transformation from xiu, etau, zetau to x, y, z\n    !\n    xp = 0.\n    yp = 0.\n    zp = 0.\n    !\n    do i = 1,8\n        xp = xp + sf(i) * x(i)\n        yp = yp + sf(i) * y(i)\n        zp = zp + sf(i) * z(i)\n    enddo\n    !\n  end subroutine hexatrafoxietazeta2xyz\n"}
{"instruction": "Write a Fortran subroutine named \"trafochitau2xietazeta\" to transform the input chi and tau values into xi, eta, and zeta coordinates based on the given iside and ineighborvertex. The number of input arguments is 4 and the test_data type is ['real', 'real', 'real', 'real']. The number of output arguments is 3 and the test_data type is ['real', 'real', 'real'].", "input": "", "output": "  subroutine trafochitau2xietazeta(xi,eta,zeta,chi,tau,iside,ineighborvertex)\n    !-------------------------------------------------------------------------!\n    implicit none\n    !-------------------------------------------------------------------------!\n    ! argument list declaration\n    real        :: xi, eta, zeta                       ! output: xi eta zeta  !\n    real        :: chi,tau                             ! input:  chi, tau     !\n    integer     :: iside, ineighborvertex              ! element orientation  !\n    ! local variable declaration\n    real        :: chi1,tau1                           ! intermediate results !\n    !-------------------------------------------------------------------------!\n    intent(in)  :: chi, tau, iside, ineighborvertex\n    intent(out) :: xi,eta,zeta\n    !-------------------------------------------------------------------------!\n    !\n    select case(ineighborvertex)\n    ! inside the element itself\n    case(0) \n        select case(iside)\n        case(1)\n          xi   = tau\n          eta  = chi\n          zeta = 0. \n        case(2)\n          xi   = chi\n          eta  = 0. \n          zeta = tau\n        case(3)\n          xi   = 0. \n          eta  = tau\n          zeta = chi\n        case(4)\n          xi   = 1.-chi-tau\n          eta  = chi\n          zeta = tau\n        end select\n        !\n        return\n    ! inside the neighbor\n    case(1)\n      chi1 = tau\n      tau1 = chi\n    case(2)\n      chi1 = 1.-chi-tau\n      tau1 = tau\n    case(3)\n      chi1 = chi\n      tau1 = 1.-chi-tau\n    end select\n    !\n    select case(iside)\n    case(1)\n      xi   = tau1\n      eta  = chi1\n      zeta = 0. \n    case(2)\n      xi   = chi1\n      eta  = 0. \n      zeta = tau1\n    case(3)\n      xi   = 0. \n      eta  = tau1\n      zeta = chi1\n    case(4)\n      xi   = 1.-chi1-tau1\n      eta  = chi1\n      zeta = tau1\n    end select\n    !\n    return\n    !\n  end subroutine trafochitau2xietazeta\n"}
{"instruction": "Create a Fortran subroutine named remove_brackets that takes a single input argument of type character(len=*) and returns a single output argument of type character(len=*). The subroutine replaces any parentheses in the input string with underscores and stores the modified string in the output argument.", "input": "", "output": "        subroutine remove_brackets(instr, outstr)\n                ! convert parentheses to underscores\n                ! contract: output str must have at least the length of the input str\n                character(len=*), intent(in) :: instr\n                character(len=*), intent(out) :: outstr\n\n                integer :: i \n\n                outstr = trim(instr)\n                do i = 1,len(outstr)\n                        if(outstr(i:i) == '(' .or. outstr(i:i) == ')') then\n                                outstr(i:i) = '_'\n                        end if\n                end do\n        end subroutine\n"}
{"instruction": "Create a Fortran subroutine named ymd_to_julian_day to convert a calendar date to a Julian date. The subroutine takes 3 input parameters of type integer (yyyy, mm, dd) representing year, month, and day, and 1 output parameter of type integer (julian) representing the number of days since the start of the Julian calendar.", "input": "", "output": "    elemental subroutine ymd_to_julian_day(yyyy, mm, dd, julian)\n        !! converts a calendar date to a julian date (i.e. integer number of days since start of julian calendar)\n        !! fliegel and van flandern (1968) cacm 11(10):657\n        !! various discussions of this online, e.g.\n        !! https://software.intel.com/en-us/forums/intel-fortran-compiler/topic/271933\n        !! https://stackoverflow.com/questions/17354100/date-time-difference-in-fortran\n        integer, intent(in) :: yyyy, mm, dd\n            !! year, month, day\n        integer, intent(out) :: julian\n            !! number of days since start of julian calendar\n\n        julian = dd-32075+1461*(yyyy+4800+(mm-14)/12)/4 + 367*(mm-2-((mm-14)/12)*12)/12- &\n            3*((yyyy + 4900 + (mm - 14)/12)/100)/4\n\n    end subroutine\n"}
{"instruction": "Create a Fortran subroutine named julian_day_to_ymd to convert a Julian date (days since the start of the Julian calendar) into year, month, and day. The subroutine should take 1 input parameter with the test_data type ['integer'] and provide 3 output parameters with the test_data type ['integer', 'integer', 'integer'].", "input": "", "output": "    elemental subroutine julian_day_to_ymd (jd, yyyy, mm, dd)\n        !! convert a julian date (days since start of julian calendar) into year/month/day \n        !! fliegel and van flandern (1968) cacm 11(10):657\n        !! see discussion at:\n        !! https://software.intel.com/en-us/forums/intel-fortran-compiler/topic/271933\n        integer,intent(in) :: jd\n            !! number of days since start of julian calendar\n        integer,intent(out) :: yyyy,mm,dd\n            !! year, month, day\n\n        integer :: l,n\n\n        l = jd + 68569\n        n = 4*l/146097\n        l = l - (146097*n + 3)/4\n        yyyy = 4000*(l + 1)/1461001\n        l = l - 1461*yyyy/4 + 31\n        mm = 80*l/2447\n        dd = l - 2447*mm/80\n        l = mm/11\n        mm = mm + 2 - 12*l\n        yyyy = 100*(n - 49) + yyyy + l\n\n    end subroutine\n"}
{"instruction": "Write a Fortran subroutine named \"juliandatetodaymonthyear\" that takes one input parameter of type integer and returns four output parameters of type integer. The number of input arguments is 1 and the test_data type is ['integer']. The number of output arguments is 4 and the test_data type is ['integer', 'integer', 'integer', 'integer,optional'].", "input": "", "output": "  subroutine juliandatetodaymonthyear(ijulian,iday,imonth,iyear,istat)\n    integer,intent(in)           :: ijulian\n    integer,intent(out)          :: iday,imonth,iyear\n    integer,optional,intent(out) :: istat\n\n    !local variables\n    integer :: l,n\n\n    l      = ijulian+68569\n    n      = 4*l/146097\n    l      = l-(146097*n+3)/4\n    iyear  = 4000*(l+1)/1461001\n    l      = l-1461*iyear/4+31\n    imonth = 80*l/2447\n    iday   = l-2447*imonth/80\n    l      = imonth/11\n    imonth = imonth+2-12*l\n    iyear  = 100*(n-49)+iyear+l\n\n    if (present(istat)) istat = 0\n\n\n  end subroutine juliandatetodaymonthyear\n"}
{"instruction": "Create a Fortran subroutine named calc_n_mean to calculate the coefficient of variation and the arithmetic mean of abundance estimates. The subroutine takes 2 input parameters of type real(kind = 8) and returns 2 output parameters of type real(kind = 8).", "input": "", "output": "  subroutine calc_n_mean(cv, n_hat, cv_mean, n_mean)\n! ----------------------------------------------------------------------------------------\n! function to calculate the cv of weighted average. \n\n! the assumption here for n_mean follows from the approach taken by,\n!   wade and demaster. 1999. determining the optimum interval for abundance surveys\n! that assumption is that the cv's are equal for the simulated survey estimates,\n!   so they just used the arithmetic mean (n_mean) to plug into calculations of n_min\n! i think the geometric mean might be a closer approximation, given assumption of log-normality? -jbrandon\n! ----------------------------------------------------------------------------------------\n    real(kind = 8), intent(in) :: cv(:)          ! vector of cv's\n    real(kind = 8), intent(in) :: n_hat(:)       ! vector of abundance estimates (point estimates) \n    integer(kind = 4) :: n_surveys               ! number of survey estimates to average\n    real(kind = 8), allocatable :: n_variance(:) ! vector of variances\n    real(kind = 8) :: sum_variance               ! sum of the variances\n    real(kind = 8), intent(out) :: cv_mean       ! cv of the averaged abundance estimate\n    real(kind = 8), intent(out) :: n_mean        ! arithmetic mean of the abundance estimates\n    \n    n_surveys = size(cv)                         ! retrieve length of vector\n    allocate(n_variance(1:n_surveys))            ! allocate size of variance vector\n    \n    n_variance = cv * n_hat                      ! standard deviation\n    n_variance = n_variance * n_variance         ! variance\n    \n    sum_variance = sum(n_variance)               ! sum variances\n    sum_variance = sum_variance / (n_surveys * n_surveys)\n    \n    n_mean = sum(n_hat) / n_surveys              ! arithmetic mean of the abundance estimates\n    cv_mean = sqrt(sum_variance) / n_mean        ! cv of the averaged abundance estimate  \n        \n    return\n  end subroutine calc_n_mean\n"}
{"instruction": "Write a Fortran subroutine named tdma to solve a tridiagonal matrix equation using the Thomas algorithm. The subroutine takes 5 input parameters of type real(8) and integer, and 1 output parameter of type real(8). The input parameters are arrays a, b, c, d of type real(8) and an integer n. The output parameter is an array x of type real(8), which stores the solution to the tridiagonal matrix equation.", "input": "", "output": "subroutine tdma(a,b,c,d,n,x)\n  real(8),intent(in) :: a(:),b(:),c(:),d(:)\n  real(8),intent(out) :: x(:)\n  real(8),allocatable :: g(:),h(:)\n  real(8) :: temp\n  integer,intent(in) :: n\n  integer :: i\n  \n  allocate(g(n),h(n))\n  \n  !forward elimination\n  g(1) = -c(1) / b(1)\n  h(1) = d(1) / b(1)\n  do i = 2,n\n    temp = b(i) + a(i)*g(i-1)\n    g(i) = -c(i) / temp\n    h(i) = (d(i) - a(i)*h(i-1)) / temp\n  end do\n  \n  !backward substitution\n  x(n) = h(n)\n  do i = n-1,1,-1\n    x(i) = g(i)*x(i+1) + h(i)\n  end do\nend subroutine tdma\n"}
{"instruction": "Write a Fortran subroutine named julian to calculate the Julian date from the given year, month, day, hour, minute, and second. The subroutine takes 6 input parameters of types integer, integer, integer, integer, integer, real*8 and returns 1 output parameter of type real*8.", "input": "", "output": "subroutine julian (year, month, day, hour, minute, second, julian_date)\n    implicit none\n    integer, intent(in) :: year, month, day, hour, minute\n    real*8, intent(in) :: second\n    real*8, intent(out) :: julian_date\n\n    real*8 ut, term1\n    integer term2, term3\n\n    term1 = 367.000 * year\n    term2 = int((7 * (year + int((month + 9) / 12))) / 4)\n    term3 = int(275 * month / 9)\n    ut = ((second / 60.000 + minute) / 60.000 + hour) / 24.000\n\n    julian_date = (term1 - term2 + term3) + day + 1721013.500 + ut\n\n    return\n    end subroutine\n"}
{"instruction": "Write a Fortran subroutine called get_arg that retrieves a specific argument from the command line. The subroutine takes 1 input argument, which is an integer representing the argument number to retrieve. The subroutine also has 2 output arguments, a logical flag indicating the success or failure of retrieving the argument, and a character string containing the retrieved argument.", "input": "", "output": "   subroutine get_arg ( arg_num , arg , error )\n\n\n      ! this routine gets arg_num'th argument from the command line.\n\n   ! note: the functionality in this routine was replaced by get_command_argument(), which will be available intrinsically in fortran 2000.\n\n\n      ! argument declarations.\n\n   integer, intent(in)          :: arg_num                                      ! the argument number to get.\n\n   logical, intent(out)         :: error                                        ! the error flag returned to the calling program.\n\n   character(*), intent(out)    :: arg                                          ! the argument string returned to the calling program.\n\n\n      ! local declarations.\n\n   integer                      :: status                                       ! the status of the attempt to get an argument.\n\n\n\n   call getarg ( arg_num, arg )  !20110512 jm remove 3rd arg for linux port\n\n   if ( len_trim( arg ) > 0 )  then\n      error = .false.\n   else\n      error = .true.\n   end if\n\n\n   return\n   end subroutine get_arg ! ( arg_num , arg , error )\n"}
{"instruction": "Create a Fortran subroutine named lege_stieltjes to calculate the value of a special function. The subroutine takes 2 input parameters of type double precision and returns 1 output parameter of type double precision. The number of input arguments is 2 and the test_data type is ['double precision', 'double precision']. The number of output arguments is 1 and the test_data type is ['double precision'].", "input": "", "output": "subroutine lege_stieltjes(dnu,t,val)\nimplicit double precision (a-h,o-z)\n\ndouble precision, intent(in)     :: dnu,t\ndouble precision, intent(out)    :: val\n\ndata pi           /3.14159265358979323846264338327950288q0/\ndata sqrt2overpi / 0.797884560802865355879892119868763737q0/\ndata piover2     / 1.57079632679489661923132169163975144q0/\n\nval    = 0\nnterms = 17\nx      = dnu+0.75d0\n\ndd = 1-1874409467055q0/(7.0368744177664q13*x**14)+  &\n7426362705q0/(1.099511627776q12*x**12)-  &\n20898423q0/(8.589934592q9*x**10)+180323/(1.34217728q8*x**8)-  &\n671/(5.2428799999999995q5*x**6)+21/(8.192q3*x**4)-  &\n1/(6.4q1*x**2)\n\nc0  = 1.0d0/sqrt(x) * dd\ndd  = 1.0d0\ndd2 = 1/sin(t)\n\ndo m=0,nterms\na   = (dnu+m+0.5d0)*t-(m+0.5d0)*piover2\nval = val + c0 * cos(a)*dd\ndd  = dd*dd2\nc0  = c0 * (m+0.5d0)**2/(2*(m+1.0d0)*(dnu+m+1.5d0))\nend do\n\nval = val * sqrt2overpi*sqrt(dd2)\n\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named sumvectorsub to calculate the sum of all elements in an integer array. The subroutine takes 1 input parameter of type integer array and 1 output parameter of type integer.", "input": "", "output": "  subroutine sumvectorsub(vector, vecsum)\n    integer, intent(in) :: vector(:)\n    integer, intent(out) :: vecsum\n    integer :: i\n\n    vecsum = 0\n    do i = 1, size(vector)\n      vecsum = vecsum + vector(i)\n    end do\n  end subroutine sumvectorsub\n"}
{"instruction": "Create a Fortran subroutine named f_computeomega to calculate the vertical velocity component (omega) in atmospheric models. The subroutine takes 7 input parameters of types integer and real(kind=8) arrays with dimensions mx, my, and mz. It returns 1 output parameter, a real(kind=8) array with dimensions mx, my, and mz.", "input": "", "output": "subroutine f_computeomega(qvp,tmk,www,prs,omg,mx,my,mz)\n\n    implicit none\n\n    integer,intent(in) :: mx, my, mz\n    real(kind=8),intent(in),dimension(mx,my,mz) :: qvp\n    real(kind=8),intent(in),dimension(mx,my,mz) :: tmk\n    real(kind=8),intent(in),dimension(mx,my,mz) :: www\n    real(kind=8),intent(in),dimension(mx,my,mz) :: prs\n    real(kind=8),intent(out),dimension(mx,my,mz) :: omg\n\n    ! local variables\n    integer :: i, j, k\n    real(kind=8),parameter :: grav=9.81, rgas=287.04, eps=0.622\n\n    do k=1,mz\n        do j=1,my\n          do i=1,mx\n              omg(i,j,k)=-grav*prs(i,j,k) / &\n              (rgas*((tmk(i,j,k)*(eps+qvp(i,j,k))) / &\n              (eps*(1.+qvp(i,j,k)))))*www(i,j,k)\n          end do\n        end do\n    end do\n    !\n    return\n\nend subroutine f_computeomega\n"}
{"instruction": "Create a Fortran subroutine named f_computetv that calculates the virtual temperature for a given set of temperature and specific humidity arrays. The subroutine takes 5 input parameters: three integers (nx, ny, nz), and two real arrays of dimension nx, ny, nz (temp and qv). It also has one output parameter, a real array of dimension nx, ny, nz (tv). Use the imperative tone to define the instructions.", "input": "", "output": "subroutine f_computetv(temp,qv,tv,nx,ny,nz)\n\n    implicit none\n\n    integer, intent(in) :: nx,ny,nz\n    real(kind=8),dimension(nx,ny,nz),intent(in) :: temp\n    real(kind=8),dimension(nx,ny,nz),intent(in) :: qv\n    real(kind=8),dimension(nx,ny,nz),intent(out) :: tv\n\n    integer :: i,j,k\n    real(kind=8),parameter :: eps = 0.622d0\n\n    do k=1,nz\n        do j=1,ny\n          do i=1,nx\n            tv(i,j,k) = temp(i,j,k) * (eps+qv(i,j,k)) / (eps * (1.d0+qv(i,j,k)))\n          end do\n        end do\n    end do\n\n    return\n\nend subroutine f_computetv\n"}
{"instruction": "Create a Fortran subroutine named limit_t_infty_fc_fs_mono to compute the limit of fc and fs as t tends to infinity. The subroutine takes 5 input parameters of type real * 8 and dimension(:), and 2 output parameters of type real * 8 and dimension(:). The subroutine uses the imperative tone to perform the computation.", "input": "", "output": "subroutine limit_t_infty_fc_fs_mono(d0,gamma_val,k,lamk,sk,fc,fs)\n\timplicit none\n\treal * 8, intent(in) :: d0, gamma_val\n\treal * 8, dimension(:), intent(in) :: k, lamk, sk\n\treal * 8, dimension(:), intent(out) :: fc, fs\n\treal * 8 :: delz_infty\n\treal * 8, dimension(size(k)) :: k2, lamkdelz\n\tif (gamma_val < 1.d20 ) then\n\t\tk2 = k*k\n\t\tdelz_infty = 1.d0 / gamma_val\n\t\tlamkdelz = lamk * delz_infty\n\t\tfc = lamkdelz * sk     / (lamkdelz + (k2 * d0 / sk) )\n\t\tfs = lamkdelz / (lamkdelz + (k2 * d0) )\n\telse\n\t\tprint*, \"system is not arrested\"\n\tend if\nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named gaulob. This subroutine takes 3 input parameters of type real, integer, and real array and 2 output parameters of type real array and real array. The subroutine computes the Gauss-Lobatto nodes and weights for numerical integration over a specified interval. The subroutine uses the Newton-Raphson method to update the nodes and calculates the corresponding weights.", "input": "", "output": "pure subroutine gaulob(x1,x2,x,w,n1)\n\n  !--------------------------------------------------------------------------\n  implicit none\n  !--------------------------------------------------------------------------\n  ! argument list\n  integer          :: n1\n  real :: x1,x2,x(n1),w(n1)\n  ! local variables\n  real, parameter  :: eps = 1.0e-15\n  real, parameter  :: m_pi = 4.0*atan(1.0)\n  integer           :: i,k\n  real  :: xold(n1)\n  real  :: p(n1,n1)\n  integer           :: n, iter, maxiter\n  !--------------------------------------------------------------------------\n  intent(in)  :: x1,x2,n1\n  intent(out) :: x,w\n  !--------------------------------------------------------------------------\n  \n  !\n  n = n1-1;\n\n  ! use the chebyshev-gauss-lobatto nodes as the first guess\n\n  do i = 0, n\n   x(i+1) = cos(m_pi*real(i)/real(n))\n  end do\n  ! the legendre vandermonde matrix\n  p=0.0\n  !\n  ! compute p_(n) using the recursion relation\n  ! compute its first and second derivatives and\n  ! update x using the newton-raphson method.\n  !\n  xold=2.0\n  !\n  maxiter = 100000\n  do iter = 1, maxiter\n    xold=x\n    p(:,1)=1.0\n    p(:,2)=x\n    do k = 2, n\n        p(:,k+1)=( (2*k-1)*x*p(:,k)-(k-1)*p(:,k-1) )/real(k)\n    end do\n    x=xold-( x*p(:,n1)-p(:,n) )/( n1*p(:,n1) )\n    if(maxval(abs(x-xold)) .le. eps) then\n      exit\n    end if\n  end do\n  w = 2.0/(real(n*n1)*p(:,n1)**2)\n  w = 0.5*w*(x2-x1)\n  x = x1 + 0.5*(x+1.0)*(x2-x1)\n  !\nend subroutine gaulob\n"}
{"instruction": "Create a Fortran subroutine named make_wrf_file_name that generates the WRF output file name based on the working directory, domain number, and number of minutes into the simulation. The number of input parameters is 3, and their types are ['character(len=*)', 'integer', 'integer']. The number of output parameters is 1, of type ['character(len=255)']. Use the subroutine's imperative tone to specify the required inputs and the output file name generation process.", "input": "", "output": "  subroutine make_wrf_file_name(prddir,domnum,time_min,fname)\n\n! creates the wrf output file name based on the working directory,\n! domain number, and number of minutes into simulation\n\n    implicit none\n\n    character(len=*), intent(in)               :: prddir\n    integer, intent(in)                        :: domnum\n    integer, intent(in)                        :: time_min\n    character(len=255), intent(out)            :: fname\n\n    character(len=2)                           :: domstr\n    character(len=6)                           :: timestr\n\n    write(domstr, '(i2.2)') domnum\n    write(timestr, '(i6.6)') time_min\n\n    fname = trim(prddir) // '/wrfout_d' // domstr // '_' // timestr\n    return\n  end subroutine make_wrf_file_name\n"}
{"instruction": "Create a Fortran subroutine named gsub that takes 4 input parameters of type double precision and returns 1 output parameter of type double precision with the dimension (4, 2, 2). The subroutine computes and populates the output parameter based on the input parameters using complex number operations and reshaping.", "input": "", "output": "subroutine gsub(yout, delta, eps, offset, phase)\n\n    implicit none\n    double precision, intent(in) :: delta, eps, offset, phase\n    double precision, dimension(4, 2, 2), intent(out) :: yout\n    double precision, dimension(2, 2) :: reg, img, regt, imgt, sy\n\n    sy  = reshape((/ 0, 1, -1, 0 /), shape(sy))\n\n    reg     = realpart(delta * exp((0d0,1d0) * phase) / (eps + (0d0,1d0) * sqrt(delta**2 - (eps + (0d0,1d0) * offset)**2)) * sy)\n    img     = imagpart(delta * exp((0d0,1d0) * phase) / (eps + (0d0,1d0) * sqrt(delta**2 - (eps + (0d0,1d0) * offset)**2)) * sy)\n    regt    = realpart(delta * exp(-(0d0,1d0) * phase) / (eps + (0d0,1d0) * sqrt(delta**2 - (eps + (0d0,1d0) * offset)**2)) * sy)\n    imgt    = imagpart(delta * exp(-(0d0,1d0) * phase) / (eps + (0d0,1d0) * sqrt(delta**2 - (eps + (0d0,1d0) * offset)**2)) * sy)\n\n    yout(1,:,:) = reg\n    yout(2,:,:) = img\n    yout(3,:,:) = regt\n    yout(4,:,:) = imgt\n\nend subroutine gsub\n"}
{"instruction": "Create a Fortran subroutine named xdiff2_l2 that calculates the squared distance between points in arrays xa and xb, and stores the results in xdiff2. The subroutine takes 5 input parameters of types integer, real*8, and 1D or 2D real*8 arrays, and 1 output parameter of type real*8.", "input": "", "output": "subroutine xdiff2_l2(nd, nb, xa, xb, l, xdiff2)\n  integer, intent(in)    :: nd, nb             ! dimension and number of points\n  real(8), intent(in)    :: xa(nd), xb(nd, nb) ! points\n  real(8), intent(in)    :: l(nd)              ! length scales\n  real(8), intent(out)   :: xdiff2(nb)         ! output: squared distance\n\n  integer :: kb\n\n  !$omp simd\n  do kb = 1, nb\n    xdiff2(kb) = sum(((xa - xb(:, kb))/l)**2)\n  end do\nend subroutine xdiff2_l2\n"}
{"instruction": "Write a Fortran subroutine named put_characters_default_unit to output a string to the default output unit. The input parameter is a string of variable length (character(len=*)), and the output parameter is an optional integer (integer, optional).", "input": "", "output": "    subroutine put_characters_default_unit(string, iostat)\n        ! sec. 3.6.2\n        character(len=*), intent(in) :: string\n        integer, optional, intent(out) :: iostat\n\n        if (present(iostat)) then\n            write(*, fmt='(a)', advance='no', iostat=iostat) string\n        else\n            write(*, fmt='(a)', advance='no') string\n        end if\n    end subroutine\n"}
{"instruction": "Write a Fortran subroutine named setx_crit that takes 4 input arguments of type real (tc, vc, zc(2), pc) and 1 output argument of type real (x(4)). The subroutine sets the elements of the output array x to zc(1), log(tc), log(vc), and log(pc) respectively.", "input": "", "output": "  subroutine setx_crit(tc,vc,zc,pc,x)\n    real, intent(in) :: tc,vc,zc(2),pc\n    real, intent(out) :: x(4)\n    x(1) = zc(1)\n    x(2) = log(tc)\n    x(3) = log(vc)\n    x(4) = log(pc)\n    !print *,\"tc,pc,zc,vc\",tc,pc,zc(1),vc\n  end subroutine setx_crit\n"}
{"instruction": "Write a Fortran subroutine named getpropfromxaz to calculate various properties based on input values. The subroutine takes 2 input parameters of types real(4) and integer, and 4 output parameters of types real, real, real, and real. The inputs represent an array of 4 real numbers and an integer, while the outputs represent real numbers corresponding to temperature (t), vapor density (vg), liquid density (vl), and an array of 2 real numbers (z).", "input": "", "output": "  subroutine getpropfromxaz(x,t,vg,vl,z,ic)\n    real, intent(out) :: t,vg,vl,z(2)\n    real, intent(in) :: x(4)\n    integer, intent(in) :: ic\n    t = exp(x(1))\n    z = 1 - x(2)\n    z(ic) = x(2)\n    vl = exp(x(3))\n    vg = exp(x(4))\n  end subroutine getpropfromxaz\n"}
{"instruction": "Create a Fortran subroutine named setxaz that takes 5 input parameters of type real, real, real, real, and integer, and 1 output parameter of type real. The subroutine computes the natural logarithm of the first input parameter, assigns the value of the second element of the input array z to the second element of the output array x, and computes the natural logarithm of the third and fourth input parameters, and assigns the results to the third and fourth elements of the output array x, respectively.", "input": "", "output": "  subroutine setxaz(t,vg,vl,z,x,ic)\n    real, intent(in) :: t,vg,vl,z(2)\n    real, intent(out) :: x(4)\n    integer, intent(in) :: ic\n    x(1) = log(t)\n    x(2) = z(ic)\n    x(3) = log(vl)\n    x(4) = log(vg)\n  end subroutine setxaz\n"}
{"instruction": "Create a Fortran subroutine named cubspline_init to initialize a cubic spline. The subroutine takes 3 input parameters of type integer, real(8), and real(8) and 1 output parameter of type real(8).", "input": "", "output": "subroutine cubspline_init(n, x, y,y2)\n  !! initialize a cubic spline\n  integer, intent(in) :: n !! data length\n  real(8), intent(in) :: x(n) !! x input data\n  real(8), intent(in) :: y(n) !! y(x) \n  real(8), intent(out) :: y2(n) !! spline data\n\n  integer :: i,k\n  real(8) :: p,qn,sig, un,u(n), yp1,yp2,h\n\n  h = x(2)-x(1)\n\n  y2(1)=0.d0\n  u(1)=0.d0\n  do i=2,n-1\n    sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))\n    p=sig*y2(i-1)+2.d0\n    y2(i)=(sig-1.d0)/p\n    yp1=(y(i+1)-y(i))/(x(i+1)-x(i))\n    yp2=(y(i)-y(i-1))/(x(i)-x(i-1))\n    u(i)=(6.d0*(yp1-yp2)/(x(i+1)-x(i-1))-sig*u(i-1))/p\n  end do\n  qn=0.d0\n  un=0.d0\n  y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.d0)\n  do k=n-1,1,-1\n    y2(k) = y2(k)*y2(k+1) + u(k)\n  end do\n  \nend subroutine\n"}
{"instruction": "Create a Fortran subroutine named bdy_tracer_value to calculate the value of a tracer variable. The subroutine takes 4 input parameters of type real, real, real, and integer, and returns 1 output parameter of type real. The subroutine computes the value of the tracer variable based on the input values and a small epsilon value. Use the imperative tone in your instructions.", "input": "", "output": "  subroutine bdy_tracer_value ( trac, trac_b, trac_bt, dt,ic)\n    implicit none\n    real, intent(out) :: trac\n    real, intent(in) :: trac_b\n    real, intent(in) :: trac_bt\n    real, intent(in) :: dt\n    integer, intent(in) :: ic\n    real :: epsilc = 1.e-12\n      trac=max(epsilc,trac_b + trac_bt * dt)\n      return\n  end subroutine bdy_tracer_value\n"}
{"instruction": "Create a Fortran subroutine named sl_stcov to compute the block-toeplitz covariance matrix for MSSA analysis. The subroutine takes 1 input parameter of type real and returns 1 output parameter of type real. The input parameter var does not need to be centered.", "input": "", "output": "\tsubroutine sl_stcov(var, cov)\n\t\n\t! compute the block-toeplitz covariance matrix for mssa analysis\n\t!\n\t! .. note:: ``var`` does not need to be centered\n\t\n\t\n\t\timplicit none\n\t\t\n\t\treal, intent(in)  :: var(:, :)\n\t\treal, intent(out) :: cov(:, :)\n\t\t\n\t\treal, allocatable :: varmean(:)\n\t\tinteger ::  nchan, nt, nsteof, nwindow\n\t\tinteger :: iw, iw1, iw2, i1, i2, ic1, ic2\n\t\t\n\t\tnchan = size(var, 1)\n\t\tnt = size(var, 2)\n\t\tnsteof = size(cov, 1)\n\t\tnwindow = nsteof/nchan\n\t\t\n\t\tallocate(varmean(nchan))\n\t\tvarmean = sum(var, dim=2)/real(nt)\n\t\n\t\tdo ic1 = 1, nchan\n\t\t\tdo ic2 = 1, nchan\n\t\t\t\tdo iw2 = 1, nwindow\n\t\t\t\t\tdo iw1 = 1, iw2\n\t\t\t\t\t\ti1 = (ic1-1) * nwindow + iw1\n\t\t\t\t\t\ti2 = (ic2-1) * nwindow + iw2\n\t\t\t\t\t\tiw = iw2 - iw1 + 1\n\t\t\t\t\t\tcov(i1,i2) = &\n\t\t\t\t\t\t\t& dot_product(var(ic1, 1  : nt-iw+1)-varmean(ic1),  &\n\t\t\t\t\t\t\t&             var(ic2, iw : nt\t )-varmean(ic2)) / &\n\t\t\t\t\t\t\t& real(nt-iw+1)\n\t\t\t\t\t\tcov(i2,i1) = cov(i1,i2)\n\t\t\t\t\tend do\n\t\t\t\tend do\n\t\t\tend do\n\t\tend do\n\t\t\n\t\tdeallocate(varmean)\n\n\tend subroutine sl_stcov\n"}
{"instruction": "Create a Fortran subroutine named rotaxis to calculate the rotation axis and the rotation angle based on the input Euler angles. The subroutine takes 3 input parameters of type real: alpha, beta, and gamma. It returns 2 output parameters of type real: rax (an array of 4 elements) and theta.", "input": "", "output": "  subroutine rotaxis(alpha,beta,gamma,rax,theta)\n\n    ! determines the rotation axis based on the euler angles\n    implicit none\n    real, intent(in) :: alpha,beta,gamma\n    real, intent(out) :: rax(4),theta \n\n    real :: costhe2,the2\n    integer :: i\n\n    costhe2=cos(beta/2.0)*cos((alpha+gamma)/2.0)\n    the2=acos(costhe2)\n    rax=0.0\n    if (the2.gt.0.00001) then\n       rax(1)=-sin(beta/2.0)*sin((alpha-gamma)/2.0)/sin(the2)\n       rax(2)= sin(beta/2.0)*cos((alpha-gamma)/2.0)/sin(the2)\n       rax(3)= cos(beta/2.0)*sin((alpha+gamma)/2.0)/sin(the2)\n    endif\n    do i=1,3\n       if (abs(rax(i)).gt.0.0001) then\n          rax(i)=rax(i)/abs(rax(i))\n       endif\n    enddo\n    rax(4)=rax(1)**2+rax(2)**2+rax(3)**2\n    theta=the2*2.0\n  end subroutine rotaxis\n"}
{"instruction": "Create a Fortran subroutine named map_mstep_dense. This subroutine takes 5 input parameters of types integer, double precision, and double precision, and produces 3 output parameters of type double precision. The subroutine performs a specific calculation involving arrays and loops.", "input": "", "output": "  subroutine map_mstep_dense(n, eb, ez, en0, en1, alpha, d0, d1)\n    integer, intent(in) :: n\n    double precision, intent(in) :: eb(1:n), ez(1:n)\n    double precision, intent(in) :: en0(1:n,1:n), en1(1:n,1:n)\n    double precision, intent(out) :: alpha(1:n), d0(1:n,1:n), d1(1:n,1:n)\n    integer :: i, j\n    double precision :: tmp(1:n)\n\n    alpha(1:n) = eb(1:n)\n    tmp(1:n) = 0.0d0\n    do j = 1, n\n      do i = 1, n\n        if (i /= j) then\n          d0(i,j) = en0(i,j) / ez(i)\n          tmp(i) = tmp(i) + d0(i,j)\n        end if\n        d1(i,j) = en1(i,j) / ez(i)\n        tmp(i) = tmp(i) + d1(i,j)\n      end do\n    end do\n\n    do i = 1, n\n      d0(i,i) = -tmp(i)\n    end do\n  end subroutine map_mstep_dense\n"}
{"instruction": "Create a Fortran subroutine named makeobsbinary that takes 5 input parameters of type real (a, ecc, inc, phi, mean) and 1 output parameter of type real (sky(1:2)). The subroutine calculates the position of an object in the sky based on the input orbital parameters.", "input": "", "output": "subroutine makeobsbinary(a,ecc,inc,phi,mean,sky)\n    implicit none\n\n    real, intent(in) :: a,ecc,inc,phi,mean\n    real, intent(out):: sky(1:2)\n    real:: pi,ee,old,theta,rt,r(1:3),x,y\n\n    pi=4.*atan(1.)\n\n    !calculate eccentric anomaly with newton-raphson\n    ee=mean\n    old=mean\n    do\n        old=ee\n        ee=ee-(ee-ecc*sin(ee)-mean)/(1.-ecc*cos(ee))\n        if (old-ee<1.e-6) exit\n    end do\n\n    !calculate true anomaly and true distance\n    theta=2.*atan(sqrt((1.+ecc)/(1.-ecc))*tan(0.5*ee))\n    rt = a*(1.-ecc*ecc)/(1.+ecc*cos(theta)) \n\n    !get x and y positions\n    r(1:3)=0.\n    r(1)=rt*cos(theta)\n    r(2)=rt*sin(theta)\n    !orientation around z axis\n    x=r(1);y=r(2)\n    r(1)=x*cos(phi)-y*sin(phi)\n    r(2)=x*sin(phi)+y*cos(phi)\n    !modify inclination\n    x=r(1);y=r(2)\n    r(1)=x\n    r(2)=y*cos(inc)\n    r(3)=y*sin(inc)\n    !positions on the sky\n    sky(1)=r(1)\n    sky(2)=r(3)\n\nend subroutine makeobsbinary\n"}
{"instruction": "Create a Fortran subroutine named linear_regress to calculate the linear regression coefficients and optionally the correlation coefficient. The subroutine takes 3 input parameters of type integer, real(kind=8) array of dimension nn, and real(kind=8) array of dimension nn. It returns 3 output parameters of type real(kind=8), real(kind=8), and optionally real(kind=8).", "input": "", "output": "subroutine linear_regress(nn,x,y,a,b,r)\n! get a, b in y = a.x + b\n! and optionally correlation r\n\nimplicit none\n\ninteger, intent(in) :: nn\n\nreal(kind=8), dimension(nn), intent(in) :: x, y\n\nreal(kind=8), intent(out) :: a, b\n\nreal(kind=8), intent(out), optional :: r\n\nreal(kind=8) :: sumx, sumy, sumx2, sumy2, sumxy\n\nsumx  = sum(x)\nsumy  = sum(y)                                                           \nsumx2 = sum(x*x)                                                             \nsumy2 = sum(y*y)                                                             \nsumxy = sum(x*y)                                                             \n\na = (nn * sumxy  -  sumx * sumy) / (nn * sumx2 - sumx**2)          ! slope\nb = (sumy * sumx2  -  sumx * sumxy) / (nn * sumx2  -  sumx**2)     ! y-intercept\nr = (sumxy - sumx * sumy / nn)                       &             ! correlation coefficient\n&   / sqrt((sumx2 - sumx**2/nn) * (sumy2 - sumy**2/nn))\n\nend subroutine linear_regress\n"}
{"instruction": "Write a Fortran subroutine named spl_make_open_knots to generate open knot vector for a spline. The subroutine takes 2 input parameters of type integer, p and n, and has 1 output parameter of type real(kind=8), dimension(:), knots.", "input": "", "output": "  subroutine spl_make_open_knots(n, p, knots)\n    implicit none\n    integer, intent(in)  :: p\n    integer, intent(in)  :: n\n    real(kind=8), dimension(:), intent(out) :: knots\n    ! local\n    integer :: n_elements\n    integer :: i\n    integer :: i_b\n    integer :: i_e\n\n    i_b = lbound(knots, 1)\n    i_e = ubound(knots, 1)\n\n    n_elements = n - p\n\n    knots = 0.0\n    do i = i_b, i_b + p, 1\n      knots(i) = 0.0d0\n    end do\n\n    do i = i_b + 1 + p, i_b + n, 1\n      knots(i) = (i - i_b - p)*1.0d0/n_elements\n    end do\n\n    do i = i_b + 1 + n, i_b + n + p, 1\n      knots(i) = 1.0d0\n    end do\n\n  end subroutine spl_make_open_knots\n"}
{"instruction": "Create a Fortran subroutine named lin_reg to perform linear regression on a set of data points. The subroutine takes 3 input parameters of type integer, real(kind=8), and real(kind=8) and 3 output parameters of type real(kind=8), real(kind=8), and real(kind=8), respectively. The subroutine calculates the slope, y-intercept, and correlation coefficient for the given data points.", "input": "", "output": "subroutine lin_reg(x_data,y_data,npts,slope,y_inter,corre)\n\nimplicit none                                   \n!     number of points in the given data arrays\ninteger,intent(in) :: npts\n!     the x coordinates of the given data\nreal(kind=8), intent(in) :: x_data(npts)\n!     the y coordinates of the given data\nreal(kind=8), intent(in) :: y_data(npts)\n!     the slope of the y data \nreal(kind=8), intent(out) :: slope \n!     the y-intercept for the y data\nreal(kind=8), intent(out) :: y_inter\n!     the correlation coefficient of the given data\nreal(kind=8), intent(out) :: corre\n!     squared correlation coefficient \nreal(kind=8) ::  r    \n!     intermediate sums for calculations \nreal(kind=8) :: sumx,sumy,sumx2,sumy2,sumxy                       \n!     actual x and y coordinates \nreal(kind=8) :: x,y\n!     loop index\ninteger :: i\n!\n!     set default values for variables \n!\nslope=0.d0\ny_inter=0.d0\ncorre=0.d0\nsumx=0.d0\nsumy=0.d0\nsumx2=0.d0\nsumy2=0.d0\nsumxy=0.d0\n!\n!     perform loop over all data pairs and calculate values \n!\ndo i=1,npts\n!\n!     read out actual data from array\n!\n   x=x_data(i)\n   y=y_data(i)\n!\n!     compute sum of x\n!\n   sumx  = sumx + x  \n!\n!     compute sum of x**2\n!\n   sumx2 = sumx2 + x * x  \n!\n!     compute sum of x * y\n!\n   sumxy = sumxy + x * y\n!\n!     compute sum of y\n!\n   sumy  = sumy + y  \n!\n!     compute sum of y**2\n!\n   sumy2 = sumy2 + y * y\nend do\n!\n!     compute slope\n!\nslope = (npts * sumxy  -  sumx * sumy) / (npts * sumx2 - sumx**2)   \n!\n!     compute y-intercept\n!\ny_inter = (sumy * sumx2  -  sumx * sumxy) / (npts * sumx2  -  sumx**2) \n!\n!     compute correlation coefficient\n!\ncorre = (sumxy-sumx*sumy/npts)/sqrt((sumx2-sumx**2/npts)*(sumy2-sumy**2/npts))\n\nreturn\nend subroutine lin_reg\n"}
{"instruction": "Write a Fortran subroutine named cholsl that performs backward and forward substitution to solve a linear system of equations using the Cholesky factorization method. The subroutine takes 5 input parameters of type integer(4), integer(4), real(8), real(8), and real(8), and 1 output parameter of type real(8).", "input": "", "output": "subroutine cholsl(a,n,np,p,b,x)\n  \n    integer(4), intent(in)      :: n, np\n    real(8), intent(in)         :: a(1:np,1:np), p(1:n), b(1:n)\n    real(8), intent(out)        :: x(1:n)\n    integer(4)                  :: i, k\n    real(8)                     :: sum\n\n    do i = 1, n\n      sum = b(i)\n      do k = i-1, 1, -1\n        sum = sum - a(i,k)*x(k)\n      enddo\n      x(i) = sum/p(i)\n    enddo\n    do i = n, 1, -1\n      sum = x(i)\n      do k = i+1, n\n        sum = sum - a(k,i)*x(k)\n      enddo\n      x(i) = sum/p(i)\n    enddo\n    return\n\nend subroutine cholsl\n"}
{"instruction": "Create a Fortran subroutine named calc_rcouple_scales to calculate the rscale values based on the input arrays a and msf. The subroutine takes 6 input parameters of types integer, integer, integer, integer, real, and real, and 1 output parameter of type real. The function computes the rscale values using the formula rscale(i) = a(i)/msf(i) for the specified range of indices.", "input": "", "output": "  subroutine calc_rcouple_scales(a, msf, rscale, ims,ime, its,ite)\n\n  implicit none\n\n\n  integer, intent(in)  :: ims,ime           \n  integer, intent(in)  :: its,ite           \n  real, intent(in)     :: a( ims:ime )      \n  real, intent(in)     :: msf( ims:ime )    \n  real, intent(out)    :: rscale( ims:ime ) \n\n\n  integer :: i\n\n\n  do i = its,ite\n    rscale(i) = a(i)/msf(i)\n  enddo\n\n  return\n  end subroutine calc_rcouple_scales\n"}
{"instruction": "Write a Fortran subroutine named minmax_r that takes an array of 64-bit real numbers as input and returns the minimum and maximum values found in the array as output. The input parameter should be of type real(kind=8), dimension(:), and the output parameters should be of type real(kind=8).", "input": "", "output": "subroutine minmax_r (array, min, max)\n  implicit none\n\n  real(kind=8), intent(in), dimension(:) :: array\n\n  real(kind=8), intent(out) :: min, max\n  integer :: i\n\n  do i = 1, size(array)\n     if (array(i) > min) min = array(i)\n     if (array(i) < max) max = array(i)\n  end do\nend subroutine minmax_r\n"}
{"instruction": "Create a Fortran subroutine named calend that takes two input parameters of type integer, yyyy and ddd, and two output parameters of type integer, mm and dd. The subroutine is responsible for converting a given year and day of the year into the corresponding month and day of the month, using the ACM Algorithm 398. The number of input arguments is 2 and the test_data type is ['integer', 'integer']. The number of output arguments is 2 and the test_data type is ['integer', 'integer'].", "input": "", "output": "subroutine calend(yyyy, ddd, mm, dd)\r\n!=============calend when given a valid year, yyyy, and day of the year, ddd,\r\n!             returns the month, mm, and day of the month, dd.\r\n!             see acm algorithm 398, tableless date conversion, by\r\n!             dick stone, cacm 13(10):621.\r\n\r\ninteger, intent(in)   :: yyyy\r\ninteger, intent(in)   :: ddd\r\ninteger, intent(out)  :: mm\r\ninteger, intent(out)  :: dd\r\n\r\ninteger :: t\r\n\r\nt = 0\r\nif(mod(yyyy, 4) == 0) t = 1\r\n\r\n!-----------the following statement is necessary if yyyy is < 1900 or > 2100.\r\nif(mod(yyyy, 400) /= 0 .and. mod(yyyy, 100) == 0) t = 0\r\n\r\ndd = ddd\r\nif(ddd > 59+t) dd = dd + 2 - t\r\nmm = ((dd+91)*100)/3055\r\ndd = (dd+91) - (mm*3055)/100\r\nmm = mm - 2\r\n!----------mm will be correct iff ddd is correct for yyyy.\r\nif(mm >= 1 .and. mm <= 12) return\r\nwrite(*,1) ddd\r\n1 format('0$$$calend: day of the year input =', i11,  ' is out of range.')\r\n\r\nstop\r\nend subroutine calend\r\n"}
{"instruction": "Create a Fortran subroutine named m_wat to compute the complex index of refraction of liquid water based on frequency and temperature. The subroutine takes 2 input parameters of type real*8, representing frequency and temperature, and returns 2 output parameters of type real*8, representing the real and imaginary parts of the index of refraction.", "input": "", "output": "  subroutine m_wat(freq, tk, n_r, n_i)\n  implicit none\n!  \n! purpose:\n!   compute complex index of refraction of liquid water\n!\n! inputs:\n!   [freq]    frequency (ghz)\n!   [tk]       temperature (k)\n!\n! outputs:\n!   [n_r]     real part index of refraction\n!   [n_i]     imaginary part index of refraction\n!\n! reference:\n!   based on the work of ray (1972)\n!\n! coded:\n!   03/22/05  john haynes (haynes@atmos.colostate.edu)\n  \n! ----- inputs -----\n  real*8, intent(in) :: freq,tk\n  \n! ----- outputs -----\n  real*8, intent(out) :: n_r, n_i\n\n! ----- internal -----    \n  real*8 ld,es,ei,a,ls,sg,tm1,cos1,sin1\n  real*8 e_r,e_i\n  real*8 pi\n  real*8 tc\n  complex*16 e_comp, sq\n\n  tc = tk - 273.15\n\n  ld = 100.*2.99792458e8/(freq*1e9)\n  es = 78.54*(1-(4.579e-3*(tc-25.)+1.19e-5*(tc-25.)**2 &\n       -2.8e-8*(tc-25.)**3))\n  ei = 5.27137+0.021647*tc-0.00131198*tc**2\n  a = -(16.8129/(tc+273.))+0.0609265\n  ls = 0.00033836*exp(2513.98/(tc+273.))\n  sg = 12.5664e8\n\n  tm1 = (ls/ld)**(1-a)\n  pi = acos(-1.d0)\n  cos1 = cos(0.5*a*pi)\n  sin1 = sin(0.5*a*pi)\n\n  e_r = ei + (((es-ei)*(1.+tm1*sin1))/(1.+2*tm1*sin1+tm1**2))\n  e_i = (((es-ei)*tm1*cos1)/(1.+2*tm1*sin1+tm1**2)) &\n        +((sg*ld)/1.885e11)\n\n  e_comp = dcmplx(e_r,e_i)\n  sq = sqrt(e_comp)\n  \n  n_r = real(sq)\n  n_i = aimag(sq)      \n  \n  return\n  end subroutine m_wat\n"}
{"instruction": "Create a Fortran subroutine named \"hmatrix\" to generate a matrix \"h\" based on the input data. The subroutine should take 6 input parameters: nl and nr of type integer(ip), model_i and model_j of type integer(ip) arrays with dimension nl, and codar_i and codar_j of type integer(ip) arrays with dimension nr. It should also have 1 output parameter: h of type integer(ip) array with dimension (2*nr,2*nl). This subroutine allocates memory for array \"c\", initializes matrix \"h\" with zeros, populates array \"c\" based on the input data, and then fills matrix \"h\" based on the values of array \"c\".", "input": "", "output": "subroutine hmatrix(nl,nr,codar_i,codar_j,model_i,model_j,h)\n    implicit none\n    integer,parameter::ip=4,wp=8\n\n    integer(ip),intent(in):: nl,nr\n    integer(ip),dimension(nl),intent(in) :: model_i,model_j\n    integer(ip),dimension(nr),intent(in) :: codar_i,codar_j\n    integer(ip),allocatable,dimension(:,:) :: c\n    integer(ip),intent(out),dimension(2*nr,2*nl) :: h\n\n    integer(ip)i,j\n    allocate(c(nr,nl))\n    h(:,:) = 0\n    do i = 1,nr\n      do j = 1,nl\n        if (codar_i(i) == model_i(j) .and. codar_j(i) == model_j(j)) then\n           c(i,j) = 1\n        else\n           c(i,j) = 0\n        end if\n      end do\n    end do\n\n      do i =1,nr\n        do j = 1,nl\n          h(i,j) = c(i,j)\n          h(nr+i,nl+j) = c(i,j)\n        end do\n      end do\n\nend subroutine hmatrix\n"}
{"instruction": "Create a Fortran subroutine named perform_integral to calculate the integral of a given function using the trapezoidal rule. The subroutine takes 3 input parameters of type real, dimension(1:), real, dimension(1:), and integer, and 1 output parameter of type real.", "input": "", "output": "subroutine perform_integral(n,f,w,answer)\nimplicit none\n   real,dimension(1:), intent(in):: f,w \n   real, intent(out):: answer\n   integer, intent(in):: n\n   real:: sum\n   integer:: iv\n  \n   sum = 0.0\n   do iv= 1,n\n     sum = sum + w(iv)*f(iv)\n   end do\n\n   answer = sum\n\nend subroutine perform_integral\n"}
{"instruction": "Create a Fortran subroutine named snowz0 that calculates the effective roughness length (z0) for snow-covered surfaces. The subroutine takes 2 input parameters of type real (z0brd and snowh) and returns 1 output parameter of type real (z0).", "input": "", "output": "  subroutine snowz0 (z0, z0brd, snowh)\n    implicit none\n    real, intent(in) :: z0brd\n    real, intent(out) :: z0\n    real, parameter :: z0s=0.001\n    real, intent(in) :: snowh\n    real :: burial\n    real :: z0eff\n    burial = 7.0*z0brd - snowh\n    if(burial.le.0.0007) then\n       z0eff = z0s\n    else\n       z0eff = burial/7.0\n    endif\n    z0 = z0eff\n  end subroutine snowz0\n"}
{"instruction": "Create a Fortran subroutine named setwtlimits that calculates the maximum and minimum values of weights for each category. The subroutine takes 2 input parameters of type integer and returns 2 output parameters of type integer. The input parameters are numcatobs and weights, and the output parameters are maxw and minw.", "input": "", "output": "subroutine setwtlimits(numcatobs,weights,maxw,minw)\r\nimplicit none\r\ninteger,intent(in)::numcatobs(:),weights(:)\r\ninteger,intent(out)::maxw(:),minw(:)\r\n!\tcounter counts categories.\r\n!\titem counts items.\r\ninteger::counter,item\r\ncounter=1\r\ndo item=1,size(numcatobs)\r\n\tmaxw(item)=maxval(weights(counter:counter+numcatobs(item)-1))\r\n\tminw(item)=minval(weights(counter:counter+numcatobs(item)-1))\r\n\tcounter=counter+numcatobs(item)\r\nend do\r\nreturn\r\nend subroutine setwtlimits\n"}
{"instruction": "Write a Fortran subroutine named mapc2pspherical to convert Cartesian coordinates to spherical coordinates. The subroutine takes 5 input parameters of type real(kind=8) and dimension, and 3 output parameters of type real(kind=8) and dimension. The input parameters are xc, yc, zc, xyz0, and xyzn, while the output parameters are xp, yp, and zp.", "input": "", "output": "  subroutine mapc2pspherical(xc,yc,zc,xyz0,xyzn,xp,yp,zp)\n\n    implicit none\n\n    ! input\n    real(kind=8), dimension(:), intent(in) :: xc,yc,zc\n    real(kind=8), dimension(3), intent(in) :: xyz0,xyzn\n\n    ! output\n    real(kind=8), dimension(size(xc)), intent(out) :: xp\n    real(kind=8), dimension(size(yc)), intent(out) :: yp\n    real(kind=8), dimension(size(zc)), intent(out) :: zp\n\n    ! local\n    real(kind=8), dimension(size(xc)) :: theta\n    real(kind=8), dimension(size(yc)) :: phi\n    real(kind=8), dimension(size(zc)) :: r\n\n    ! x,xi coordinate\n    xp = xyz0(1) + xc*(xyzn(1)-xyz0(1))\n\n    ! y,eta coordinate\n    yp = xyz0(2) + yc*(xyzn(2)-xyz0(2))\n\n    ! z,phi coordinate\n    zp = xyz0(3) + zc*(xyzn(3)-xyz0(3))\n\n    ! spherical to cartesian coordinates\n    theta = xp\n    phi = yp\n    r = zp    \n    xp = r*sin(theta)*cos(phi)\n    yp = r*sin(theta)*sin(phi)\n    zp = r*cos(theta)\n\n    return\n  end subroutine mapc2pspherical\n"}
{"instruction": "Create a Fortran subroutine named calc_signal to calculate a signal value based on given parameters. The subroutine takes 8 input parameters of types integer, real(8), real(8), real(8), real(8), real(8), real(8), real(8). It returns 1 output parameter of type real(8).", "input": "", "output": "subroutine calc_signal(np,xn,yn,an,bn,cn,dn,xx,signal)\n  implicit none\n  integer,intent(in) :: np\n  real(8),intent(in) :: xn(0:np-1),yn(0:np-1)\n  real(8),intent(in) :: an(0:np-2),bn(0:np-2),cn(0:np-2),dn(0:np-2)\n  real(8),intent(in) :: xx\n  real(8),intent(out) :: signal\n  integer :: ip\n  real(8) :: dx, xx_abs\n  \n\n  xx_abs = abs(xx)\n\n  if(xx_abs < xn(0))then\n    write(*,*)\"error: xx<xn(0)\"\n    stop\n  end if\n\n  if(xx_abs > xn(np-1))then\n    write(*,*)\"error: xx>xn(np-1)\"\n    stop\n  end if\n\n  do ip = 1,np-1\n    if(xx_abs <= xn(ip))exit\n  end do\n  ip = ip - 1\n  dx = xx_abs - xn(ip)\n\n  signal = an(ip)*dx**3 + bn(ip)*dx**2 + cn(ip)*dx + dn(ip)\n  signal = sign(signal,xx)\n\nend subroutine calc_signal\n"}
{"instruction": "Create a Fortran subroutine named calindex to calculate the indices i, j, and k based on the input parameters para, nvx, and nvz. The number of input parameters is 3, and the test_data type is ['integer', 'integer', 'integer']. The number of output parameters is 3, and the test_data type is ['integer', 'integer', 'integer'].", "input": "", "output": "       subroutine calindex(para,nvx,nvz,i,j,k)\n       implicit none\n       integer,intent(in):: para\n       integer,intent(in):: nvx,nvz\n       integer,intent(out):: i,j,k\n       integer:: res\n\n       k=int(para/(nvz*nvx))\n       k=k+1\n       res=para-(k-1)*(nvz*nvx)\n       if (res.eq.0)then\n            k=k-1\n            res=para-(k-1)*(nvz*nvx)\n       endif\n       j=int(res/(nvx))\n       j=j+1\n       i=res-(j-1)*nvx\n        if (i.eq.0)then\n            j=j-1\n            i=res-(j-1)*nvx\n         endif\n         end subroutine calindex\n"}
{"instruction": "Write a Fortran subroutine named \"raingas\" that computes the gas-phase rainwater mixing ratio.The subroutine takes 7 input parameters of type real: rrain, dtscav, clwx, cfx, qm, qt, qtdis, and returns 1 output parameter of type real: qtrain.", "input": "", "output": "subroutine raingas( rrain, dtscav, clwx, cfx, qm, qt, qtdis, qtrain )\n      real, intent(in) :: rrain\n      real, intent(in) :: dtscav\n      real, intent(in) :: clwx,cfx\n      real, intent(in) :: qm\n      real, intent(in) :: qt\n      real, intent(in) :: qtdis\n      real, intent(out) :: qtrain\n      real :: qtlf, qtdisstar\n      qtdisstar = (qtdis*(qt*cfx))/(qtdis+(qt*cfx))\n      qtlf = (rrain*qtdisstar)/(clwx*qm*qt*cfx)\n      qtrain = qt*cfx*(one - exp( -dtscav*qtlf ))\nend subroutine raingas\n"}
{"instruction": "Write a Fortran subroutine named set_descra to determine the descriptor string for a matrix based on its properties. The subroutine takes 1 input parameter of type integer and returns 2 output parameters of types character*11 and integer. The descriptor string represents various properties of the matrix and is stored in the output parameter descra. The integer output parameter ierr indicates the success or failure of the operation.", "input": "", "output": "      subroutine set_descra(descra,prpty,ierr)\n      character*11, intent(out) :: descra\n      integer, intent(in) :: prpty\n      integer, intent(out) :: ierr\n      integer :: dummy\n      descra = ''\n      ierr = -1\n      dummy = prpty\n      !check, if matrix has unstored unity diagonal\n      if (mod(dummy,2).eq.1) then\n         descra(1:1) = 'u'\n      else\n         descra(1:1) = 'n' !default\n      end if\n      dummy = dummy - mod(dummy,2)\n      !repeated indices \n      if (mod(dummy,4).eq.2) then\n         descra(2:2) = 'r' \n      else\n         descra(2:2) = 'u' !default\n      end if\n      dummy = dummy - mod(dummy,4)      \n      !both/lower/upper half of matrix specified\n      select case(mod(dummy,16))\n      case(0)\n         descra(3:3) = 'b' !default\n      case(4)\n         descra(3:3) = 'u'\n      case(8)\n         descra(3:3) = 'l'\n      case default\n         return\n      end select\n      dummy = dummy - mod(dummy,16)      \n      !matrix is irregular/regular/unassembled\n      select case(mod(dummy,64))\n      case(0)\n         descra(4:4) = 'i' !default\n      case(16)\n         descra(4:4) = 'r'\n      case(32)\n         descra(4:4) = 'u'\n      case default\n         return\n      end select\n      dummy = dummy - mod(dummy,64)      \n      !index base\n      if (mod(dummy,128).eq.64) then\n         descra(5:5) = 'c' \n      else \n         descra(5:5) = 'f' !default\n      end if\n      dummy = dummy - mod(dummy,128)      \n      ! matrix type\n      select case(mod(dummy,1024))\n      case (0)\n         descra(6:6) = 'g' !default\n      case(128)\n         descra(6:6) = 's'\n      case(256)\n         descra(6:6) = 'h'\n      case(512)\n         descra(6:6) = 't'\n      case default\n         return\n      end select\n      dummy = dummy - mod(dummy,1024)      \n      !internal block storage\n      if (mod(dummy,2048).eq.1024) then\n         descra(7:7) = 'r' \n      else \n         descra(7:7) = 'c' !default\n      end if\n      dummy = dummy - mod(dummy,2048)      \n      ierr = 0\n      end subroutine set_descra\n"}
{"instruction": "Write a Fortran subroutine named get_infoa to retrieve specific information from an integer array based on the given description. The subroutine takes 2 input parameters of type ['integer, dimension(10)', 'character'] and 2 output parameters of type ['integer', 'integer']. The subroutine uses a select case statement to determine the value of 'val' based on the input 'descr' and assigns it to the output parameter 'val'. Additionally, the subroutine sets the output parameter 'ierr' to 0 if the operation is successful, otherwise sets it to -1.", "input": "", "output": "      subroutine get_infoa(infoa,descr,val,ierr)\n      implicit none\n      integer, dimension(10), intent(in) :: infoa\n      character, intent(in) :: descr\n      integer, intent(out) :: val,ierr\n      val = -1\n      ierr = -1\n      select case(descr)\n      case('b') !base of array indices\n         val = infoa(2)\n      case('c') !copy or not\n         val = infoa(9)\n      case('d') !multidim array:row-dim of block\n         val = infoa(3)\n      case('e') !multidim array:col-dim of block\n         val = infoa(4)\n      case('f') !block structure array:row-dim in blocks\n         val = infoa(5)\n      case('g') !block structure array:col-dim in blocks\n         val = infoa(6)\n      case('n') !nnz\n         val = infoa(1)\n      case default\n         return\n      end select\n      ierr = 0\n      end subroutine get_infoa\n"}
{"instruction": "Write a Fortran subroutine named mk_iseed that takes 4 input parameters of type integer: ymdh, ij, ilev, and n. It also has 1 output parameter of type integer: iseed. The subroutine computes the value of iseed based on the input parameters using a series of arithmetic operations.", "input": "", "output": "subroutine mk_iseed(ymdh, ij,ilev,n,iseed)\n  integer, intent(in) :: ymdh, ij, ilev, n\n  integer, intent(out) :: iseed\n  integer :: index_grd\n  integer :: index_date\n  integer :: dd, hh\n  integer :: ymdhtmp=1982123112\n\n! hh = ymdhtmp-nint(ymdhtmp*0.01d0)*100\n! dd = nint( (ymdhtmp-nint(ymdhtmp*0.0001d0)*10000-hh) * 0.01d0)\n  hh = ymdh-nint(ymdh*0.01d0)*100\n  dd = nint( (ymdh-nint(ymdh*0.0001d0)*10000-hh) * 0.01d0)\n  index_date = (dd-1)*24 + hh\n  index_grd = (ij-1)*nprocs + myrank+1\n  iseed = index_date*1000 + index_grd*100 + n*10 + ilev\n\n  return\nend subroutine mk_iseed\n"}
{"instruction": "Write a Fortran subroutine named copy_data_5d_real8 that takes an input array of 5D real(8) data and copies it to an output array of the same type and dimensions.The number of input arguments is 1 and the test_data type is [real(8)], and the number of output arguments is 1 with the test_data type [real(8)].", "input": "", "output": "  subroutine copy_data_5d_real8(src,dst)\n    implicit none\n    real(8), intent(in)  :: src(:,:,:,:,:)\n    real(8), intent(out) :: dst(:,:,:,:,:)\n    integer :: nx,ny,nz,nw,nl\n    integer :: ix,iy,iz,iw,il\n\n    nl = size(src,5)\n    nw = size(src,4)\n    nz = size(src,3)\n    ny = size(src,2)\n    nx = size(src,1)\n\n!$omp parallel do collapse(4) default(none) &\n!$omp          private(ix,iy,iz,iw,il) &\n!$omp          firstprivate(nx,ny,nz,nw,nl) &\n!$omp          shared(src,dst)\n    do il=1,nl\n    do iw=1,nw\n    do iz=1,nz\n    do iy=1,ny\n    do ix=1,nx\n      dst(ix,iy,iz,iw,il) = src(ix,iy,iz,iw,il)\n    end do\n    end do\n    end do\n    end do\n    end do\n!$omp end parallel do\n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named \"mc_step\" that takes 3 input parameters of type real(8) in the form of arrays \"rthetaphi1\", \"center_xyz\", and \"stepsize\". The subroutine should also have 2 output parameters of type real(8) in the form of arrays \"rthetaphi2\" and \"xyz2\". The subroutine should compute changes in spherical coordinates and corresponding Cartesian coordinates based on the input parameters using Monte Carlo simulation steps. Ensure that the subroutine uses the random_number function to generate random numbers and returns the updated values in \"rthetaphi2\" and \"xyz2\".", "input": "", "output": "subroutine mc_step(rthetaphi1, center_xyz, rthetaphi2, xyz2, stepsize)\nreal(8), intent(in)  :: rthetaphi1(3)\nreal(8), intent(in)  :: center_xyz(3)\nreal(8), intent(in)  :: stepsize\nreal(8), intent(out) :: rthetaphi2(3), xyz2(3)\nreal(8)              :: rand1, rand2                ! random numbers to change theta and phi\nreal(8), parameter   :: pi = 3.14159265358979323846 ! define pi\n\ncall random_number(rand1)                         ! random number to change theta\ncall random_number(rand2)                         ! same for phi\nrthetaphi2(1) = rthetaphi1(1)\nrthetaphi2(2) = rthetaphi1(2) + (2*rand1 - 1)*pi*stepsize \nrthetaphi2(3) = rthetaphi1(3) + (2*rand2 - 1)*2*pi*stepsize\nxyz2(1)       = rthetaphi2(1)*sin(rthetaphi2(2))*cos(rthetaphi2(3)) + center_xyz(1)\nxyz2(2)       = rthetaphi2(1)*sin(rthetaphi2(2))*sin(rthetaphi2(3)) + center_xyz(2)\nxyz2(3)       = rthetaphi2(1)*cos(rthetaphi2(2)) + center_xyz(3)\nreturn\nend subroutine mc_step\n"}
{"instruction": "Create a Fortran subroutine named get_lo_hi to calculate the lower and upper indices for each block in a block-based partitioning scheme. The subroutine takes 2 input parameters of type integer: ncells and nblks, and returns 2 output parameters of type integer: lo and hi. The function calculates the lower and upper indices for each block based on the total number of cells and the number of blocks specified.", "input": "", "output": "  subroutine get_lo_hi(ncells, nblks, lo, hi)\r\n    integer, intent(in) :: ncells, nblks\r\n    integer, intent(out) :: lo(0:nblks-1), hi(0:nblks-1)\r\n    integer ::  blksize, nleft, i\r\n    blksize = ncells/nblks\r\n    nleft = ncells - nblks * blksize  ! note nleft < nblks\r\n    do i=0,nblks-1\r\n       lo(i) = i*blksize + min(nleft, i)\r\n    end do\r\n    if (nblks .ge. 2) then\r\n       do i=0,nblks-2\r\n          hi(i) = lo(i+1)-1\r\n       end do\r\n    end if\r\n    hi(nblks-1) = ncells-1\r\n  end subroutine get_lo_hi\r\n"}
{"instruction": "Create a Fortran subroutine named get_key_value to extract a key_word and key_value from a string formatted as key_word=key_value. The subroutine takes 1 input parameter of type character(100) and 2 output parameters of type character(100).", "input": "", "output": "   subroutine get_key_value(line, key_word, key_value)\n\n      ! seperate a key_word and key_value component of a string given key_word=key_value syntax\n\n      character(100), intent(in)  :: line\n      character(100), intent(out) :: key_word, key_value\n\n      key_word = \"\"\n      key_value = \"\"\n\n      key_word = line(1:index(line, '=') - 1)\n      key_value = line(index(line, '=') + 1:len_trim(line))\n\n      if (key_value(1:1) .eq. '\"' .or. key_value(1:1) .eq. \"'\") key_value = key_value(2:len_trim(key_value) - 1)\n\n   end subroutine get_key_value\n"}
{"instruction": "Create a Fortran subroutine named ddthetahpauto to compute the auto-correlation function for Healpix data. The subroutine takes 7 input parameters of types ['integer', 'integer', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(n1)', 'real(8),dimension(m)'], and has 1 output parameter of type ['real(8),dimension(2,m-1)'].", "input": "", "output": "subroutine ddthetahpauto(theta1, phi1, delta1, fpix1, bins, c, n1, m)\n    ! auto correlation function \n    ! healpix based\n    implicit none\n\n    ! variables\n    integer,intent(in)                  :: n1, m\n    real(8),dimension(n1),intent(in)    :: theta1, phi1, delta1, fpix1\n    real(8),dimension(m),intent(in)     :: bins\n    real(8),dimension(2,m-1),intent(out) :: c\n\n    ! local variables\n    real(8) :: s, be, sinti, costi, sinpi, cospi, delta1i, fpix1i\n    integer :: i,j,binid\n    real(8), dimension(n1) :: cost1,sint1,cosp1,sinp1\n\n    ! theta and phi\n    cost1 = dcos(theta1)\n    sint1 = dsin(theta1)\n    cosp1 = dcos(phi1)\n    sinp1 = dsin(phi1)\n\n\n    c    = 0.0\n    s    = 0.0\n\n    do i = 1, n1\n        ! temp array\n        sinti   = sint1(i)\n        costi   = cost1(i)\n        sinpi   = sinp1(i)\n        cospi   = cosp1(i)\n        delta1i = delta1(i)\n        fpix1i  = fpix1(i)\n\n        do j = i+1, n1  ! no auto pairs\n           s = sinti*sint1(j)*(cospi*cosp1(j) + sinpi*sinp1(j)) + (costi*cost1(j))\n           be = bins(1) ! starts from the max sep angle\n           binid = 0\n           do while (s > be)\n                binid = binid + 1\n                be    = bins(binid+1)\n           end do\n           if ((binid .ge. 1) .and. (binid .le. m)) then\n               c(1,binid) = c(1,binid) + delta1i*delta1(j)*fpix1i*fpix1(j)\n               c(2,binid) = c(2,binid) + fpix1i*fpix1(j)\n           end if\n           s = 0\n        end do\n    end do\n\nreturn\nend subroutine ddthetahpauto\n"}
{"instruction": "Create a Fortran subroutine named fitline that calculates the parameters of a linear fit and the chi-squared value. The subroutine takes 3 input parameters of type real*8, real*8, and integer, and 3 output parameters of type real*8, real*8, and real*8.", "input": "", "output": "subroutine fitline(a, b, chi2, xw, fw, n)\n  implicit none\n  real*8, intent(out) :: a, b, chi2\n  real*8, intent(in)  :: xw(n), fw(n)\n  integer, intent(in) :: n\n  ! locals\n  real*8 :: s, sx, sxx, sy, sxy, x, y, den\n  integer :: i\n  do i=1,n\n     x = xw(i)\n     y = fw(i)\n     s   = s   + 1\n     sx  = sx  + x\n     sxx = sxx + x*x\n     sy  = sy  + y\n     sxy = sxy + x*y\n  enddo\n  den = s*sxx-sx*sx\n  a = (sxx*sy-sx*sxy)/den\n  b = (s*sxy-sx*sy)/den\n  chi2=0\n  do i=1,n\n     chi2 = chi2 + (a+b*xw(i) - fw(i))**2\n  enddo\n  chi2 = chi2/n\nend subroutine fitline\n"}
{"instruction": "Create a Fortran subroutine named \"twodee_bathy\" to calculate the depth of a two-dimensional bathymetry based on the provided land and depth data. The subroutine should take 7 input parameters of types real, integer, and integer, and 1 output parameter of type real. The input parameters are temp1(ix,iy), depth1(maxk+1), maxi, maxj, maxk, ix, iy, and iland(0:maxi+1,0:maxj+1).", "input": "", "output": "  subroutine twodee_bathy(temp1, depth1, maxi, maxj, maxk, ix, iy, iland)\n    implicit none\n    real, intent(out) :: temp1(ix,iy)\n    real, intent(in) :: depth1(maxk+1)\n    integer, intent(in) :: maxi, maxj, maxk, ix, iy\n    integer, intent(in) :: iland(0:maxi+1,0:maxj+1)\n\n    integer :: i, j, here_dep\n\n    do j = 1, maxj\n       do i = 1, maxi\n          if (iland(i,j) >= 90) then\n             temp1(i,j) = -99999.0\n          else\n             here_dep = maxk - iland(i,j) + 2\n             if (here_dep < 1) print *, 'bathymetry too shallow'\n             if (here_dep > maxk+1) print *, 'bathymetry too deep'\n             temp1(i,j) = depth1(here_dep)\n          end if\n       end do\n    end do\n  end subroutine twodee_bathy\n"}
{"instruction": "Write a Fortran subroutine named egrid that computes energy grid points and grid intervals for a given number of bins. The subroutine takes 1 input parameter of type integer and 2 output parameters of type real, which store the energy grid points and grid intervals respectively.", "input": "", "output": "subroutine egrid (ener, del, nbins)\n\n  implicit none\n\n  integer,intent(in) :: nbins\n  real,intent(out) :: ener(nbins), del(nbins)\n\n  integer :: n\n\n  do n=1,nbins\n    if (n <= 21) then\n      ener(n) = 0.5 * float(n)\n    else\n      ener(n) = exp (0.05 * float(n+26))\n    endif\n  enddo\n\n  del(1) = 0.5\n\n  do n=2,nbins\n    del(n) = ener(n)-ener(n-1)\n  enddo\n\n  do n=1,nbins\n    ener(n) = ener(n) - del(n)/2.0\n  enddo\n\n  return\n\nend subroutine egrid\n"}
{"instruction": "Create a Fortran subroutine named read_in_mass_resolution_and_assignment_group to extract information from a character string. The subroutine takes 1 input parameter of type character(len=100) and returns 2 output parameters of type character(len=100) and double precision. The subroutine reads the input string and extracts a double precision value and a character string based on specific patterns within the input string.", "input": "", "output": " subroutine read_in_mass_resolution_and_assignment_group(line, dm, group)\n!--------------------------------------------------------------------\n character(len=100), intent(in) :: line\n character(len=100), intent(out) :: group\n double precision, intent(out) :: dm\n \n integer :: i, indx, prev, beginning\n integer :: j, indxstr, prevstr, beginningstr\n\n prev      = 0 \n beginning = 1 \n prevstr      = 0\n beginningstr = 1\n\n group = \"\"\n \n do i=1,len(line)\n\n  indx = index('0123456789.', line(i:i))\n  if (indx.eq.0 .and. prev.gt.0) then\n   read(line(beginning:i-1), *) dm\n  else if (indx.gt.0 .and. prev.eq.0) then\n   beginning = i \n  end if\n  prev = indx\n         \n  indxstr = index('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz_', line(i:i))\n  if (indxstr.eq.0 .and. prevstr.gt.0) then\n   read(line(beginningstr:i-1), *) group\n  else if (indxstr.gt.0 .and. prevstr.eq.0) then\n   beginningstr = i\n  end if\n  prevstr = indxstr\n end do\n \n! group=trim(adjustl(group_tmp))\n \n end subroutine read_in_mass_resolution_and_assignment_group \n"}
{"instruction": "Create a Fortran subroutine named load_div_parallel to distribute a given number of data points among a specified number of processors. The subroutine takes 1 input parameter of type integer and 2 output parameters of type integer. The input parameter represents the total number of data points, while the output parameters ir and id represent the distribution of data points among processors.", "input": "", "output": "  subroutine load_div_parallel( ir, id, ndat )\n    implicit none\n    integer,intent(out) :: ir(0:),id(0:)\n    integer,intent(in) :: ndat\n    integer :: np, nres, i, j\n    np=size(ir)\n    ir=ndat/np\n    nres = ndat - sum(ir)\n    do i = 1, nres\n      j = mod(i-1,np)\n      ir(j) = ir(j) + 1\n    end do\n    id=0\n    do i=0,np-1\n      id(i) = sum( ir(0:i) ) - ir(i)\n    end do\n  end subroutine load_div_parallel\n"}
{"instruction": "Create a Fortran subroutine named getvelo_mpt_dukowicz to calculate the pressure and velocity based on the given input parameters. The subroutine takes 9 input parameters of type real*8 and returns 2 output parameters of type real*8. The inputs are wl, wr, rhol, rhor, pl, pr, ssl, ssr, gamlg, and the outputs are p12 and w12. The subroutine performs a series of calculations using the input parameters to determine the pressure and velocity, and assigns the results to the output parameters.", "input": "", "output": "subroutine getvelo_mpt_dukowicz(wl,wr,rhol,rhor,pl,pr,ssl,ssr,gamlg,p12,w12)\nreal*8, intent(in):: wl,wr,rhol,rhor,pl,pr,ssl,ssr,gamlg\nreal*8, intent(out)::p12, w12\nreal*8::wmin,wmax,plmin,prmin,al,ar\nreal*8::a,b,c,d,bl,br,dd\n!\nal = (gamlg+1.d0)/2.d0\nar = (gamlg+1.d0)/2.d0\n!\nwmin=wr-0.5d0*ssr/ar\nwmax=wl+0.5d0*ssl/al\nplmin=pl-0.25d0*rhol*ssl**2/al\nprmin=pr-0.25d0*rhor*ssr**2/ar\nbl=rhol*al\nbr=rhor*ar\na=(br-bl)*(prmin-plmin)\nb=br*wmin**2-bl*wmax**2\nc=br*wmin-bl*wmax\nd=br*bl*(wmin-wmax)**2\n! ***\n! ***case a: w12-wmin>o,wl2-wmax<o\n! ***\ndd=sqrt(amax1(0.d0,d-a))\nw12=(b+prmin-plmin)/(c-sign(dd, wmax-wmin))\nif(w12-wmin.ge.0.d0.and.w12-wmax.le.0.) goto 10\n! ***\n! ***case b: w12-wmin<o,wl2-wmax>o\n! ***\ndd=sqrt(amax1(0.d0, d+a))\nw12=(b-prmin+plmin)/(c-sign(dd, wmax-wmin))\nif(w12-wmin.le.0..and.w12-wmax.ge.0.) goto 10\na=(bl+br)*(plmin-prmin)\nb=bl*wmax+br*wmin\nc=1./(bl+br)\n! ***\n! ***case c: w12-wmin>o,wl2-wmax>o\n! ***\ndd=sqrt(amax1(0.d0,a-d))\nw12=(b+dd)*c\nif(w12-wmin.ge.0..and.w12-wmax.ge.0.) goto 10\n! ***\n! *** case d: w12-wmin<o,wl2-wmax<o\n! ***\ndd=sqrt(amax1(0.d0,-a-d))\nw12=(b-dd)*c\n\n10 p12=0.5d0*(plmin+prmin+br*abs(w12-wmin)*(wl2-wmin)-bl*abs(w12-wmax)*(w12-wmax))\n\nend subroutine getvelo_mpt_dukowicz\n"}
{"instruction": "Create a Fortran subroutine named qdot to calculate the dot product of the first four elements of each row of an input matrix \"a\" with the corresponding elements of another input matrix \"b\". The number of input arguments is 2, with test_data types ['real(kind=8), dimension(:, :)','real(kind=8), dimension(size(a, 1), size(a, 2))']. The number of output arguments is 1, with a test_data type of ['real(kind=8), dimension(size(a, 1))']. Use the imperative tone to ensure that the subroutine qdot is implemented correctly.", "input": "", "output": "subroutine qdot(a, b, output)\n  real(kind=8), dimension(:, :), intent(in) :: a\n  real(kind=8), dimension(size(a, 1), size(a, 2)), intent(in) :: b\n  real(kind=8), dimension(size(a, 1)), intent(out) :: output\n  integer :: i\n\n  do i = 1, size(a, 1)\n     output(i) = dot_product(a(i, 1:4), b(i, 1:4))\n  enddo\n\nend subroutine qdot\n"}
{"instruction": "Write a Fortran subroutine named look_and_say to generate the next sequence in the \"look and say\" sequence based on the input string. The subroutine takes 1 input parameter of type character(len=*) and 1 output parameter of type character(len=*).", "input": "", "output": "  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(i2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(i2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n"}
{"instruction": "Create a Fortran subroutine named \"fmmspline\" to compute the cubic spline with specified endpoint conditions based on the Forsythe, Malcolm, and Moler method. The subroutine takes 2 input parameters of type real arrays with unspecified dimensions and returns 1 output parameter of type real array with unspecified dimensions.", "input": "", "output": "pure subroutine fmmspline(x,y, yp)\r\n! ------------------------------------------------------------------------------\r\n! purpose - compute the cubic spline with endpoint conditions chosen\r\n!    by fmm  (from the book by forsythe,malcolm & moler)\r\n  real,intent(in),dimension(:):: x,y\r\n  real,intent(out),dimension(:):: yp\r\n\r\n  integer:: i,n\r\n  real,allocatable,dimension(:):: dx,dy,delta,dd,alpha,beta,sigma\r\n  real:: deriv1,deriv2\r\n!-------------------------------------------------------------------------------\r\n  n=size(x)   ! y and yp must be at least this size\r\n  if (n<2) then\r\n    yp(1)=0.0\r\n    return\r\n  end if\r\n  allocate(dx(n-1), dy(n-1), delta(n-1))\r\n  dx(:)=x(2:n)-x(1:n-1)\r\n  dy(:)=y(2:n)-y(1:n-1)\r\n  delta(:)=dy(:)/dx(:)\r\n  if (n==2) then\r\n    yp(1)=delta(1)\r\n    yp(2)=delta(1)\r\n    deallocate(dx,dy,delta)\r\n    return\r\n  end if\r\n  allocate(dd(n-2))\r\n  dd(:)=delta(2:n-1)-delta(1:n-2)\r\n  if (n==3) then\r\n    deriv2=dd(1)/(x(3)-x(1))\r\n    deriv1=delta(1)-deriv2*dx(1)\r\n    yp(1)=deriv1\r\n    yp(2)=deriv1+deriv2*dx(1)\r\n    yp(3)=deriv1+deriv2*(x(3)-x(1))\r\n    deallocate(dx,dy,delta,dd)\r\n    return\r\n  end if\r\n! this gets rid of the trivial cases n=1,2,3. assume from here on n>3\r\n\r\n  allocate(alpha(n),beta(n),sigma(n))\r\n  alpha(1)=-dx(1)\r\n  alpha(2:n-1)=2.0*(dx(1:n-2)+dx(2:n-1))\r\n  do i=2,n-1                                                    ! serial loop\r\n    alpha(i)=alpha(i)-dx(i-1)*dx(i-1)/alpha(i-1)            ! fwd elimination\r\n  end do\r\n  alpha(n)=-dx(n-1)-dx(n-1)*dx(n-1)/alpha(n-1)\r\n\r\n  beta(1)=dd(2)/(x(4)-x(2)) - dd(1)/(x(3)-x(1))\r\n  beta(1)=beta(1)*dx(1)*dx(1)/(x(4)-x(1))\r\n\r\n  beta(2:n-1)=dd(1:n-2)\r\n\r\n  beta(n)=dd(n-2)/(x(n)-x(n-2)) - dd(n-3)/(x(n-1)-x(n-3))\r\n  beta(n)=-beta(n)*dx(n-1)*dx(n-1)/(x(n)-x(n-3)) \r\n\r\n  do i=2,n                                                    ! serial loop\r\n    beta(i)=beta(i)-dx(i-1)*beta(i-1)/alpha(i-1)          ! fwd elimination\r\n  end do\r\n\r\n  sigma(n)=beta(n)/alpha(n)\r\n  do i=n-1,1,-1                                 ! reverse order serial loop\r\n    sigma(i)=(beta(i)-dx(i)*sigma(i+1))/alpha(i)        ! back substitution\r\n  end do\r\n\r\n  yp(1:n-1)=delta-dx*(sigma(1:n-1)+sigma(1:n-1)+sigma(2:n))\r\n  yp(n)=yp(n-1)+dx(n-1)*3.0*(sigma(n)+sigma(n-1))\r\n\r\n  deallocate(dx,dy,delta, alpha,beta,sigma, dd)\r\n\r\n  return\r\nend subroutine fmmspline   ! ---------------------------------------------------\r\n"}
{"instruction": "Create a Fortran subroutine named \"shmagpowerspectrum\" to compute the dimensionless power spectrum of the magnetic field. The number of input parameters is 4, and the test_data type is ['real*8', 'real*8', 'real*8', 'integer']. The number of output parameters is 1, and the test_data type is ['real*8'].", "input": "", "output": "subroutine shmagpowerspectrum(c, a, r, lmax, spectra)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!\n!\tthis function will compute the dimensionless power spectrum\n!\tof the magnetic field evaluated at radius r, \n!\tgiven the schmidt seminormalized spherical harmonic \n!\tcoefficients c(i, l, m) of the magnetic potential evaluated \n!\tat radius a.\n!\n!\tpower(l) = (a/r)^(2l+4) (l+1) sum_{m=0}^l ( c1lm**2 + c2lm**2 )\n!\n!\tcalling parameters\n!\t\tin\n!\t\t\tc\tschmidt seminormalized spherical harmonic coefficients of the\n!\t\t\t\tmagnetic potential evaluated at radius a, dimensioned as \n!\t\t\t\t(2, lmax+1, lmax+1).\n!\t\t\ta\treference radius of the magnetic potential spherical harmonic \n!\t\t\t\tcoefficients.\n!\t\t\tr\tradius to evaluate the magnetic field.\n!\t\t\tlmax\tmaximum spherical harmonic degree to compute power of.\n!\t\tout\n!\t\t\tspectra\tarray of length (lmax+1) containing the power spectra of c.\n!\n!\twritten by mark wieczorek, march 2008.\n!\n!\tcopyright (c) 2008, mark a. wieczorek\n!\tall rights reserved.\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\timplicit none\n\treal*8, intent(in) :: c(:,:,:)\n\treal*8, intent(in) :: a, r\n\tinteger, intent(in) :: lmax\n\treal*8, intent(out) ::\tspectra(:)\n\tinteger i, m, l1, m1, l\n\t\n\tif (size(c(:,1,1)) < 2 .or. size(c(1,:,1)) < lmax+1 .or. size(c(1,1,:)) < lmax+1) then\n\t\tprint*, \"shmagpowerspectrum --- error\"\n\t\tprint*, \"c must be dimensioned as (2, lmax+1, lmax+1) where lmax is \", lmax\n\t\tprint*, \"input array is dimensioned \", size(c(:,1,1)),  size(c(1,:,1)), size(c(1,1,:)) \n\t\tstop\n\telseif (size(spectra) < lmax+1) then\n\t\tprint*, \"shmagpowerspectrum --- error\"\n\t\tprint*, \"spectra must be dimensioned as (lmax+1) where lmax is \", lmax\n\t\tprint*, \"input vector has dimension \", size(spectra)\n\t\tstop\n\tendif\n\t\n\tspectra = 0.0d0\n\t\n\tdo l=0, lmax\n\t\tl1 = l+1\n\t\t\n\t\tdo m = 0, l\n\t\t\tm1 = m+1\n\t\t\t\n\t\t\tdo i=1, 2\n\t\t\t\tspectra(l1) = spectra(l1) + c(i, l1, m1)**2\n\t\t\tenddo\n\t\tenddo\n\t\t\n\t\tspectra(l1) = spectra(l1) * dble(l+1) * (a/r)**(2*l+4)\n\tenddo\n\nend subroutine shmagpowerspectrum\n"}
{"instruction": "Create a Fortran subroutine named linspace to generate an array of equidistant points between xmin and xmax with a total of n points. The number of input arguments is 3 with test_data type ['real', 'real', 'integer'], and the number of output arguments is 1 with test_data type ['real'].", "input": "", "output": "  subroutine linspace(xmin,xmax,n,x)\n    real, intent(in) :: xmin, xmax !< limits\n    integer, intent(in) :: n !< number of points\n    real, intent(out) :: x(n) !< equidistant points\n    ! locals\n    integer :: i\n    real :: dx\n    dx = (xmax-xmin)/(n-1)\n    do i=1,n\n      x(i) = xmin + dx*(i-1)\n    enddo\n  end subroutine linspace\n"}
{"instruction": "Create a Fortran subroutine named case_select to determine the values of vw, h, and dpdx based on the selected num_case. The number of input arguments is 1 with the test_data type ['integer'], and the number of output arguments is 3 with the test_data type ['real(8)', 'real(8)', 'real(8)']. Use the imperative tone.", "input": "", "output": "subroutine case_select(num_case,vw, h, dpdx)\nimplicit none\n  real(8),intent(out)         ::vw, h, dpdx\n  integer,intent(in)          :: num_case\n  \n        if (num_case==1) then\n        vw=12.84;        h=66e-3;         dpdx=0.0d0\t\t!case 1\n\telseif (num_case==2) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-0.808 \t        !case 2\n\telseif (num_case==3) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-1.486\t\t!case 3\n\telseif (num_case==4) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-1.510\t\t!case 4\n\telseif (num_case==5) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-1.960\t\t!case 5\n\telseif (num_case==6) then\n\tvw=8.59;\t h=66e-3;\t  dpdx=-1.430\t\t!case 6\n\telseif (num_case==7) then\n\tvw=17.08;\t h=101e-3;\t  dpdx=-3.548\t\t!case 7\t\n\telseif (num_case==8) then\n\tvw=12.84;\t h=101e-3;\t  dpdx=-2.323\t\t!case 8\n\telseif (num_case==9) then\n\tvw=8.59;\t h=101e-3;\t  dpdx=-1.212\t\t!case 9\n\telseif (num_case==10) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-4.830\t\t!case 10\n\telseif (num_case==11) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-7.500\t\t!case 11\n\telseif (num_case==12) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-14.30\t\t!case 12\n\telseif (num_case==13) then\n\tvw=12.84;\t h=66e-3;\t  dpdx=-18.50\t\t!case 13\n\telseif (num_case==14) then\n\tvw=8.59;\t h=66e-3;\t  dpdx=-20.80\t\t!case 14\n\telseif (num_case==15) then\n\tvw=0.0d0;\t h=66e-3;\t  dpdx=-13.14\t\t!case 15\n\telseif (num_case==16) then\n\tvw=1.8; \t h=30e-3;\t  dpdx=-0.48\t\t!case 16\n\telseif (num_case==17) then\n\tvw=3.09;\t h=30e-3;\t  dpdx=-0.60\t\t!case 17\n\telseif (num_case==18) then\n\tvw=3.75;\t h=30e-3;\t  dpdx=-0.66\t\t!case 18\n        else\n        print *, \"invalid case selected. exiting.\"\n        end if\n\nend subroutine case_select\n"}
{"instruction": "Write a Fortran subroutine named getpsucount that calculates the number of PSUs (Primary Sampling Units) for each stratum. The subroutine takes 2 input parameters of type integer (psu and stratum) and 1 output parameter of type integer (npsu). This subroutine uses the imperative tone to define the number and type of input and output parameters and to summarize the function of the code.", "input": "", "output": "subroutine getpsucount(psu,stratum,npsu)\r\nimplicit none\r\ninteger,intent(in)::psu(:),stratum(:)\r\ninteger,intent(out)::npsu(:)\r\n!\ts counts strata.\r\ninteger::s\r\n\r\nif(size(npsu)==1)then\r\n\tnpsu(1)=maxval(psu)\r\nelse\r\n\tdo s=1,size(npsu)\r\n\t\tnpsu(s)=maxval(psu,stratum==s)\r\n\tend do\r\nend if\r\n\r\nreturn\r\nend subroutine getpsucount\r\n"}
{"instruction": "Create a Fortran subroutine named rotation_sphere to perform calculations for spatial rotations in spherical coordinates. The subroutine takes 4 input parameters of type real: lambda, phi, lambda_rot, phi_rot. It also returns 2 output parameters of type real: lambda_out, phi_out. The subroutine computes the rotation of a point on a sphere specified by lambda and phi using the given rotation angles lambda_rot and phi_rot, and updates the resulting coordinates in lambda_out and phi_out.", "input": "", "output": "    pure elemental subroutine rotation_sphere(lambda, phi, lambda_rot, phi_rot, lambda_out, phi_out)\n        !arguments\n        real, intent(in) :: lambda, phi, lambda_rot, phi_rot\n        real, intent(out) :: lambda_out, phi_out\n        !varaibles\n        real :: sigma, theta, theta_rot, x, y, z, tan_lambda_out, cos_phi_out\n\n        !azimuthal angle: phi, ploar angle: theta\n        sigma = lambda + lambda_rot\n        theta = pi/2.0 - phi\n        theta_rot = -phi_rot\n        x = cos(sigma)*cos(theta_rot)*sin(theta) + cos(theta)*sin(theta_rot)\n        y = sin(sigma)*sin(theta)\n        z = -cos(sigma)*sin(theta_rot)*sin(theta) + cos(theta)*cos(theta_rot)\n        lambda_out = atan(y/x)\n        if(x < 0.0) then\n            lambda_out = lambda_out + pi\n        end if\n\n        if(z >= 1.0) then\n            phi_out = pi/2.0\n        else if(z <= -1.0) then\n            phi_out = -pi/2.0\n        else\n            phi_out = pi/2.0 - acos(z)\n        end if\n    end subroutine rotation_sphere\n"}
{"instruction": "Create a Fortran subroutine named initker_fermion that takes 6 input parameters of type real*8, real*8, real*8, real*8, integer, and integer, and 1 output parameter of type real*8. The subroutine computes the values of ker for given input arrays w, dw, t, beta, nt, and nw, and stores the results in the output array ker. Make sure to initialize the arrays ker, w, dw, t, and beta before calling this subroutine.", "input": "", "output": "subroutine initker_fermion(ker,w,dw,beta,t,nt,nw)\n  implicit none\n  real*8, intent(out) :: ker(-nw:nw,nt)\n  real*8, intent(in)  :: w(-nw:nw), dw(-nw:nw), t(nt), beta\n  integer, intent(in) :: nw, nt\n  ! locals\n  integer :: it,iw\n  real*8  :: tau, omega\n  do iw=-nw,nw\n     do it=1,nt\n        tau = t(it)\n        omega = w(iw)\n        if (omega*beta<-50.)then\n           ker(iw,it) = dw(iw) * exp( (beta-tau)*omega )\n        else \n           ker(iw,it) = dw(iw) * exp(-tau*omega)/(1.+exp(-beta*omega))\n        endif\n     enddo\n  enddo\n  return\nend subroutine initker_fermion\n"}
{"instruction": "Create a Fortran subroutine named fourpart to calculate the value of gtau based on the input parameters. The subroutine takes 6 input parameters of types ['complex*16', 'real*8', 'real*8', 'real*8', 'real*8', 'integer'] and returns 1 output parameter of type ['real*8'].", "input": "", "output": "subroutine fourpart(gtau,t,gm,om,ah,beta,nom)\n  implicit none\n  real*8, intent(out)    :: gtau\n  complex*16, intent(in) :: gm(nom)\n  real*8, intent(in)     :: om(nom), t, ah, beta\n  integer, intent(in)    :: nom\n  ! locals\n  integer:: im\n  real*8 :: dsum\n  dsum=0.\n  do im=1,nom\n     dsum = dsum + cos(om(im)*t)*real(gm(im)) + sin(om(im)*t)*(aimag(gm(im))+ah/om(im))\n  enddo\n  gtau = 2*dsum/beta-0.5*ah\nend subroutine fourpart\n"}
{"instruction": "Write a Fortran subroutine named padeg to calculate the Pad\u00e9 approximant of a given complex value. The subroutine takes 4 input parameters of type complex*16, complex*16, complex*16, and integer, and returns 1 output parameter of type complex*16.", "input": "", "output": "subroutine padeg(gx,x,zn,pt,nn)\n!*****************************\n  implicit none\n  complex*16, intent(out) :: gx\n  complex*16, intent(in)  :: x, zn(nn),pt(nn)\n  integer, intent(in)     :: nn\n  ! locals\n  complex*16 :: aw(0:nn),bw(0:nn)\n  integer :: i\n  aw(0)=(0.d0,0.d0)\n  aw(1)=pt(1)\n  bw(0)=(1.d0,0.d0)\n  bw(1)=(1.d0,0.d0)\n  do i=1,nn-1\n     aw(i+1)=aw(i)+(x-zn(i))*pt(i+1)*aw(i-1)\n     bw(i+1)=bw(i)+(x-zn(i))*pt(i+1)*bw(i-1)\n  enddo\n  gx=aw(nn)/bw(nn)\n  return\nend subroutine padeg\n"}
{"instruction": "You need to create a Fortran subroutine named \"interpz1d\" to interpolate values from one set of vertical levels to another. The subroutine should have 8 input parameters of types integer and real(8) arrays, and 1 output parameter of type real(8) array. The purpose of this subroutine is to interpolate the values from the input vertical levels to the output vertical levels based on the given conditions and store the result in the output array.", "input": "", "output": "subroutine interpz1d(varin, zin, zout, np, nzin, nzout, kz, null_value, varout)\n\n\n    integer                     , intent(in)        :: np, nzin, nzout, kz\n    real(8)                     , intent(in)        :: null_value\n    real(8), dimension(np,nzin) , intent(in)        :: zin , varin\n    real(8), dimension(nzout)   , intent(in)        :: zout\n    real(8), dimension(np,nzout), intent(out)       :: varout\n    ! locals \n    integer                                         :: i,k,kout,k0\n    real(8)                                         :: rat\n\n    real, parameter     :: almost_zero = 1.e-6\n\n    ! zout and zin should be negative\n\n    !zin(kz:nzin)\n    ! k=kz (bottom)  (=1 if only sigma, no zlevels below)\n    ! k=nzin (top)\n\n    !zout(1:nzout)\n    ! k=1 (top)\n    ! k=nzout (bottom)\n\n    ! for a given time instant, if a requested level is above water varout == surface\n    ! if below, varout is interpolated.\n\n    !varout=null_value  !problem: if dry, varout will be null_value instead of 0.0\n    ! problem because we need velocities to be zero when dry?\n\n    varout=null_value\n\n    do i=1,np\n\n      if (abs(zin(i,kz)) <= almost_zero .and. abs(zin(i,nzin)) <= almost_zero) cycle ! dry nodes have all zins =0.\n\n      do kout=1,nzout\n\n        ! interpolate z\n        if (zout(kout) < zin(i,kz)) then ! zout below bathymetry\n          varout(i,kout) =-99999! do nothing\n        elseif (zout(kout) >= zin(i,nzin)) then\n          !if (debug .and. i==debug_node) write(*,*) 'getting surface!'\n          write(*,*) 'getting surface!'\n          varout(i,kout) = varin(i,nzin)\n        else\n\n          ! interp1d\n          k0=-1! layer below\n          do k=kz,nzin-1\n            if (zin(i,k) <= zout(kout) .and. zout(kout) < zin(i,k+1)) then\n              k0=k\n              exit\n            endif\n          enddo !k\n\n          if (k0<0) then\n            ! should never enter here because below and above zin cases were comtemplated before\n            write(*,*) \"couldn't find any layers for zlevel \", zout(kout), 'at node ', i\n            write(*,*) \"zin = \", zin(i,:)\n            stop 'interpolatez - selfe2netcdf - err02'\n          endif\n\n          rat = (zout(kout)-zin(i,k0)) / (zin(i,k0+1)-zin(i,k0))\n          varout(i,kout) = varin(i,k0)*(1.-rat)+varin(i,k0+1)*rat\n\n        endif\n\n        !if (debug .and. i==debug_node) then\n        ! write(*,*) 'kout, zout(kout), k0, zin(i,k0), zin(i,k0+1), varin(i,k0), varin(i,k0+1), varout(i,kout) = ', &\n        !           kout, zout(kout), k0, zin(i,k0), zin(i,k0+1), varin(i,k0), varin(i,k0+1), varout(i,kout)\n        !endif\n  \n\n      enddo !kout\n\n    enddo !i=1,np\n\n\n  end subroutine\n"}
{"instruction": "Create a Fortran subroutine named slopes to compute the local slopes for a given set of data points. The subroutine takes 3 input parameters: an integer n representing the length dimension of the input data array, x which is a 1D array of real(8) type and length n representing input data coordinates, and y which is a 1D array of real(8) type and length n containing values y(x). The output parameter is slope, a 1D array of real(8) type and length n storing the computed slopes for the input data.", "input": "", "output": "   subroutine slopes(n, x, y, slope)\n      !!\n      !!   c o m p u t a t i o n   o f   s l o p e s  :\n      !!   --------------------------------------------\n      !! * for each given point, we compute its local slope, from the four\n      !!   surrounding points and itself; following akima 1970, p.590, eq.(1)\n      !! * the slopes are stored into an array 'slp(:)' of length n\n      !!\n      !! input :\n      !! -------\n      !!          - n       = length dimension of the array contening the\n      !!                      input data\n      !!          - x       = 1d array (n) contening input data coordinates\n      !!          - y       = 1d array (n) contains values y(x)\n      !!\n      !! output :\n      !! --------\n      !!          - slope  = 1d array (n) contening the slopes\n      !!\n      !!\n      !! author : laurent brodeau, dec. 2004\n      !!\n      !!-------------------------------------------------------------------\n      !!\n      integer,  intent(in) :: n\n      real(8), dimension(n), intent(in)  :: x, y\n      real(8), dimension(n), intent(out) :: slope\n      !!_______________________________________________________\n      !!\n      !! local :\n      integer  :: k\n      real(8) :: m1, m2, m3, m4\n      !!\n      !!\n      !! treating middle of array ( at least to points away from the bordures ) :\n      !!-------------------------------------------------------------------------\n      do k=3, n-2\n         m1 =  ( y(k-1) - y(k-2) ) / ( x(k-1) - x(k-2) )\n         m2 =  ( y(k)   - y(k-1) ) / ( x(k)   - x(k-1) )\n         m3 =  ( y(k+1) - y(k)   ) / ( x(k+1) - x(k)   )\n         m4 =  ( y(k+2) - y(k+1) ) / ( x(k+2) - x(k+1) )\n         !!\n         if ( (m1 == m2).and.(m3 == m4) ) then\n            slope(k) = 0.5*(m2 + m3)\n         else\n            slope(k) =   ( abs(m4-m3)*m2 + abs(m2-m1)*m3 ) &\n               &     / ( abs(m4-m3)    + abs(m2-m1) )\n         end if\n         !!\n      end do\n      !!\n      !!\n      !! treating 'second' and 'before last' points :\n      !! --------------------------------------------\n      !! point k=2\n      m2 =  ( y(2)   - y(1)   ) / ( x(2)   - x(1)   )\n      m3 =  ( y(3)   - y(2)   ) / ( x(3)   - x(2)   )\n      slope(2)   = 0.5*( m2 + m3 )\n      !! point k=n-1\n      m2 =  ( y(n-1) - y(n-2) ) / ( x(n-1) - x(n-2) )\n      m3 =  ( y(n)   - y(n-1) ) / ( x(n)   - x(n-1) )\n      slope(n-1) = 0.5*( m2 + m3 )\n      !!\n      !! treating 'first' and 'last' points :\n      !! --------------------------------------------\n      !! point k = 1\n      m3 =  ( y(2)   - y(1)   ) / ( x(2)   - x(1)   )\n      slope(1)   = m3\n      !! point k = n\n      m2 =  ( y(n) - y(n-1) ) / ( x(n) - x(n-1) )\n      slope(n)   = m2\n      !!\n      !!\n   end subroutine slopes\n"}
{"instruction": "Write a Fortran subroutine named g2l that calculates the processor array index and local array index based on the global array index, global array dimension, processor array dimension, and block size. The subroutine has 4 input parameters of type integer: i, n, np, and nb, and 2 output parameters of type integer: p and il.", "input": "", "output": "   pure subroutine g2l(i, n, np, nb, p, il)\n      implicit none\n      integer,intent(in) :: i    ! global array index, input\n      integer,intent(in) :: n    ! global array dimension, input\n      integer,intent(in) :: np   ! processor array dimension, input\n      integer,intent(in) :: nb   ! block size, input\n      integer,intent(out) :: p    ! processor array index, output\n      integer,intent(out) :: il   ! local array index, output\n      integer :: im1\n      im1 = i - 1\n      p = mod((im1/nb), np)\n      il = (im1/(np*nb))*nb + mod(im1, nb) + 1\n      return\n   end subroutine g2l\n"}
{"instruction": "Create a Fortran subroutine named compute_bounds to calculate the lower and upper bounds of a range based on the size, rank, and total number of elements. The subroutine takes 3 input parameters of type integer: size, rank, and n, and returns 2 output parameters of type integer: lbound and ubound.", "input": "", "output": "    subroutine compute_bounds(size, rank, n, lbound, ubound)\n        implicit none\n        integer, intent(in) :: size, rank, n\n        integer, intent(out) :: lbound, ubound\n        integer :: chunk_size, rest\n        chunk_size = n/size\n        rest = mod(n, size)\n        lbound = min(rank, size - rest)*chunk_size + &\n                 max(0, rank - (size - rest))*(chunk_size + 1)\n        ubound = lbound + chunk_size\n        if (rank >= size - rest) ubound = ubound + 1\n        lbound = lbound + 1\n    end subroutine compute_bounds\n"}
{"instruction": "Create a Fortran subroutine named read_char_param that takes a single input argument of type character(len=*) and returns a single output argument of the same type. This subroutine copies the value of the input argument to the output argument.", "input": "", "output": "  subroutine read_char_param(valstr,par)\n    character(len=*), intent(in) :: valstr\n    character(len=*), intent(out) :: par\n    par = valstr\n  end subroutine read_char_param\n"}
{"instruction": "Write a Fortran subroutine named get_paramstr that extracts a parameter name and its corresponding value from a given input string. The subroutine takes 1 input parameter of type character(len=*), and returns 2 output parameters, both of type character(len=*).", "input": "", "output": "  subroutine get_paramstr(instr,name,valuestr)\n    character(len=*), intent(in) :: instr\n    character(len=*), intent(out) :: name, valuestr\n    integer :: ii\n\n    ii = 1\n    do while (instr(ii:ii) /= '=')\n       ii = ii + 1\n       if (ii > len(instr)) then\n          write(0,*) 'no equal sign (=) in parameter string!'\n          stop 531\n       end if\n    end do\n\n    name = trim(adjustl(instr(:ii-1)))\n    valuestr = trim(adjustl(instr(ii+1:)))\n\n  end subroutine get_paramstr\n"}
{"instruction": "Create a Fortran subroutine named get_distance to calculate the distance between two points in a three-dimensional space, considering periodic boundary conditions. The subroutine takes 6 input parameters of type real*8 and logical, and returns 3 output parameters of type integer and real*8.", "input": "", "output": "  subroutine get_distance(posi, posj, a, b, c, pbc, dist, d, i_shift)\n\n    implicit none\n\n    real*8, intent(in) :: posi(1:3), posj(1:3), a(1:3), b(1:3), c(1:3)\n    integer, intent(out) :: i_shift(1:3)\n    logical, intent(in) :: pbc(1:3)\n    real*8, intent(out) :: d\n    real*8, intent(out) :: dist(1:3)\n    real*8 :: d2, l(1:3), d_tol = 1.d-6\n    real*8 :: mat(1:3,1:3), md, indices_real(1:3), res, res_opt, dist_opt(1:3), dist_temp(1:3)\n    real*8, save :: a0(1:3) = 0.d0, b0(1:3) = 0.d0, c0(1:3) = 0.d0, mat_inv(1:3,1:3) = 0.d0\n    integer :: i, j, k, indices(1:3)\n    logical :: lattice_check_a(1:3), lattice_check_b(1:3), lattice_check_c(1:3)\n\n    if( dabs(a(2)) < d_tol .and. dabs(a(3)) < d_tol .and. &\n        dabs(b(1)) < d_tol .and. dabs(b(3)) < d_tol .and. &\n        dabs(c(1)) < d_tol .and. dabs(c(2)) < d_tol )then\n      dist = posj - posi\n      i_shift = floor([dist(1)/a(1), dist(2)/b(2), dist(3)/c(3)])\n!     fast solution for orthorhombic cells\n      l = (/ a(1), b(2), c(3) /)\n      d2 = 0.d0\n      do i = 1, 3\n        if( pbc(i) )then\n          dist(i) = modulo(posj(i) - posi(i), l(i))\n          if( dist(i) > l(i)/2.d0 )then\n            dist(i) = dist(i) - l(i)\n          end if\n        else\n          dist(i) = posj(i) - posi(i)\n        end if\n        d2 = d2 + dist(i)**2\n      end do\n      d = dsqrt(d2)\n    else if( all( pbc ) )then\n!     slow solution for other unit cells\n      lattice_check_a = ( a /= a0 )\n      lattice_check_b = ( b /= b0 )\n      lattice_check_c = ( c /= c0 )\n      if( any(lattice_check_a) .or. any(lattice_check_b) .or. any(lattice_check_c) )then\n        a0 = a\n        b0 = b\n        c0 = c\n!       we construct our matrix to get the mic only if the lattice vectors have changed\n        mat(1,1) = dot_product(a, a)\n        mat(1,2) = dot_product(a, b)\n        mat(1,3) = dot_product(a, c)\n        mat(2,1) = mat(1,2)\n        mat(2,2) = dot_product(b, b)\n        mat(2,3) = dot_product(b, c)\n        mat(3,1) = mat(1,3)\n        mat(3,2) = mat(2,3)\n        mat(3,3) = dot_product(c, c)\n!       we compute the inverse of this matrix analytically\n        md = -mat(1,3)**2*mat(2,2) + 2.d0*mat(1,2)*mat(1,3)*mat(2,3) - mat(1,1)*mat(2,3)**2 &\n             - mat(1,2)**2*mat(3,3) + mat(1,1)*mat(2,2)*mat(3,3)\n        mat_inv(1,1) = mat(2,2)*mat(3,3) - mat(2,3)**2\n        mat_inv(1,2) = mat(1,3)*mat(2,3) - mat(1,2)*mat(3,3)\n        mat_inv(1,3) = mat(1,2)*mat(2,3) - mat(1,3)*mat(2,2)\n        mat_inv(2,1) = mat_inv(1,2)\n        mat_inv(2,2) = mat(1,1)*mat(3,3) - mat(1,3)**2\n        mat_inv(2,3) = mat(1,2)*mat(1,3) - mat(1,1)*mat(2,3)\n        mat_inv(3,1) = mat_inv(1,3)\n        mat_inv(3,2) = mat_inv(2,3)\n        mat_inv(3,3) = mat(1,1)*mat(2,2) - mat(1,2)**2\n        mat_inv = mat_inv / md\n      end if\n      dist = posj - posi\n      indices_real = -1.d0 * (/ dot_product(dist, a), dot_product(dist, b), dot_product(dist,c) /)\n      indices_real = matmul(mat_inv, indices_real)\n      i_shift = floor(-indices_real)\n!     closest integer solution\n      indices(1:3) = nint(indices_real(1:3))\n!     we bruteforce the integer solution among the 27 points surrounding the real solution\n      res_opt = 1.d10\n      do i = indices(1)-1, indices(1)+1\n        do j = indices(2)-1, indices(2)+1\n          do k = indices(3)-1, indices(3)+1\n            dist_temp(1:3) = dist(1:3) + dfloat(i)*a(1:3) + dfloat(j)*b(1:3) + dfloat(k)*c(1:3)\n            res = dot_product(dist_temp, dist_temp)\n            if( res < res_opt )then\n              res_opt = res\n              dist_opt = dist_temp\n            end if\n          end do\n        end do\n      end do\n      dist = dist_opt\n      d = dsqrt( dot_product(dist,dist) )\n    else\n      write(*,*) \"sorry, non-orthorhombic unit cells only work in combination with full pbc\"\n    end if\n\n  return\n  end subroutine get_distance\n"}
{"instruction": "Write a Fortran subroutine named initialdata to initialize a 2D array with values calculated using the x and y coordinate arrays. The subroutine takes 4 input parameters: two integers (nx and ny), and two 1D real arrays of size nx and ny (x and y). It also has 2 output parameters: two 2D real arrays of size nx by ny (u and uold).", "input": "", "output": "subroutine initialdata(nx,ny,x,y,u,uold)\n  use omp_lib\n  implicit none\n  integer(kind=4), intent(in)                        :: nx,ny\n  real(kind=8), dimension(1:nx), intent(in)          :: x\n  real(kind=8), dimension(1:ny), intent(in)          :: y\n  real(kind=8), dimension(1:nx,1:ny), intent(out)    :: u,uold\n  integer(kind=4)                                    :: i,j\n  !$omp parallel do private(j) schedule(static)\n  do j=1,ny\n     u(1:nx,j)=0.5d0*exp(-1.0d0*(x(1:nx)**2 +y(j)**2))\n  end do\n  !$omp end parallel do\n  !$omp parallel do private(j) schedule(static)\n  do j=1,ny\n     uold(1:nx,j)=0.5d0*exp(-1.0d0*(x(1:nx)**2 +y(j)**2))\n  end do\n  !$omp end parallel do\nend subroutine initialdata\n"}
{"instruction": "Create a Fortran subroutine named tdew to compute the dew point temperature at a specific pressure and specific humidity. The subroutine takes 5 input parameters: three integers (km, jm, im), and two arrays of real(8) type with dimensions (km, jm, im) for pressure (p) and specific humidity (q). It returns one output parameter, an array of real(8) type with dimensions (km, jm, im) for the dew point temperature (t).", "input": "", "output": "subroutine tdew(km,jm,im,p,q,t)\n\n! compute dew point temperature tdew  [k] \n! at pressure p [mb] and specific humidity q [g/kg]\n! use bolton eqn (11)\n!\n  implicit none\n  integer,intent(in)                       :: km,jm,im\n!f2py intent(hide) km,jm,im\n  real(8), dimension(km,jm,im), intent(in) :: p,q\n  real(8), dimension(km,jm,im), intent(out) :: t\n\n! local\n  real(8) :: rv, rd, eps\n  real(8), dimension(km,jm,im) :: r,es,loges\n\n  rv  = 461.5\n  rd  = 287.04\n  eps = rd/rv\n  r = q/(1.e3 - q) * 1.e3 ! water vap. mixing ratio [g/kg]\n  es = p*r/(r+eps*1.e3)   ! vapor pressure of water vap\n  loges = log(es)\n\n  t = ( 243.5*loges-440.8 )/( 19.48-loges ) + 273.15\n\nend subroutine tdew\n"}
{"instruction": "Write a Fortran subroutine named get_format_statement to extract a format statement from the input string. The subroutine takes 1 input parameter of type character(len=*) and returns 1 output parameter of type character(len=*).", "input": "", "output": "    subroutine get_format_statement(str,fmt)\n\n    implicit none\n\n    character(len=*),intent(in)  :: str\n    character(len=*),intent(out) :: fmt\n\n    integer :: i1,i2\n\n    !note: other text after the format statement is ignored\n\n    i1 = index(str,'(')\n    i2 = index(str,')')\n\n    if (i1/=0 .and. i2/=0 .and. i2>i1) then\n        fmt = str(i1:i2)\n    else\n        write(*,*) 'error: the string does not contain a format statement: '//trim(str)\n        fmt = ''\n    end if\n\n    end subroutine get_format_statement\n"}
{"instruction": "Write a Fortran subroutine named network_mapdensityofstates to calculate the density of states for a network. The subroutine takes in 6 input parameters: e0 (real(8)), ngrains0 (integer), densstates0 (real(8) array of size 1:ngrains0), elist0 (real(8) array of size 1:ngrains0), ngrains (integer), elist (real(8) array of size 1:ngrains). It also has 1 output parameter: densstates (real(8) array of size 1:ngrains).\n\nThe subroutine loops through each element in the elist array and calculates the corresponding density of states based on the given conditions and values in densstates0 and elist0 arrays. The calculated density of states is stored in the densstates array.\n\nYour task is to implement the subroutine network_mapdensityofstates.", "input": "", "output": "    subroutine network_mapdensityofstates(e0, densstates0, elist0, ngrains0, densstates, elist, ngrains)\n\n        real(8), intent(in) :: e0        \n        integer, intent(in) :: ngrains0\n        real(8), dimension(1:ngrains0), intent(in) :: densstates0\n        real(8), dimension(1:ngrains0), intent(in) :: elist0\n        integer, intent(in) :: ngrains\n        real(8), dimension(1:ngrains), intent(out) :: densstates\n        real(8), dimension(1:ngrains), intent(in) :: elist\n\n        integer :: r, s\n\n        do r = 1, ngrains\n            densstates(r) = 0.\n        end do\n\n        do r = 1, ngrains\n            if (elist(r) >= e0) then\n                do s = 2, ngrains0\n                    if (e0 + elist0(s) >= elist(r)) then\n                        if (densstates0(s-1) > 0 .and. densstates0(s) > 0) then\n                            densstates(r) = densstates0(s) * (densstates0(s-1) / densstates0(s)) ** &\n                                ((elist(r) - e0 - elist0(s)) / (elist0(s-1) - elist0(s)))\n                        else\n                            densstates(r) = densstates0(s) + (densstates0(s-1) - densstates0(s)) * &\n                                (elist(r) - e0 - elist0(s)) / (elist0(s-1) - elist0(s))\n                        end if\n                        exit\n                    end if\n                end do\n            end if\n        end do\n\n    end subroutine\n"}
{"instruction": "Write a Fortran subroutine named make_rates to calculate rates based on given input parameters. The subroutine takes 7 input parameters and 1 output parameter. \n\nThe input parameters are:\n- d: A real number (kind=8)\n- dd: A real number (kind=8)\n- rho: A real number (kind=8)\n- drho: A real number (kind=8)\n- dx: A real number (kind=8)\n- maskp: An integer\n- maskm: An integer\n\nThe output parameter is:\n- rates: An array of two real numbers (kind=8), represented as real(kind=8), dimension(2)\n\nThe subroutine calculates the rates by performing the following steps:\n1. Calculate r as the division of d by dx squared.\n2. Calculate dr as the division of (dd + d multiplied by drho divided by rho) by (2 multiplied by dx).\n3. If maskp is equal to 1, set rates(1) as the maximum value between r+dr and 0. Otherwise, set rates(1) as 0.\n4. If maskm is equal to 1, set rates(2) as the maximum value between r-dr and 0. Otherwise, set rates(2) as 0.\n\nRemember to use the imperative tone when writing the instructions.", "input": "", "output": "subroutine make_rates(d,dd,rho,drho,dx,maskp,maskm,rates)\nreal(kind=8), intent(in) :: d,dd,rho,drho,dx\ninteger, intent(in) :: maskp, maskm\nreal(kind=8), dimension(2), intent(out) :: rates\n\nreal(kind=8) r,dr\n\nr = d/dx**2\ndr = (dd+d*drho/rho)/(2*dx)\nif (maskp == 1) then\n    rates(1) = max(r+dr,0.)\nelse\n    rates(1) = 0.\nend if\n\nif (maskm == 1) then\n    rates(2) = max(r-dr,0.)\nelse\n    rates(2) = 0.\nend if\nend subroutine\n"}
{"instruction": "Write a Fortran subroutine named fixchar to modify a character string based on the specified option. The subroutine takes 2 input parameters with the test_data type ['character*(*)', 'integer'] and 1 output parameter with the test_data type ['character*(*)']. The subroutine manipulates the input string based on the provided option, converting it to either upper case or lower case, and stores the result in the output parameter.", "input": "", "output": "      subroutine fixchar(name_in, name_out, option)\n      implicit none\n\n      character*(*), intent(in)   ::  name_in\n      character*(*), intent(out)  ::  name_out\n      integer, intent(in)         ::  option\n\n      character*10                :: temp\n      integer                     :: i, ic\n\n      name_out= '          '\n      temp = trim(adjustl(name_in))\n      do i = 1, len_trim(temp)\n        ic = iachar(temp(i:i))\n        if(option == 1 ) then             !<--- convert to upper case\n          if(ic .ge. 97 .and. ic .le. 122) then\n            name_out(i:i) = char( ic-32 )\n          else\n            name_out(i:i) = temp(i:i)\n          endif\n        endif\n        if(option == 2 ) then             !<--- convert to lower case\n          if(ic .ge. 65 .and. ic .le. 90) then\n            name_out(i:i) = char( ic+32 )\n          else\n            name_out(i:i) = temp(i:i)\n          endif\n        endif\n\n      enddo\n      name_out=trim(name_out)\n      return\n\n      end subroutine fixchar\n"}
